id,file,merge_commitid,times,recur_segment
1,core/java/android/accounts/AccountManager.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        android.util.SeempLog.record(25);
        if (account == null) throw new IllegalArgumentException(""account is null"");
        return new Future2Task<Boolean>(handler, callback) {
            @Override
            public void doWork() throws RemoteException {
                android.util.SeempLog.record(31);
                mService.removeAccount(mResponse, account, false);
            }
            @Override
            public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
                if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                    throw new AuthenticatorException(""no result in response"");
                }
                return bundle.getBoolean(KEY_BOOLEAN_RESULT);
            }
        }.start();
"
2,core/java/android/accounts/AccountManager.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        android.util.SeempLog.record(28);
        if (account == null) throw new IllegalArgumentException(""account is null"");
        return new AmsTask(activity, handler, callback) {
            @Override
            public void doWork() throws RemoteException {
                android.util.SeempLog.record(34);
                mService.removeAccount(mResponse, account, activity != null);
            }
        }.start();
"
3,core/java/android/accounts/AccountManager.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        android.util.SeempLog.record(29);
        if (accountType == null) throw new IllegalArgumentException(""accountType is null"");
        final Bundle optionsIn = new Bundle();
        if (addAccountOptions != null) {
            optionsIn.putAll(addAccountOptions);
        }
        optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());

        return new AmsTask(activity, handler, callback) {
            @Override
            public void doWork() throws RemoteException {
                android.util.SeempLog.record(31);
                mService.addAccount(mResponse, accountType, authTokenType,
                        requiredFeatures, activity != null, optionsIn);
"
4,core/java/android/app/ActivityManagerInternal.java,"['1b62159ffcebb2c102e129b2e778a8f65b7e5948', '3933f277a025be704e68ea593536e492831a7e05', '24818fca475a6726f5ef0cae42149615079af6e9', '35fa949362e35d8514c64a645b6448424f174c82', '2051462f672b5986ef321bf1de3657e7653864e8', 'a9736185db896fe2edde0281d71102b35327b7f8', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6', 'df73284a33506ba26aadbd20a1dbd01353820200', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'e85435d4d9a2f7122bd5c97ad0a25c768d124a0e', '9272406e82304c5a2a8124c75eedb4b5fdf7273a', '02a7ee5d65cb8d40fd1dde9aaf6b5ead9222a5a6']",12,"    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
"
5,core/java/android/app/Instrumentation.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"            Intent intent, int requestCode, Bundle options, boolean ignoreTargetSecurity,
            int userId) {
        android.util.SeempLog.record_str(379, intent.toString());
"
6,core/java/android/app/StatusBarManager.java,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",3,"    public static final int CAMERA_LAUNCH_SOURCE_SCREEN_GESTURE = 3;
"
7,core/java/android/bluetooth/BluetoothAdapter.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"            BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
            return true;
        } else if (profile == BluetoothProfile.BA_TRANSMITTER) {
            BluetoothBATransmitter baTransmitter = new BluetoothBATransmitter(context, listener);
            return true;
"
8,core/java/android/bluetooth/BluetoothAdapter.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"            case BluetoothProfile.DUN:
                BluetoothDun dun = (BluetoothDun)proxy;
                dun.close();
"
9,core/java/android/bluetooth/BluetoothAdapter.java,['88b45c586d461df38b866d529bc98d1dfa3e8838'],1,"            case BluetoothProfile.DUN:
                BluetoothDun dun = (BluetoothDun)proxy;
                dun.close();
                break;
            case BluetoothProfile.HEALTH:
                BluetoothHealth health = (BluetoothHealth) proxy;
                health.close();
                break;
"
10,core/java/android/bluetooth/BluetoothAdapter.java,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']",2,"            if (mManagerService != null) {
                SystemProperties.set(""persist.bluetooth.factoryreset"", ""true"");
                return mManagerService.factoryReset();
            }
"
11,core/java/android/bluetooth/BluetoothAdapter.java,['a33382db0bb0bc29bab84f1e5ee36d682bea593e'],1,"            if (mManagerService != null) {
                SystemProperties.set(""persist.bluetooth.factoryreset"", ""true"");
                return mManagerService.factoryReset();
            }
            Log.e(TAG, ""factoryReset(): IBluetooth Service is null"");
"
12,core/java/android/bluetooth/BluetoothAdapter.java,['af02bd5317cc0cced0a7646d5bbf407a181dda9c'],1,"        android.util.SeempLog.record(63);
        int state = BluetoothAdapter.STATE_OFF;

        try {
            mServiceLock.readLock().lock();
            if (mService != null) {
                state = mService.getState();
            }
        } catch (RemoteException e) {
            Log.e(TAG, """", e);
        } finally {
            mServiceLock.readLock().unlock();
        }
"
13,core/java/android/bluetooth/BluetoothAdapter.java,['32c3556fef45f3b7fb003880f4e23227cda95f74'],1,"        android.util.SeempLog.record(63);
        int state = mBluetoothGetStateCache.query(null);
"
14,core/java/android/bluetooth/BluetoothAdapter.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        } else if (profile == BluetoothProfile.DUN) {
            BluetoothDun dun = new BluetoothDun(context, listener);
"
15,core/java/android/bluetooth/BluetoothCodecConfig.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 4;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_LDAC = 5;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_APTX_TWSP = 6;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_MAX = 7;
    /* CELT is not an A2DP Codec and only used to fetch encoder
    ** format for BA usecase, moving out of a2dp codec value list
    */
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_CELT = 8;
"
16,core/java/android/bluetooth/BluetoothCodecConfig.java,"['449f659b21d039b8692602294b040038ac1e6ccb', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']",2,"    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 4;

    public static final int SOURCE_CODEC_TYPE_LDAC = 5;

    public static final int SOURCE_CODEC_TYPE_APTX_TWSP = 6;

    public static final int SOURCE_CODEC_TYPE_MAX = 7;

    /* CELT is not an A2DP Codec and only used to fetch encoder
    ** format for BA usecase, moving out of a2dp codec value list
    */
    public static final int SOURCE_CODEC_TYPE_CELT = 8;

   "
17,core/java/android/bluetooth/BluetoothCodecConfig.java,['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba'],1,"    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 4;

    public static final int SOURCE_CODEC_TYPE_LDAC = 5;

    public static final int SOURCE_CODEC_TYPE_APTX_TWSP = 6;

    public static final int SOURCE_CODEC_TYPE_MAX = 7;

    /* CELT is not an A2DP Codec and only used to fetch encoder
    ** format for BA usecase, moving out of a2dp codec value list
    */
    public static final int SOURCE_CODEC_TYPE_CELT = 8;

    public static final int SOURCE_CODEC_TYPE_LC3 = 9;

"
18,core/java/android/bluetooth/BluetoothCodecConfig.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 5;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_MAX = 6;
"
19,core/java/android/bluetooth/BluetoothDevice.java,['c77ad764fad2451538f140b31601e7b8c6c59fa2'],1,"     * Broadcast Action: Indicates the remote devices are TWS plus earbuds pair.
     * <p>Always contains the extra fields {@link #EXTRA_TWS_PLUS_DEVICE1},
     * {@link #EXTRA_TWS_PLUS_DEVICE2}.
     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
     * @hide
     */
    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
    public static final String ACTION_TWS_PLUS_DEVICE_PAIR =
"
20,core/java/android/bluetooth/BluetoothHeadset.java,['1eef3e1566be8570a0f7a856f12f8992f7d34824'],1,"            try {
                 mAdapter.getBluetoothManager().unbindBluetoothProfileService(
                         BluetoothProfile.HEADSET, mConnection);
            } catch (RemoteException e) {
                Log.e(TAG, ""Unable to unbind HeadsetService"", e);
"
21,core/java/android/bluetooth/BluetoothHeadset.java,['1eef3e1566be8570a0f7a856f12f8992f7d34824'],1,"            try {
                mServiceLock.writeLock().lock();
                mService = null;
                mHandler.sendMessage(mHandler.obtainMessage(
                        MESSAGE_HEADSET_SERVICE_DISCONNECTED));
            } finally {
                mServiceLock.writeLock().unlock();
            }
"
22,core/java/android/bluetooth/le/ScanFilter.java,['2edeff882ab756e76b3a028a1568d8774ddc0257'],1,"     * @hide
"
23,core/java/android/bluetooth/le/ScanFilter.java,['2edeff882ab756e76b3a028a1568d8774ddc0257'],1,"     * @hide
     */
    public static boolean matchesServiceSolicitationUuids(ParcelUuid solicitationUuid,
"
24,core/java/android/bluetooth/le/ScanRecord.java,['2edeff882ab756e76b3a028a1568d8774ddc0257'],1,"     * @hide
"
25,core/java/android/bluetooth/le/ScanRecord.java,['2edeff882ab756e76b3a028a1568d8774ddc0257'],1,"     * identify the bluetooth GATT services.
     * @hide
     */
"
26,core/java/android/content/ContentResolver.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"        android.util.SeempLog.record_uri(13, uri);
        Preconditions.checkNotNull(uri, ""uri"");
"
27,core/java/android/content/ContentResolver.java,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,"        android.util.SeempLog.record_uri(37, url);
"
28,core/java/android/content/ContentResolver.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"        android.util.SeempLog.record_uri(37, url);
        Preconditions.checkNotNull(url, ""url"");
"
29,core/java/android/content/Intent.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"                case ACTION_PACKAGE_NEEDS_OPTIONAL_VERIFICATION:
"
30,core/java/android/content/pm/ApplicationInfo.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    /** @hide */
    public int getOverrideDensity() {
        return overrideDensity;
"
31,core/java/android/content/pm/ApplicationInfo.java,"['337095f9d277c566cb888bc3adbac16576f1ae70', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']",2,"    /** {@hide} */ public int canOverrideRes() { return overrideRes; }
"
32,core/java/android/content/pm/ApplicationInfo.java,['6f47ceafbe6febe54aa5c376baed3415cdf848ad'],1,"    /** {@hide} */ public void setGwpAsanEnabled(@Nullable Boolean value) { enableGwpAsan = value; }
    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
"
33,core/java/android/content/pm/ApplicationInfo.java,"['337095f9d277c566cb888bc3adbac16576f1ae70', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e', '6f47ceafbe6febe54aa5c376baed3415cdf848ad']",3,"    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
"
34,core/java/android/content/pm/ApplicationInfo.java,['6f47ceafbe6febe54aa5c376baed3415cdf848ad'],1,"    @Nullable
    public Boolean isGwpAsanEnabled() { return enableGwpAsan; }
    /** {@hide} */ public int canOverrideRes() { return overrideRes; }
"
35,core/java/android/hardware/Camera.java,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"        if (cameraId >= getNumberOfCameras()) {
            throw new RuntimeException(""Unknown camera ID"");
        }
        _getCameraInfo(cameraId, cameraInfo);
"
36,core/java/android/hardware/Camera.java,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",3,"{
            throw new RuntimeException(""Unknown camera ID"");
        }
        _getCameraInfo(cameraId, cameraInfo);
"
37,core/java/android/hardware/camera2/CameraDevice.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"     * @param outputs The new set of Surfaces that should be made available as
     *                targets for captured image data.
     * @param callback The callback to notify about the status of the new capture session.
     * @param handler The handler on which the callback should be invoked, or {@code null} to use
     *                the current thread's {@link android.os.Looper looper}.
     *
     * @throws IllegalArgumentException if the set of output Surfaces do not meet the requirements,
     *                                  the callback is null, or the handler is null but the current
     *                                  thread has no looper.
     * @throws CameraAccessException if the camera device is no longer connected or has
     *                               encountered a fatal error
     * @throws IllegalStateException if the camera device has been closed
     *
     * @see CameraCaptureSession
     * @see StreamConfigurationMap#getOutputFormats()
     * @see StreamConfigurationMap#getOutputSizes(int)
     * @see StreamConfigurationMap#getOutputSizes(Class)
     */
    public abstract void createCaptureSession(@NonNull List<Surface> outputs,
            @NonNull CameraCaptureSession.StateCallback callback, @Nullable Handler handler)
            throws CameraAccessException;

    /** @hide */
    public abstract void setVendorStreamConfigMode(int index)
            throws CameraAccessException;

    /**
     * <p>Create a new camera capture session by providing the target output set of Surfaces and
     * its corresponding surface configuration to the camera device.</p>
     *
     * @see #createCaptureSession
     * @see OutputConfiguration
     */
    public abstract void createCaptureSessionByOutputConfigurations(
            List<OutputConfiguration> outputConfigurations,
            CameraCaptureSession.StateCallback callback, @Nullable Handler handler)
            throws CameraAccessException;
    /**
     * Create a new reprocessable camera capture session by providing the desired reprocessing
     * input Surface configuration and the target output set of Surfaces to the camera device.
"
38,core/java/android/hardware/camera2/CameraManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"            synchronized(mLock) {
                // Try to make sure we have an up-to-date list of camera devices.
                connectCameraServiceLocked();

                boolean exposeAuxCamera = false;
                String packageName = ActivityThread.currentOpPackageName();
                String packageList = SystemProperties.get(""vendor.camera.aux.packagelist"");
                if (packageList.length() > 0) {
                    TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(',');
                    splitter.setString(packageList);
                    for (String str : splitter) {
                        if (packageName.equals(str)) {
                            exposeAuxCamera = true;
                            break;
                        }
                    }
                }
                int idCount = 0;
                for (int i = 0; i < mDeviceStatus.size(); i++) {
                    if(!exposeAuxCamera && (i == 2)) break;
                    int status = mDeviceStatus.valueAt(i);
                    if (status == ICameraServiceListener.STATUS_NOT_PRESENT ||
                            status == ICameraServiceListener.STATUS_ENUMERATING) continue;
                    idCount++;
                }
                cameraIds = new String[idCount];
                idCount = 0;
                for (int i = 0; i < mDeviceStatus.size(); i++) {
                    if(!exposeAuxCamera && (i == 2)) break;
                    int status = mDeviceStatus.valueAt(i);
                    if (status == ICameraServiceListener.STATUS_NOT_PRESENT ||
                            status == ICameraServiceListener.STATUS_ENUMERATING) continue;
                    cameraIds[idCount] = mDeviceStatus.keyAt(i);
                    idCount++;
                }
"
39,core/java/android/hardware/camera2/CameraManager.java,"['74a21b989f82a6a024f29085ad324e939472bed1', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']",2,"import android.app.ActivityThread;
"
40,core/java/android/net/ConnectivityManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"     * WIGIG tethering type. Use a separate type to prevent
     * conflicts with TETHERING_WIFI
     * @hide
     */
    public static final int TETHERING_WIGIG = 3;
"
41,core/java/android/nfc/cardemulation/AidGroup.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"    protected List<String> aids;
    @UnsupportedAppUsage
    protected String category;
    @UnsupportedAppUsage
    protected String description;
"
42,core/java/android/nfc/cardemulation/ApduServiceInfo.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"    protected  HashMap<String, AidGroup> m"
43,core/java/android/nfc/cardemulation/ApduServiceInfo.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"    protected  HashMap<String, AidGroup> mDynamicAidGroups;
"
44,core/java/android/nfc/cardemulation/ApduServiceInfo.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"    protected  HashMap<String, AidGroup> mStaticAidGroups;
"
45,core/java/android/nfc/cardemulation/ApduServiceInfo.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"    protected  ResolveInfo mService;
"
46,core/java/android/os/Process.java,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', '6aa497092f6337fbafb5b9858a3ec8f28c9d3caf']",2,"     * Sets the scheduling group for processes in the same cgroup.procs of uid and pid
     * @hide
     * @param uid The user identifier of the process to change.
     * @param pid The identifier of the process to change.
     * @param group The target group for this process from THREAD_GROUP_*.
     *
     * @throws IllegalArgumentException Throws IllegalArgumentException if
     * <var>tid</var> does not exist.
     * @throws SecurityException Throws SecurityException if your process does
     * not have permission to modify the given thread, or to use the given
     * priority.
     *
     * group == THREAD_GROUP_DEFAULT means to move all non-background priority
     * threads to the foreground scheduling group, but to leave background
     * priority threads alone.  group == THREAD_GROUP_BG_NONINTERACTIVE moves all
     * threads, regardless of priority, to the background scheduling group.
     * group == THREAD_GROUP_FOREGROUND is not allowed.
     *
     * Always sets cpusets.
     */
    public static final native void setCgroupProcsProcessGroup(int uid, int pid, int group)
            throws IllegalArgumentException, SecurityException;
"
47,core/java/android/provider/Settings.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"            ACCESSIBILITY_MINIMUM_UI_TIMEOUT_ENABLED,
            ACCESSIBILITY_MINIMUM_UI_TIMEOUT_MS,
            WIFI_DISCONNECT_DELAY_DURATION,
"
48,core/java/android/provider/Settings.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED);
            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_COVERAGE_EXTEND_FEATURE_ENABLED);
"
49,core/java/android/provider/Settings.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"            VALIDATORS.put(ACCESSIBILITY_MINIMUM_UI_TIMEOUT_ENABLED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_MINIMUM_UI_TIMEOUT_MS, NON_NEGATIVE_INTEGER_VALIDATOR);
            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
"
50,core/java/android/provider/Settings.java,"['1730c08a2fd38f0ff8135692a855ada865130939', '2edeff882ab756e76b3a028a1568d8774ddc0257', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6', '1581c348fc5d6cbf1673b3dbc5960637f891d488']",4,"            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
"
51,core/java/android/provider/Settings.java,"['1730c08a2fd38f0ff8135692a855ada865130939', '2edeff882ab756e76b3a028a1568d8774ddc0257', '1581c348fc5d6cbf1673b3dbc5960637f891d488']",3,            WIFI_DISCONNECT_DELAY_DURATION
52,core/java/android/provider/Settings.java,['1581c348fc5d6cbf1673b3dbc5960637f891d488'],1,"            WIFI_DISCONNECT_DELAY_DURATION
"
53,core/java/android/provider/Settings.java,"['1730c08a2fd38f0ff8135692a855ada865130939', '2edeff882ab756e76b3a028a1568d8774ddc0257']",2,"            WIFI_DISCONNECT_DELAY_DURATION,
"
54,core/java/android/provider/Settings.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"            android.util.SeempLog.record(android.util.SeempLog.getSeempPutApiIdFromValue(name));
"
55,core/java/android/provider/Settings.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"         * All settings in {@link SETTINGS_TO_BACKUP} and {@link DEVICE_SPECIFIC_SETTINGS_TO_BACKUP}
         * array *must* have a non-null validator, otherwise they won't be restored.
         *
         * @hide
         */
        public static final Map<String, Validator> VALIDATORS = new ArrayMap<>();
        static {
            VALIDATORS.put(BUGREPORT_IN_POWER_MENU, BUGREPORT_IN_POWER_MENU_VALIDATOR);
            VALIDATORS.put(ALLOW_MOCK_LOCATION, ALLOW_MOCK_LOCATION_VALIDATOR);
            VALIDATORS.put(USB_MASS_STORAGE_ENABLED, USB_MASS_STORAGE_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_INVERSION_ENABLED,
                    ACCESSIBILITY_DISPLAY_INVERSION_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_DALTONIZER,
                    ACCESSIBILITY_DISPLAY_DALTONIZER_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_DALTONIZER_ENABLED,
                    ACCESSIBILITY_DISPLAY_DALTONIZER_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
                    ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_MAGNIFICATION_NAVBAR_ENABLED,
                    ACCESSIBILITY_DISPLAY_MAGNIFICATION_NAVBAR_ENABLED_VALIDATOR);
            VALIDATORS.put(AUTOFILL_SERVICE, AUTOFILL_SERVICE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
                    ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE_VALIDATOR);
            VALIDATORS.put(ENABLED_ACCESSIBILITY_SERVICES,
                    ENABLED_ACCESSIBILITY_SERVICES_VALIDATOR);
            VALIDATORS.put(ENABLED_VR_LISTENERS, ENABLED_VR_LISTENERS_VALIDATOR);
            VALIDATORS.put(TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
                    TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES_VALIDATOR);
            VALIDATORS.put(TOUCH_EXPLORATION_ENABLED, TOUCH_EXPLORATION_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_ENABLED, ACCESSIBILITY_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_TARGET_SERVICE,
                    ACCESSIBILITY_SHORTCUT_TARGET_SERVICE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_BUTTON_TARGET_COMPONENT,
                    ACCESSIBILITY_BUTTON_TARGET_COMPONENT_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_DIALOG_SHOWN,
                    ACCESSIBILITY_SHORTCUT_DIALOG_SHOWN_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_ENABLED,
                    ACCESSIBILITY_SHORTCUT_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_ON_LOCK_SCREEN,
                    ACCESSIBILITY_SHORTCUT_ON_LOCK_SCREEN_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_HIGH_TEXT_CONTRAST_ENABLED,
                    ACCESSIBILITY_HIGH_TEXT_CONTRAST_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_PRESET,
                    ACCESSIBILITY_CAPTIONING_PRESET_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_ENABLED,
                    ACCESSIBILITY_CAPTIONING_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_LOCALE,
                    ACCESSIBILITY_CAPTIONING_LOCALE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR,
                    ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR,
                    ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_EDGE_TYPE,
                    ACCESSIBILITY_CAPTIONING_EDGE_TYPE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_EDGE_COLOR,
                    ACCESSIBILITY_CAPTIONING_EDGE_COLOR_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_TYPEFACE,
                    ACCESSIBILITY_CAPTIONING_TYPEFACE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_FONT_SCALE,
                    ACCESSIBILITY_CAPTIONING_FONT_SCALE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_WINDOW_COLOR,
                    ACCESSIBILITY_CAPTIONING_WINDOW_COLOR_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_RATE, TTS_DEFAULT_RATE_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_PITCH, TTS_DEFAULT_PITCH_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_SYNTH, TTS_DEFAULT_SYNTH_VALIDATOR);
            VALIDATORS.put(TTS_ENABLED_PLUGINS, TTS_ENABLED_PLUGINS_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_LOCALE, TTS_DEFAULT_LOCALE_VALIDATOR);
            VALIDATORS.put(SHOW_IME_WITH_HARD_KEYBOARD, SHOW_IME_WITH_HARD_KEYBOARD_VALIDATOR);
            VALIDATORS.put(WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,
                    WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON_VALIDATOR);
            VALIDATORS.put(WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,
                    WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY_VALIDATOR);
            VALIDATORS.put(WIFI_NUM_OPEN_NETWORKS_KEPT, WIFI_NUM_OPEN_NETWORKS_KEPT_VALIDATOR);
            VALIDATORS.put(MOUNT_PLAY_NOTIFICATION_SND, MOUNT_PLAY_NOTIFICATION_SND_VALIDATOR);
            VALIDATORS.put(MOUNT_UMS_AUTOSTART, MOUNT_UMS_AUTOSTART_VALIDATOR);
            VALIDATORS.put(MOUNT_UMS_PROMPT, MOUNT_UMS_PROMPT_VALIDATOR);
            VALIDATORS.put(MOUNT_UMS_NOTIFY_ENABLED, MOUNT_UMS_NOTIFY_ENABLED_VALIDATOR);
            VALIDATORS.put(DOUBLE_TAP_TO_WAKE, DOUBLE_TAP_TO_WAKE_VALIDATOR);
            VALIDATORS.put(WAKE_GESTURE_ENABLED, WAKE_GESTURE_ENABLED_VALIDATOR);
            VALIDATORS.put(LONG_PRESS_TIMEOUT, LONG_PRESS_TIMEOUT_VALIDATOR);
            VALIDATORS.put(CAMERA_GESTURE_DISABLED, CAMERA_GESTURE_DISABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_AUTOCLICK_ENABLED,
                    ACCESSIBILITY_AUTOCLICK_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_AUTOCLICK_DELAY, ACCESSIBILITY_AUTOCLICK_DELAY_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_LARGE_POINTER_ICON,
                    ACCESSIBILITY_LARGE_POINTER_ICON_VALIDATOR);
            VALIDATORS.put(PREFERRED_TTY_MODE, PREFERRED_TTY_MODE_VALIDATOR);
            VALIDATORS.put(ENHANCED_VOICE_PRIVACY_ENABLED,
                    ENHANCED_VOICE_PRIVACY_ENABLED_VALIDATOR);
            VALIDATORS.put(TTY_MODE_ENABLED, TTY_MODE_ENABLED_VALIDATOR);
            VALIDATORS.put(RTT_CALLING_MODE, RTT_CALLING_MODE_VALIDATOR);
            VALIDATORS.put(INCALL_POWER_BUTTON_BEHAVIOR, INCALL_POWER_BUTTON_BEHAVIOR_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_CUSTOM_START_TIME,
                    NIGHT_DISPLAY_CUSTOM_START_TIME_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_CUSTOM_END_TIME, NIGHT_DISPLAY_CUSTOM_END_TIME_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_COLOR_TEMPERATURE,
                    NIGHT_DISPLAY_COLOR_TEMPERATURE_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_AUTO_MODE, NIGHT_DISPLAY_AUTO_MODE_VALIDATOR);
            VALIDATORS.put(DISPLAY_WHITE_BALANCE_ENABLED, DISPLAY_WHITE_BALANCE_ENABLED_VALIDATOR);
            VALIDATORS.put(SYNC_PARENT_SOUNDS, SYNC_PARENT_SOUNDS_VALIDATOR);
            VALIDATORS.put(CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED,
                    CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED_VALIDATOR);
            VALIDATORS.put(CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED,
                    CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED_VALIDATOR);
            VALIDATORS.put(SYSTEM_NAVIGATION_KEYS_ENABLED,
                    SYSTEM_NAVIGATION_KEYS_ENABLED_VALIDATOR);
            VALIDATORS.put(QS_TILES, QS_TILES_VALIDATOR);
            VALIDATORS.put(DOZE_ENABLED, DOZE_ENABLED_VALIDATOR);
            VALIDATORS.put(DOZE_ALWAYS_ON, DOZE_ALWAYS_ON_VALIDATOR);
            VALIDATORS.put(DOZE_PICK_UP_GESTURE, DOZE_PICK_UP_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_DOUBLE_TAP_GESTURE, DOZE_DOUBLE_TAP_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_TAP_SCREEN_GESTURE, DOZE_TAP_SCREEN_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_WAKE_LOCK_SCREEN_GESTURE, DOZE_WAKE_LOCK_SCREEN_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_WAKE_DISPLAY_GESTURE, DOZE_WAKE_DISPLAY_GESTURE_VALIDATOR);
            VALIDATORS.put(NFC_PAYMENT_DEFAULT_COMPONENT, NFC_PAYMENT_DEFAULT_COMPONENT_VALIDATOR);
            VALIDATORS.put(AUTOMATIC_STORAGE_MANAGER_DAYS_TO_RETAIN,
                    AUTOMATIC_STORAGE_MANAGER_DAYS_TO_RETAIN_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_KEYGUARD_ENABLED, FACE_UNLOCK_KEYGUARD_ENABLED_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_DISMISSES_KEYGUARD,
                    FACE_UNLOCK_DISMISSES_KEYGUARD_VALIDATOR);
            VALIDATORS.put(SHOW_MEDIA_WHEN_BYPASSING, SHOW_MEDIA_WHEN_BYPASSING_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_APP_ENABLED, FACE_UNLOCK_APP_ENABLED_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_ALWAYS_REQUIRE_CONFIRMATION,
                    FACE_UNLOCK_ALWAYS_REQUIRE_CONFIRMATION_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_ENABLED, ASSIST_GESTURE_ENABLED_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_SILENCE_ALERTS_ENABLED,
                    ASSIST_GESTURE_SILENCE_ALERTS_ENABLED_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_WAKE_ENABLED, ASSIST_GESTURE_WAKE_ENABLED_VALIDATOR);
            VALIDATORS.put(VR_DISPLAY_MODE, VR_DISPLAY_MODE_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_BADGING, NOTIFICATION_BADGING_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_BUBBLES, NOTIFICATION_BUBBLES_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_DISMISS_RTL, NOTIFICATION_DISMISS_RTL_VALIDATOR);
            VALIDATORS.put(QS_AUTO_ADDED_TILES, QS_AUTO_ADDED_TILES_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_ENABLED, SCREENSAVER_ENABLED_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_COMPONENTS, SCREENSAVER_COMPONENTS_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_ACTIVATE_ON_DOCK, SCREENSAVER_ACTIVATE_ON_DOCK_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_ACTIVATE_ON_SLEEP, SCREENSAVER_ACTIVATE_ON_SLEEP_VALIDATOR);
            VALIDATORS.put(LOCKDOWN_IN_POWER_MENU, LOCKDOWN_IN_POWER_MENU_VALIDATOR);
            VALIDATORS.put(SHOW_FIRST_CRASH_DIALOG_DEV_OPTION,
                    SHOW_FIRST_CRASH_DIALOG_DEV_OPTION_VALIDATOR);
            VALIDATORS.put(VOLUME_HUSH_GESTURE, VOLUME_HUSH_GESTURE_VALIDATOR);
            VALIDATORS.put(ENABLED_NOTIFICATION_LISTENERS,
                    ENABLED_NOTIFICATION_LISTENERS_VALIDATOR); //legacy restore setting
            VALIDATORS.put(ENABLED_NOTIFICATION_ASSISTANT,
                    ENABLED_NOTIFICATION_ASSISTANT_VALIDATOR); //legacy restore setting
            VALIDATORS.put(ENABLED_NOTIFICATION_POLICY_ACCESS_PACKAGES,
                    ENABLED_NOTIFICATION_POLICY_ACCESS_PACKAGES_VALIDATOR); //legacy restore setting
            VALIDATORS.put(HUSH_GESTURE_USED, HUSH_GESTURE_USED_VALIDATOR);
            VALIDATORS.put(MANUAL_RINGER_TOGGLE_COUNT, MANUAL_RINGER_TOGGLE_COUNT_VALIDATOR);
            VALIDATORS.put(IN_CALL_NOTIFICATION_ENABLED, IN_CALL_NOTIFICATION_ENABLED_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_ALLOW_PRIVATE_NOTIFICATIONS, BOOLEAN_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_SHOW_NOTIFICATIONS, BOOLEAN_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_SHOW_SILENT_NOTIFICATIONS, BOOLEAN_VALIDATOR);
            VALIDATORS.put(SHOW_NOTIFICATION_SNOOZE, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ZEN_DURATION, ZEN_DURATION_VALIDATOR);
            VALIDATORS.put(SHOW_ZEN_UPGRADE_NOTIFICATION, BOOLEAN_VALIDATOR);
            VALIDATORS.put(SHOW_ZEN_SETTINGS_SUGGESTION, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ZEN_SETTINGS_UPDATED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ZEN_SETTINGS_SUGGESTION_VIEWED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(CHARGING_SOUNDS_ENABLED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(CHARGING_VIBRATION_ENABLED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_NON_INTERACTIVE_UI_TIMEOUT_MS,
                    NON_NEGATIVE_INTEGER_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_INTERACTIVE_UI_TIMEOUT_MS, NON_NEGATIVE_INTEGER_VALIDATOR);
            VALIDATORS.put(USER_SETUP_COMPLETE, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_SETUP_COMPLETE, BOOLEAN_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_NEW_INTERRUPTION_MODEL, BOOLEAN_VALIDATOR);
            VALIDATORS.put(TRUST_AGENTS_EXTEND_UNLOCK, TRUST_AGENTS_EXTEND_UNLOCK_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_CUSTOM_CLOCK_FACE, LOCK_SCREEN_CUSTOM_CLOCK_FACE_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_WHEN_TRUST_LOST, LOCK_SCREEN_WHEN_TRUST_LOST_VALIDATOR);
            VALIDATORS.put(SKIP_GESTURE, SKIP_GESTURE_VALIDATOR);
            VALIDATORS.put(SKIP_DIRECTION, SKIP_DIRECTION_VALIDATOR);
            VALIDATORS.put(SKIP_DIRECTION, SKIP_DIRECTION_VALIDATOR);
            VALIDATORS.put(SILENCE_GESTURE, SILENCE_GESTURE_VALIDATOR);
            VALIDATORS.put(THEME_CUSTOMIZATION_OVERLAY_PACKAGES,
                    THEME_CUSTOMIZATION_OVERLAY_PACKAGES_VALIDATOR);
            VALIDATORS.put(NAVIGATION_MODE, NAVIGATION_MODE_VALIDATOR);
            VALIDATORS.put(AWARE_ENABLED, AWARE_ENABLED_VALIDATOR);
            VALIDATORS.put(SKIP_GESTURE_COUNT, SKIP_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SKIP_TOUCH_COUNT, SKIP_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_ALARMS_GESTURE_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_TIMER_GESTURE_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_CALL_GESTURE_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_ALARMS_TOUCH_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_TIMER_TOUCH_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_CALL_TOUCH_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(ODI_CAPTIONS_ENABLED, ODI_CAPTIONS_ENABLED_VALIDATOR);
            VALIDATORS.put(DARK_MODE_DIALOG_SEEN, BOOLEAN_VALIDATOR);
            VALIDATORS.put(UI_NIGHT_MODE, UI_NIGHT_MODE_VALIDATOR);
            VALIDATORS.put(GLOBAL_ACTIONS_PANEL_ENABLED, GLOBAL_ACTIONS_PANEL_ENABLED_VALIDATOR);
            VALIDATORS.put(AWARE_LOCK_ENABLED, AWARE_LOCK_ENABLED_VALIDATOR);
            VALIDATORS.put(DISPLAY_DENSITY_FORCED, DISPLAY_DENSITY_FORCED_VALIDATOR);
        }

        /**
"
56,core/java/android/provider/Settings.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"         * Setting to configure Wifi disconnect delay duration in seconds.
         * @hide
         **/
        public static final String WIFI_DISCONNECT_DELAY_DURATION =
                ""wifi_disconnect_delay_duration"";

        private static final Validator WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR =
                NON_NEGATIVE_INTEGER_VALIDATOR;

        /**
         * Location access disabled.
"
57,core/java/android/provider/Settings.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"        private static final Validator AWARE_LOCK_ENABLED_VALIDATOR = BOOLEAN_VALIDATOR;

        /**
         * This are the settings to be backed up.
         *
         * NOTE: Settings are backed up and restored in the order they appear
         *       in this array. If you have one setting depending on another,
         *       make sure that they are ordered appropriately.
         *
         * @hide
         */
        @UnsupportedAppUsage
        public static final String[] SETTINGS_TO_BACKUP = {
            BUGREPORT_IN_POWER_MENU,                            // moved to global
            ALLOW_MOCK_LOCATION,
            USB_MASS_STORAGE_ENABLED,                           // moved to global
            ACCESSIBILITY_DISPLAY_INVERSION_ENABLED,
            ACCESSIBILITY_DISPLAY_DALTONIZER,
            ACCESSIBILITY_DISPLAY_DALTONIZER_ENABLED,
            ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
            ACCESSIBILITY_DISPLAY_MAGNIFICATION_NAVBAR_ENABLED,
            AUTOFILL_SERVICE,
            ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
            ENABLED_ACCESSIBILITY_SERVICES,
            ENABLED_VR_LISTENERS,
            TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
            TOUCH_EXPLORATION_ENABLED,
            ACCESSIBILITY_ENABLED,
            ACCESSIBILITY_SHORTCUT_TARGET_SERVICE,
            ACCESSIBILITY_BUTTON_TARGET_COMPONENT,
            ACCESSIBILITY_SHORTCUT_DIALOG_SHOWN,
            ACCESSIBILITY_SHORTCUT_ENABLED,
            ACCESSIBILITY_SHORTCUT_ON_LOCK_SCREEN,
            ACCESSIBILITY_HIGH_TEXT_CONTRAST_ENABLED,
            ACCESSIBILITY_CAPTIONING_PRESET,
            ACCESSIBILITY_CAPTIONING_ENABLED,
            ACCESSIBILITY_CAPTIONING_LOCALE,
            ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR,
            ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR,
            ACCESSIBILITY_CAPTIONING_EDGE_TYPE,
            ACCESSIBILITY_CAPTIONING_EDGE_COLOR,
            ACCESSIBILITY_CAPTIONING_TYPEFACE,
            ACCESSIBILITY_CAPTIONING_FONT_SCALE,
            ACCESSIBILITY_CAPTIONING_WINDOW_COLOR,
            TTS_DEFAULT_RATE,
            TTS_DEFAULT_PITCH,
            TTS_DEFAULT_SYNTH,
            TTS_ENABLED_PLUGINS,
            TTS_DEFAULT_LOCALE,
            SHOW_IME_WITH_HARD_KEYBOARD,
            WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,            // moved to global
            WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,               // moved to global
            WIFI_NUM_OPEN_NETWORKS_KEPT,                        // moved to global
            MOUNT_PLAY_NOTIFICATION_SND,
            MOUNT_UMS_AUTOSTART,
            MOUNT_UMS_PROMPT,
            MOUNT_UMS_NOTIFY_ENABLED,
            DOUBLE_TAP_TO_WAKE,
            WAKE_GESTURE_ENABLED,
            LONG_PRESS_TIMEOUT,
            CAMERA_GESTURE_DISABLED,
            ACCESSIBILITY_AUTOCLICK_ENABLED,
            ACCESSIBILITY_AUTOCLICK_DELAY,
            ACCESSIBILITY_LARGE_POINTER_ICON,
            PREFERRED_TTY_MODE,
            ENHANCED_VOICE_PRIVACY_ENABLED,
            TTY_MODE_ENABLED,
            RTT_CALLING_MODE,
            INCALL_POWER_BUTTON_BEHAVIOR,
            NIGHT_DISPLAY_CUSTOM_START_TIME,
            NIGHT_DISPLAY_CUSTOM_END_TIME,
            NIGHT_DISPLAY_COLOR_TEMPERATURE,
            NIGHT_DISPLAY_AUTO_MODE,
            DISPLAY_WHITE_BALANCE_ENABLED,
            SYNC_PARENT_SOUNDS,
            CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED,
            CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED,
            SYSTEM_NAVIGATION_KEYS_ENABLED,
            QS_TILES,
            DOZE_ENABLED,
            DOZE_ALWAYS_ON,
            DOZE_PICK_UP_GESTURE,
            DOZE_DOUBLE_TAP_GESTURE,
            DOZE_TAP_SCREEN_GESTURE,
            DOZE_WAKE_LOCK_SCREEN_GESTURE,
            DOZE_WAKE_DISPLAY_GESTURE,
            NFC_PAYMENT_DEFAULT_COMPONENT,
            AUTOMATIC_STORAGE_MANAGER_DAYS_TO_RETAIN,
            FACE_UNLOCK_KEYGUARD_ENABLED,
            SHOW_MEDIA_WHEN_BYPASSING,
            FACE_UNLOCK_DISMISSES_KEYGUARD,
            FACE_UNLOCK_APP_ENABLED,
            FACE_UNLOCK_ALWAYS_REQUIRE_CONFIRMATION,
            ASSIST_GESTURE_ENABLED,
            ASSIST_GESTURE_SILENCE_ALERTS_ENABLED,
            ASSIST_GESTURE_WAKE_ENABLED,
            VR_DISPLAY_MODE,
            NOTIFICATION_BADGING,
            NOTIFICATION_BUBBLES,
            NOTIFICATION_DISMISS_RTL,
            QS_AUTO_ADDED_TILES,
            SCREENSAVER_ENABLED,
            SCREENSAVER_COMPONENTS,
            SCREENSAVER_ACTIVATE_ON_DOCK,
            SCREENSAVER_ACTIVATE_ON_SLEEP,
            LOCKDOWN_IN_POWER_MENU,
            SHOW_FIRST_CRASH_DIALOG_DEV_OPTION,
            VOLUME_HUSH_GESTURE,
            MANUAL_RINGER_TOGGLE_COUNT,
            HUSH_GESTURE_USED,
            IN_CALL_NOTIFICATION_ENABLED,
            LOCK_SCREEN_ALLOW_PRIVATE_NOTIFICATIONS,
            LOCK_SCREEN_CUSTOM_CLOCK_FACE,
            LOCK_SCREEN_SHOW_NOTIFICATIONS,
            LOCK_SCREEN_SHOW_SILENT_NOTIFICATIONS,
            SHOW_NOTIFICATION_SNOOZE,
            ZEN_DURATION,
            SHOW_ZEN_UPGRADE_NOTIFICATION,
            SHOW_ZEN_SETTINGS_SUGGESTION,
            ZEN_SETTINGS_UPDATED,
            ZEN_SETTINGS_SUGGESTION_VIEWED,
            CHARGING_SOUNDS_ENABLED,
            CHARGING_VIBRATION_ENABLED,
            WIFI_DISCONNECT_DELAY_DURATION,
            ACCESSIBILITY_NON_INTERACTIVE_UI_TIMEOUT_MS,
            ACCESSIBILITY_INTERACTIVE_UI_TIMEOUT_MS,
            NOTIFICATION_NEW_INTERRUPTION_MODEL,
            TRUST_AGENTS_EXTEND_UNLOCK,
            UI_NIGHT_MODE,
            LOCK_SCREEN_WHEN_TRUST_LOST,
            SKIP_GESTURE,
            SKIP_DIRECTION,
            SILENCE_GESTURE,
            THEME_CUSTOMIZATION_OVERLAY_PACKAGES,
            NAVIGATION_MODE,
            AWARE_ENABLED,
            SKIP_GESTURE_COUNT,
            SKIP_TOUCH_COUNT,
            SILENCE_ALARMS_GESTURE_COUNT,
            SILENCE_CALL_GESTURE_COUNT,
            SILENCE_TIMER_GESTURE_COUNT,
            SILENCE_ALARMS_TOUCH_COUNT,
            SILENCE_CALL_TOUCH_COUNT,
            SILENCE_TIMER_TOUCH_COUNT,
            DARK_MODE_DIALOG_SEEN,
            GLOBAL_ACTIONS_PANEL_ENABLED,
            AWARE_LOCK_ENABLED
        };

"
58,core/java/android/util/NtpTrustedTime.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"            final Resources res = context.getResources();
            final ContentResolver resolver = context.getContentResolver();

            final String defaultServer = res.getString(
                    com.android.internal.R.string.config_ntpServer);
            final long defaultTimeout = res.getInteger(
                    com.android.internal.R.integer.config_ntpTimeout);

            final String secureServer = Settings.Global.getString(
                    resolver, Settings.Global.NTP_SERVER);
            final long timeout = Settings.Global.getLong(
                    resolver, Settings.Global.NTP_TIMEOUT, defaultTimeout);

            final String server = secureServer != null ? secureServer : defaultServer;
            sSingleton = new NtpTrustedTime(server, timeout);
            sContext = context;

            final String sserver_prop = Settings.Global.getString(
                    resolver, Settings.Global.NTP_SERVER_2);

            final String secondServer_prop = ((null != sserver_prop)
                                               && (0 < sserver_prop.length()))
                                               ? sserver_prop : BACKUP_SERVER;

            final String backupServer = SystemProperties.get(secondServer_prop);

            if ((null != backupServer) && (0 < backupServer.length())) {
                int retryMax = res.getInteger(com.android.internal.R.integer.config_ntpRetry);
                if (0 < retryMax) {
                    sSingleton.mNtpRetriesMax = retryMax;
                    sSingleton.mBackupServer = (backupServer.trim()).replace(""\"""", """");
                }
            }
"
59,core/java/android/util/NtpTrustedTime.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        if (LOGD) Log.d(TAG, ""forceRefresh() from cache miss"");
        final SntpClient client = new SntpClient();

        String targetServer = mServer;
        if (getBackupmode()) {
            setBackupmode(false);
            targetServer = mBackupServer;
        }
        if (LOGD) Log.d(TAG, ""Ntp Server to access at:"" + targetServer);
        if (client.requestTime(targetServer, (int) mTimeout, network)) {
            mHasCache = true;
            mCachedNtpTime = client.getNtpTime();
            mCachedNtpElapsedRealtime = client.getNtpTimeReference();
            mCachedNtpCertainty = client.getRoundTripTime() / 2;
            return true;
        } else {
            countInBackupmode();
            return false;
"
60,core/java/android/util/NtpTrustedTime.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        return hasCache() ? forceSync() : false;
    }

    @Override
    public boolean forceSync() {
        // We can't do this at initialization time: ConnectivityService might not be running yet.
"
61,core/java/android/util/NtpTrustedTime.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"    private boolean mBackupmode = false;
    private static String mBackupServer = """";
    private static int mNtpRetries = 0;
    private static int mNtpRetriesMax = 0;
    private static final String BACKUP_SERVER = ""persist.backup.ntpServer"";

    private NtpTrustedTime(String server, long timeout) {
        if (LOGD) Log.d(TAG, ""creating NtpTrustedTime using "" + server);
        mServer = server;
        mTimeout = timeout;
"
62,core/java/android/view/Choreographer.java,['645ae5df5346c679626d708a62c0a24d6b294f1a'],1,"     * {@hide}
     */
    public void setMotionEventInfo(int motionEventType, int touchMoveNum) {
        synchronized(this) {
            mTouchMoveNum = touchMoveNum;
            mMotionEventType = motionEventType;
        }
"
63,core/java/android/view/InputEventReceiver.java,"['c77ad764fad2451538f140b31601e7b8c6c59fa2', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']",2,"    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
"
64,core/java/android/view/InputEventReceiver.java,"['c77ad764fad2451538f140b31601e7b8c6c59fa2', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']",2,"    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
    "
65,core/java/android/view/InputEventReceiver.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
    public static interface Factory {
        public InputEventReceiver createInputEventReceiver(
                InputChannel inputChannel, Looper looper);
"
66,core/java/android/view/InputEventReceiver.java,['c77ad764fad2451538f140b31601e7b8c6c59fa2'],1,"    @UnsupportedAppUsage
    private void dispatchBatchedInputEventPending() {
        onBatchedInputEventPending();
    }

    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
"
67,core/java/android/view/SurfaceControl.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            IBinder layerHandleToken, Rect sourceCrop, float frameScale, IBinder[] excludeLayers);
"
68,core/java/android/view/SurfaceControl.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"        // TODO(b/150410543) Re-enable CloseGuard.
        //mCloseGuard.open(""release"");
"
69,core/java/android/view/ViewRootImpl.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '24f36fd2514856aaafe6a32a99050e272a6bd361']",2,"    boolean mHaveMoveEvent = false;
"
70,core/java/android/view/ViewRootImpl.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"    boolean mHaveMoveEvent = false;

"
71,core/java/com/android/ims/internal/uce/common/CapInfo.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        dest.writeInt(mSmChatbotSupported ? 1 : 0);
        dest.writeInt(mMmtelCallComposerSupported ? 1 : 0);
"
72,core/java/com/android/ims/internal/uce/common/CapInfo.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        mSmChatbotSupported = (source.readInt() == 0) ? false : true;
        mMmtelCallComposerSupported = (source.readInt() == 0) ? false : true;
"
73,core/java/com/android/ims/internal/uce/common/CapInfo.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",2,"     /** Standalone Chatbot communication support. */
    private boolean mSmChatbotSupported = false;
     /** MMtel based call composer support. */
"
74,core/java/com/android/ims/internal/uce/common/CapInfo.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"     /** Standalone Chatbot communication support. */
    private boolean mSmChatbotSupported = false;
     /** MMtel based call composer support. */
    private boolean mMmtelCallComposerSupported = false;
"
75,core/java/com/android/ims/internal/uce/common/CapInfo.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"    /**
     * Checks whether standalone chatbot communication is supported.
     */
    @UnsupportedAppUsage
    public boolean isSmChatbotSupported() {
        return mSmChatbotSupported;
    }

    /**
     * Sets standalone chatbot communication as supported or not supported.
     */
    @UnsupportedAppUsage
    public void setSmChatbotSupported(boolean smChatbotSupported) {
        this.mSmChatbotSupported = smChatbotSupported;
    }

    /**
     * Checks whether Mmtel based call composer is supported.
     */
    @UnsupportedAppUsage
    public boolean isMmtelCallComposerSupported() {
        return mMmtelCallComposerSupported;
    }

    /**
     * Sets Mmtel based call composer as supported or not supported.
     */
    @UnsupportedAppUsage
    public void setMmtelCallComposerSupported(boolean mmtelCallComposerSupported) {
        this.mMmtelCallComposerSupported = mmtelCallComposerSupported;
    }

"
76,core/java/com/android/ims/internal/uce/common/CapInfo.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",2,"    @UnsupportedAppUsage
"
77,core/java/com/android/internal/app/ChooserActivity.java,"['c5b9da0f6b5ab4da9e1ee4b8dfb3de427cdac2d9', 'd274c33a679b96f638f6b6d14abb2472dd3fc2ac']",2,"        return ChooserGridAdapter.MAX_TARGETS_PER_ROW_LANDSCAPE;
"
78,core/java/com/android/internal/os/ZygoteInit.java,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '6445e9361550e1306d29713dd600481e125f88a8']",2,"        try {
            System.loadLibrary(""qti_performance"");
        } catch (UnsatisfiedLinkError e) {
            Log.e(TAG, ""Couldn't load qti_performance"");
"
79,core/java/com/android/internal/widget/LocalImageResolver.java,"['f2b53072aa24c3f9f84e762d313f85f5f179e4a4', '8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",3,"                if (!(TextUtils.isEmpty(icon.getResPackage())
                        || context.getPackageName().equals(icon.getResPackage()))) {
                    // We can't properly resolve icons from other packages here, so fall back.
                    return icon.loadDrawable(context);
                }

                Drawable result = resolveImage(icon.getResId(), context, maxWidth, maxHeight);
"
80,core/java/com/android/internal/widget/LockPatternUtils.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    /**
     * clears stored password.
     */
    public void sanitizePassword() {
        try {
            getLockSettings().sanitizePassword();
        } catch (RemoteException re) {
            Log.e(TAG, ""Couldn't sanitize password"" + re);
        }
"
81,core/java/com/android/internal/widget/LockPatternUtils.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"    }

    /**
     * Transform a pattern byte array to base zero form.
     * @param bytes pattern byte array.
     * @return The pattern in base zero form.
     */
    public static byte[] patternByteArrayToBaseZero(byte[] bytes) {
        if (bytes == null) {
            return new byte[0];
        }
        final int patternSize = bytes.length;
        byte[] res = new byte[patternSize];
        for (int i = 0; i < patternSize; i++) {
            res[i] = (byte) (bytes[i] - '1');
        }
        return res;
"
82,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"            @NonNull LocationRequest request,
            @NonNull LocationListener listener,
            @Nullable Looper looper) {
        android.util.SeempLog.record(47);
        checkListener(listener);
        requestLocationUpdates(request, listener, looper, null);
"
83,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"            @NonNull LocationRequest request, @NonNull PendingIntent intent) {
        android.util.SeempLog.record(47);
        checkPendingIntent(intent);
        requestLocationUpdates(request, null, null, intent);
"
84,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"            PendingIntent intent) {
        android.util.SeempLog.record(45);
"
85,location/java/android/location/LocationManager.java,"['a97ca47ee3713a075711c311c49e3951264007ef', '18970c4d9d55a44040fe6fb762dac93a077c64b5', '27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '7fd6edc3a3ff37a750641d5e192835fe217f6050']",4,        android.util.SeempLog.record(4
86,location/java/android/location/LocationManager.java,['af02bd5317cc0cced0a7646d5bbf407a181dda9c'],1,"        android.util.SeempLog.record(43);
        UnsupportedOperationException ex = new UnsupportedOperationException(
                ""GpsStatus APIs not supported in S and above, use GnssStatus APIs instead"");
        if (mContext.getApplicationInfo().targetSdkVersion > Build.VERSION_CODES.R) {
            throw ex;
        } else {
            Log.w(TAG, ex);
"
87,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"        android.util.SeempLog.record(43);
        boolean result;

        if (mGpsStatusListeners.get(listener) != null) {
            // listener is already registered
            return true;
        }
        try {
            GnssStatusListenerTransport transport = new GnssStatusListenerTransport(listener);
            result = mService.registerGnssStatusCallback(transport, mContext.getPackageName());
            if (result) {
                mGpsStatusListeners.put(listener, transport);
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }

        return result;
"
88,location/java/android/location/LocationManager.java,['a97ca47ee3713a075711c311c49e3951264007ef'],1,"        android.util.SeempLog.record(43);
        return false;
"
89,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"        android.util.SeempLog.record(44);
        boolean result;

        if (mGpsNmeaListeners.get(listener) != null) {
            // listener is already registered
            return true;
        }
        try {
            GnssStatusListenerTransport transport = new GnssStatusListenerTransport(listener);
            result = mService.registerGnssStatusCallback(transport, mContext.getPackageName());
            if (result) {
                mGpsNmeaListeners.put(listener, transport);
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }

        return result;
"
90,location/java/android/location/LocationManager.java,"['2775a5a9b030266a910301e8b464811acafcd5fa', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",2,"        android.util.SeempLog.record(45);
"
91,location/java/android/location/LocationManager.java,['af02bd5317cc0cced0a7646d5bbf407a181dda9c'],1,"        android.util.SeempLog.record(45);
        checkPendingIntent(intent);
"
92,location/java/android/location/LocationManager.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"        android.util.SeempLog.record(48);
"
93,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"        android.util.SeempLog.record(64);
        check"
94,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"        android.util.SeempLog.record(64);
        checkCriteria(criteria);
        checkListener(listener);
"
95,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"        android.util.SeempLog.record(64);
        checkProvider(provider);
        checkListener(listener);
"
96,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"     * @deprecated Do not manipulate providers individually, use
     * {@link #setLocationEnabledForUser(boolean, UserHandle)} instead.
     * @hide
     */
    @Deprecated
    @SystemApi
    @RequiresPermission(WRITE_SECURE_SETTINGS)
    public boolean setProviderEnabledForUser(
            @NonNull String provider, boolean enabled, @NonNull UserHandle userHandle) {
        checkProvider(provider);

        return Settings.Secure.putStringForUser(
                mContext.getContentResolver(),
                Settings.Secure.LOCATION_PROVIDERS_ALLOWED,
                (enabled ? ""+"" : ""-"") + provider,
                userHandle.getIdentifier());
    }

    /**
     * Get the last known location.
     *
     * <p>This location could be very old so use
     * {@link Location#getElapsedRealtimeNanos} to calculate its age. It can
     * also return null if no previous location is available.
     *
     * <p>Always returns immediately.
     *
     * @return The last known location, or null if not available
     * @throws SecurityException if no suitable permission is present
     *
     * @hide
     */
    @Nullable
    public Location getLastLocation() {
        String packageName = mContext.getPackageName();

        try {
            return mService.getLastLocation(null, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Returns a Location indicating the data from the last known
     * location fix obtained from the given provider.
     *
     * <p> This can be done
     * without starting the provider.  Note that this location could
     * be out-of-date, for example if the device was turned off and
     * moved to another location.
     *
     * <p> If the provider is currently disabled, null is returned.
     *
     * @param provider the name of the provider
     * @return the last known location for the provider, or null
     *
     * @throws SecurityException if no suitable permission is present
     * @throws IllegalArgumentException if provider is null or doesn't exist
     */
    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    @Nullable
    public Location getLastKnownLocation(@NonNull String provider) {
        android.util.SeempLog.record(46);
        checkProvider(provider);
        String packageName = mContext.getPackageName();
        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, 0, 0, true);

        try {
            return mService.getLastLocation(request, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Creates a mock location provider and adds it to the set of active providers.
     *
     * @param name the provider name
     *
"
97,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"     * Sends additional commands to a location provider. Can be used to support provider specific
     * extensions to the Location Manager API.
     *
     * @param provider name of the location provider.
     * @param command  name of the command to send to the provider.
     * @param extras   optional arguments for the command (or null).
     * @return true always
     */
    public boolean sendExtraCommand(
            @NonNull String provider, @NonNull String command, @Nullable Bundle extras) {
        android.util.SeempLog.record(48);
        Preconditions.checkArgument(provider != null, ""invalid null provider"");
        Preconditions.checkArgument(command != null, ""invalid null command"");

        try {
            return mService.sendExtraCommand(provider, command, extras);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
"
98,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    @Deprecated
    @RequiresPermission(ACCESS_FINE_LOCATION)
    public boolean addGpsStatusListener(GpsStatus.Listener listener) {
        android.util.SeempLog.record(43);
        boolean result;
"
99,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void addProximityAlert(double latitude, double longitude, float radius, long expiration,
            @NonNull PendingIntent intent) {
        android.util.SeempLog.record(45);
        checkPendingIntent(intent);
        if (expiration < 0) expiration = Long.MAX_VALUE;
"
100,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(@NonNull String provider, long minTime, float minDistance,
            @NonNull LocationListener listener) {
        android.util.SeempLog.record(47);
        checkProvider(provider);
        checkListener(listener);

        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, minTime, minDistance, false);
        requestLocationUpdates(request, listener, null, null);
"
101,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(@NonNull String provider, long minTime, float minDistance,
            @NonNull LocationListener listener, @Nullable Looper looper) {
        android.util.SeempLog.record(47);
        checkProvider(provider);
        checkListener(listener);

        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, minTime, minDistance, false);
        requestLocationUpdates(request, listener, looper, null);
"
102,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(@NonNull String provider, long minTime, float minDistance,
            @NonNull PendingIntent intent) {
        android.util.SeempLog.record(47);
        checkProvider(provider);
        checkPendingIntent(intent);

        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, minTime, minDistance, false);
        requestLocationUpdates(request, null, null, intent);
    }

    /**
     * Register for location updates using a Criteria and pending intent.
     *
     * <p>The <code>requestLocationUpdates()</code> and
     * <code>requestSingleUpdate()</code> register the current activity to be
     * updated periodically by the named provider, or by the provider matching
     * the specified {@link Criteria}, with location and status updates.
     *
     * <p> It may take a while to receive the first location update. If
     * an immediate location is required, applications may use the
     * {@link #getLastKnownLocation(String)} method.
     *
     * <p> Location updates are received either by {@link LocationListener}
     * callbacks, or by broadcast intents to a supplied {@link PendingIntent}.
     *
     * <p> If the caller supplied a pending intent, then location updates
     * are sent with a key of {@link #KEY_LOCATION_CHANGED} and a
     * {@link android.location.Location} value.
     *
     * <p> The location update interval can be controlled using the minTime parameter.
     * The elapsed time between location updates will never be less than
     * minTime, although it can be more depending on the Location Provider
     * implementation and the update interval requested by other applications.
     *
     * <p> Choosing a sensible value for minTime is important to conserve
     * battery life. Each location update requires power from
     * GPS, WIFI, Cell and other radios. Select a minTime value as high as
     * possible while still providing a reasonable user experience.
     * If your application is not in the foreground and showing
     * location to the user then your application should avoid using an active
     * provider (such as {@link #NETWORK_PROVIDER} or {@link #GPS_PROVIDER}),
     * but if you insist then select a minTime of 5 * 60 * 1000 (5 minutes)
     * or greater. If your application is in the foreground and showing
     * location to the user then it is appropriate to select a faster
     * update interval.
     *
     * <p> The minDistance parameter can also be used to control the
     * frequency of location updates. If it is greater than 0 then the
     * location provider will only send your application an update when
     * the location has changed by at least minDistance meters, AND
     * at least minTime milliseconds have passed. However it is more
     * difficult for location providers to save power using the minDistance
     * parameter, so minTime should be the primary tool to conserving battery
     * life.
     *
     * <p> If your application wants to passively observe location
     * updates triggered by other applications, but not consume
     * any additional power otherwise, then use the {@link #PASSIVE_PROVIDER}
     * This provider does not actively turn on or modify active location
     * providers, so you do not need to be as careful about minTime and
     * minDistance. However if your application performs heavy work
     * on a location update (such as network activity) then you should
     * select non-zero values for minTime and/or minDistance to rate-limit
     * your update frequency in the case another application enables a
     * location provider with extremely fast updates.
     *
     * <p>In case the provider is disabled by the user, updates will stop,
     * and a provider availability update will be sent.
     * As soon as the provider is enabled again,
     * location updates will immediately resume and a provider availability
     * update sent. Providers can also send status updates, at any time,
     * with extra's specific to the provider. If a callback was supplied
     * then status and availability updates are via
     * {@link LocationListener#onProviderDisabled},
     * {@link LocationListener#onProviderEnabled} or
     * {@link LocationListener#onStatusChanged}. Alternately, if a
     * pending intent was supplied then status and availability updates
     * are broadcast intents with extra keys of
     * {@link #KEY_PROVIDER_ENABLED} or {@link #KEY_STATUS_CHANGED}.
     *
     * <p> If a {@link LocationListener} is used but with no Looper specified
     * then the calling thread must already
     * be a {@link android.os.Looper} thread such as the main thread of the
     * calling Activity. If a Looper is specified with a {@link LocationListener}
     * then callbacks are made on the supplied Looper thread.
     *
     * <p> When location callbacks are invoked, the system will hold a wakelock
     * on your application's behalf for some period of time, but not
     * indefinitely. If your application requires a long running wakelock
     * within the location callback, you should acquire it yourself.
     *
     * <p class=""note""> Prior to Jellybean, the minTime parameter was
     * only a hint, and some location provider implementations ignored it.
     * From Jellybean and onwards it is mandatory for Android compatible
     * devices to observe both the minTime and minDistance parameters.
     *
     * @param minTime minimum time interval between location updates, in milliseconds
     * @param minDistance minimum distance between location updates, in meters
     * @param criteria contains parameters for the location manager to choose the
     * appropriate provider and parameters to compute the location
     * @param intent a {@link PendingIntent} to be sent for each location update
     *
     * @throws IllegalArgumentException if criteria is null
     * @throws IllegalArgumentException if intent is null
"
103,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(long minTime, float minDistance, @NonNull Criteria criteria,
            @NonNull LocationListener listener, @Nullable Looper looper) {
        android.util.SeempLog.record(47);
        checkCriteria(criteria);
        checkListener(listener);
"
104,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    @UnsupportedAppUsage
    private void requestLocationUpdates(LocationRequest request, LocationListener listener,
            Looper looper, PendingIntent intent) {
        android.util.SeempLog.record(47);

        String packageName = mContext.getPackageName();

        // wrap the listener class
        ListenerTransport transport = wrapListener(listener, looper);
"
105,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public Location getLastKnownLocation(String provider) {
        android.util.SeempLog.record(46);
"
106,location/java/android/location/LocationManager.java,"['edb6252578f9b76151e5125a7fb1b16823a68418', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']",2,"    public boolean addNmeaListener(GpsStatus.NmeaListener listener) {
        android.util.SeempLog.record(44);
"
107,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    public boolean addNmeaListener(GpsStatus.NmeaListener listener) {
        android.util.SeempLog.record(44);
        return false;
"
108,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public boolean sendExtraCommand(String provider, String command, Bundle extras) {
        android.util.SeempLog.record(48);
"
109,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public void requestLocationUpdates(LocationRequest request, LocationListener listener,
            Looper looper) {
        android.util.SeempLog.record(47);
"
110,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public void requestLocationUpdates(LocationRequest request, PendingIntent intent) {
        android.util.SeempLog.record(47);
"
111,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            "
112,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            LocationListener listener"
113,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            LocationListener listener) {
        android.util.SeempLog.record(47);
"
114,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            LocationListener listener, Looper looper) {
        android.util.SeempLog.record(47);
"
115,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            PendingIntent intent) {
        android.util.SeempLog.record(47);
"
116,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    public void requestLocationUpdates(long minTime, float minDistance, @NonNull Criteria criteria,
            @NonNull PendingIntent intent) {
        android.util.SeempLog.record(47);
        checkCriteria(criteria);
        checkPendingIntent(intent);
"
117,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria,
            "
118,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria,
            LocationListener listener, Looper looper) {
        android.util.SeempLog.record(47);
"
119,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria,
            PendingIntent intent) {
        android.util.SeempLog.record(47);
"
120,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    public void requestSingleUpdate(@NonNull Criteria criteria, @NonNull PendingIntent intent) {
        android.util.SeempLog.record(64);
        checkCriteria(criteria);
        checkPendingIntent(intent);
"
121,location/java/android/location/LocationManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    public void requestSingleUpdate(@NonNull String provider, @NonNull PendingIntent intent) {
        android.util.SeempLog.record(64);
        checkProvider(provider);
        checkPendingIntent(intent);
"
122,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public void requestSingleUpdate(Criteria criteria, LocationListener listener, Looper looper) {
        android.util.SeempLog.record(64);
"
123,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public void requestSingleUpdate(Criteria criteria, PendingIntent intent) {
        android.util.SeempLog.record(64);
"
124,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public void requestSingleUpdate(String provider, LocationListener listener, Looper looper) {
        android.util.SeempLog.record(64);
"
125,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"    public void requestSingleUpdate(String provider, PendingIntent intent) {
        android.util.SeempLog.record(64);
"
126,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1," PendingIntent intent) {
        android.util.SeempLog.record("
127,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,",
            LocationListener listener, Looper looper) {
        android.util.SeempLog.record(47);
"
128,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,", LocationListener listener, Looper looper) {
        android.util.SeempLog.record(64);
"
129,location/java/android/location/LocationManager.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,", PendingIntent intent) {
        android.util.SeempLog.record(64);
"
130,media/java/android/media/AudioFormat.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        ENCODING_AMRNB,
        ENCODING_AMRWB,
        ENCODING_EVRC,
        ENCODING_EVRCB,
        ENCODING_EVRCWB,
        ENCODING_EVRCNW }
"
131,media/java/android/media/AudioFormat.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        case ENCODING_AMRNB:
        case ENCODING_AMRWB:
        case ENCODING_EVRC:
        case ENCODING_EVRCB:
        case ENCODING_EVRCWB:
        case ENCODING_EVRCNW:
"
132,media/java/android/media/AudioFormat.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_AMRNB:
        case ENCODING_AMRWB:
        case ENCODING_EVRC:
        case ENCODING_EVRCB:
        case ENCODING_EVRCWB:
        case ENCODING_EVRCNW:
            return true;
        default:
            return false;
"
133,media/java/android/media/AudioFormat.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937: // wrapped in PCM but compressed
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_AMRNB:
        case ENCODING_AMRWB:
        case ENCODING_EVRC:
        case ENCODING_EVRCB:
        case ENCODING_EVRCWB:
        case ENCODING_EVRCNW:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException(""Bad audio format "" + audioFormat);
"
134,media/java/android/media/AudioSystem.java,['dfd2f7fed77160af2c57edfa20f1768b42aaa8da'],1,"            case AUDIO_FORMAT_CELT: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_CELT;
            case AUDIO_FORMAT_APTX_ADAPTIVE:
                     return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_ADAPTIVE;
            case AUDIO_FORMAT_APTX_TWSP:
                     return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_TWSP;
            default: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID;
"
135,media/java/android/media/MediaFile.java,['2edeff882ab756e76b3a028a1568d8774ddc0257'],1,"        addFileType(""MP3"", FILE_TYPE_MP3, ""audio/mpeg"", MtpConstants.FORMAT_MP3, true);
        addFileType(""MPGA"", FILE_TYPE_MP3, ""audio/mpeg"", MtpConstants.FORMAT_MP3, false);
        addFileType(""M4A"", FILE_TYPE_M4A, ""audio/mp4"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""WAV"", FILE_TYPE_WAV, ""audio/x-wav"", MtpConstants.FORMAT_WAV, true);
        addFileType(""AMR"", FILE_TYPE_AMR, ""audio/amr"");
        addFileType(""AWB"", FILE_TYPE_AWB, ""audio/amr-wb"");
        if (isWMAEnabled()) {
            addFileType(""WMA"", FILE_TYPE_WMA, ""audio/x-ms-wma"", MtpConstants.FORMAT_WMA, true);
        }
        addFileType(""OGG"", FILE_TYPE_OGG, ""audio/ogg"", MtpConstants.FORMAT_OGG, false);
        addFileType(""OGG"", FILE_TYPE_OGG, ""application/ogg"", MtpConstants.FORMAT_OGG, true);
        addFileType(""OGA"", FILE_TYPE_OGG, ""application/ogg"", MtpConstants.FORMAT_OGG, false);
        addFileType(""AAC"", FILE_TYPE_AAC, ""audio/aac"", MtpConstants.FORMAT_AAC, true);
        addFileType(""AAC"", FILE_TYPE_AAC, ""audio/aac-adts"", MtpConstants.FORMAT_AAC, false);
        addFileType(""MKA"", FILE_TYPE_MKA, ""audio/x-matroska"");

        addFileType(""MID"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""MIDI"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""XMF"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""RTTTL"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""SMF"", FILE_TYPE_SMF, ""audio/sp-midi"");
        addFileType(""IMY"", FILE_TYPE_IMY, ""audio/imelody"");
        addFileType(""RTX"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""OTA"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""MXMF"", FILE_TYPE_MID, ""audio/midi"");

        addFileType(""MPEG"", FILE_TYPE_MP4, ""video/mpeg"", MtpConstants.FORMAT_MPEG, true);
        addFileType(""MPG"", FILE_TYPE_MP4, ""video/mpeg"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""MP4"", FILE_TYPE_MP4, ""video/mp4"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""M4V"", FILE_TYPE_M4V, ""video/mp4"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""MOV"", FILE_TYPE_QT, ""video/quicktime"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""MP4"", FILE_TYPE_MP4, ""audio/mhas"", MtpConstants.FORMAT_MPEG, false);

        addFileType(""3GP"", FILE_TYPE_3GPP, ""video/3gpp"",  MtpConstants.FORMAT_3GP_CONTAINER, true);
        addFileType(""3GPP"", FILE_TYPE_3GPP, ""video/3gpp"", MtpConstants.FORMAT_3GP_CONTAINER, false);
        addFileType(""3G2"", FILE_TYPE_3GPP2, ""video/3gpp2"", MtpConstants.FORMAT_3GP_CONTAINER, false);
        addFileType(""3GPP2"", FILE_TYPE_3GPP2, ""video/3gpp2"", MtpConstants.FORMAT_3GP_CONTAINER, false);
        addFileType(""MKV"", FILE_TYPE_MKV, ""video/x-matroska"");
        addFileType(""WEBM"", FILE_TYPE_WEBM, ""video/webm"");
        addFileType(""TS"", FILE_TYPE_MP2TS, ""video/mp2ts"");
        addFileType(""AVI"", FILE_TYPE_AVI, ""video/avi"");

        if (isWMVEnabled()) {
            addFileType(""WMV"", FILE_TYPE_WMV, ""video/x-ms-wmv"", MtpConstants.FORMAT_WMV, true);
            addFileType(""ASF"", FILE_TYPE_ASF, ""video/x-ms-asf"");
        }

        addFileType(""JPG"", FILE_TYPE_JPEG, ""image/jpeg"", MtpConstants.FORMAT_EXIF_JPEG, true);
        addFileType(""JPEG"", FILE_TYPE_JPEG, ""image/jpeg"", MtpConstants.FORMAT_EXIF_JPEG, false);
        addFileType(""GIF"", FILE_TYPE_GIF, ""image/gif"", MtpConstants.FORMAT_GIF, true);
        addFileType(""PNG"", FILE_TYPE_PNG, ""image/png"", MtpConstants.FORMAT_PNG, true);
        addFileType(""BMP"", FILE_TYPE_BMP, ""image/x-ms-bmp"", MtpConstants.FORMAT_BMP, true);
        addFileType(""WBMP"", FILE_TYPE_WBMP, ""image/vnd.wap.wbmp"", MtpConstants.FORMAT_DEFINED, false);
        addFileType(""WEBP"", FILE_TYPE_WEBP, ""image/webp"", MtpConstants.FORMAT_DEFINED, false);
        addFileType(""HEIC"", FILE_TYPE_HEIF, ""image/heif"", MtpConstants.FORMAT_HEIF, true);
        addFileType(""HEIF"", FILE_TYPE_HEIF, ""image/heif"", MtpConstants.FORMAT_HEIF, false);

        addFileType(""DNG"", FILE_TYPE_DNG, ""image/x-adobe-dng"", MtpConstants.FORMAT_DNG, true);
        addFileType(""CR2"", FILE_TYPE_CR2, ""image/x-canon-cr2"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""NEF"", FILE_TYPE_NEF, ""image/x-nikon-nef"", MtpConstants.FORMAT_TIFF_EP, false);
        addFileType(""NRW"", FILE_TYPE_NRW, ""image/x-nikon-nrw"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""ARW"", FILE_TYPE_ARW, ""image/x-sony-arw"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""RW2"", FILE_TYPE_RW2, ""image/x-panasonic-rw2"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""ORF"", FILE_TYPE_ORF, ""image/x-olympus-orf"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""RAF"", FILE_TYPE_RAF, ""image/x-fuji-raf"", MtpConstants.FORMAT_DEFINED, false);
        addFileType(""PEF"", FILE_TYPE_PEF, ""image/x-pentax-pef"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""SRW"", FILE_TYPE_SRW, ""image/x-samsung-srw"", MtpConstants.FORMAT_TIFF, false);

        addFileType(""M3U"", FILE_TYPE_M3U, ""audio/x-mpegurl"", MtpConstants.FORMAT_M3U_PLAYLIST, true);
        addFileType(""M3U"", FILE_TYPE_M3U, ""application/x-mpegurl"", MtpConstants.FORMAT_M3U_PLAYLIST, false);
        addFileType(""PLS"", FILE_TYPE_PLS, ""audio/x-scpls"", MtpConstants.FORMAT_PLS_PLAYLIST, true);
        addFileType(""WPL"", FILE_TYPE_WPL, ""application/vnd.ms-wpl"", MtpConstants.FORMAT_WPL_PLAYLIST, true);
        addFileType(""M3U8"", FILE_TYPE_HTTPLIVE, ""application/vnd.apple.mpegurl"");
        addFileType(""M3U8"", FILE_TYPE_HTTPLIVE, ""audio/mpegurl"");
        addFileType(""M3U8"", FILE_TYPE_HTTPLIVE, ""audio/x-mpegurl"");

        addFileType(""FL"", FILE_TYPE_FL, ""application/x-android-drm-fl"");

        addFileType(""TXT"", FILE_TYPE_TEXT, ""text/plain"", MtpConstants.FORMAT_TEXT, true);
        addFileType(""HTM"", FILE_TYPE_HTML, ""text/html"", MtpConstants.FORMAT_HTML, true);
        addFileType(""HTML"", FILE_TYPE_HTML, ""text/html"", MtpConstants.FORMAT_HTML, false);
        addFileType(""PDF"", FILE_TYPE_PDF, ""application/pdf"");
        addFileType(""DOC"", FILE_TYPE_MS_WORD, ""application/msword"", MtpConstants.FORMAT_MS_WORD_DOCUMENT, true);
        addFileType(""XLS"", FILE_TYPE_MS_EXCEL, ""application/vnd.ms-excel"", MtpConstants.FORMAT_MS_EXCEL_SPREADSHEET, true);
        addFileType(""PPT"", FILE_TYPE_MS_POWERPOINT, ""application/vnd.ms-powerpoint"", MtpConstants.FORMAT_MS_POWERPOINT_PRESENTATION, true);
        addFileType(""FLAC"", FILE_TYPE_FLAC, ""audio/flac"", MtpConstants.FORMAT_FLAC, true);
        addFileType(""ZIP"", FILE_TYPE_ZIP, ""application/zip"");
        addFileType(""MPG"", FILE_TYPE_MP2PS, ""video/mp2p"");
        addFileType(""MPEG"", FILE_TYPE_MP2PS, ""video/mp2p"");
        addFileType(""DIVX"", FILE_TYPE_DIVX, ""video/divx"");
        addFileType(""FLV"", FILE_TYPE_FLV, ""video/flv"");
        addFileType(""QCP"", FILE_TYPE_QCP, ""audio/qcelp"");
        addFileType(""AC3"", FILE_TYPE_AC3, ""audio/ac3"");
        addFileType(""EC3"", FILE_TYPE_EC3, ""audio/eac3"");
        addFileType(""AIF"", FILE_TYPE_AIFF, ""audio/x-aiff"");
        addFileType(""AIFF"", FILE_TYPE_AIFF, ""audio/x-aiff"");
        addFileType(""APE"", FILE_TYPE_APE, ""audio/x-ape"");
        addFileType(""DSF"", FILE_TYPE_DSD, ""audio/x-dsf"");
        addFileType(""DFF"", FILE_TYPE_DSD, ""audio/x-dff"");
        addFileType(""DSD"", FILE_TYPE_DSD, ""audio/dsd"");
        addFileType(""MHAS"", FILE_TYPE_MHAS, ""audio/mhas"");
"
136,media/java/android/media/MediaFile.java,['2edeff882ab756e76b3a028a1568d8774ddc0257'],1,"        return ((fileType >= FIRST_AUDIO_FILE_TYPE &&
                fileType <= LAST_AUDIO_FILE_TYPE) ||
                (fileType >= FIRST_MIDI_FILE_TYPE &&
                fileType <= LAST_MIDI_FILE_TYPE) ||
                (fileType >= FIRST_AUDIO_FILE_TYPE_EXT &&
                fileType <= LAST_AUDIO_FILE_TYPE_EXT));
"
137,media/java/android/media/MediaFile.java,['2edeff882ab756e76b3a028a1568d8774ddc0257'],1,"    private static final int LAST_AUDIO_FILE_TYPE = FILE_TYPE_FLAC;

    // More audio file types
    public static final int FILE_TYPE_DTS   = 210;
    public static final int FILE_TYPE_3GPA  = 211;
    public static final int FILE_TYPE_AC3   = 212;
    public static final int FILE_TYPE_QCP   = 213;
    public static final int FILE_TYPE_PCM   = 214;
    public static final int FILE_TYPE_EC3   = 215;
    public static final int FILE_TYPE_AIFF  = 216;
    public static final int FILE_TYPE_APE   = 217;
    public static final int FILE_TYPE_DSD   = 218;
    public static final int FILE_TYPE_MHAS  = 219;
    private static final int FIRST_AUDIO_FILE_TYPE_EXT = FILE_TYPE_DTS;
    private static final int LAST_AUDIO_FILE_TYPE_EXT = FILE_TYPE_MHAS;

    // MIDI file types
    public static final int FILE_TYPE_MID     = 11;
    public static final int FILE_TYPE_SMF     = 12;
    public static final int FILE_TYPE_IMY     = 13;
    private static final int FIRST_MIDI_FILE_TYPE = FILE_TYPE_MID;
    private static final int LAST_MIDI_FILE_TYPE = FILE_TYPE_IMY;

    // Video file types
    public static final int FILE_TYPE_MP4     = 21;
    public static final int FILE_TYPE_M4V     = 22;
    public static final int FILE_TYPE_3GPP    = 23;
    public static final int FILE_TYPE_3GPP2   = 24;
    public static final int FILE_TYPE_WMV     = 25;
    public static final int FILE_TYPE_ASF     = 26;
    public static final int FILE_TYPE_MKV     = 27;
    public static final int FILE_TYPE_MP2TS   = 28;
    public static final int FILE_TYPE_AVI     = 29;
    public static final int FILE_TYPE_WEBM    = 30;
    private static final int FIRST_VIDEO_FILE_TYPE = FILE_TYPE_MP4;
    private static final int LAST_VIDEO_FILE_TYPE = FILE_TYPE_WEBM;

    // More video file types
    public static final int FILE_TYPE_MP2PS   = 200;
    public static final int FILE_TYPE_QT      = 201;
    public static final int FILE_TYPE_DIVX    = 202;
    public static final int FILE_TYPE_FLV = 203;
    private static final int FIRST_VIDEO_FILE_TYPE2 = FILE_TYPE_MP2PS;
    private static final int LAST_VIDEO_FILE_TYPE2 = FILE_TYPE_FLV;

    // Image file types
    public static final int FILE_TYPE_JPEG    = 31;
    public static final int FILE_TYPE_GIF     = 32;
    public static final int FILE_TYPE_PNG     = 33;
    public static final int FILE_TYPE_BMP     = 34;
    public static final int FILE_TYPE_WBMP    = 35;
    public static final int FILE_TYPE_WEBP    = 36;
    public static final int FILE_TYPE_HEIF    = 37;
    private static final int FIRST_IMAGE_FILE_TYPE = FILE_TYPE_JPEG;
    private static final int LAST_IMAGE_FILE_TYPE = FILE_TYPE_HEIF;

    // Raw image file types
    public static final int FILE_TYPE_DNG     = 300;
    public static final int FILE_TYPE_CR2     = 301;
    public static final int FILE_TYPE_NEF     = 302;
    public static final int FILE_TYPE_NRW     = 303;
    public static final int FILE_TYPE_ARW     = 304;
    public static final int FILE_TYPE_RW2     = 305;
    public static final int FILE_TYPE_ORF     = 306;
    public static final int FILE_TYPE_RAF     = 307;
    public static final int FILE_TYPE_PEF     = 308;
    public static final int FILE_TYPE_SRW     = 309;
    private static final int FIRST_RAW_IMAGE_FILE_TYPE = FILE_TYPE_DNG;
    private static final int LAST_RAW_IMAGE_FILE_TYPE = FILE_TYPE_SRW;

    // Playlist file types
    public static final int FILE_TYPE_M3U      = 41;
    public static final int FILE_TYPE_PLS      = 42;
    public static final int FILE_TYPE_WPL      = 43;
    public static final int FILE_TYPE_HTTPLIVE = 44;

    private static final int FIRST_PLAYLIST_FILE_TYPE = FILE_TYPE_M3U;
    private static final int LAST_PLAYLIST_FILE_TYPE = FILE_TYPE_HTTPLIVE;

    // Drm file types
    public static final int FILE_TYPE_FL      = 51;
    private static final int FIRST_DRM_FILE_TYPE = FILE_TYPE_FL;
    private static final int LAST_DRM_FILE_TYPE = FILE_TYPE_FL;

    // Other popular file types
    public static final int FILE_TYPE_TEXT          = 100;
    public static final int FILE_TYPE_HTML          = 101;
    public static final int FILE_TYPE_PDF           = 102;
    public static final int FILE_TYPE_XML           = 103;
    public static final int FILE_TYPE_MS_WORD       = 104;
    public static final int FILE_TYPE_MS_EXCEL      = 105;
    public static final int FILE_TYPE_MS_POWERPOINT = 106;
    public static final int FILE_TYPE_ZIP           = 107;
"
138,packages/SettingsLib/src/com/android/settingslib/Utils.java,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']",2,"        return getWifiIconResource(level, 0 /* standard */, false /* isReady */);
"
139,packages/SettingsLib/src/com/android/settingslib/Utils.java,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']",2,"     * @param level The number of bars to show (0-4)
     * @throws IllegalArgumentException if an invalid RSSI level is given.
     */
    public static int getWifiIconResource(int level, int standard, boolean isReady) {
        if (level < 0 || level >= WIFI_PIE.length) {
            throw new IllegalArgumentException(""No Wifi icon found for level: "" + level);
        }

        switch (standard) {
            case 4:
                return WIFI_4_PIE[level];
            case 5:
                if (isReady) {
                    return WIFI_6_PIE[level];
                } else {
                    return WIFI_5_PIE[level];
                }
            case 6:
                return WIFI_6_PIE[level];
            default:
                return WIFI_PIE[level];
       }
"
140,packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,['b6292e3e1ba3616eac1032737a91925391d94b92'],1,"        if (V) Log.d(TAG, "" execute getHighQualityAudioOptionLabel()"");
"
141,packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf'],1,"        if (V) Log.d(TAG, "" execute getHighQualityAudioOptionLabel()"");
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
"
142,packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,"['b6292e3e1ba3616eac1032737a91925391d94b92', '6aa497092f6337fbafb5b9858a3ec8f28c9d3caf']",2,"        if (V) Log.d(TAG, "" execute isHighQualityAudioEnabled()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        "
143,packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf'],1,"        if (V) Log.d(TAG, "" execute isHighQualityAudioEnabled()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
"
144,packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,['b6292e3e1ba3616eac1032737a91925391d94b92'],1,"        if (V) Log.d(TAG, "" execute isHighQualityAudioEnabled()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        int enabled = mService.getOptionalCodecsEnabled(device);
"
145,packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,"['b6292e3e1ba3616eac1032737a91925391d94b92', '6aa497092f6337fbafb5b9858a3ec8f28c9d3caf']",2,"        if (V) Log.d(TAG, "" execute setHighQualityAudioEnabled()"");
        int prefValue = enabled
                ? BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED
                : BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED;
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return;
        }
        "
146,packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf'],1,"        if (V) Log.d(TAG, "" execute setHighQualityAudioEnabled()"");
        int prefValue = enabled
                ? BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED
                : BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED;
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return;
        }
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
"
147,packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,['b6292e3e1ba3616eac1032737a91925391d94b92'],1,"        if (V) Log.d(TAG, "" execute setHighQualityAudioEnabled()"");
        int prefValue = enabled
                ? BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED
                : BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED;
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return;
        }
        mService.setOptionalCodecsEnabled(device, prefValue);
        if (getConnectionStatus(device) != BluetoothProfile.STATE_CONNECTED) {
"
148,packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,"['b6292e3e1ba3616eac1032737a91925391d94b92', '6aa497092f6337fbafb5b9858a3ec8f28c9d3caf']",2,"        if (V) Log.d(TAG, "" execute supportsHighQualityAudio()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        "
149,packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf'],1,"        if (V) Log.d(TAG, "" execute supportsHighQualityAudio()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
"
150,packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,['b6292e3e1ba3616eac1032737a91925391d94b92'],1,"        if (V) Log.d(TAG, "" execute supportsHighQualityAudio()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        int support = mService.supportsOptionalCodecs(device);
"
151,packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothEventManager.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"
    private void addHandler(String action, Handler handler) {
        mHandlerMap.put(action, handler);
        mAdapterIntentFilter.addAction(action);
    }

"
152,packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothEventManager.java,['2edeff882ab756e76b3a028a1568d8774ddc0257'],1,"                // callback to UI to create Preference for new device
"
153,packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"['1a06b5ab8af3c54728101c4dff83c8b5a6113ba9', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",2,"                        == BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET)) {
                    mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_ALLOWED);
                } else {
                    mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_REJECTED);
"
154,packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '757dbb836469bbdd7eb8312deaf584fe0c99c17d']",2,"                if ((mDevice.getBluetoothClass() != null) &&
                   (mDevice.getBluetoothClass().getDeviceClass()
                        == BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE ||
                    mDevice.getBluetoothClass().getDeviceClass()
"
155,packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,['2edeff882ab756e76b3a028a1568d8774ddc0257'],1,"            if (getPhonebookPermissionChoice() == CachedBluetoothDevice.ACCESS_UNKNOWN) {
                if ((mDevice.getBluetoothClass() != null) &&
                   (mDevice.getBluetoothClass().getDeviceClass()
                        == BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE ||
                    mDevice.getBluetoothClass().getDeviceClass()
                        == BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET)) {
                    setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
"
156,packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,['c77ad764fad2451538f140b31601e7b8c6c59fa2'],1,"        // be valid

        if (mDevice.isTwsPlusDevice() && mTwspBatteryState != -1 &&
           mTwspBatteryLevel != -1) {
            String s = ""TWSP: "";
            String chargingState;
            if (mTwspBatteryState == 1) {
                chargingState = ""Charging, "";
            } else {
                chargingState = ""Discharging, "";
            }
            s = s.concat (chargingState);
            s = s.concat(
                 com.android.settingslib.Utils.formatPercentage(mTwspBatteryLevel));
            batteryLevelPercentageString = s;
            Log.i(TAG, ""UI string"" + batteryLevelPercentageString);
        } else {
            final int batteryLevel = getBatteryLevel();
            if (batteryLevel != BluetoothDevice.BATTERY_LEVEL_UNKNOWN) {
                // TODO: name com.android.settingslib.bluetooth.Utils something different
                batteryLevelPercentageString =
"
157,packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"['6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6', '1581c348fc5d6cbf1673b3dbc5960637f891d488']",2,"        A2dpSinkProfile a2dpSinkProfile = mProfileManager.getA2dpSinkProfile();
        Log.i(TAG, ""a2dpProfile :"" + a2dpProfile + "" a2dpSinkProfile :"" + a2dpSinkProfile);
        if (a2dpProfile != null) {
            return a2dpProfile.getConnectionStatus(mDevice) ==
"
158,packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"        if (bondState == BluetoothDevice.BOND_BONDED) {
            boolean mIsBondingInitiatedLocally = mDevice.isBondingInitiatedLocally();
            Log.w(TAG, ""mIsBondingInitiatedLocally"" + mIsBondingInitiatedLocally);
            if (mIsBondingInitiatedLocally) {
                mDevice.setBondingInitiatedLocally(false);
            }
            if (mDevice.isBluetoothDock()) {
                onBondingDockConnect();
            } else if (mIsTwsConnectEnabled) {
                Log.d(TAG, ""Initiating connection to"" + mDevice);
                if (mIsBondingInitiatedLocally || mDevice.isTwsPlusDevice()) {
                    connect(false);
                }
            } else if (mIsBondingInitiatedLocally) {
                 connect(false);
            }
"
159,packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        if (bondState == BluetoothDevice.BOND_BONDED) {
            boolean mIsBondingInitiatedLocally = mDevice.isBondingInitiatedLocally();
            Log.w(TAG, ""mIsBondingInitiatedLocally"" + mIsBondingInitiatedLocally);
            if (mIsBondingInitiatedLocally) {
                mDevice.setBondingInitiatedLocally(false);
            }
            if (mIsTwsConnectEnabled) {
                Log.d(TAG, ""Initiating connection to"" + mDevice);
                if (mIsBondingInitiatedLocally || mDevice.isTwsPlusDevice()) {
                    connect(false);
                }
            } else if (mIsBondingInitiatedLocally) {
                 connect(false);
            }
"
160,packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', '2051462f672b5986ef321bf1de3657e7653864e8']",2,"    /* Gets Device for seondary TWS device
     * @param mDevice Primary TWS device  to get secondary
     * @return Description of the device
     */

    private BluetoothDevice getTwsPeerDevice() {
      BluetoothAdapter bluetoothAdapter;
      BluetoothDevice peerDevice = null;
      if (mDevice.isTwsPlusDevice()) {
        bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        String peerAddress = mDevice.getTwsPlusPeerAddress();
        peerDevice = bluetoothAdapter.getRemoteDevice(peerAddress);
      }
      return peerDevice;
"
161,packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"    private static final boolean mIsTwsConnectEnabled = false;
"
162,packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', '1581c348fc5d6cbf1673b3dbc5960637f891d488']",2,".annotation.VisibleForTesting;
import android.os.SystemProperties;
"
163,packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"import android.os.SystemProperties;
"
164,packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,['1581c348fc5d6cbf1673b3dbc5960637f891d488'],1,"import android.support.annotation.VisibleForTesting;
import android.os.SystemProperties;
"
165,packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,['ddcaa93e851eb5e57692799446f2ef3fe31436ae'],1,"import androidx.annotation.VisibleForTesting;
import android.os.SystemProperties;

"
166,packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"            if ((BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.HSP_AG) &&
                    BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP)) ||
                    (BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.Handsfree_AG) &&
                            BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree)) ||
                    (mHeadsetProfile.getConnectionStatus(device) == BluetoothProfile.STATE_CONNECTED)) {
"
167,packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,['6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6'],1,"        List<Integer> supportedList = mLocalAdapter.getSupportedProfiles();
        if (supportedList.contains(BluetoothProfile.HEARING_AID)) {
            mHearingAidProfile = new HearingAidProfile(mContext, mLocalAdapter, mDeviceManager,
                                                       this);
            addProfile(mHearingAidProfile, HearingAidProfile.NAME,
                       BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);
        }

        mDunProfile = new DunServerProfile(context);
        addProfile(mDunProfile, DunServerProfile.NAME,
                BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);

"
168,packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"        if (mA2dpProfile != null) {
            if (BluetoothUuid.containsAnyUuid(uuids, A2dpProfile.SINK_UUIDS) ||
                (mA2dpProfile.getConnectionStatus(device) == BluetoothProfile.STATE_CONNECTED)) {
                profiles.add(mA2dpProfile);
                removedProfiles.remove(mA2dpProfile);
            }
"
169,packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"['1730c08a2fd38f0ff8135692a855ada865130939', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']",2,"        if (mDunProfile == null && supportedList.contains(BluetoothProfile.DUN)) {
            if(DEBUG) Log.d(TAG, ""Adding local DUN profile"");
            mDunProfile = new DunServerProfile(mContext);
            addProfile(mDunProfile, DunServerProfile.NAME,
                    BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);
"
170,packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,['a9808279aa66eb64ea573100d13cf753bf293a4c'],1,"        mHearingAidProfile = new HearingAidProfile(mContext, mLocalAdapter, mDeviceManager, this);
        addProfile(mHearingAidProfile, HearingAidProfile.NAME,
                   BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);

        mDunProfile = new DunServerProfile(context);
        addProfile(mDunProfile, DunServerProfile.NAME,
                BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);

"
171,packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"        }
        if (mDunProfile == null && supportedList.contains(BluetoothProfile.DUN)) {
            if(DEBUG) Log.d(TAG, ""Adding local DUN profile"");
            mDunProfile = new DunServerProfile(mContext);
            addProfile(mDunProfile, DunServerProfile.NAME,
                    BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);
"
172,packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"    private DunServerProfile mDunProfile;
"
173,packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,['2edeff882ab756e76b3a028a1568d8774ddc0257'],1,"    private DunServerProfile mDunProfile;
    private final boolean mUsePbapPce;
    private final boolean mUseMapClient;
"
174,packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']",2,"import android.bluetooth.BluetoothDun;
"
175,packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"import android.bluetooth.BluetoothDun;
import android.bluetooth.BluetoothSap;
"
176,packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,['af02bd5317cc0cced0a7646d5bbf407a181dda9c'],1,"import android.os.SystemProperties;
"
177,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"            case SECURITY_DPP:
                return concise ? context.getString(R.string.wifi_security_short_dpp) :
                    context.getString(R.string.wifi_security_dpp);
"
178,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"        boolean wpa3TransitionMode = result.capabilities.contains(""PSK"")
                                         && result.capabilities.contains(""SAE"");
"
179,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        if (config.allowedKeyManagement.get(KeyMgmt.DPP)) {
            return SECURITY_DPP;
        }
        if (config.allowedKeyManagement.get(KeyMgmt.SAE)) {
            return SECURITY_SAE;
        }
"
180,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,['5358a994b854c7a6627858c48d6947e8acff6ea9'],1,"        } else if (result.capabilities.contains(""PSK"")
                   && result.capabilities.contains(""SAE"")) {
            return SECURITY_PSK_SAE_TRANSITION;
"
181,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        } else if (security == SECURITY_DPP) {
            return ""DPP"";
        } else if (security == SECURITY_SAE) {
            return ""SAE"";
"
182,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '4a30c150e58ec67edb92a7bec5ea48cebd6b90d4']",2,"    private static final int LEGACY_CAPABLE_BSSID = 0;
    private static final int HT_CAPABLE_BSSID = 1;
    private static final int VHT_CAPABLE_BSSID = 2;
    private static final int HE_CAPABLE_BSSID = 3;
    private static final int MAX_CAPABLE_BSSID = Integer.MAX_VALUE;

    private static final int WIFI_GENERATION_LEGACY = 0;
    private static final int WIFI_GENERATION_4 = 4;
    private static final int WIFI_GENERATION_5 = 5;
    private static final int WIFI_GENERATION_6 = 6;
"
183,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"    private static final int LEGACY_CAPABLE_BSSID = 0;
    private static final int HT_CAPABLE_BSSID = 1;
    private static final int VHT_CAPABLE_BSSID = 2;
    private static final int HE_CAPABLE_BSSID = 3;
    private static final int MAX_CAPABLE_BSSID = Integer.MAX_VALUE;

    private static final int WIFI_GENERATION_LEGACY = 0;
    private static final int WIFI_GENERATION_4 = 4;
    private static final int WIFI_GENERATION_5 = 5;
    private static final int WIFI_GENERATION_6 = 6;

    /**
     * The number of distinct wifi levels.
     *
     * <p>Must keep in sync with {@link R.array.wifi_signal} and {@link WifiManager#RSSI_LEVELS}.
     */
    public static final int SIGNAL_LEVELS = 5;

"
184,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"['799030b703da27e7117eba75c2ca753b0e976a8d', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']",2,"    private static int getSecurity(ScanResult result) {
        if (result.capabilities.contains(""DPP"")) {
            return SECURITY_DPP;
        } else if (result.capabilities.contains(""WEP"")) {
            return SECURITY_WEP;
        } else if ("
185,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"    private static int getSecurity(ScanResult result) {
        if (result.capabilities.contains(""DPP"")) {
            return SECURITY_DPP;
        } else if (result.capabilities.contains(""WEP"")) {
            return SECURITY_WEP;
        } else if (result.capabilities.contains(""PSK"")
                   && result.capabilities.contains(""SAE"")) {
            return SECURITY_PSK_SAE_TRANSITION;
        } else if (result.capabilities.contains(""SAE"")) {
"
186,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"['757dbb836469bbdd7eb8312deaf584fe0c99c17d', 'b76115be4efabffaa6febc57cec47acc2f933c79', '8d21ad0d966c1e9f96e5a65144efad2582391957']",3,    public static final int SECURITY_DPP = 
187,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"    public static final int SECURITY_DPP = 6;
"
188,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"['757dbb836469bbdd7eb8312deaf584fe0c99c17d', '8d21ad0d966c1e9f96e5a65144efad2582391957']",2,"    public static final int SECURITY_DPP = 7;
"
189,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,['9caf34febf01086c96266e38d024f7a0315b892d'],1,"    public static final int SECURITY_DPP = 7;
    public static final int SECURITY_MAX_VAL = 8; // Has to be the last
"
190,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"    public static final int SECURITY_PSK_SAE_TRANSITION = 7;
    public static final int SECURITY_OWE_TRANSITION = 8;
    public static final int SECURITY_DPP = 9;
    public static final int SECURITY_MAX_VAL = 10; // Has to be the last
"
191,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPointPreference.java,['9caf34febf01086c96266e38d024f7a0315b892d'],1,"        if (mAccessPoint.getSecurity() != AccessPoint.SECURITY_NONE &&
            mAccessPoint.getSecurity() != AccessPoint.SECURITY_OWE) {
"
192,packages/SettingsLib/src/com/android/settingslib/wifi/AccessPointPreference.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        if (mAccessPoint.getSecurity() == AccessPoint.SECURITY_SAE) {
            mFrictionSld.setState(STATE_SECURED_SAE);
        } else if (mAccessPoint.getSecurity() == AccessPoint.SECURITY_OWE) {
            mFrictionSld.setState(STATE_SECURED_OWE);
        } else if (mAccessPoint.getSecurity() != AccessPoint.SECURITY_NONE) {
"
193,packages/SettingsLib/src/com/android/settingslib/wifi/WifiEntryPreference.java,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']",2,"        final Drawable drawable = mIconInjector.getIcon(level, standard, isReady);
"
194,packages/SettingsLib/src/com/android/settingslib/wifi/WifiEntryPreference.java,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']",2,"        final int standard = mWifiEntry.getWifiStandard();
        final boolean vhtMax8SpatialStreamsSupport = mWifiEntry.isVhtMax8SpatialStreamsSupported();
        final boolean he8ssCapableAp = mWifiEntry.isHe8ssCapableAp();

        if (level != mLevel || standard != mWifiStandard || he8ssCapableAp != mHe8ssCapableAp ||
                vhtMax8SpatialStreamsSupport != mVhtMax8SpatialStreamsSupport) {
            mLevel = level;
            mWifiStandard = standard;
            mHe8ssCapableAp = he8ssCapableAp;
            mVhtMax8SpatialStreamsSupport = vhtMax8SpatialStreamsSupport;
            updateIcon(mLevel, mWifiStandard, mHe8ssCapableAp && mVhtMax8SpatialStreamsSupport);
"
195,packages/SettingsLib/src/com/android/settingslib/wifi/WifiEntryPreference.java,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']",2,"    private int mWifiStandard;
    private boolean mVhtMax8SpatialStreamsSupport;
    private boolean mHe8ssCapableAp;
"
196,packages/SettingsLib/src/com/android/settingslib/wifi/WifiEntryPreference.java,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']",2,"    private void updateIcon(int level, int standard, boolean isReady) {
"
197,packages/SettingsLib/src/com/android/settingslib/wifi/WifiUtils.java,['6fc85c43e31aad55eecd51d3b0de34715ae03810'],1,"        int maxRssi5 = WifiConfiguration.INVALID_RSSI;
        int maxRssi24 = WifiConfiguration.INVALID_RSSI;
        int maxRssi60 = WifiConfiguration.INVALID_RSSI;
"
198,packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java,['3a5272699e3e16fbfdc397480898bb27abeb2caa'],1,"	    loadStringSetting(stmt, Settings.Global.NTP_SERVER_2,
                    R.string.def_ntp_server_2);
"
199,packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java,['4646ace2d5aecc79f895d6273c928602852d7f12'],1,"                         ""ro.telephony.default_network"",
                         Integer.toString(RILConstants.NETWORK_MODE_WCDMA_PREF));
"
200,packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"                        ? RILConstants.NETWORK_MODE_WCDMA_PREF : defaultNetworks.get(phoneId);
"
201,packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"                mode = TelephonyManager.getTelephonyProperty(phoneId,
                         ""ro.telephony.default_network"",
                         Integer.toString(RILConstants.NETWORK_MODE_WCDMA_PREF));
                if (phoneId == 0) {
                    val = mode;
                } else {
                    val = val + "","" + mode;
                }
"
202,packages/SystemUI/src/com/android/keyguard/CarrierTextController.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '35fa949362e35d8514c64a645b6448424f174c82']",2,"    @VisibleForTesting
    protected boolean mDisplayOpportunisticSubscriptionCarrierText;
    private FiveGServiceClient mFiveGServiceClient;
"
203,packages/SystemUI/src/com/android/keyguard/EmergencyButton.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"import android.telephony.ServiceState;
"
204,packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"    private boolean mScramblePin;

    private List<Integer> mNumbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 0);
"
205,packages/SystemUI/src/com/android/keyguard/KeyguardSimPinView.java,"['657230bb5e95ec8560c534360cac5a25fd743129', '89cad5d93a5083474840e90d08d6e4aec5833932']",2,"                // If the SIM is removed, then we must remove the keyguard. It will be put up
                // again when the PUK locked SIM is re-entered.
                case ABSENT: {
                    KeyguardUpdateMonitor.getInstance(getContext()).reportSimUnlocked(subId);
                    // onSimStateChanged callback can fire when the SIM PIN lock is not currently
                    // active and mCallback is null.
                    if (mCallback != null) {
                        mCallback.dismiss(true, KeyguardUpdateMonitor.getCurrentUser());
                    }
                    "
206,packages/SystemUI/src/com/android/keyguard/KeyguardSimPinView.java,['89cad5d93a5083474840e90d08d6e4aec5833932'],1,"                // If the SIM is removed, then we must remove the keyguard. It will be put up
                // again when the PUK locked SIM is re-entered.
                case ABSENT: {
                    KeyguardUpdateMonitor.getInstance(getContext()).reportSimUnlocked(subId);
                    // onSimStateChanged callback can fire when the SIM PIN lock is not currently
                    // active and mCallback is null.
                    if (mCallback != null) {
                        mCallback.dismiss(true, KeyguardUpdateMonitor.getCurrentUser());
                    }
                    break;
                }
"
207,packages/SystemUI/src/com/android/keyguard/KeyguardSimPinView.java,['657230bb5e95ec8560c534360cac5a25fd743129'],1,"                // If the SIM is removed, then we must remove the keyguard. It will be put up
                // again when the PUK locked SIM is re-entered.
                case ABSENT: {
                    KeyguardUpdateMonitor.getInstance(getContext()).reportSimUnlocked(subId);
                    // onSimStateChanged callback can fire when the SIM PIN lock is not currently
                    // active and mCallback is null.
                    if (mCallback != null) {
                        mCallback.dismiss(true, KeyguardUpdateMonitor.getCurrentUser());
                    }
                    mSubId = subId;
                    break;
                }
"
208,packages/SystemUI/src/com/android/keyguard/KeyguardSimPinView.java,['6e44ad255823e1b7f2b23386d61af655c19adb49'],1,"    private void showDefaultMessage() {
        if (mRemainingAttempts >= 0) {
            mSecurityMessageDisplay.setMessage(getPinPasswordErrorMessage(
                    mRemainingAttempts, true));
            return;
        }

        mSlotId = SubscriptionManager.getSlotIndex(mSubId) + 1;
"
209,packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,['4e4914b22b779e6376bb00ae20636175b2a70d8c'],1,"                case MSG_LOCALE_CHANGED:
                    handleLocaleChanged();
"
210,packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"['f2b53072aa24c3f9f84e762d313f85f5f179e4a4', '8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",3,"            Log.d(TAG, ""handleFingerprintAuth"
211,packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"['f2b53072aa24c3f9f84e762d313f85f5f179e4a4', '8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",3,"            Log.d(TAG, ""handleFingerprintAuthFailed()""
"
212,packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"['f2b53072aa24c3f9f84e762d313f85f5f179e4a4', '8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",3,"            Log.d(TAG, ""handleFingerprintAuthenticated()""
"
213,packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,['4e4914b22b779e6376bb00ae20636175b2a70d8c'],1,"            } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);
"
214,packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"        for (int j = 0; j < mCallbacks.size(); j++) {
            KeyguardUpdateMonitorCallback cb = mCallbacks.get(j).get();
            if (cb != null) {
                cb.onRefreshCarrierInfo();
                cb.onServiceStateChanged(subId, serviceState);
            }
        }
"
215,packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"['1730c08a2fd38f0ff8135692a855ada865130939', '657230bb5e95ec8560c534360cac5a25fd743129', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6', '4e4914b22b779e6376bb00ae20636175b2a70d8c']",4,"    private static final int MSG_LOCALE_CHANGED = 500;
"
216,packages/SystemUI/src/com/android/keyguard/NumPadKey.java,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",2,"import lineageos.providers.LineageSettings;

public class NumPadKey extends ViewGroup {
"
217,packages/SystemUI/src/com/android/systemui/CornerHandleView.java,"['4986b8091f9beefea4189a5884e7a9edd7f53034', '35fa949362e35d8514c64a645b6448424f174c82']",2,"                com.android.internal.R.dimen.rounded_corner_radius_bottom);
        if (radius == 0 && mDisableRoundedCorner == 0) {
"
218,packages/SystemUI/src/com/android/systemui/ScreenDecorations.java,"['8abdf0e95a5d15a310b6df69d33a4510a0b44b4a', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '2b1a920917d6b9235c008921845152448c7e5fc7']",3,"        int newRoundedDefault = mContext.getResources().getDimensionPixelSize(
"
219,packages/SystemUI/src/com/android/systemui/biometrics/UdfpsDialogMeasureAdapter.java,"['45681a1567c48072612384989589781af2c646f1', '5cb9413cc504ba46231d9eef0ea04abd6f435b7a']",2,"                    + "", Bottom spacer height (portrait): "" + spacerHeight);
"
220,packages/SystemUI/src/com/android/systemui/biometrics/UdfpsDialogMeasureAdapter.java,"['45681a1567c48072612384989589781af2c646f1', '5cb9413cc504ba46231d9eef0ea04abd6f435b7a']",2,"                    + "", Horizontal spacer width (landscape): "" + horizontalPadding);
"
221,packages/SystemUI/src/com/android/systemui/biometrics/UdfpsDialogMeasureAdapter.java,"['45681a1567c48072612384989589781af2c646f1', '5cb9413cc504ba46231d9eef0ea04abd6f435b7a']",2,"                dialogMargin);
"
222,packages/SystemUI/src/com/android/systemui/biometrics/UdfpsDialogMeasureAdapter.java,"['45681a1567c48072612384989589781af2c646f1', '5cb9413cc504ba46231d9eef0ea04abd6f435b7a']",2,"                mSensorProps, displayWidth, dialogMargin);
"
223,packages/SystemUI/src/com/android/systemui/biometrics/UdfpsDialogMeasureAdapter.java,"['45681a1567c48072612384989589781af2c646f1', '5cb9413cc504ba46231d9eef0ea04abd6f435b7a']",2,"            int dialogMarginPx) {
"
224,packages/SystemUI/src/com/android/systemui/biometrics/UdfpsDialogMeasureAdapter.java,"['45681a1567c48072612384989589781af2c646f1', '5cb9413cc504ba46231d9eef0ea04abd6f435b7a']",2,"            int textIndicatorHeightPx, int buttonBarHeightPx, int dialogMarginPx) {
"
225,packages/SystemUI/src/com/android/systemui/doze/DozeSensors.java,"['45681a1567c48072612384989589781af2c646f1', '5cb9413cc504ba46231d9eef0ea04abd6f435b7a']",2,"                        !dozeParameters.longPressNeedsProximityCheck() /* performsProxCheck */),
"
226,packages/SystemUI/src/com/android/systemui/doze/DozeSensors.java,"['45681a1567c48072612384989589781af2c646f1', '5cb9413cc504ba46231d9eef0ea04abd6f435b7a']",2,                    performsProxCheck
227,packages/SystemUI/src/com/android/systemui/doze/DozeSensors.java,"['45681a1567c48072612384989589781af2c646f1', '5cb9413cc504ba46231d9eef0ea04abd6f435b7a']",2,"                    performsProxCheck
"
228,packages/SystemUI/src/com/android/systemui/doze/DozeSensors.java,"['45681a1567c48072612384989589781af2c646f1', '5cb9413cc504ba46231d9eef0ea04abd6f435b7a']",2,"                    performsProxCheck,
"
229,packages/SystemUI/src/com/android/systemui/doze/DozeSensors.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"                if (DEBUG) Log.d(TAG, ""onSensorEvent: "" + triggerEventToString(event));
                mSensorCallback.onSensorPulse(mPulseReason, true /* sensorPerformsProxCheck */,
                        -1, -1, event.getValues());
"
230,packages/SystemUI/src/com/android/systemui/doze/DozeSensors.java,"['45681a1567c48072612384989589781af2c646f1', '5cb9413cc504ba46231d9eef0ea04abd6f435b7a']",2,"                mSensorCallback.onSensorPulse(mPulseReason, mPerformsProxCheck,
                        screenX, screenY, event.values);
                if (!mRegistered) {
                    updateListening();  // reregister, this sensor only fires once
"
231,packages/SystemUI/src/com/android/systemui/globalactions/GlobalActionsDialog.java,"['12930acc5076e1acff0744b8d225bb2d2173f1b5', '7100a7fa7244d86adf9e33b9079ce2a355e2a525']",2,"        for (int i = 0; i < mCurrentMenuActions.length; i++) {
            String actionKey = mCurrentMenuActions[i];
"
232,packages/SystemUI/src/com/android/systemui/globalactions/GlobalActionsDialog.java,"['12930acc5076e1acff0744b8d225bb2d2173f1b5', '7100a7fa7244d86adf9e33b9079ce2a355e2a525']",2,"import android.os.Messenger;
import android.os.PowerManager;
"
233,packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"                mStatusBarKeyguardViewManager.setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
"
234,packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java,['b6292e3e1ba3616eac1032737a91925391d94b92'],1,"                mStatusBarKeyguardViewManagerLazy.get().setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
"
235,packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java,"['edb6252578f9b76151e5125a7fb1b16823a68418', '74a21b989f82a6a024f29085ad324e939472bed1', 'b6292e3e1ba3616eac1032737a91925391d94b92']",3,".setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
"
236,packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java,"['74a21b989f82a6a024f29085ad324e939472bed1', 'b6292e3e1ba3616eac1032737a91925391d94b92']",2,"erLazy.get().setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
"
237,packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"import com.android.systemui.Dependency;
import com.android.systemui.DumpController;
"
238,packages/SystemUI/src/com/android/systemui/navigationbar/NavigationBarView.java,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",2,"import com.android.systemui.statusbar.phone.NotificationPanelViewController;
import com.android.systemui.tuner.TunerService;
"
239,packages/SystemUI/src/com/android/systemui/qs/QSFooterImpl.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"
    private void handleUpdateState() {
        for (int i = 0; i < SIM_SLOTS; i++) {
            mMobileGroups[i].setVisibility(mInfos[i].visible ? View.VISIBLE : View.GONE);
            if (mInfos[i].visible) {
                mMobileRoamings[i].setVisibility(mInfos[i].roaming ? View.VISIBLE : View.GONE);
                mMobileRoamings[i].setImageTintList(ColorStateList.valueOf(mColorForeground));
                SignalDrawable d = new SignalDrawable(mContext);
                d.setDarkIntensity(QuickStatusBarHeader.getColorIntensity(mColorForeground));
                mMobileSignals[i].setImageDrawable(d);
                mMobileSignals[i].setImageLevel(mInfos[i].mobileSignalIconId);

                StringBuilder contentDescription = new StringBuilder();
                if (mInfos[i].contentDescription != null) {
                    contentDescription.append(mInfos[i].contentDescription).append("", "");
                }
                if (mInfos[i].roaming) {
                    contentDescription
                            .append(mContext.getString(R.string.data_connection_roaming))
                            .append("", "");
                }
                // TODO: show mobile data off/no internet text for 5 seconds before carrier text
                if (TextUtils.equals(mInfos[i].typeContentDescription,
                        mContext.getString(R.string.data_connection_no_internet))
                        || TextUtils.equals(mInfos[i].typeContentDescription,
                        mContext.getString(R.string.cell_data_off_content_description))) {
                    contentDescription.append(mInfos[i].typeContentDescription);
                }
                mMobileSignals[i].setContentDescription(contentDescription);
            }
        }
        mCarrierDivider.setVisibility(
                mInfos[0].visible && mInfos[1].visible ? View.VISIBLE : View.GONE);
    }

    @VisibleForTesting
    protected int getSlotIndex(int subscriptionId) {
        return SubscriptionManager.getSlotIndex(subscriptionId);
    }

    @Override
    public void updateCarrierInfo(CarrierTextController.CarrierTextCallbackInfo info) {
        if (info.anySimReady) {
            boolean[] slotSeen = new boolean[SIM_SLOTS];
            if (info.listOfCarriers.length == info.subscriptionIds.length) {
                for (int i = 0; i < SIM_SLOTS && i < info.listOfCarriers.length; i++) {
                    int slot = getSlotIndex(info.subscriptionIds[i]);
                    if (slot >= SIM_SLOTS) {
                        Log.w(TAG, ""updateInfoCarrier - slot: "" + slot);
                        continue;
                    }
                    if (slot == SubscriptionManager.INVALID_SIM_SLOT_INDEX) {
                        Log.e(TAG,
                                ""Invalid SIM slot index for subscription: ""
                                        + info.subscriptionIds[i]);
                        continue;
                    }
                    mInfos[slot].visible = true;
                    slotSeen[slot] = true;
                    mCarrierTexts[slot].setText(info.listOfCarriers[i].toString().trim());
                    mCarrierGroups[slot].setVisibility(View.VISIBLE);
                }
                for (int i = 0; i < SIM_SLOTS; i++) {
                    if (!slotSeen[i]) {
                        mInfos[i].visible = false;
                        mCarrierGroups[i].setVisibility(View.GONE);
                    }
                }
            } else {
                Log.e(TAG, ""Carrier information arrays not of same length"");
            }
        } else {
            mInfos[0].visible = false;
            mCarrierTexts[0].setText(info.carrierText);
            mCarrierGroups[0].setVisibility(View.VISIBLE);
            for (int i = 1; i < SIM_SLOTS; i++) {
                mInfos[i].visible = false;
                mCarrierTexts[i].setText("""");
                mCarrierGroups[i].setVisibility(View.GONE);
            }
        }
        handleUpdateState();
    }

    @Override
    public void setMobileDataIndicators(NetworkController.IconState statusIcon,
            NetworkController.IconState qsIcon, int statusType,
            int qsType, boolean activityIn, boolean activityOut,
            int volteIcon, String typeContentDescription,
            String description, boolean isWide, int subId, boolean roaming) {
        int slotIndex = getSlotIndex(subId);
        if (slotIndex >= SIM_SLOTS) {
            Log.w(TAG, ""setMobileDataIndicators - slot: "" + slotIndex);
            return;
        }
        if (slotIndex == SubscriptionManager.INVALID_SIM_SLOT_INDEX) {
            Log.e(TAG, ""Invalid SIM slot index for subscription: "" + subId);
            return;
        }
        mInfos[slotIndex].visible = statusIcon.visible;
        mInfos[slotIndex].mobileSignalIconId = statusIcon.icon;
        mInfos[slotIndex].contentDescription = statusIcon.contentDescription;
        mInfos[slotIndex].typeContentDescription = typeContentDescription;
        mInfos[slotIndex].roaming = roaming;
        handleUpdateState();
    }

    @Override
    public void setNoSims(boolean hasNoSims, boolean simDetected) {
        if (hasNoSims) {
            mInfos[0].visible = false;
            mInfos[1].visible = false;
        }
        handleUpdateState();
    }

    private final class CellSignalState {
        boolean visible;
        int mobileSignalIconId;
        public String contentDescription;
        String typeContentDescription;
        boolean roaming;
    }

    /**
     * TextView that changes its ellipsize value with its visibility.
     */
    public static class QSCarrierText extends TextView {
        public QSCarrierText(Context context) {
            super(context);
        }

        public QSCarrierText(Context context, AttributeSet attrs) {
            super(context, attrs);
        }

        public QSCarrierText(Context context, AttributeSet attrs, int defStyleAttr) {
            super(context, attrs, defStyleAttr);
        }

        public QSCarrierText(Context context, AttributeSet attrs, int defStyleAttr,
                int defStyleRes) {
            super(context, attrs, defStyleAttr, defStyleRes);
        }

        @Override
        protected void onVisibilityChanged(View changedView, int visibility) {
            super.onVisibilityChanged(changedView, visibility);
            // Only show marquee when visible
            if (visibility == VISIBLE) {
                setEllipsize(TextUtils.TruncateAt.MARQUEE);
                setSelected(true);
            } else {
                setEllipsize(TextUtils.TruncateAt.END);
                setSelected(false);
            }
        }
    }
"
240,packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,"['4a30c150e58ec67edb92a7bec5ea48cebd6b90d4', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']",2,"
        updateResources();
"
241,packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,['af02bd5317cc0cced0a7646d5bbf407a181dda9c'],1,"
        updateResources();

        mPluginManager = pluginManager;
"
242,packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0'],1,"                findViewById(R.id.brightness_slider), broadcastDispatcher);

        updateResources();
"
243,packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,"['3933f277a025be704e68ea593536e492831a7e05', '587cb520382d349c91bd59ada23fbefcdb44314f']",2,"        for (TileRecord r : mRecords) {
            r.tile.clearState();
        }
        "
244,packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,['587cb520382d349c91bd59ada23fbefcdb44314f'],1,"        for (TileRecord r : mRecords) {
            r.tile.clearState();
        }
        refreshAllTiles();
"
245,packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"        mDumpController = dumpController;

        updateResources();
"
246,packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,['19ac51594dd13e5a2e702d2c50b290f1f71a9fc0'],1,"        mTileLayout.setListening(mListening);
        addView((View) mTileLayout);

        mQsTileRevealController = new QSTileRevealController(mContext, this,
                (PagedTileLayout) mTileLayout);

        addDivider();

        mFooter = new QSSecurityFooter(this, context);
        addView(mFooter.getView());

"
247,packages/SystemUI/src/com/android/systemui/qs/QSPanelController.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
"
248,packages/SystemUI/src/com/android/systemui/qs/QSTileHost.java,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",2,"
"
249,packages/SystemUI/src/com/android/systemui/qs/QuickStatusBarHeader.java,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"        qqsLP.topMargin = largeScreenHeaderActive || !mUseCombinedQSHeader
                ? mContext.getResources().getDimensionPixelSize(R.dimen.qqs_layout_margin_top)
                : SystemBarUtils.getQuickQsOffsetHeight(mContext);
"
250,packages/SystemUI/src/com/android/systemui/qs/customize/QSCustomizer.java,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"        SpannableString resetText = new SpannableString(
                mContext.getString(com.android.internal.R.string.reset));
        resetText.setSpan(new ForegroundColorSpan(isNightMode() ?
                Color.WHITE : Color.BLACK), 0, resetText.length(), 0);
        toolbar.getMenu().add(Menu.NONE, MENU_RESET, 0, resetText);
"
251,packages/SystemUI/src/com/android/systemui/qs/tileimpl/QSFactoryImpl.java,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",2,"            // Additional tiles.
            case ""ambient_display"":
                return mAmbientDisplayTileProvider.get();
            case ""aod"":
                return mAODTileProvider.get();
            case ""caffeine"":
                return mCaffeineTileProvider.get();
            case ""heads_up"":
                return mHeadsUpTileProvider.get();
            case ""reading_mode"":
                return mReadingModeTileProvider.get();
            case ""sync"":
                return mSyncTileProvider.get();
            case ""powershare"":
                return mPowerShareTileProvider.get();
            case """
252,packages/SystemUI/src/com/android/systemui/qs/tileimpl/QSFactoryImpl.java,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",2,"            Provider<AmbientDisplayTile> ambientDisplayTileProvider,
            Provider<AODTile> aodTileProvider,
            Provider<CaffeineTile> caffeineTileProvider,
            Provider<HeadsUpTile> headsUpTileProvider,
            Provider<PowerShareTile> powerShareTileProvider,
            Provider<"
253,packages/SystemUI/src/com/android/systemui/qs/tileimpl/QSFactoryImpl.java,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",2,"        mAmbientDisplayTileProvider = ambientDisplayTileProvider;
        mAODTileProvider = aodTileProvider;
        mCaffeineTileProvider = caffeineTileProvider;
        mHeadsUpTileProvider = headsUpTileProvider;
        mReadingModeTileProvider = readingModeTileProvider;
        mSyncTileProvider = syncTileProvider;
        mPowerShareTileProvider = powerShareTileProvider;
        m"
254,packages/SystemUI/src/com/android/systemui/qs/tileimpl/QSFactoryImpl.java,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",2,"    private final Provider<AmbientDisplayTile> mAmbientDisplayTileProvider;
    private final Provider<AODTile> mAODTileProvider;
    private final Provider<CaffeineTile> mCaffeineTileProvider;
    private final Provider<HeadsUpTile> mHeadsUpTileProvider;
    private final Provider<ReadingModeTile> mReadingModeTileProvider;
    private final Provider<SyncTile> mSyncTileProvider;
    private final Provider<PowerShareTile> mPowerShareTileProvider;
    private final Provider<"
255,packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTile.java,"['efe5cc44da2c1772c733a6740a761b3b42969db4', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",2,"                int qsType, boolean activityIn, boolean activityOut, int volteIcon,
                String typeContentDescription, String description, boolean isWide,
                int subId, boolean roaming) {
"
256,packages/SystemUI/src/com/android/systemui/qs/tiles/HotspotTile.java,['1eef3e1566be8570a0f7a856f12f8992f7d34824'],1,"            state.icon = ResourceIcon.get(R.drawable.ic_hotspot_transient_animation);
        } else if (state.value) {
            if (mIeee80211axSupport) {
                state.icon = mWifi6EnabledStatic;
            } else if (mIeee80211acSupport) {
                state.icon = mWifi5EnabledStatic;
            }
"
257,packages/SystemUI/src/com/android/systemui/qs/tiles/HotspotTile.java,"['2051462f672b5986ef321bf1de3657e7653864e8', '3d2fc559e13b7293212955f1858d443f4fe8234e']",2,"e;
import android.content.Context;
"
258,packages/SystemUI/src/com/android/systemui/qs/tiles/HotspotTile.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"import android.content.ComponentName;
import android.content.Context;
"
259,packages/SystemUI/src/com/android/systemui/screenshot/GlobalScreenshot.java,"['b7ff81acc796b2957f68c9412cef71b9b47e67de', '8943bbe92bfbc3ead44f63a6a3c145a135548b7c']",2,"    private static final String SCREENSHOT_FILE_NAME_TEMPLATE_APPNAME = ""Screenshot_%s_%s.png"";
"
260,packages/SystemUI/src/com/android/systemui/screenshot/ImageExporter.java,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"                String foregroundAppName, CompressFormat format, int quality, boolean publish) {
"
261,packages/SystemUI/src/com/android/systemui/screenshot/ImageExporter.java,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"            String foregroundAppName) {
        return export(executor, requestId, bitmap, ZonedDateTime.now(), foregroundAppName);
"
262,packages/SystemUI/src/com/android/systemui/screenshot/ImageExporter.java,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"            ZonedDateTime captureTime, String foregroundAppName) {

        final Task task = new Task(mResolver, requestId, bitmap, captureTime, foregroundAppName,
                mCompressFormat, mQuality, /* publish */ true);
"
263,packages/SystemUI/src/com/android/systemui/screenshot/ImageExporter.java,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"            mFileName = createFilename(mCaptureTime, mFormat, foregroundAppName);
"
264,packages/SystemUI/src/com/android/systemui/screenshot/LongScreenshotActivity.java,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"                mLongScreenshotHolder.getForegroundAppName());
"
265,packages/SystemUI/src/com/android/systemui/screenshot/SaveImageInBackgroundTask.java,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"                    mImageExporter.export(Runnable::run, requestId, image,
                            params != null ? params[0] : null);
"
266,packages/SystemUI/src/com/android/systemui/screenshot/SaveImageInBackgroundTask.java,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"            mImageData.viewTransition = createViewAction(mContext, mContext.getResources(), uri);
            mImageData.shareTransition = createShareAction(mContext, mContext.getResources(), uri);
            mImageData.editTransition = createEditAction(mContext, mContext.getResources(), uri);
            mImageData.deleteAction = createDeleteAction(mContext, mContext.getResources(), uri);
"
267,packages/SystemUI/src/com/android/systemui/screenshot/ScreenshotView.java,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"            startSharedTransition(
                    imageData.viewTransition.get());
"
268,packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"
    private final TunerService mTunerService;

"
269,packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"            TunerService tunerService,
            Context context) {
        super(view,
                falsingManager,
                dozeLog,
                keyguardStateController,
                (SysuiStatusBarStateController) statusBarStateController,
                notificationShadeWindowController,
                vibratorHelper,
                statusBarKeyguardViewManager,
                latencyTracker,
                flingAnimationUtilsBuilder.get(),
                statusBarTouchableRegionManager,
                lockscreenGestureLogger,
                panelExpansionStateManager,
                ambientState,
                interactionJankMonitor,
                shadeLogger,
                systemClock);
"
270,packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"    @Override
    protected OnLayoutChangeListener createLayoutChangeListener() {
        return new OnLayoutChangeListenerImpl();
    }

    @Override
    protected TouchHandler createTouchHandler() {
        return new TouchHandler() {

            private long mLastTouchDownTime = -1L;

            @Override
            public boolean onInterceptTouchEvent(MotionEvent event) {
                if (SPEW_LOGCAT) {
                    Log.v(TAG,
                            ""NPVC onInterceptTouchEvent ("" + event.getId() + ""): ("" + event.getX()
                                    + "","" + event.getY() + "")"");
                }
                if (mBlockTouches || mQs.disallowPanelTouches()) {
                    return false;
                }
                initDownStates(event);
                // Do not let touches go to shade or QS if the bouncer is visible,
                // but still let user swipe down to expand the panel, dismissing the bouncer.
                if (mCentralSurfaces.isBouncerShowing()) {
                    return true;
                }
                if (mCommandQueue.panelsEnabled()
                        && !mNotificationStackScrollLayoutController.isLongPressInProgress()
                        && mHeadsUpTouchHelper.onInterceptTouchEvent(event)) {
                    mMetricsLogger.count(COUNTER_PANEL_OPEN, 1);
                    mMetricsLogger.count(COUNTER_PANEL_OPEN_PEEK, 1);
                    return true;
                }
                if (!shouldQuickSettingsIntercept(mDownX, mDownY, 0)
                        && mPulseExpansionHandler.onInterceptTouchEvent(event)) {
                    return true;
                }

                if (!isFullyCollapsed() && onQsIntercept(event)) {
                    if (DEBUG_LOGCAT) Log.d(TAG, ""onQsIntercept true"");
                    return true;
                }
                return super.onInterceptTouchEvent(event);
            }

            @Override
            public boolean onTouch(View v, MotionEvent event) {
                if (event.getAction() == MotionEvent.ACTION_DOWN) {
                    if (event.getDownTime() == mLastTouchDownTime) {
                        // An issue can occur when swiping down after unlock, where multiple down
                        // events are received in this handler with identical downTimes. Until the
                        // source of the issue can be located, detect this case and ignore.
                        // see b/193350347
                        Log.w(TAG, ""Duplicate down event detected... ignoring"");
                        return true;
                    }
                    mLastTouchDownTime = event.getDownTime();
                }


                if (mBlockTouches || (mQsFullyExpanded && mQs != null
                        && mQs.disallowPanelTouches())) {
                    return false;
                }

                // Do not allow panel expansion if bouncer is scrimmed or showing over a dream,
                // otherwise user would be able to pull down QS or expand the shade.
                if (mCentralSurfaces.isBouncerShowingScrimmed()
                        || mCentralSurfaces.isBouncerShowingOverDream()) {
                    return false;
                }

                if (mDoubleTapToSleepEnabled && !mPulsing && !mDozing) {
                    mDoubleTapGesture.onTouchEvent(event);
                }

                // Make sure the next touch won't the blocked after the current ends.
                if (event.getAction() == MotionEvent.ACTION_UP
                        || event.getAction() == MotionEvent.ACTION_CANCEL) {
                    mBlockingExpansionForCurrentTouch = false;
                }
                // When touch focus transfer happens, ACTION_DOWN->ACTION_UP may happen immediately
                // without any ACTION_MOVE event.
                // In such case, simply expand the panel instead of being stuck at the bottom bar.
                if (mLastEventSynthesizedDown && event.getAction() == MotionEvent.ACTION_UP) {
                    expand(true /* animate */);
                }
                initDownStates(event);

                // If pulse is expanding already, let's give it the touch. There are situations
                // where the panel starts expanding even though we're also pulsing
                boolean pulseShouldGetTouch = (!mIsExpanding
                        && !shouldQuickSettingsIntercept(mDownX, mDownY, 0))
                        || mPulseExpansionHandler.isExpanding();
                if (pulseShouldGetTouch && mPulseExpansionHandler.onTouchEvent(event)) {
                    // We're expanding all the other ones shouldn't get this anymore
                    mShadeLog.logMotionEvent(event, ""onTouch: PulseExpansionHandler handled event"");
                    return true;
                }
                if (mListenForHeadsUp && !mHeadsUpTouchHelper.isTrackingHeadsUp()
                        && !mNotificationStackScrollLayoutController.isLongPressInProgress()
                        && mHeadsUpTouchHelper.onInterceptTouchEvent(event)) {
                    mMetricsLogger.count(COUNTER_PANEL_OPEN_PEEK, 1);
                }
                boolean handled = mHeadsUpTouchHelper.onTouchEvent(event);

                if (!mHeadsUpTouchHelper.isTrackingHeadsUp() && handleQsTouch(event)) {
                    mShadeLog.logMotionEvent(event, ""onTouch: handleQsTouch handled event"");
                    return true;
                }
                if (event.getActionMasked() == MotionEvent.ACTION_DOWN && isFullyCollapsed()) {
                    mMetricsLogger.count(COUNTER_PANEL_OPEN, 1);
                    handled = true;
                }

                if (event.getActionMasked() == MotionEvent.ACTION_DOWN && isFullyExpanded()
                        && mStatusBarKeyguardViewManager.isShowing()) {
                    mStatusBarKeyguardViewManager.updateKeyguardPosition(event.getX());
                }

                handled |= super.onTouch(v, event);
                return !mDozing || mPulsing || handled;
            }
        };
    }

    private final PhoneStatusBarView.TouchEventHandler mStatusBarViewTouchEventHandler =
            new PhoneStatusBarView.TouchEventHandler() {
                @Override
                public void onInterceptTouchEvent(MotionEvent event) {
                    mCentralSurfaces.onTouchEvent(event);
                }

                @Override
                public boolean handleTouchEvent(MotionEvent event) {
                    mCentralSurfaces.onTouchEvent(event);

                    // TODO(b/202981994): Move the touch debugging in this method to a central
                    //  location. (Right now, it's split between CentralSurfaces and here.)

                    // If panels aren't enabled, ignore the gesture and don't pass it down to the
                    // panel view.
                    if (!mCommandQueue.panelsEnabled()) {
                        if (event.getAction() == MotionEvent.ACTION_DOWN) {
                            Log.v(
                                    TAG,
                                    String.format(
                                            ""onTouchForwardedFromStatusBar: ""
                                                    + ""panel disabled, ignoring touch at (%d,%d)"",
                                            (int) event.getX(),
                                            (int) event.getY()
                                    )
                            );
                        }
                        return false;
                    }

                    // If the view that would receive the touch is disabled, just have status bar
                    // eat the gesture.
                    if (event.getAction() == MotionEvent.ACTION_DOWN && !mView.isEnabled()) {
                        Log.v(TAG,
                                String.format(
                                        ""onTouchForwardedFromStatusBar: ""
                                                + ""panel view disabled, eating touch at (%d,%d)"",
                                        (int) event.getX(),
                                        (int) event.getY()
                                )
                        );
                        return true;
                    }

                    return mView.dispatchTouchEvent(event);
                }
            };

    @Override
    protected OnConfigurationChangedListener createOnConfigurationChangedListener() {
        return new OnConfigurationChangedListener();
"
271,packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"    private class OnAttachStateChangeListener implements View.OnAttachStateChangeListener,
            TunerService.Tunable {
"
272,packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"    private final NotificationIconAreaController mNotificationIconAreaController;

    /**
     * Maximum time before which we will expand the panel even for slow motions when getting a
     * touch passed over from launcher.
     */
    private static final int MAX_TIME_TO_OPEN_WHEN_FLINGING_FROM_LAUNCHER = 300;

    private static final int MAX_DOWN_EVENT_BUFFER_SIZE = 50;

    private static final String COUNTER_PANEL_OPEN = ""panel_open"";
    private static final String COUNTER_PANEL_OPEN_QS = ""panel_open_qs"";
    private static final String COUNTER_PANEL_OPEN_PEEK = ""panel_open_peek"";

    private static final String STATUS_BAR_QUICK_QS_PULLDOWN =
            ""lineagesystem:"" + LineageSettings.System.STATUS_BAR_QUICK_QS_PULLDOWN;
    private static final String DOUBLE_TAP_SLEEP_GESTURE =
            ""lineagesystem:"" + LineageSettings.System.DOUBLE_TAP_SLEEP_GESTURE;

    private static final Rect M_DUMMY_DIRTY_RECT = new Rect(0, 0, 1, 1);
    private static final Rect EMPTY_RECT = new Rect();

"
273,packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",3,"import android.content.Context;
"
274,packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",3,"import android.view.GestureDetector;
"
275,packages/SystemUI/src/com/android/systemui/statusbar/StatusBarMobileView.java,['1581c348fc5d6cbf1673b3dbc5960637f891d488'],1,"        updateFiveGState(state);
"
276,packages/SystemUI/src/com/android/systemui/statusbar/StatusBarMobileView.java,['4a30c150e58ec67edb92a7bec5ea48cebd6b90d4'],1,"    private ImageView mVolte;
"
277,packages/SystemUI/src/com/android/systemui/statusbar/connectivity/MobileSignalController.java,"['f2b53072aa24c3f9f84e762d313f85f5f179e4a4', '8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",3,"        if (mProviderModelBehavior) {
"
278,packages/SystemUI/src/com/android/systemui/statusbar/notification/row/wrapper/NotificationMediaTemplateViewWrapper.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']",3,"        addOnPreDrawListener();
    }


    private void addOnPreDrawListener() {
        if ( !mOnPreDrawListenerRegistered ) {
            mOnPreDrawListenerRegistered = true;
            mSeekBarView.getViewTreeObserver().addOnPreDrawListener(mPreDrawListener);
        }
    }

    private void removeOnPreDrawListener() {
        if ( mOnPreDrawListenerRegistered ) {
            mSeekBarView.getViewTreeObserver().removeOnPreDrawListener(mPreDrawListener);
            mHandler.postDelayed(mOnUpdateTimerTick, PROGRESS_UPDATE_INTERVAL);
            mOnPreDrawListenerRegistered = false;
"
279,packages/SystemUI/src/com/android/systemui/statusbar/notification/row/wrapper/NotificationMediaTemplateViewWrapper.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']",3,"    private boolean mOnPreDrawListenerRegistered = false;
"
280,packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java,"['337095f9d277c566cb888bc3adbac16576f1ae70', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",3,"    private EmergencyCarrierArea mEmergencyCarrierArea;
"
281,packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    private EmergencyCarrierArea mEmergencyCarrierArea;
    private final UnlockMethodCache mUnlockMethodCache;
"
282,packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java,['4646ace2d5aecc79f895d6273c928602852d7f12'],1,"    private void updateEmergencyButton() {
        if (mEmergencyButton != null) {
            mEmergencyButton.updateEmergencyCallButton();
        }
"
283,packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarFragment.java,['db8a16a19bc4c35bc8ba2ff9a3fd4341177e1e26'],1,"        int nbMode = mStatusBar.computeBarMode(0, mSystemUiVisibility,
                View.NAVIGATION_BAR_TRANSIENT, View.NAVIGATION_BAR_TRANSLUCENT,
                View.NAVIGATION_BAR_TRANSPARENT);
        if ( nbMode != -1 ) {
            mNavigationBarMode = nbMode;
"
284,packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationIconContainer.java,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",3,"    public final int MAX_ICONS_ON_LOCKSCREEN =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIconsOnLock);
    public final int MAX_STATIC_ICONS =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIcons);
    private static final int MAX_DOTS = 1;
"
285,packages/SystemUI/src/com/android/systemui/statusbar/phone/PanelViewController.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"
        mPerf = new BoostFramework();
"
286,packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java,['ddc3dc79034f4570388245270b50ddad964c11f0'],1,"
    @Override
    public void onMediaDataLoaded(String key, MediaData data) {
        updateMediaIcon();
    }

    @Override
    public void onMediaDataRemoved(String key) {
        updateMediaIcon();
    }

    private void updateMediaIcon() {
        mIconController.setIconVisibility(mSlotMedia, mMediaDataManager.hasActiveMedia());
    }

    private void updateHotspotIcon(int standard) {
        if (standard == ScanResult.WIFI_STANDARD_11AX) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_6_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11AC) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_5_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11N) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_4_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        }
    }
"
287,packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '8faa0d981413f18b2468dde1b1fe71e248df0df1']",2,"        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        broadcastDispatcher.registerReceiver"
288,packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        broadcastDispatcher.registerReceiver(mIntentReceiver, filter, mHandler);
"
289,packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        broadcastDispatcher.registerReceiverWithHandler(mIntentReceiver, filter, mHandler);
"
290,packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        mContext.registerReceiver(mIntentReceiver, filter, null, mHandler);
"
291,packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"    private void updateHotspotIcon() {
        int generation;
        if (mWifiManager != null) {
            generation = mWifiManager.getSoftApWifiGeneration();
        } else {
            generation = WifiManager.WIFI_GENERATION_DEFAULT; // boot not completed yet
        }
        if (generation == WifiManager.WIFI_GENERATION_6) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_6_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        } else if (generation == WifiManager.WIFI_GENERATION_5) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_5_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        } else if (generation == WifiManager.WIFI_GENERATION_4) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_4_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        } else {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        }
    }

    private void handleBootCompleted() {
        mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
        // hotspot
        updateHotspotIcon();
        mIconController.setIconVisibility(mSlotHotspot, mHotspot.isHotspotEnabled());
"
292,packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java,"['ddc3dc79034f4570388245270b50ddad964c11f0', 'a9736185db896fe2edde0281d71102b35327b7f8']",2,"    private void updateHotspotIcon(int standard) {
        if (standard == ScanResult.WIFI_STANDARD_11AX) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_6_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11AC) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_5_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11N) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_4_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        }
"
293,packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java,"['f67897bc05520f743974fc397aa96e4049a057b3', '8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6']",2,"    private View mLeftSide, mStatusIcons, mNetworkTraffic, mBattery"
294,packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",2,"    private View mLeftSide, mStatusIcons, mNetworkTraffic, mBattery;
"
295,packages/SystemUI/src/com/android/systemui/statusbar/phone/ScrimState.java,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"
        // to make sure correct color is returned before ""prepare"" is called
        @Override
        public int getBehindTint() {
            return Color.TRANSPARENT;
        }
"
296,packages/SystemUI/src/com/android/systemui/statusbar/phone/ScrimState.java,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"            mBehindTint = Color.TRANSPARENT;
"
297,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4', '96e5fca97c43ea282d5ad4b7c6fad40acd91586d', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']",4,"                new Handler(), mKeyguardUpdateMonitor, "
298,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']",3,"                new Handler(), mKeyguardUpdateMonitor, Dependency.get(TunerService.class));
"
299,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    @VisibleForTesting
    final class DozeServiceHost implements DozeHost {
        private final ArrayList<Callback> mCallbacks = new ArrayList<>();
        private boolean mAnimateWakeup;
        private boolean mAnimateScreenOff;
        private boolean mIgnoreTouchWhilePulsing;
        @VisibleForTesting
        boolean mWakeLockScreenPerformsAuth = SystemProperties.getBoolean(
                ""persist.sysui.wake_performs_auth"", true);

        @Override
        public String toString() {
            return ""PSB.DozeServiceHost[mCallbacks="" + mCallbacks.size() + ""]"";
        }

        public void firePowerSaveChanged(boolean active) {
            for (Callback callback : mCallbacks) {
                callback.onPowerSaveChanged(active);
            }
        }

        public void fireNotificationPulse(NotificationEntry entry) {
            Runnable pulseSupressedListener = () -> {
                entry.setPulseSuppressed(true);
                mNotificationIconAreaController.updateAodNotificationIcons();
            };
            for (Callback callback : mCallbacks) {
                callback.onNotificationAlerted(pulseSupressedListener);
            }
        }

        @Override
        public void addCallback(@NonNull Callback callback) {
            mCallbacks.add(callback);
        }

        @Override
        public void removeCallback(@NonNull Callback callback) {
            mCallbacks.remove(callback);
        }

        @Override
        public void startDozing() {
            if (!mDozingRequested) {
                mDozingRequested = true;
                DozeLog.traceDozing(mContext, mDozing);
                updateDozing();
                updateIsKeyguard();
            }else{
                mDozingRequested = true;
            }
        }

        @Override
        public void pulseWhileDozing(@NonNull PulseCallback callback, int reason) {
            if (reason == DozeLog.PULSE_REASON_SENSOR_LONG_PRESS) {
                mPowerManager.wakeUp(SystemClock.uptimeMillis(), PowerManager.WAKE_REASON_GESTURE,
                        ""com.android.systemui:LONG_PRESS"");
                startAssist(new Bundle());
                return;
            }

            if (reason == DozeLog.PULSE_REASON_SENSOR_WAKE_LOCK_SCREEN) {
                mScrimController.setWakeLockScreenSensorActive(true);
            }

            if (reason == DozeLog.PULSE_REASON_DOCKING && mStatusBarWindow != null) {
                mStatusBarWindow.suppressWakeUpGesture(true);
            }

            boolean passiveAuthInterrupt = reason == DozeLog.PULSE_REASON_SENSOR_WAKE_LOCK_SCREEN
                            && mWakeLockScreenPerformsAuth;
            // Set the state to pulsing, so ScrimController will know what to do once we ask it to
            // execute the transition. The pulse callback will then be invoked when the scrims
            // are black, indicating that StatusBar is ready to present the rest of the UI.
            mPulsing = true;
            mDozeScrimController.pulse(new PulseCallback() {
                @Override
                public void onPulseStarted() {
                    callback.onPulseStarted();
                    updateNotificationPanelTouchState();
                    setPulsing(true);
                }

                @Override
                public void onPulseFinished() {
                    mPulsing = false;
                    callback.onPulseFinished();
                    updateNotificationPanelTouchState();
                    mScrimController.setWakeLockScreenSensorActive(false);
                    if (mStatusBarWindow != null) {
                        mStatusBarWindow.suppressWakeUpGesture(false);
                    }
                    setPulsing(false);
                }

                private void setPulsing(boolean pulsing) {
                    mStatusBarStateController.setPulsing(pulsing);
                    mStatusBarKeyguardViewManager.setPulsing(pulsing);
                    mKeyguardViewMediator.setPulsing(pulsing);
                    mNotificationPanel.setPulsing(pulsing);
                    mVisualStabilityManager.setPulsing(pulsing);
                    mStatusBarWindow.setPulsing(pulsing);
                    mIgnoreTouchWhilePulsing = false;
                    if (mKeyguardUpdateMonitor != null && passiveAuthInterrupt) {
                        mKeyguardUpdateMonitor.onAuthInterruptDetected(pulsing /* active */);
                    }
                    updateScrimController();
                    mPulseExpansionHandler.setPulsing(pulsing);
                    mWakeUpCoordinator.setPulsing(pulsing);
                }
            }, reason);
            // DozeScrimController is in pulse state, now let's ask ScrimController to start
            // pulsing and draw the black frame, if necessary.
            updateScrimController();
        }

        @Override
        public void stopDozing() {
            if (mDozingRequested) {
                mDozingRequested = false;
                DozeLog.traceDozing(mContext, mDozing);
                updateDozing();
            }
        }

        @Override
        public void onIgnoreTouchWhilePulsing(boolean ignore) {
            if (ignore != mIgnoreTouchWhilePulsing) {
                DozeLog.tracePulseTouchDisabledByProx(mContext, ignore);
            }
            mIgnoreTouchWhilePulsing = ignore;
            if (isDozing() && ignore) {
                mStatusBarWindow.cancelCurrentTouch();
            }
        }

        @Override
        public void dozeTimeTick() {
            mNotificationPanel.dozeTimeTick();
            if (mAmbientIndicationContainer instanceof DozeReceiver) {
                ((DozeReceiver) mAmbientIndicationContainer).dozeTimeTick();
            }
        }

        @Override
        public boolean isPowerSaveActive() {
            return mBatteryController.isAodPowerSave();
        }

        @Override
        public boolean isPulsingBlocked() {
            return mBiometricUnlockController.getMode()
                    == BiometricUnlockController.MODE_WAKE_AND_UNLOCK;
        }

        @Override
        public boolean isProvisioned() {
            return mDeviceProvisionedController.isDeviceProvisioned()
                    && mDeviceProvisionedController.isCurrentUserSetup();
        }

        @Override
        public boolean isBlockingDoze() {
            if (mBiometricUnlockController.hasPendingAuthentication()) {
                Log.i(TAG, ""Blocking AOD because fingerprint has authenticated"");
                return true;
            }
            return false;
        }

        @Override
        public void extendPulse(int reason) {
            if (reason == DozeLog.PULSE_REASON_SENSOR_WAKE_LOCK_SCREEN) {
                mScrimController.setWakeLockScreenSensorActive(true);
            }
            if (mDozeScrimController.isPulsing() && mHeadsUpManager.hasNotifications()) {
                mHeadsUpManager.extendHeadsUp();
            } else {
                mDozeScrimController.extendPulse();
            }
        }

        @Override
        public void stopPulsing() {
            if (mDozeScrimController.isPulsing()) {
                mDozeScrimController.pulseOutNow();
            }
        }

        @Override
        public void setAnimateWakeup(boolean animateWakeup) {
            if (mWakefulnessLifecycle.getWakefulness() == WAKEFULNESS_AWAKE
                    || mWakefulnessLifecycle.getWakefulness() == WAKEFULNESS_WAKING) {
                // Too late to change the wakeup animation.
                return;
            }
            mAnimateWakeup = animateWakeup;
        }

        @Override
        public void setAnimateScreenOff(boolean animateScreenOff) {
            mAnimateScreenOff = animateScreenOff;
        }

        @Override
        public void onSlpiTap(float screenX, float screenY) {
            if (screenX > 0 && screenY > 0 && mAmbientIndicationContainer != null
                && mAmbientIndicationContainer.getVisibility() == View.VISIBLE) {
                mAmbientIndicationContainer.getLocationOnScreen(mTmpInt2);
                float viewX = screenX - mTmpInt2[0];
                float viewY = screenY - mTmpInt2[1];
                if (0 <= viewX && viewX <= mAmbientIndicationContainer.getWidth()
                        && 0 <= viewY && viewY <= mAmbientIndicationContainer.getHeight()) {
                    dispatchTap(mAmbientIndicationContainer, viewX, viewY);
                }
            }
        }

        @Override
        public void setDozeScreenBrightness(int value) {
            mStatusBarWindowController.setDozeScreenBrightness(value);
        }

        @Override
        public void setAodDimmingScrim(float scrimOpacity) {
            mScrimController.setAodFrontScrimAlpha(scrimOpacity);
        }

        @Override
        public void prepareForGentleWakeUp() {
            mScrimController.prepareForGentleWakeUp();
        }

        private void dispatchTap(View view, float x, float y) {
            long now = SystemClock.elapsedRealtime();
            dispatchTouchEvent(view, x, y, now, MotionEvent.ACTION_DOWN);
            dispatchTouchEvent(view, x, y, now, MotionEvent.ACTION_UP);
        }

        private void dispatchTouchEvent(View view, float x, float y, long now, int action) {
            MotionEvent ev = MotionEvent.obtain(now, now, action, x, y, 0 /* meta */);
            view.dispatchTouchEvent(ev);
            ev.recycle();
        }

        private boolean shouldAnimateWakeup() {
            return mAnimateWakeup;
        }

        public boolean shouldAnimateScreenOff() {
            return mAnimateScreenOff;
        }
    }

"
300,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
"
301,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
"
302,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
"
303,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
"
304,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
"
305,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['f2b53072aa24c3f9f84e762d313f85f5f179e4a4', '8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",3,"            mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
"
306,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
"
307,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
"
308,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
"
309,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
"
310,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
"
311,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
"
312,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
"
313,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
"
314,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
"
315,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
"
316,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
"
317,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
"
318,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
"
319,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarSignalPolicy.java,"['efe5cc44da2c1772c733a6740a761b3b42969db4', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",2,"            int qsType, boolean activityIn, boolean activityOut, int volteIcon,
            String typeContentDescription, String description, boolean isWide,
            int subId, boolean roaming) {
"
320,packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarSignalPolicy.java,"['efe5cc44da2c1772c733a6740a761b3b42969db4', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",2,"        public String typeContentDescription;
        public int volteId;
"
321,packages/SystemUI/src/com/android/systemui/statusbar/phone/fragment/CollapsedStatusBarFragment.java,"['72ae328c0ea598eaf6e115a44520b2e7f3cc9eba', '5cb9413cc504ba46231d9eef0ea04abd6f435b7a']",2,"            animateShow(mNetworkTrafficHolder, animate);
"
322,packages/SystemUI/src/com/android/systemui/statusbar/phone/fragment/CollapsedStatusBarFragment.java,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",2,"            animateShow(mSystemIconArea, animate);
            animateShow(mNetworkTrafficHolder, animate);
        } else {
            // We are in the middle of a system status event animation, which will animate the
            // alpha (but not the visibility). Allow the view to become visible again
            mSystemIconArea.setVisibility(View.VISIBLE);
            mNetworkTrafficHolder.setVisibility(View.VISIBLE);
"
323,packages/SystemUI/src/com/android/systemui/statusbar/phone/fragment/CollapsedStatusBarFragment.java,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",2,"        mSystemIconArea = mStatusBar.findViewById(R.id.system_icon_area);
        mNetworkTrafficHolder = mStatusBar.findViewById(R.id.network_traffic_holder);
"
324,packages/SystemUI/src/com/android/systemui/statusbar/phone/fragment/CollapsedStatusBarFragment.java,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",2,"    private void hideSystemIconArea(boolean animate) {
        animateHide(mSystemIconArea, animate);
        animateHide(mNetworkTrafficHolder, animate);
"
325,packages/SystemUI/src/com/android/systemui/statusbar/policy/BluetoothControllerImpl.java,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",2,"    public int getBatteryLevel() {
        if (!mConnectedDevices.isEmpty()) {
            return mConnectedDevices.get(0).getBatteryLevel();
        }
        return -1;
    }

    private void updateBattery() {
        int batteryLevel = getBatteryLevel();
        if (batteryLevel != mBatteryLevel) {
            mBatteryLevel = batteryLevel;
            mHandler.sendEmptyMessage(H.MSG_STATE_CHANGED);
        }
    }

    @Override
    public void onBluetoothStateChanged(int bluetoothState) {
        if (DEBUG) Log.d(TAG, ""BluetoothStateChanged="" + stateToString(bluetoothState));
"
326,packages/SystemUI/src/com/android/systemui/statusbar/policy/CallbackHandler.java,"['efe5cc44da2c1772c733a6740a761b3b42969db4', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",2,"            final int statusType, final int qsType,final boolean activityIn,
            final boolean activityOut, final int volteIcon,
            final String typeContentDescription, final String description, final boolean isWide,
            final int subId, boolean roaming) {
        post(new Runnable() {
            @Override
            public void run() {
                for (SignalCallback signalCluster : mSignalCallbacks) {
                    signalCluster.setMobileDataIndicators(statusIcon, qsIcon, statusType, qsType,
                            activityIn, activityOut, volteIcon, typeContentDescription,
                            description, isWide, subId, roaming);
                }
"
327,packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java,['657230bb5e95ec8560c534360cac5a25fd743129'],1,"                    Dependency.get(Dependency.MAIN_HANDLER));
            } else {
                mWifiManager.unregisterSoftApCallback(this);
"
328,packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']",2,"    @Override
    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
"
329,packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6', '240d78276b3206717587bea012131945c6f60179']",3,"    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback("
330,packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java,['240d78276b3206717587bea012131945c6f60179'],1,"    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback();
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
"
331,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"['efe5cc44da2c1772c733a6740a761b3b42969db4', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",2,"                    && ((MobileState) o).imsRegistered == imsRegistered
                    && ((MobileState) o).voiceCapable == voiceCapable
                    && ((MobileState) o).videoCapable == videoCapable;
"
332,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"['efe5cc44da2c1772c733a6740a761b3b42969db4', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",2,"                activityIn, activityOut,volteIcon,
                dataContentDescription, description, icons.mIsWide,
                mSubscriptionInfo.getSubscriptionId(), mCurrentState.roaming);
"
333,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['595572aed3270fda20949d9c19381969d40ecfd4'],1,"                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
                int qsDataType) {
                this(name, sbIcons, qsIcons, contentDesc, sbNullState, qsNullState, sbDiscState,
                        qsDiscState, discContentDesc, dataContentDesc, dataType, isWide,
                        qsDataType, 0, 0, 0, 0);
        }

        public MobileIconGroup(String name, int[][] sbIcons, int[][] qsIcons, int[] contentDesc,
                int sbNullState, int qsNullState, int sbDiscState, int qsDiscState,
                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
                int qsDataType, int singleSignalIcon, int stackedDataIcon,
                int stackedVoicelIcon, int activityId) {
"
334,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['2edeff882ab756e76b3a028a1568d8774ddc0257'],1,"            Log.d(mTag, ""updateTelephony: hasService="" + hasService()
                    + "" ss="" + mSignalStrength);
"
335,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"['efe5cc44da2c1772c733a6740a761b3b42969db4', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",2,"            builder.append(""imsRegistered="").append(imsRegistered).append(',');
            builder.append(""voiceCapable="").append(voiceCapable).append(',');
            builder.append(""videoCapable="").append(videoCapable);
"
336,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['595572aed3270fda20949d9c19381969d40ecfd4'],1,"            if (mConfig.readIconsFromXml) {
                return getIcons().mSingleSignalIcon;
            }else {
                return SignalDrawable.getState(level, getNumLevels(),
                        mCurrentState.inetCondition == 0);
            }
"
337,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"['efe5cc44da2c1772c733a6740a761b3b42969db4', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",2,"            imsRegistered = state.imsRegistered;
            voiceCapable = state.voiceCapable;
            videoCapable = state.videoCapable;
"
338,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['595572aed3270fda20949d9c19381969d40ecfd4'],1,"            mQsDataType = qsDataType;
            mSingleSignalIcon = singleSignalIcon;
            mStackedDataIcon = stackedDataIcon;
            mStackedVoiceIcon = stackedVoicelIcon;
            mActivityId = activityId;
"
339,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"['efe5cc44da2c1772c733a6740a761b3b42969db4', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",2,"        boolean imsRegistered;
        boolean voiceCapable;
        boolean videoCapable;

"
340,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['657230bb5e95ec8560c534360cac5a25fd743129'],1,"        if ( mAlwasyShowTypeIcon ) {
            int iconType = TelephonyManager.NETWORK_TYPE_UNKNOWN;
            if ( isDataNetworkTypeAvailable() ) {
                iconType = mDataNetType;
            }else {
                iconType = getVoiceNetworkType();
            }

            if (mNetworkToIconLookup.indexOfKey(iconType) >= 0) {
                mCurrentState.iconGroup = mNetworkToIconLookup.get(iconType);
            } else {
                mCurrentState.iconGroup = mDefaultIcons;
            }
        }else {
            if (mNetworkToIconLookup.indexOfKey(mDataNetType) >= 0) {
                mCurrentState.iconGroup = mNetworkToIconLookup.get(mDataNetType);
            } else {
                mCurrentState.iconGroup = mDefaultIcons;
            }
"
341,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"        mFiveGStateListener = new FiveGStateListener();
        mFiveGState = new FiveGServiceState();
        mPhoneStateListener = new MobilePhoneStateListener(receiverLooper);
"
342,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_0, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_A, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_B, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EHRPD, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UMTS, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_TD_SCDMA, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_NR, TelephonyIcons.FIVE_G_SA);
"
343,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['f9f9f03acdeb05e6978feca02f6ef20ff57d06bc'],1,"        mPhoneStateListener = new MobilePhoneStateListener(info.getSubscriptionId(),
                receiverLooper);
        mFiveGStateListener = new FiveGStateListener();
        mFiveGState = new FiveGServiceState();
"
344,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4', '3d2fc559e13b7293212955f1858d443f4fe8234e']",3,"        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
"
345,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
    };
"
346,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"['2b252c526c654de6d04ec0165b4b8f039b37f82b', 'efe5cc44da2c1772c733a6740a761b3b42969db4', '188a21cc8ac704f36fd3f2984b4da86307ab7949', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",4,"        pw.println(""  mFiveGState="" + mFiveGState + "","");
"
347,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"        pw.println(""  mIsShowingIconGracefully="" + mIsShowingIconGracefully + "","");
        pw.println(""  mFiveGState="" + mFiveGState + "","");
"
348,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"        } else if (isDataDisabled() && !mConfig.alwaysShowDataRatIcon
                && !mConfig.alwaysShowNetworkTypeIcon) {
            mCurrentState.iconGroup = TelephonyIcons.DATA_DISABLED;
"
349,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"    private DataState mMMSDataState = DataState.DISCONNECTED;
"
350,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['6f47ceafbe6febe54aa5c376baed3415cdf848ad'],1,"    private DataState mMMSDataState = DataState.DISCONNECTED;
    private DisplayInfo mDisplayInfo = new DisplayInfo(TelephonyManager.NETWORK_TYPE_UNKNOWN,
            DisplayInfo.OVERRIDE_NETWORK_TYPE_NONE);
"
351,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c', '6f47ceafbe6febe54aa5c376baed3415cdf848ad']",3,";
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
"
352,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']",2,";
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
"
353,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"import android.content.BroadcastReceiver;
"
354,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"import android.telephony.CellSignalStrengthNr;
import android.telephony.DataSpecificRegistrationInfo;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
import android.telephony.NetworkRegistrationInfo;
"
355,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['6f47ceafbe6febe54aa5c376baed3415cdf848ad'],1,"import android.telephony.CellSignalStrengthNr;
import android.telephony.DisplayInfo;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
"
356,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']",2,"import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
"
357,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"import android.telephony.NetworkRegistrationState;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.feature.MmTelFeature;
"
358,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"['2775a5a9b030266a910301e8b464811acafcd5fa', '657230bb5e95ec8560c534360cac5a25fd743129']",2,"import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims."
359,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"['edb6252578f9b76151e5125a7fb1b16823a68418', '657230bb5e95ec8560c534360cac5a25fd743129', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c', '6f47ceafbe6febe54aa5c376baed3415cdf848ad']",4,"import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims."
360,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['657230bb5e95ec8560c534360cac5a25fd743129'],1,"import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.stub.ImsRegistrationImplBase;
"
361,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"['b76115be4efabffaa6febc57cec47acc2f933c79', '71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']",3,"import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
"
362,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
import com.android.settingslib.graph.SignalDrawable;
"
363,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c'],1,"import com.android.internal.telephony.TelephonyIntents;
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
"
364,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"import com.android.internal.telephony.cdma.EriInfo;
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
"
365,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"import java.util.List;
"
366,packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"import static android.telephony.AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
import static android.telephony.NetworkRegistrationInfo.DOMAIN_PS;

import android.content.BroadcastReceiver;
"
367,packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java,"['efe5cc44da2c1772c733a6740a761b3b42969db4', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",2,"                int qsType, boolean activityIn, boolean activityOut, int volteIcon,
                String typeContentDescription, String description, boolean isWide,
                int subId, boolean roaming) {}
"
368,packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java,['657230bb5e95ec8560c534360cac5a25fd743129'],1,"            config.showRsrpSignalLevelforLTE =
                    res.getBoolean(R.bool.config_showRsrpSignalLevelforLTE);
            config.showVolteIcon = res.getBoolean(R.bool.config_display_volte);
"
369,packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java,['2b252c526c654de6d04ec0165b4b8f039b37f82b'],1,"        boolean readIconsFromXml;
        boolean showRsrpSignalLevelforLTE = false;
        boolean hideNoInternetState = false;
        boolean showVolteIcon = false;
        boolean alwaysShowNetworkTypeIcon = false;
"
370,packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java,"['edb6252578f9b76151e5125a7fb1b16823a68418', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']",2,"        filter.addAction(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
        m"
371,packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        filter.addAction(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
        mBroadcastDispatcher.registerReceiver(this, filter, mReceiverHandler);
"
372,packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"        filter.addAction(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
        mContext.registerReceiver(this, filter, null, mReceiverHandler);
"
373,packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"        public String patternOfCarrierSpecificDataIcon = """";
        public long nrIconDisplayGracePeriodMs;

        boolean showRsrpSignalLevelforLTE = false;
        boolean hideNoInternetState = false;
        boolean showVolteIcon = false;
        boolean alwaysShowNetworkTypeIcon = false;
        /**
         * Mapping from NR 5G status string to an integer. The NR 5G status string should match
         * those in carrier config.
         */
        private static final Map<String, Integer> NR_STATUS_STRING_TO_INDEX;
        static {
            NR_STATUS_STRING_TO_INDEX = new HashMap<>(5);
            NR_STATUS_STRING_TO_INDEX.put(""connected_mmwave"", NR_CONNECTED_MMWAVE);
            NR_STATUS_STRING_TO_INDEX.put(""connected"", NR_CONNECTED);
            NR_STATUS_STRING_TO_INDEX.put(""not_restricted_rrc_idle"", NR_NOT_RESTRICTED_RRC_IDLE);
            NR_STATUS_STRING_TO_INDEX.put(""not_restricted_rrc_con"", NR_NOT_RESTRICTED_RRC_CON);
            NR_STATUS_STRING_TO_INDEX.put(""restricted"", NR_RESTRICTED);
        }
"
374,packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java,"['35fa949362e35d8514c64a645b6448424f174c82', '6fc85c43e31aad55eecd51d3b0de34715ae03810']",2,"    @VisibleForTesting
    FiveGServiceClient mFiveGServiceClient;
"
375,packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,['6fc85c43e31aad55eecd51d3b0de34715ae03810'],1,"
        mDefaultWifiIconGroup = new IconGroup(
"
376,packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,"['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '2b1a920917d6b9235c008921845152448c7e5fc7']",2,"                        || !mHasMobileDataFeature || mWifiTracker.isDefaultNetwork);
"
377,packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"                    || !mHasMobileData);
        String wifiDesc = wifiVisible ? mCurrentState.ssid : null;
"
378,packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"                && (mCurrentState.connected || !mHasMobileData);
"
379,packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,['df73284a33506ba26aadbd20a1dbd01353820200'],1,"        boolean wifiVisible = mCurrentState.enabled
                && ((mCurrentState.connected && mCurrentState.inetCondition == 1)
                    || !mHasMobileData);
"
380,packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"        if (wifiManager != null) {
            wifiManager.registerTrafficStateCallback(new WifiTrafficStateCallback(), null);
        }

        mDefaultWifiIconGroup = new IconGroup(
"
381,packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,"['1730c08a2fd38f0ff8135692a855ada865130939', '657230bb5e95ec8560c534360cac5a25fd743129']",2,"        if(wifiManager != null){
            wifiManager.registerTrafficStateCallback(new WifiTrafficStateCallback(),  null);
"
382,packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"        if(wifiManager != null){
            wifiManager.registerTrafficStateCallback(new WifiTrafficStateCallback(),  null);
        }
"
383,packages/SystemUI/src/com/android/systemui/theme/ThemeOverlayController.java,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"            @Main Resources resources, WakefulnessLifecycle wakefulnessLifecycle,
            ConfigurationController configurationController) {
        super(context);

"
384,packages/SystemUI/src/com/android/systemui/tuner/TunerActivity.java,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",3,"            final Fragment fragment;
            if (""com.android.settings.action.DEMO_MODE"".equals(action)) {
                fragment = new DemoModeFragment(mDemoModeController);
            } else if (""com.android.settings.action.STATUS_BAR_TUNER"".equals(action)) {
                fragment = new StatusBarTuner();
            } else {
                fragment = new TunerFragment(mTunerService);
            }

"
385,packages/SystemUI/src/com/android/systemui/util/sensors/AsyncSensorManager.java,"['8abdf0e95a5d15a310b6df69d33a4510a0b44b4a', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']",2,"        if ( sensor == null ) {
            Log.e(TAG, ""sensor cannot be null \n"" + Log.getStackTraceString(new Throwable()));
            return false;
"
386,packages/SystemUI/tests/src/com/android/keyguard/KeyguardSecurityContainerControllerTest.java,"['f2b53072aa24c3f9f84e762d313f85f5f179e4a4', '8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",3,"    private static final int VIEW_WIDTH = 1600;
"
387,packages/SystemUI/tests/src/com/android/systemui/qs/QSTileHostTest.java,"['f2b53072aa24c3f9f84e762d313f85f5f179e4a4', '8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",3,"                TileLifecycleManager.Factory tileLifecycleManagerFactory) {
            super(context, iconController, defaultFactory, mainExecutor, pluginManager,
                    tunerService, autoTiles, dumpManager, Optional.of(centralSurfaces), qsLogger,
                    uiEventLogger, userTracker, secureSettings, customTileStatePersister,
                    tileServiceRequestControllerBuilder, tileLifecycleManagerFactory);
"
388,packages/SystemUI/tests/src/com/android/systemui/qs/QSTileHostTest.java,"['f2b53072aa24c3f9f84e762d313f85f5f179e4a4', '8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",3,"                mTileServiceRequestControllerBuilder, mTileLifecycleManagerFactory);
"
389,packages/SystemUI/tests/src/com/android/systemui/qs/QSTileHostTest.java,"['f2b53072aa24c3f9f84e762d313f85f5f179e4a4', '8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",3,"    private FakeExecutor mMainExecutor;

"
390,packages/SystemUI/tests/src/com/android/systemui/screenshot/ImageExporterTest.java,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"                exporter.export(DIRECT_EXECUTOR, requestId, original, CAPTURE_TIME, null);
"
391,packages/SystemUI/tests/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManagerTest.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
"
392,packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/CallbackHandlerTest.java,"['efe5cc44da2c1772c733a6740a761b3b42969db4', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",2,"                outArg.capture(),
                ArgumentCaptor.forClass(Integer.class).capture(),
                typeContentArg.capture(), descArg.capture(), wideArg.capture(),
                subIdArg.capture(), eq(roaming));
"
393,packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/CallbackHandlerTest.java,"['efe5cc44da2c1772c733a6740a761b3b42969db4', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",2,"        mHandler.setMobileDataIndicators(status, qs, type, qsType, in, out, 0,
                typeDescription, description, wide, subId, roaming);
"
394,packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/NetworkControllerBaseTest.java,"['2775a5a9b030266a910301e8b464811acafcd5fa', 'efe5cc44da2c1772c733a6740a761b3b42969db4', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",3,"                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
"
395,packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/NetworkControllerBaseTest.java,"['2775a5a9b030266a910301e8b464811acafcd5fa', 'efe5cc44da2c1772c733a6740a761b3b42969db4', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",3,"                ArgumentCaptor.forClass(Integer.class).capture(),
                "
396,packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/NetworkControllerBaseTest.java,"['efe5cc44da2c1772c733a6740a761b3b42969db4', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",2,"                ArgumentCaptor.forClass(Integer.class).capture(),
                anyString(), anyString(), anyBoolean(),
                anyInt(), eq(roaming));
"
397,packages/Tethering/src/com/android/networkstack/tethering/Tethering.java,['f6f595c8a4c17ed2347482c43e2cccc89531224e'],1,"                if (ifaceNameToType(iface) == TETHERING_WIGIG) {
"
398,services/appwidget/java/com/android/server/appwidget/AppWidgetXmlUtil.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",3,"        out.attribute(null, ATTR_OS_FINGERPRINT, "
399,services/appwidget/java/com/android/server/appwidget/AppWidgetXmlUtil.java,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"        out.attribute(null, ATTR_OS_FINGERPRINT, Build.VERSION.INCREMENTAL);
"
400,services/core/java/com/android/server/BluetoothManagerService.java,"['657230bb5e95ec8560c534360cac5a25fd743129', '89cad5d93a5083474840e90d08d6e4aec5833932']",2,"
"
401,services/core/java/com/android/server/BluetoothManagerService.java,['69bee5bb55994d647b678b2cb2ce1becd3d77b32'],1,"
                case MESSAGE_REGISTER_ADAPTER: {
                    if (DBG) Slog.d(TAG,""MESSAGE_REGISTER_ADAPTER"");
                    IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                    mCallbacks.register(callback);
                    break;
                }
                case MESSAGE_UNREGISTER_ADAPTER: {
                    if (DBG) Slog.d(TAG,""MESSAGE_UNREGISTER_ADAPTER"");
                    IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                    mCallbacks.unregister(callback);
                    break;
                }
                case MESSAGE_INFORM_ADAPTER_SERVICE_UP: {
                    if (DBG) Slog.d(TAG,""MESSAGE_INFORM_ADAPTER_SERVICE_UP"");
                    sendBluetoothServiceUpCallback();
                    break;
                }
"
402,services/core/java/com/android/server/BluetoothManagerService.java,['1eef3e1566be8570a0f7a856f12f8992f7d34824'],1,"
            if (psc.getProxyCount() == 0) {
                Slog.w(TAG, ""psc.getProxyCount() returned 0, removing psc entry for profile ""
                       + bluetoothProfile);
                mProfileServices.remove(new Integer(bluetoothProfile));
"
403,services/core/java/com/android/server/BluetoothManagerService.java,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']",2,"                            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                            waitForMonitoredOnOff(false, true);
"
404,services/core/java/com/android/server/BluetoothManagerService.java,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']",2,"                            waitForMonitoredOnOff(false, true);
"
405,services/core/java/com/android/server/BluetoothManagerService.java,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']",2,"                        //     is accomplished by ""waitForMonitoredOnOff(false, true)"".
"
406,services/core/java/com/android/server/BluetoothManagerService.java,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'df73284a33506ba26aadbd20a1dbd01353820200', '35fa949362e35d8514c64a645b6448424f174c82']",3,"                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitFor"
407,services/core/java/com/android/server/BluetoothManagerService.java,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']",2,"                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitForMonitoredOnOff(false, true);
"
408,services/core/java/com/android/server/BluetoothManagerService.java,['df73284a33506ba26aadbd20a1dbd01353820200'],1,"                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitForState(Set.of(BluetoothAdapter.STATE_OFF));
                        Message restartMsg =
                                mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mHandler.sendMessageDelayed(restartMsg, getServiceRestartMs());
"
409,services/core/java/com/android/server/BluetoothManagerService.java,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']",2,"                        boolean didDisableTimeout = !waitForMonitoredOnOff(false, true);
"
410,services/core/java/com/android/server/BluetoothManagerService.java,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']",2,                        waitForMonitoredOnOff(
411,services/core/java/com/android/server/BluetoothManagerService.java,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']",2,"                        waitForMonitoredOnOff(true, false);
"
412,services/core/java/com/android/server/BluetoothManagerService.java,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']",2,"                        waitForMonitoredOnOff(true, false);

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
                        mEnable = false;
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
"
413,services/core/java/com/android/server/BluetoothManagerService.java,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']",2,"                        waitForMonitoredOnOff(true, false);
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
"
414,services/core/java/com/android/server/BluetoothManagerService.java,['df73284a33506ba26aadbd20a1dbd01353820200'],1,"                        waitForState(Set.of(BluetoothAdapter.STATE_ON));

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
"
415,services/core/java/com/android/server/BluetoothManagerService.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"                    // If state is BLE_ON make sure we trigger disableBLE
                    if (st == BluetoothAdapter.STATE_BLE_ON) {
                        try {
                            mBluetoothLock.readLock().lock();
                            if (mBluetooth != null) {
                                addActiveLog(
                                        BluetoothProtoEnums.ENABLE_DISABLE_REASON_AIRPLANE_MODE,
                                        mContext.getPackageName(), false);
                                mBluetooth.onBrEdrDown();
                                mEnable = false;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to call onBrEdrDown"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
"
416,services/core/java/com/android/server/BluetoothManagerService.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"                } else if (mEnableExternal) {
                    if (st!= BluetoothAdapter.STATE_ON && isBluetoothPersistedStateOn()) {
                    sendEnableMsg(mQuietEnableExternal,
                            BluetoothProtoEnums.ENABLE_DISABLE_REASON_AIRPLANE_MODE,
"
417,services/core/java/com/android/server/BluetoothManagerService.java,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']",2,"            if (on || off) {
                SystemClock.sleep(500);
            } else {
                SystemClock.sleep(30);
            }
            i++;
        }
        Slog.e(TAG,""waitForOnOff time out"");
        return false;
    }

    /**
     *  if on is true, wait for state become ON
     *  if off is true, wait for state become OFF
     *  if both on and off are false, wait for state not ON
     */
    private boolean waitForMonitoredOnOff(boolean on, boolean off) {
        int i = 0;
        while (i < 10) {
            synchronized(mConnection) {
                try {
                    if (mBluetooth == null) break;
                    if (on) {
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_ON) return true;
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_BLE_TURNING_ON,
                                                        BluetoothAdapter.STATE_BLE_ON);
                            if (mBluetoothGatt != null) {
                                Slog.d(TAG,""GattService is connected, execute waitForOnOff"");
                                boolean ret = waitForOnOff(on, off);
                                return ret;
                            } else {
                                Slog.d(TAG,
                                    ""GattService connect in progress, return to avoid timeout"");
                                return true;
                            }
                        }
                    } else if (off) {
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_OFF) return true;
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF,
                                                        BluetoothAdapter.STATE_BLE_ON);
                            boolean ret = waitForOnOff(on, off);
                            return ret;
                        }
                    } else {
                        if (mBluetooth.getState() != BluetoothAdapter.STATE_ON) return true;
                    }
                } catch (RemoteException e) {
                    Slog.e(TAG, ""getState()"", e);
                    break;
                }
            }
            if (on || off) {
                SystemClock.sleep(300);
            } else {
                SystemClock.sleep(50);
            }
            i++;
        }
        Slog.e(TAG,""waitForMonitoredOnOff time out"");
"
418,services/core/java/com/android/server/BluetoothManagerService.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"            if (persist) {
                persistBluetoothSetting(BLUETOOTH_OFF);
                mEnableExternal = false;
                sendDisableMsg(BluetoothProtoEnums.ENABLE_DISABLE_REASON_APPLICATION_REQUEST,
"
419,services/core/java/com/android/server/BluetoothManagerService.java,['e57c0a642086a0bb5c194764cf98068ea772a86d'],1,"            int st = mBluetooth.getState();
            if (st != BluetoothAdapter.STATE_BLE_ON) {
                if (DBG) Slog.v(TAG, ""onBluetoothServiceUp: state isn't BLE_ON: "" +
                         BluetoothAdapter.nameForState(st));
                return;
            }
            if (!mEnableExternal && isAirplaneModeOn()) {
                // Airplane mode is turned on while enabling BLE only mode, disable
                // BLE now.
"
420,services/core/java/com/android/server/BluetoothManagerService.java,['df73284a33506ba26aadbd20a1dbd01353820200'],1,"            int st = mBluetooth.getState();
            if (st != BluetoothAdapter.STATE_BLE_ON) {
                if (DBG) Slog.v(TAG, ""onBluetoothServiceUp: state isn't BLE_ON: "" +
                         BluetoothAdapter.nameForState(st));
                return;
            }
           if (isAirplaneModeOn() && !mEnableExternal) {
                addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_AIRPLANE_MODE,
                    mContext.getPackageName(), false);

                mBluetooth.onBrEdrDown();
                mEnable = false;
            } else if (isBluetoothPersistedStateOnBluetooth() ||
                 mEnableExternal) {
"
421,services/core/java/com/android/server/BluetoothManagerService.java,"['7fd6edc3a3ff37a750641d5e192835fe217f6050', '82ca638edd627c1b70aae1505f06c8ddaef731d2', 'd1ffad806502fc4ff57f88b4eb543cc81fc601a1']",3,"        if (isBluetoothAvailableForBinding() == false) {
            Slog.w(TAG, ""bindBluetoothProfileService:Trying to bind to profile: ""
                       + bluetoothProfile + "", while Bluetooth is disabled"");
"
422,services/core/java/com/android/server/BluetoothManagerService.java,['df73284a33506ba26aadbd20a1dbd01353820200'],1,"        if(appCount == 0) {
            try {
                mBluetoothLock.readLock().lock();
                if (mBluetooth != null) {
                    st = mBluetooth.getState();
                }
                if (!mEnableExternal || (st == BluetoothAdapter.STATE_BLE_ON)) {
                    if (DBG) Slog.d(TAG, ""Move to BT state OFF"");
                    sendBrEdrDownCallback();
                }
            } catch (RemoteException e) {
                Slog.e(TAG, """", e);
            } finally {
                mBluetoothLock.readLock().unlock();
            }
"
423,services/core/java/com/android/server/BluetoothManagerService.java,['1eef3e1566be8570a0f7a856f12f8992f7d34824'],1,"        public int getProxyCount() {
            int retval = 0;
            if (mProxies != null) {
                retval = mProxies.getRegisteredCallbackCount();
            }
            Slog.w(TAG, ""getProxyCount(): returning retval "" + retval);
            return retval;
"
424,services/core/java/com/android/server/BluetoothManagerService.java,['69bee5bb55994d647b678b2cb2ce1becd3d77b32'],1,"        try {
            mBluetoothLock.writeLock().lock();
            int n = mCallbacks.beginBroadcast();
            Slog.d(TAG, ""Broadcasting onBluetoothServiceUp() to "" + n + "" receivers."");
            for (int i = 0; i < n; i++) {
                try {
                    mCallbacks.getBroadcastItem(i).onBluetoothServiceUp(mBluetooth);
                } catch (RemoteException e) {
                    Slog.e(TAG, ""Unable to call onBluetoothServiceUp() on callback #"" + i, e);
"
425,services/core/java/com/android/server/BluetoothManagerService.java,['69bee5bb55994d647b678b2cb2ce1becd3d77b32'],1,"        } finally {
            mCallbacks.finishBroadcast();
            mBluetoothLock.writeLock().unlock();
"
426,services/core/java/com/android/server/BluetoothManagerService.java,['df73284a33506ba26aadbd20a1dbd01353820200'],1,"    private boolean mTryBindOnBindTimeout = false;
"
427,services/core/java/com/android/server/BluetoothManagerService.java,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']",2,"    private static final String BLUETOOTH_PRIVILEGED_PERM = android.Manifest.permission.BLUETOOTH_PRIVILEGED;
"
428,services/core/java/com/android/server/BluetoothManagerService.java,['69bee5bb55994d647b678b2cb2ce1becd3d77b32'],1,"    private static final int MESSAGE_REGISTER_ADAPTER = 20;
    private static final int MESSAGE_UNREGISTER_ADAPTER = 21;
    private static final int MESSAGE_INFORM_ADAPTER_SERVICE_UP = 22;
"
429,services/core/java/com/android/server/BluetoothManagerService.java,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'df73284a33506ba26aadbd20a1dbd01353820200', '35fa949362e35d8514c64a645b6448424f174c82']",3,");

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
"
430,services/core/java/com/android/server/ConnectivityService.java,['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c'],1,"
        if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
            Slog.wtf(TAG, String.format(
                    ""BUG: %s changed requestable capabilities during rematch: %s -> %s"",
                    newNetwork.name(), nc, newNetwork.networkCapabilities));
        }
        if (newNetwork.getCurrentScore() != score) {
            Slog.wtf(TAG, String.format(
                    ""BUG: %s changed score during rematch: %d -> %d"",
                    newNetwork.name(), score, newNetwork.getCurrentScore()));
        }

        if ((satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities) == false) &&
             !newNetwork.isVPN()) {
            // Force trigger permission change on non-DDS network to close all live connections
            try {
                mNMS.setNetworkPermission(newNetwork.network.netId,
                                           INetd.PERMISSION_NETWORK);
            } catch (RemoteException e) {
                loge(""Exception in setNetworkPermission: "" + e);
            }
        }
        // Notify requested networks are available after the default net is switched, but
        // before LegacyTypeTracker sends legacy broadcasts
        for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
"
431,services/core/java/com/android/server/ConnectivityService.java,"['1730c08a2fd38f0ff8135692a855ada865130939', '1452baeffa18c2760dac56bee26c20fa12a499a3', '1581c348fc5d6cbf1673b3dbc5960637f891d488']",3,"
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }
"
432,services/core/java/com/android/server/ConnectivityService.java,"['1730c08a2fd38f0ff8135692a855ada865130939', '1581c348fc5d6cbf1673b3dbc5960637f891d488']",2,"
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }
"
433,services/core/java/com/android/server/ConnectivityService.java,['1581c348fc5d6cbf1673b3dbc5960637f891d488'],1,"
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }
}
"
434,services/core/java/com/android/server/ConnectivityService.java,['6fc85c43e31aad55eecd51d3b0de34715ae03810'],1,"                    ((getNetworkForRequest(nri.request.requestId) != null)
                    && (getNetworkForRequest(nri.request.requestId).getCurrentScore() <
                            nai.getCurrentScoreAsValidated())))) {
"
435,services/core/java/com/android/server/ConnectivityService.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"                    satisfiesMobileMultiNetworkDataCheck(nai.networkCapabilities,
                       nri.request.networkCapabilities) &&
                    (nai.isSatisfyingRequest(nri.request.requestId)
                    // Note that canPossiblyBeat catches two important cases:
                    // 1. Unvalidated slow networks will not be reaped when an unvalidated fast
                    // network is currently satisfying the request. This is desirable for example
                    // when cellular ends up validating but WiFi/Ethernet does not.
                    // 2. Fast networks will not be reaped when a validated slow network is
                    // currently satisfying the request. This is desirable for example when
                    // Ethernet ends up validating and out scoring WiFi, or WiFi/Ethernet ends
                    // up validating and out scoring cellular.
                            || nai.canPossiblyBeat(nri.mSatisfier))) {
"
436,services/core/java/com/android/server/ConnectivityService.java,['af02bd5317cc0cced0a7646d5bbf407a181dda9c'],1,"                // If ""newNetwork"" is listed as satisfying ""nri"" but no longer satisfies ""nri"",
                // mark it as no longer satisfying ""nri"".  Because networks are processed by
                // rematchAllNetworksAndRequests() in descending score order, ""currentNetwork"" will
                // match ""newNetwork"" before this loop will encounter a ""currentNetwork"" with higher
                // score than ""newNetwork"" and where ""currentNetwork"" no longer satisfies ""nri"".
                // This means this code doesn't have to handle the case where ""currentNetwork"" no
                // longer satisfies ""nri"" when ""currentNetwork"" does not equal ""newNetwork"".
                if (DBG) {
                    log(""Network "" + newNetwork.name() + "" stopped satisfying"" +
                            "" request "" + nri.request.requestId);
                }
                newNetwork.removeRequest(nri.request.requestId);
                if (previousSatisfier == newNetwork) {
                    nri.mSatisfier = null;
                    if (isDefaultRequest(nri)) mDefaultNetworkNai = null;
                    sendUpdatedScoreToFactories(nri.request, null);
                } else {
                    Slog.wtf(TAG, ""BUG: Removing request "" + nri.request.requestId + "" from "" +
                            newNetwork.name() +
                            "" without updating mSatisfier or providers!"");
                }
                // TODO: Technically, sending CALLBACK_LOST here is
                // incorrect if there is a replacement network currently
                // connected that can satisfy nri, which is a request
                // (not a listen). However, the only capability that can both
                // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
                // so this code is only incorrect for a network that loses
                // the TRUSTED capability, which is a rare case.
                // Linger the non-DDS network requests and do not send LOST
                // callback, since ideally callback LOSING is sent if lingering
                if (satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities)) {
                    callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
                } else {
                    newNetwork.lingerRequest(nri.request, now, mNonDefaultSubscriptionLingerDelayMs);
                }
"
437,services/core/java/com/android/server/ConnectivityService.java,['a33382db0bb0bc29bab84f1e5ee36d682bea593e'],1,"                case EVENT_TIMEOUT_NOTIFICATION:
                    mNotifier.clearNotification(msg.arg1, NotificationType.LOGGED_IN);
                    break;
                case EVENT_UPDATE_TCP_BUFFER_FOR_5G:
                    handleUpdateTCPBuffersfor5G();
                    break;
                case EVENT_UPDATE_ACTIVE_DATA_SUBID:
                    handleUpdateActiveDataSubId(msg.arg1);
                    break;
"
438,services/core/java/com/android/server/ConnectivityService.java,"['ba167de93776a7e5d1b347d1ee646e161cf24ce5', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']",2,"                case EVENT_UPDATE_TCP_BUFFER_FOR_5G:
                    handleUpdateTCPBuffersfor5G();
"
439,services/core/java/com/android/server/ConnectivityService.java,['6fc85c43e31aad55eecd51d3b0de34715ae03810'],1,"            final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
            final boolean satisfies = newNetwork.satisfies(nri.request);
            boolean satisfiesMobileMultiNetworkCheck = false;

            if (satisfies) {
                satisfiesMobileMultiNetworkCheck = satisfiesMobileMultiNetworkDataCheck(
                        newNetwork.networkCapabilities,
                        nri.request.networkCapabilities);
            }

            if (newNetwork == currentNetwork && satisfiesMobileMultiNetworkCheck) {
                if (VDBG) {
                    log(""Network "" + newNetwork.name() + "" was already satisfying"" +
                            "" request "" + nri.request.requestId + "". No change."");
                }
                keep = true;
                continue;
            }

            // check if it satisfies the NetworkCapabilities
            if (VDBG) log(""  checking if request is satisfied: "" + nri.request);
            if (satisfiesMobileMultiNetworkCheck) {
                // next check if it's better than any current network we're using for
                // this request
                if (VDBG || DDBG) {
                    log(""currentScore = "" +
                            (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) +
                            "", newScore = "" + score);
                }
                if (currentNetwork == null ||
                    isBestMobileMultiNetwork(currentNetwork,
                          currentNetwork.networkCapabilities,
                          newNetwork,
                          newNetwork.networkCapabilities,
                          nri.request.networkCapabilities) ||
                    currentNetwork.getCurrentScore() < score) {
                    if (VDBG) log(""rematch for "" + newNetwork.name());
                    if (currentNetwork != null) {
                        if (VDBG || DDBG){
                            log(""   accepting network in place of "" + currentNetwork.name());
                        }
                        currentNetwork.removeRequest(nri.request.requestId);
                        if (satisfiesMobileNetworkDataCheck(currentNetwork.networkCapabilities)) {
                            currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                        } else {
                            currentNetwork.lingerRequest(nri.request, now, mNonDefaultSubscriptionLingerDelayMs);
                        }
                        affectedNetworks.add(currentNetwork);
                    } else {
                        if (VDBG || DDBG) log(""   accepting network in place of null"");
                    }
                    newNetwork.unlingerRequest(nri.request);
                    setNetworkForRequest(nri.request.requestId, newNetwork);
                    if (!newNetwork.addRequest(nri.request)) {
                        Slog.wtf(TAG, ""BUG: "" + newNetwork.name() + "" already has "" + nri.request);
                    }
                    addedRequests.add(nri);
                    keep = true;
                    // Tell NetworkFactories about the new score, so they can stop
                    // trying to connect if they know they cannot match it.
                    // TODO - this could get expensive if we have a lot of requests for this
                    // network.  Think about if there is a way to reduce this.  Push
                    // netid->request mapping to each factory?
                    sendUpdatedScoreToFactories(nri.request, newNetwork);
                    if (isDefaultRequest(nri)) {
                        isNewDefault = true;
                        oldDefaultNetwork = currentNetwork;
                        if (currentNetwork != null) {
                            mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                        }
"
440,services/core/java/com/android/server/ConnectivityService.java,['6fc85c43e31aad55eecd51d3b0de34715ae03810'],1,"            if (nri.request.isRequest() && nai.satisfies(nri.request)
                    && satisfiesMobileMultiNetworkDataCheck(nai.networkCapabilities,
                       nri.request.networkCapabilities)
                    && (nai.isSatisfyingRequest(nri.request.requestId) ||
"
441,services/core/java/com/android/server/ConnectivityService.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"            if (nri.request.isRequest() && nai.satisfies(nri.request)
                    && satisfiesMobileMultiNetworkDataCheck(nai.networkCapabilities,
                       nri.request.networkCapabilities)
                    && (nai.isSatisfyingRequest(nri.request.requestId) ||
                    // Note that this catches two important cases:
                    // 1. Unvalidated cellular will not be reaped when unvalidated WiFi
                    //    is currently satisfying the request.  This is desirable when
                    //    cellular ends up validating but WiFi does not.
                    // 2. Unvalidated WiFi will not be reaped when validated cellular
                    //    is currently satisfying the request.  This is desirable when
                    //    WiFi ends up validating and out scoring cellular.
                    ((nri.mSatisfier != null)
                    && (nri.mSatisfier.getCurrentScore()
                            < nai.getCurrentScoreAsValidated())))) {
"
442,services/core/java/com/android/server/ConnectivityService.java,['ddcaa93e851eb5e57692799446f2ef3fe31436ae'],1,"        // Configure whether mobile data is always on.
        mHandler.sendMessage(mHandler.obtainMessage(EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON));
"
443,services/core/java/com/android/server/ConnectivityService.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"        // Second pass: process all listens.
        if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
            // If the network went from background to foreground or vice versa, we need to update
            // its foreground state. It is safe to do this after rematching the requests because
            // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
            // capability and does not affect the network's score (see the Slog.wtf call above).
            updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
        } else {
            processListenRequests(newNetwork, false);
        }

        if ((satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities) == false) &&
             !newNetwork.isVPN()) {
            // Force trigger permission change on non-DDS network to close all live connections
            try {
                mNMS.setNetworkPermission(newNetwork.network.netId,
                                           INetd.PERMISSION_NETWORK);
            } catch (RemoteException e) {
                loge(""Exception in setNetworkPermission: "" + e);
            }
        }
        // do this after the default net is switched, but
"
444,services/core/java/com/android/server/ConnectivityService.java,['af02bd5317cc0cced0a7646d5bbf407a181dda9c'],1,"        if (isNewDefault) {
            // restore permission to actual value if it becomes the default network again..
            if (!newNetwork.isVPN()) {
                try {
                    mNMS.setNetworkPermission(newNetwork.network.netId,
                                           getNetworkPermission(newNetwork.networkCapabilities));
                } catch (RemoteException e) {
                    loge(""Exception in setNetworkPermission: "" + e);
                }
            }
            updateDataActivityTracking(newNetwork, oldDefaultNetwork);
            // Notify system services that this network is up.
            makeDefault(newNetwork);
            // Log 0 -> X and Y -> X default network transitions, where X is the new default.
            mDeps.getMetricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(
                    now, newNetwork, oldDefaultNetwork);
            // Have a new default network, release the transition wakelock in
            scheduleReleaseNetworkTransitionWakelock();
        }

        if ((satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities) == false) &&
             !newNetwork.isVPN()) {
            // Force trigger permission change on non-DDS network to close all live connections
            try {
                mNMS.setNetworkPermission(newNetwork.network.netId,
                                           INetd.PERMISSION_NETWORK);
            } catch (RemoteException e) {
                loge(""Exception in setNetworkPermission: "" + e);
            }
        }
"
445,services/core/java/com/android/server/ConnectivityService.java,['af02bd5317cc0cced0a7646d5bbf407a181dda9c'],1,"        mSubscriptionManager = SubscriptionManager.from(mContext);
        mTelephonyManager.listen(mPhoneStateListener, LISTEN_ACTIVE_DATA_SUBSCRIPTION_ID_CHANGE);
"
446,services/core/java/com/android/server/ConnectivityService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"    // Overridden for testing purposes to avoid writing to SystemProperties.
    @VisibleForTesting
    protected MockableSystemProperties getSystemProperties() {
        return new MockableSystemProperties();
    }

    private void updateTcpBufferSizes(NetworkAgentInfo nai) {
        if (isDefaultNetwork(nai) == false) {
            return;
        }

        String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
        if(nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)){
            tcpBufferSizes = NetPluginDelegate.get5GTcpBuffers(tcpBufferSizes,
                nai.networkCapabilities.getNetworkSpecifier());
        }
        updateTcpBufferSizes(tcpBufferSizes);
    }

"
447,services/core/java/com/android/server/ConnectivityService.java,['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c'],1,"    private PhoneStateListener mPhoneStateListener = new PhoneStateListener() {
        @Override
        public void onActiveDataSubscriptionIdChanged(int subId) {
             if (subId != mPreferredSubId) {
                 mHandler.sendMessage(mHandler.obtainMessage(EVENT_UPDATE_ACTIVE_DATA_SUBID, subId, 0));
             }
        }
    };

    private int mPreferredSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;

    /** Handler thread used for both of the handlers below. */
"
448,services/core/java/com/android/server/ConnectivityService.java,['af02bd5317cc0cced0a7646d5bbf407a181dda9c'],1,"    private TelephonyManager mTelephonyManager;
    private SubscriptionManager mSubscriptionManager;
"
449,services/core/java/com/android/server/ConnectivityService.java,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', '1452baeffa18c2760dac56bee26c20fa12a499a3']",2,"    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }
"
450,services/core/java/com/android/server/ConnectivityService.java,"['1730c08a2fd38f0ff8135692a855ada865130939', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae', '1581c348fc5d6cbf1673b3dbc5960637f891d488']",3,"    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
"
451,services/core/java/com/android/server/ConnectivityService.java,['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c'],1,"    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (mPreferredSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) return true;

            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == mPreferredSubId)) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }

    private void handleUpdateActiveDataSubId(int subId) {
        log(""Setting mPreferredSubId to "" + subId);
        mPreferredSubId = subId;
        rematchAllNetworksAndRequests();
"
452,services/core/java/com/android/server/ConnectivityService.java,['21f5f0690d944268de9d3f082d41d4580e5f6c16'],1,"    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (mPreferredSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) return true;

            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == mPreferredSubId)) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    public boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        int specifier = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof TelephonyNetworkSpecifier) {
            specifier = ((TelephonyNetworkSpecifier) networkSpecifierObj).getSubscriptionId();
        }
        return specifier;
    }

    public boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }

    private void handleUpdateActiveDataSubId(int subId) {
        log(""Setting mPreferredSubId to "" + subId);
        mPreferredSubId = subId;
        rematchAllNetworksAndRequests();
"
453,services/core/java/com/android/server/ConnectivityService.java,"['2775a5a9b030266a910301e8b464811acafcd5fa', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']",2,"    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId())) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
"
454,services/core/java/com/android/server/ConnectivityService.java,"['ba167de93776a7e5d1b347d1ee646e161cf24ce5', '88b45c586d461df38b866d529bc98d1dfa3e8838']",2,"    private static final int EVENT_UPDATE_TCP_BUFFER_FOR_5G = 160;
"
455,services/core/java/com/android/server/ConnectivityService.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '8d21ad0d966c1e9f96e5a65144efad2582391957']",2,"    private void updateTcpBufferSizes(NetworkAgentInfo nai) {
        if (isDefaultNetwork(nai) == false) {
            return;
        }

        String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
        if(nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)){
            tcpBufferSizes = NetPluginDelegate.get5GTcpBuffers(tcpBufferSizes,
                nai.networkCapabilities.getNetworkSpecifier());
        }
"
456,services/core/java/com/android/server/ConnectivityService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"import android.net.StringNetworkSpecifier;
"
457,services/core/java/com/android/server/ConnectivityService.java,['cf03be865b65f49562f1e442ee0e7510ee597aa8'],1,"import android.telephony.SubscriptionInfo;
"
458,services/core/java/com/android/server/NetworkTimeUpdateService.java,['1581c348fc5d6cbf1673b3dbc5960637f891d488'],1,"    public void systemRunning() {
        registerForTelephonyIntents();
        registerForAlarms();

        HandlerThread thread = new HandlerThread(TAG);
        thread.start();
        mHandler = new MyHandler(thread.getLooper());
        mNetworkTimeUpdateCallback = new NetworkTimeUpdateCallback();
        mCM.registerDefaultNetworkCallback(mNetworkTimeUpdateCallback, mHandler);

        mSettingsObserver = new SettingsObserver(mHandler, EVENT_AUTO_TIME_CHANGED);
        mSettingsObserver.observe(mContext);
    }

    private void registerForTelephonyIntents() {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(TelephonyIntents.ACTION_NETWORK_SET_TIME);
        mContext.registerReceiver(mNitzReceiver, intentFilter);
    }

    private void registerForAlarms() {
        mContext.registerReceiver(
            new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    mHandler.obtainMessage(EVENT_POLL_NETWORK_TIME).sendToTarget();
                }
            }, new IntentFilter(ACTION_POLL));
    }

    private void onPollNetworkTime(int event) {
        // If Automatic time is not set, don't bother. Similarly, if we don't
        // have any default network, don't bother.
        if (mDefaultNetwork == null) return;
        mWakeLock.acquire();
        try {
            onPollNetworkTimeUnderWakeLock(event);
        } finally {
            mWakeLock.release();
        }
    }

    private void onPollNetworkTimeUnderWakeLock(int event) {
        // Force an NTP fix when outdated
        if (mTime.getCacheAge() >= mPollingIntervalMs) {
            if (DBG) Log.d(TAG, ""Stale NTP fix; forcing refresh"");
            mTime.forceSync();
        }

        if (mTime.getCacheAge() < mPollingIntervalMs) {
            // Obtained fresh fix; schedule next normal update
            resetAlarm(mPollingIntervalMs);
            if (isAutomaticTimeRequested()) {
                updateSystemClock(event);
            }

        } else {
            // No fresh fix; schedule retry
            mTryAgainCounter++;
            if (mTryAgainTimesMax < 0 || mTryAgainCounter <= mTryAgainTimesMax) {
                resetAlarm(mPollingIntervalShorterMs);
            } else {
                // Try much later
                mTryAgainCounter = 0;
                resetAlarm(mPollingIntervalMs);
            }
        }
    }

    private long getNitzAge() {
        if (mNitzTimeSetTime == NOT_SET) {
            return Long.MAX_VALUE;
        } else {
            return SystemClock.elapsedRealtime() - mNitzTimeSetTime;
        }
    }

    /**
     * Consider updating system clock based on current NTP fix, if requested by
     * user, significant enough delta, and we don't have a recent NITZ.
     */
    private void updateSystemClock(int event) {
        final boolean forceUpdate = (event == EVENT_AUTO_TIME_CHANGED);
        if (!forceUpdate) {
            if (getNitzAge() < mPollingIntervalMs) {
                if (DBG) Log.d(TAG, ""Ignoring NTP update due to recent NITZ"");
                return;
            }

            final long skew = Math.abs(mTime.currentTimeMillis() - System.currentTimeMillis());
            if (skew < mTimeErrorThresholdMs) {
                if (DBG) Log.d(TAG, ""Ignoring NTP update due to low skew"");
                return;
            }
        }

        SystemClock.setCurrentTimeMillis(mTime.currentTimeMillis());
    }

    /**
     * Cancel old alarm and starts a new one for the specified interval.
     *
     * @param interval when to trigger the alarm, starting from now.
     */
    private void resetAlarm(long interval) {
        mAlarmManager.cancel(mPendingPollIntent);
        long now = SystemClock.elapsedRealtime();
        long next = now + interval;
        mAlarmManager.set(AlarmManager.ELAPSED_REALTIME, next, mPendingPollIntent);
    }

    /**
     * Checks if the user prefers to automatically set the time.
     */
    private boolean isAutomaticTimeRequested() {
        return Settings.Global.getInt(
                mContext.getContentResolver(), Settings.Global.AUTO_TIME, 0) != 0;
    }

    /** Receiver for Nitz time events */
    private BroadcastReceiver mNitzReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (DBG) Log.d(TAG, ""Received "" + action);
            if (TelephonyIntents.ACTION_NETWORK_SET_TIME.equals(action)) {
                mNitzTimeSetTime = SystemClock.elapsedRealtime();
            }
        }
    };

    /** Handler to do the network accesses on */
    private class MyHandler extends Handler {

        public MyHandler(Looper l) {
            super(l);
        }

        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case EVENT_AUTO_TIME_CHANGED:
                case EVENT_POLL_NETWORK_TIME:
                case EVENT_NETWORK_CHANGED:
                    onPollNetworkTime(msg.what);
                    break;
            }
        }
    }

    private class NetworkTimeUpdateCallback extends NetworkCallback {
        @Override
        public void onAvailable(Network network) {
            Log.d(TAG, String.format(""New default network %s; checking time."", network));
            mDefaultNetwork = network;
            // Running on mHandler so invoke directly.
            onPollNetworkTime(EVENT_NETWORK_CHANGED);
        }

        @Override
        public void onLost(Network network) {
            if (network.equals(mDefaultNetwork)) mDefaultNetwork = null;
        }
    }

    /** Observer to watch for changes to the AUTO_TIME setting */
    private static class SettingsObserver extends ContentObserver {

        private int mMsg;
        private Handler mHandler;

        SettingsObserver(Handler handler, int msg) {
            super(handler);
            mHandler = handler;
            mMsg = msg;
        }

        void observe(Context context) {
            ContentResolver resolver = context.getContentResolver();
            resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.AUTO_TIME),
                    false, this);
        }

        @Override
        public void onChange(boolean selfChange) {
            mHandler.obtainMessage(mMsg).sendToTarget();
        }
    }

    @Override
    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;
        pw.print(""PollingIntervalMs: "");
        TimeUtils.formatDuration(mPollingIntervalMs, pw);
        pw.print(""\nPollingIntervalShorterMs: "");
        TimeUtils.formatDuration(mPollingIntervalShorterMs, pw);
        pw.println(""\nTryAgainTimesMax: "" + mTryAgainTimesMax);
        pw.print(""TimeErrorThresholdMs: "");
        TimeUtils.formatDuration(mTimeErrorThresholdMs, pw);
        pw.println(""\nTryAgainCounter: "" + mTryAgainCounter);
        pw.println(""NTP cache age: "" + mTime.getCacheAge());
        pw.println(""NTP cache certainty: "" + mTime.getCacheCertainty());
        pw.println();
    }
"
459,services/core/java/com/android/server/StorageManagerService.java,['1581c348fc5d6cbf1673b3dbc5960637f891d488'],1,"import com.android.internal.widget.ILockSettings;

import libcore.io.IoUtils;
import libcore.util.EmptyArray;
"
460,services/core/java/com/android/server/Watchdog.java,"['21cdef883cc867db55340b25d5c95e19b12ab383', '71998c3d8b36220df1be12fe6e1ba7eda81cde41', '8faa0d981413f18b2468dde1b1fe71e248df0df1']",3,"                                    subject, "
461,services/core/java/com/android/server/Watchdog.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"                                    subject, cpuInfo, finalStack, null);
"
462,services/core/java/com/android/server/Watchdog.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"                                    subject, null, finalStack, null);
"
463,services/core/java/com/android/server/Watchdog.java,['ba167de93776a7e5d1b347d1ee646e161cf24ce5'],1,"                                ""watchdog"", null, ""system_server"", null, null,
                                subject, null, finalStack, null);
"
464,services/core/java/com/android/server/Watchdog.java,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '6e44ad255823e1b7f2b23386d61af655c19adb49']",2,"                                subject, "
465,services/core/java/com/android/server/Watchdog.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '6e44ad255823e1b7f2b23386d61af655c19adb49']",2,"                                subject, null, finalStack, null);
"
466,services/core/java/com/android/server/Watchdog.java,['b6292e3e1ba3616eac1032737a91925391d94b92'],1,"                            ArrayList<Integer> pids = new ArrayList<Integer>();
                            pids.add(Process.myPid());
                            initialStack = ActivityManagerService.dumpStackTraces(pids,
                                    null, null, getInterestingNativePids(), null);
"
467,services/core/java/com/android/server/Watchdog.java,"['b6292e3e1ba3616eac1032737a91925391d94b92', '8faa0d981413f18b2468dde1b1fe71e248df0df1']",2,"                            initialStack = ActivityManagerService.dumpStackTraces(pids,
                                    null, null, getInterestingNativePids()"
468,services/core/java/com/android/server/Watchdog.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"                            initialStack = ActivityManagerService.dumpStackTraces(pids,
                                    null, null, getInterestingNativePids());
"
469,services/core/java/com/android/server/Watchdog.java,['2edeff882ab756e76b3a028a1568d8774ddc0257'],1,"                            initialStack = ActivityManagerService.dumpStackTraces(true, pids,
                                    null, null, getInterestingNativePids());
"
470,services/core/java/com/android/server/Watchdog.java,['9caf34febf01086c96266e38d024f7a0315b892d'],1,"                        mActivity.addErrorToDropBox(
                                ""watchdog"", null, ""system_server"", null, null, null,
                                subject, null, finalStack, null);
"
471,services/core/java/com/android/server/Watchdog.java,['2edeff882ab756e76b3a028a1568d8774ddc0257'],1,"            // Pass !waitedHalf so that just in case we somehow wind up here without having
            // dumped the halfway stacks, we properly re-initialize the trace file.
            final File finalStack = ActivityManagerService.dumpStackTraces(
                    !waitedHalf, pids, null, null, getInterestingNativePids());
"
472,services/core/java/com/android/server/Watchdog.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"            File watchdogTraces;
            String newTracesPath = ""traces_SystemServer_WDT""
                    + mTraceDateFormat.format(new Date()) + ""_pid""
                    + String.valueOf(Process.myPid());
            File tracesDir = new File(ActivityManagerService.ANR_TRACE_DIR);
            watchdogTraces = new File(tracesDir, newTracesPath);
            try {
                if (watchdogTraces.createNewFile()) {
                    FileUtils.setPermissions(watchdogTraces.getAbsolutePath(),
                            0600, -1, -1); // -rw------- permissions

                    // Append both traces from the first and second half
                    // to a new file, making it easier to debug Watchdog timeouts
                    // dumpStackTraces() can return a null instance, so check the same
                    if (initialStack != null) {
                        // check the last-modified time of this file.
                        // we are interested in this only it was written to in the
                        // last 5 minutes or so
                        final long age = System.currentTimeMillis()
                                - initialStack.lastModified();
                        final long FIVE_MINUTES_IN_MILLIS = 1000 * 60 * 5;
                        if (age < FIVE_MINUTES_IN_MILLIS) {
                            Slog.e(TAG, ""First set of traces taken from ""
                                    + initialStack.getAbsolutePath());
                            appendFile(watchdogTraces, initialStack);
                        } else {
                            Slog.e(TAG, ""First set of traces were collected more than ""
                                    + ""5 minutes ago, ignoring ..."");
                        }
                    } else {
                        Slog.e(TAG, ""First set of traces are empty!"");
                    }

                    if (finalStack != null) {
                        Slog.e(TAG, ""Second set of traces taken from ""
                                + finalStack.getAbsolutePath());
                        appendFile(watchdogTraces, finalStack);
                    } else {
                        Slog.e(TAG, ""Second set of traces are empty!"");
                    }
                } else {
                    Slog.w(TAG, ""Unable to create Watchdog dump file: createNewFile failed"");
                }
            } catch (Exception e) {
                // catch any exception that happens here;
                // why kill the system when it is going to die anyways?
                Slog.e(TAG, ""Exception creating Watchdog dump file:"", e);
            }
"
473,services/core/java/com/android/server/Watchdog.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '8faa0d981413f18b2468dde1b1fe71e248df0df1']",2,"            final File finalStack = ActivityManagerService.dumpStackTraces(
                    pids, "
474,services/core/java/com/android/server/Watchdog.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"            final File finalStack = ActivityManagerService.dumpStackTraces(
                    pids, null, null, getInterestingNativePids());
"
475,services/core/java/com/android/server/Watchdog.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"            final File finalStack = ActivityManagerService.dumpStackTraces(
                    pids, processCpuTracker, new SparseArray<>(), getInterestingNativePids());
"
476,services/core/java/com/android/server/Watchdog.java,['b6292e3e1ba3616eac1032737a91925391d94b92'],1,"    int mPhonePid;
    IActivityController mController;
    boolean mAllowRestart = true;
    SimpleDateFormat mTraceDateFormat = new SimpleDateFormat(""dd_MM_HH_mm_ss.SSS"");
    final OpenFdMonitor mOpenFdMonitor;
"
477,services/core/java/com/android/server/Watchdog.java,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '1581c348fc5d6cbf1673b3dbc5960637f891d488']",2,"import java.io.BufferedReader;
"
478,services/core/java/com/android/server/WiredAccessoryManager.java,['cf03be865b65f49562f1e442ee0e7510ee597aa8'],1,"                if (LOG) {
                    Slog.v(TAG, ""Output device address "" + (hs.length > 1 ? hs[1] : """")
                           + "" name "" + hs[0]);
                }
                mAudioManager.setWiredDeviceConnectionState(outDevice, state,
                                                             (hs.length > 1 ? hs[1] : """"), hs[0]);
            }
            if (inDevice != 0) {
              mAudioManager.setWiredDeviceConnectionState(inDevice, state,
                                                           (hs.length > 1 ? hs[1] : """"), hs[0]);
"
479,services/core/java/com/android/server/WiredAccessoryManager.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4']",2,"                updateLocked(name, """", mHeadsetState | (mask & state) & ~(mask & ~state));
"
480,services/core/java/com/android/server/WiredAccessoryManager.java,['cf03be865b65f49562f1e442ee0e7510ee597aa8'],1,"            updateLocked(NAME_H2W, """",
                (mHeadsetState & ~(BIT_HEADSET | BIT_HEADSET_NO_MIC | BIT_LINEOUT)) | headset);
"
481,services/core/java/com/android/server/accounts/AccountManagerService.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"    public void removeAccount(IAccountManagerResponse response, Account account,
            boolean expectActivityLaunch) {
        android.util.SeempLog.record(17);
        removeAccountAsUser(
                response,
                account,
                expectActivityLaunch,
                UserHandle.getCallingUserId());
    }

    @Override
"
482,services/core/java/com/android/server/am/ActiveServices.java,"['e85435d4d9a2f7122bd5c97ad0a25c768d124a0e', '81b587a542e8381268a9ba8e7461712ef23cd11f']",2,"

                boolean isPersistent
                        = !((r.serviceInfo.applicationInfo.flags&ApplicationInfo.FLAG_PERSISTENT) == 0);
                if(top_rc != null) {
                    if(top_rc.launching && !r.shortInstanceName.contains(top_rc.packageName)
                            && !isPersistent) {
                        shouldDelay = true;
                    }
                }
                if(!shouldDelay) {
                    bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
                } else {
                    if (DEBUG_DELAYED_SERVICE) {
                        Slog.v(TAG, ""Reschedule service restart due to app launch""
                              +"" r.shortInstanceName ""+r.shortInstanceName+"" r.app = ""+r.app);
                    }
                    r.resetRestartCounter();
                    scheduleServiceRestartLocked(r, true);
                }
            } else {
                bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
            }
"
483,services/core/java/com/android/server/am/ActiveServices.java,['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0'],1,"                    app.services.remove(r);
                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");
                    }
"
484,services/core/java/com/android/server/am/ActiveServices.java,"['337095f9d277c566cb888bc3adbac16576f1ae70', '1581c348fc5d6cbf1673b3dbc5960637f891d488', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']",3,"                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.short"
485,services/core/java/com/android/server/am/ActiveServices.java,['1581c348fc5d6cbf1673b3dbc5960637f891d488'],1,"                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortName + "" in "" + r.restartDelay + ""ms"");
                    }
"
486,services/core/java/com/android/server/am/ActiveServices.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"                + r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");

        if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
            for (int i=mRestartingServices.size()-1; i>=0; i--) {
                ServiceRecord r2 = mRestartingServices.get(i);
                Slog.w(TAG,""Restarting list - i ""+i+"" r2.nextRestartTime ""
                           +r2.nextRestartTime+"" r2.name ""+r2.name);
            }
        }

"
487,services/core/java/com/android/server/am/ActiveServices.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"                + r.shortName + "" in "" + r.restartDelay + ""ms"");

        if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
            for (int i=mRestartingServices.size()-1; i>=0; i--) {
                ServiceRecord r2 = mRestartingServices.get(i);
                Slog.w(TAG,""Restarting list - i ""+i+"" r2.nextRestartTime ""
                           +r2.nextRestartTime+"" r2.name ""+r2.name);
            }
        }

"
488,services/core/java/com/android/server/am/ActiveServices.java,['81b587a542e8381268a9ba8e7461712ef23cd11f'],1,"            if(SERVICE_RESCHEDULE) {
                boolean shouldDelay = false;
                ActivityRecord top_rc = null;
                ActivityStack stack = mAm.mStackSupervisor.mRootActivityContainer.getTopDisplayFocusedStack();
                if(stack != null) {
                    top_rc = stack.topRunningActivityLocked();
                }

                boolean isPersistent
                        = !((r.serviceInfo.applicationInfo.flags&ApplicationInfo.FLAG_PERSISTENT) == 0);
                if(top_rc != null) {
                    if(top_rc.launching && !r.shortInstanceName.contains(top_rc.packageName)
                            && !isPersistent) {
                        shouldDelay = true;
                    }
                }
                if(!shouldDelay) {
                    bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
                } else {
                    if (DEBUG_DELAYED_SERVICE) {
                        Slog.v(TAG, ""Reschedule service restart due to app launch""
                              +"" r.shortInstanceName ""+r.shortInstanceName+"" r.app = ""+r.app);
                    }
                    r.resetRestartCounter();
                    scheduleServiceRestartLocked(r, true);
                }
            } else {
                bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
            }
"
489,services/core/java/com/android/server/am/ActiveServices.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"            if(SERVICE_RESCHEDULE) {
                boolean shouldDelay = false;
                ActivityRecord top_rc = null;
                ActivityStack stack = mAm.mStackSupervisor.mRootActivityContainer.getTopDisplayFocusedStack();
                if(stack != null) {
                    top_rc = stack.topRunningActivityLocked();
                }

                boolean isPersistent
                        = !((r.serviceInfo.applicationInfo.flags&ApplicationInfo.FLAG_PERSISTENT) == 0);
                if(top_rc != null) {
                    if(top_rc.launching && !r.shortInstanceName.contains(top_rc.packageName)
                            && !isPersistent) {
                        shouldDelay = true;
                    }
                }
                if(!shouldDelay) {
                    bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false,
                            false);
                } else {
                    if (DEBUG_DELAYED_SERVICE) {
                        Slog.v(TAG, ""Reschedule service restart due to app launch""
                              +"" r.shortInstanceName ""+r.shortInstanceName+"" r.app = ""+r.app);
                    }
                    r.resetRestartCounter();
                    scheduleServiceRestartLocked(r, true);
                }
            } else {
                bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false,
                        false);
            }
"
490,services/core/java/com/android/server/am/ActiveServices.java,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",2,"Name + "" in "" + r.restartDelay + ""ms"");

        if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
            for (int i=mRestartingServices.size()-1; i>=0; i--) {
                ServiceRecord r2 = mRestartingServices.get(i);
                Slog.w(TAG,""Restarting list - i ""+i+"" r2.nextRestartTime ""
                           +r2.nextRestartTime+"" r2.name ""+r2.name);
            }
        }

"
491,services/core/java/com/android/server/am/ActiveServices.java,"['337095f9d277c566cb888bc3adbac16576f1ae70', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']",2,"e(r);
                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");
                    }
"
492,services/core/java/com/android/server/am/ActivityManagerConstants.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",2,"
        if (mPerf != null) {
          // Maximum number of cached processes we will allow.
            DEFAULT_MAX_CACHED_PROCESSES = MAX_CACHED_PROCESSES = Integer.valueOf(
                                                 mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bg_apps_limit"", ""32""));

           //Trim Settings
            USE_TRIM_SETTINGS = Boolean.parseBoolean(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.use_trim_settings"", ""true""));
            EMPTY_APP_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.empty_app_percent"", ""50""));
            TRIM_EMPTY_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_empty_percent"", ""100""));
            TRIM_CACHE_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_cache_percent"", ""100""));
            TRIM_ENABLE_MEMORY = Long.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_enable_memory"", ""1073741824""));
        }
"
493,services/core/java/com/android/server/am/ActivityManagerConstants.java,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', 'b6292e3e1ba3616eac1032737a91925391d94b92']",2,"import android.os.Process;
import android.os.SystemProperties;
"
494,services/core/java/com/android/server/am/ActivityManagerConstants.java,['b6292e3e1ba3616eac1032737a91925391d94b92'],1,"import android.os.Process;
import android.os.SystemProperties;
import android.os.UserHandle;
import android.os.UserManager;
"
495,services/core/java/com/android/server/am/ActivityManagerConstants.java,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '3d2fc559e13b7293212955f1858d443f4fe8234e']",3,"import android.os.SystemProperties;
"
496,services/core/java/com/android/server/am/ActivityManagerConstants.java,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '3d2fc559e13b7293212955f1858d443f4fe8234e']",2,"import android.os.SystemProperties;
import android.os.Process;
"
497,services/core/java/com/android/server/am/ActivityManagerConstants.java,['3454c1e1aa1d155fe2246ce2627cf58e934397e9'],1,"import android.text.TextUtils.SimpleStringSplitter;
import android.util.ArraySet;
import android.util.BoostFramework;
"
498,services/core/java/com/android/server/am/ActivityManagerConstants.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"import android.util.BoostFramework;
"
499,services/core/java/com/android/server/am/ActivityManagerService.java,['6fc85c43e31aad55eecd51d3b0de34715ae03810'],1,"
            if (mUxPerf != null && !mForceStopKill) {
                mUxPerf.perfUXEngine_events(BoostFramework.UXE_EVENT_KILL, 0, app.processName, 0);
                mUxPerf.perfHint(BoostFramework.VENDOR_HINT_KILL, app.processName, pid, 0);
            }

            EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName,
                    app.setAdj, app.setProcState);
"
500,services/core/java/com/android/server/am/ActivityManagerService.java,"['12930acc5076e1acff0744b8d225bb2d2173f1b5', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6', '7100a7fa7244d86adf9e33b9079ce2a355e2a525']",3,"
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
"
501,services/core/java/com/android/server/am/ActivityManagerService.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"                                + "" dur="" + checkDur + "" limit="" + cpuLimit, true);
                        if (app.baseProcessTracker != null) {
                            app.baseProcessTracker.reportExcessiveCpu(app.pkgList.mPkgList);
                        }
"
502,services/core/java/com/android/server/am/ActivityManagerService.java,['1581c348fc5d6cbf1673b3dbc5960637f891d488'],1,"                    if (mEnableProcessGroupCgroupFollow) {
                        setCgroupProcsProcessGroup(app.info.uid, app.pid, processGroup);
                    } else {
                        setProcessGroup(app.pid, processGroup);
                    }
                    if (app.curSchedGroup == ProcessList.SCHED_GROUP_TOP_APP) {
"
503,services/core/java/com/android/server/am/ActivityManagerService.java,['ba167de93776a7e5d1b347d1ee646e161cf24ce5'],1,"            ProcessRecord app = mLruProcesses.get(i);
            if (mEnableBServicePropagation && app.serviceb
                    && (app.curAdj == ProcessList.SERVICE_B_ADJ)) {
                numBServices++;
                for (int s = app.services.size() - 1; s >= 0; s--) {
                    ServiceRecord sr = app.services.valueAt(s);
                    if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + app.processName
                            + "" serviceb = "" + app.serviceb + "" s = "" + s + "" sr.lastActivity = ""
                            + sr.lastActivity + "" packageName = "" + sr.packageName
                            + "" processName = "" + sr.processName);
                    if (SystemClock.uptimeMillis() - sr.lastActivity
                            < mMinBServiceAgingTime) {
                        if (DEBUG_OOM_ADJ) {
                            Slog.d(TAG,""Not aged enough!!!"");
                        }
                        continue;
                    }
                    if (serviceLastActivity == 0) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    } else if (sr.lastActivity < serviceLastActivity) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    }
                }
            }
            if (DEBUG_OOM_ADJ && selectedAppRecord != null) Slog.d(TAG,
                    ""Identified app.processName = "" + selectedAppRecord.processName
                    + "" app.pid = "" + selectedAppRecord.pid);
"
504,services/core/java/com/android/server/am/ActivityManagerService.java,['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c'],1,"        /**
         * Puts the process record in the map.
         * <p>NOTE: Callers should avoid acquiring the mPidsSelfLocked lock before calling this
         * method.
         */
        void put(ProcessRecord app) {
            synchronized (this) {
                mPidMap.put(app.pid, app);
            }
            ActivityTriggerService atService = LocalServices.getService(ActivityTriggerService.class);
            if(atService != null) {
                atService.updateRecord(app.hostingRecord, app.info, app.pid, ActivityTriggerService.PROC_ADDED_NOTIFICATION);
            }
            mAtmInternal.onProcessMapped(app.pid, app.getWindowProcessController());
        }

        /**
         * Removes the process record from the map.
         * <p>NOTE: Callers should avoid acquiring the mPidsSelfLocked lock before calling this
         * method.
         */
        void remove(ProcessRecord app) {
            boolean removed = false;
            synchronized (this) {
                final ProcessRecord existingApp = mPidMap.get(app.pid);
                if (existingApp != null && existingApp.startSeq == app.startSeq) {
                    mPidMap.remove(app.pid);
                    removed = true;
                }
            }
            if (removed) {
                ActivityTriggerService atService = LocalServices.getService(ActivityTriggerService.class);
                if(atService != null) {
                    atService.updateRecord(app.hostingRecord, app.info, app.pid, ActivityTriggerService.PROC_REMOVED_NOTIFICATION);
                }
                mAtmInternal.onProcessUnMapped(app.pid);
            }
        }

        /**
         * Removes the process record from the map if it has a thread.
         * <p>NOTE: Callers should avoid acquiring the mPidsSelfLocked lock before calling this
         * method.
         */
        boolean removeIfNoThread(ProcessRecord app) {
            boolean removed = false;
            synchronized (this) {
                final ProcessRecord existingApp = get(app.pid);
                if (existingApp != null && existingApp.startSeq == app.startSeq
                        && app.thread == null) {
                    mPidMap.remove(app.pid);
                    removed = true;
                }
            }
            if (removed) {
                mAtmInternal.onProcessUnMapped(app.pid);
            }
            return removed;
        }

"
505,services/core/java/com/android/server/am/ActivityManagerService.java,"['12930acc5076e1acff0744b8d225bb2d2173f1b5', '7100a7fa7244d86adf9e33b9079ce2a355e2a525']",2,"        // Hack for pi
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
"
506,services/core/java/com/android/server/am/ActivityManagerService.java,['587cb520382d349c91bd59ada23fbefcdb44314f'],1,"        // TODO (b/67683350)
"
507,services/core/java/com/android/server/am/ActivityManagerService.java,['6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6'],1,"        // TODO (b/67683350)
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
"
508,services/core/java/com/android/server/am/ActivityManagerService.java,['59a28bc92ad55fd0c19ce28047f205978aed52ca'],1,"        ProcessRecord selectedAppRecord = null;
        long serviceLastActivity = 0;
        int numBServices = 0;
"
509,services/core/java/com/android/server/am/ActivityManagerService.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        if ((numBServices > mBServiceAppThreshold) && (true == mAllowLowerMemLevel)
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }
"
510,services/core/java/com/android/server/am/ActivityManagerService.java,['ba167de93776a7e5d1b347d1ee646e161cf24ce5'],1,"        if (app.curRawAdj != app.setRawAdj) {
            String seempStr = ""app_uid="" + app.uid
                + "",app_pid="" + app.pid + "",oom_adj="" + app.curAdj
                + "",setAdj="" + app.setAdj + "",hasShownUi="" + (app.hasShownUi ? 1 : 0)
                + "",cached="" + (app.cached ? 1 : 0)
                + "",fA="" + (app.foregroundActivities ? 1 : 0)
                + "",fS="" + (app.hasForegroundServices() ? 1 : 0)
                + "",systemNoUi="" + (app.systemNoUi ? 1 : 0)
                + "",curSchedGroup="" + app.getCurrentSchedulingGroup()
                + "",curProcState="" + app.curProcState + "",setProcState="" + app.setProcState
                + "",killed="" + (app.killed ? 1 : 0) + "",killedByAm="" + (app.killedByAm ? 1 : 0)
                + "",isDebugging="" + (app.isDebugging() ? 1 : 0);
            android.util.SeempLog.record_str(385, seempStr);
            app.setRawAdj = app.curRawAdj;
"
511,services/core/java/com/android/server/am/ActivityManagerService.java,['88b45c586d461df38b866d529bc98d1dfa3e8838'],1,"        mOomAdjProfiler.oomAdjStarted();
        final ProcessRecord TOP_APP = getTopAppLocked();
        final long now = SystemClock.uptimeMillis();
        final long nowElapsed = SystemClock.elapsedRealtime();
        final long oldTime = now - ProcessList.MAX_EMPTY_TIME;
        final int N = mProcessList.getLruSizeLocked();

        // Reset state in all uid records.
        for (int i=mActiveUids.size()-1; i>=0; i--) {
            final UidRecord uidRec = mActiveUids.valueAt(i);
            if (false && DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,
                    ""Starting update of "" + uidRec);
            uidRec.reset();
        }

        if (mAtmInternal != null) {
            mAtmInternal.rankTaskLayersIfNeeded();
        }

        mAdjSeq++;
        mNewNumServiceProcs = 0;
        mNewNumAServiceProcs = 0;

        final int emptyProcessLimit = mConstants.CUR_MAX_EMPTY_PROCESSES;
        final int cachedProcessLimit = mConstants.CUR_MAX_CACHED_PROCESSES - emptyProcessLimit;

        // Let's determine how many processes we have running vs.
        // how many slots we have for background processes; we may want
        // to put multiple processes in a slot of there are enough of
        // them.
        final int numSlots = (ProcessList.CACHED_APP_MAX_ADJ
                - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2
                / ProcessList.CACHED_APP_IMPORTANCE_LEVELS;
        int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;
        if (numEmptyProcs > cachedProcessLimit) {
            // If there are more empty processes than our limit on cached
            // processes, then use the cached process limit for the factor.
            // This ensures that the really old empty processes get pushed
            // down to the bottom, so if we are running low on memory we will
            // have a better chance at keeping around more cached processes
            // instead of a gazillion empty processes.
            numEmptyProcs = cachedProcessLimit;
        }
        int emptyFactor = (numEmptyProcs + numSlots - 1) / numSlots;
        if (emptyFactor < 1) emptyFactor = 1;
        int cachedFactor = (mNumCachedHiddenProcs > 0 ? (mNumCachedHiddenProcs + numSlots - 1) : 1)
                / numSlots;
        if (cachedFactor < 1) cachedFactor = 1;
        int stepCached = -1;
        int stepEmpty = -1;
        int numCached = 0;
        int numCachedExtraGroup = 0;
        int numEmpty = 0;
        int numTrimming = 0;
        int lastCachedGroup = 0;
        int lastCachedGroupImportance = 0;
        int lastCachedGroupUid = 0;

        mNumNonCachedProcs = 0;
        mNumCachedHiddenProcs = 0;

        // First update the OOM adjustment for each of the
        // application processes based on their current state.
        int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;
        int nextCachedAdj = curCachedAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        int curCachedImpAdj = 0;
        int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ + ProcessList.CACHED_APP_IMPORTANCE_LEVELS;
        int nextEmptyAdj = curEmptyAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        ProcessRecord selectedAppRecord = null;
        long serviceLastActivity = 0;
        int numBServices = 0;

        boolean retryCycles = false;

        // need to reset cycle state before calling computeOomAdjLocked because of service connections
        for (int i=N-1; i>=0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            app.containsCycle = false;
            app.setCurRawProcState(PROCESS_STATE_CACHED_EMPTY);
            app.setCurRawAdj(ProcessList.UNKNOWN_ADJ);
        }
        for (int i=N-1; i>=0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            if (mEnableBServicePropagation && app.serviceb
                    && (app.curAdj == ProcessList.SERVICE_B_ADJ)) {
                numBServices++;
                for (int s = app.services.size() - 1; s >= 0; s--) {
                    ServiceRecord sr = app.services.valueAt(s);
                    if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + app.processName
                            + "" serviceb = "" + app.serviceb + "" s = "" + s + "" sr.lastActivity = ""
                            + sr.lastActivity + "" packageName = "" + sr.packageName
                            + "" processName = "" + sr.processName);
                    if (SystemClock.uptimeMillis() - sr.lastActivity
                            < mMinBServiceAgingTime) {
                        if (DEBUG_OOM_ADJ) {
                            Slog.d(TAG,""Not aged enough!!!"");
                        }
                        continue;
                    }
                    if (serviceLastActivity == 0) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    } else if (sr.lastActivity < serviceLastActivity) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    }
                }
            }
            if (DEBUG_OOM_ADJ && selectedAppRecord != null) Slog.d(TAG,
                    ""Identified app.processName = "" + selectedAppRecord.processName
                    + "" app.pid = "" + selectedAppRecord.pid);
            if (!app.killedByAm && app.thread != null) {
                app.procStateChanged = false;
                computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now, false);

                // if any app encountered a cycle, we need to perform an additional loop later
                retryCycles |= app.containsCycle;

                // If we haven't yet assigned the final cached adj
                // to the process, do that now.
                if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
                    switch (app.getCurProcState()) {
                        case PROCESS_STATE_CACHED_ACTIVITY:
                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                        case ActivityManager.PROCESS_STATE_CACHED_RECENT:
                            // Figure out the next cached level, taking into account groups.
                            boolean inGroup = false;
                            if (app.connectionGroup != 0) {
                                if (lastCachedGroupUid == app.uid
                                        && lastCachedGroup == app.connectionGroup) {
                                    // This is in the same group as the last process, just tweak
                                    // adjustment by importance.
                                    if (app.connectionImportance > lastCachedGroupImportance) {
                                        lastCachedGroupImportance = app.connectionImportance;
                                        if (curCachedAdj < nextCachedAdj
                                                && curCachedAdj < ProcessList.CACHED_APP_MAX_ADJ) {
                                            curCachedImpAdj++;
                                        }
                                    }
                                    inGroup = true;
                                } else {
                                    lastCachedGroupUid = app.uid;
                                    lastCachedGroup = app.connectionGroup;
                                    lastCachedGroupImportance = app.connectionImportance;
                                }
                            }
                            if (!inGroup && curCachedAdj != nextCachedAdj) {
                                stepCached++;
                                curCachedImpAdj = 0;
                                if (stepCached >= cachedFactor) {
                                    stepCached = 0;
                                    curCachedAdj = nextCachedAdj;
                                    nextCachedAdj += ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2;
                                    if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
                                        nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;
                                    }
                                }
                            }
                            // This process is a cached process holding activities...
                            // assign it the next cached value for that type, and then
                            // step that cached level.
                            app.setCurRawAdj(curCachedAdj + curCachedImpAdj);
                            app.curAdj = app.modifyRawOomAdj(curCachedAdj + curCachedImpAdj);
                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, ""Assigning activity LRU #"" + i
                                    + "" adj: "" + app.curAdj + "" (curCachedAdj="" + curCachedAdj
                                    + "" curCachedImpAdj="" + curCachedImpAdj + "")"");
                            break;
                        default:
                            // Figure out the next cached level.
                            if (curEmptyAdj != nextEmptyAdj) {
                                stepEmpty++;
                                if (stepEmpty >= emptyFactor) {
                                    stepEmpty = 0;
                                    curEmptyAdj = nextEmptyAdj;
                                    nextEmptyAdj += ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2;
                                    if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
                                        nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;
                                    }
                                }
                            }
                            // For everything else, assign next empty cached process
                            // level and bump that up.  Note that this means that
                            // long-running services that have dropped down to the
                            // cached level will be treated as empty (since their process
                            // state is still as a service), which is what we want.
                            app.setCurRawAdj(curEmptyAdj);
                            app.curAdj = app.modifyRawOomAdj(curEmptyAdj);
                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, ""Assigning empty LRU #"" + i
                                    + "" adj: "" + app.curAdj + "" (curEmptyAdj="" + curEmptyAdj
                                    + "")"");
                            break;
                    }
                }
            }
        }

        // Cycle strategy:
        // - Retry computing any process that has encountered a cycle.
        // - Continue retrying until no process was promoted.
        // - Iterate from least important to most important.
        int cycleCount = 0;
        while (retryCycles && cycleCount < 10) {
            cycleCount++;
            retryCycles = false;

            for (int i=0; i<N; i++) {
                ProcessRecord app = mProcessList.mLruProcesses.get(i);
                if (!app.killedByAm && app.thread != null && app.containsCycle == true) {
                    app.adjSeq--;
                    app.completedAdjSeq--;
                }
            }

            for (int i=0; i<N; i++) {
                ProcessRecord app = mProcessList.mLruProcesses.get(i);
                if (!app.killedByAm && app.thread != null && app.containsCycle == true) {
                    if (computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now,
                            true)) {
                        retryCycles = true;
                    }
                }
            }
        }

        lastCachedGroup = lastCachedGroupUid = 0;

        for (int i=N-1; i>=0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            if (!app.killedByAm && app.thread != null) {
                applyOomAdjLocked(app, true, now, nowElapsed);

                // Count the number of process types.
                switch (app.getCurProcState()) {
                    case PROCESS_STATE_CACHED_ACTIVITY:
                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                        mNumCachedHiddenProcs++;
                        numCached++;
                        if (app.connectionGroup != 0) {
                            if (lastCachedGroupUid == app.uid
                                    && lastCachedGroup == app.connectionGroup) {
                                // If this process is the next in the same group, we don't
                                // want it to count against our limit of the number of cached
                                // processes, so bump up the group count to account for it.
                                numCachedExtraGroup++;
                            } else {
                                lastCachedGroupUid = app.uid;
                                lastCachedGroup = app.connectionGroup;
                            }
                        } else {
                            lastCachedGroupUid = lastCachedGroup = 0;
                        }
                        if ((numCached - numCachedExtraGroup) > cachedProcessLimit) {
                            app.kill(""cached #"" + numCached, true);
                        }
                        break;
                    case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
                        if (numEmpty > mConstants.CUR_TRIM_EMPTY_PROCESSES
                                && app.lastActivityTime < oldTime) {
                            app.kill(""empty for ""
                                    + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)
                                    / 1000) + ""s"", true);
                        } else {
                            numEmpty++;
                            if (numEmpty > emptyProcessLimit) {
                                app.kill(""empty #"" + numEmpty, true);
                            }
                        }
                        break;
                    default:
                        mNumNonCachedProcs++;
                        break;
                }

                if (app.isolated && app.services.size() <= 0 && app.isolatedEntryPoint == null) {
                    // If this is an isolated process, there are no services
                    // running in it, and it's not a special process with a
                    // custom entry point, then the process is no longer
                    // needed.  We agressively kill these because we can by
                    // definition not re-use the same process again, and it is
                    // good to avoid having whatever code was running in them
                    // left sitting around after no longer needed.
                    app.kill(""isolated not needed"", true);
                } else {
                    // Keeping this process, update its uid.
                    final UidRecord uidRec = app.uidRecord;
                    if (uidRec != null) {
                        uidRec.ephemeral = app.info.isInstantApp();
                        if (uidRec.getCurProcState() > app.getCurProcState()) {
                            uidRec.setCurProcState(app.getCurProcState());
                        }
                        if (app.hasForegroundServices()) {
                            uidRec.foregroundServices = true;
                        }
                    }
                }

                if (app.getCurProcState() >= ActivityManager.PROCESS_STATE_HOME
                        && !app.killedByAm) {
                    numTrimming++;
                }
            }
        }
        if ((numBServices > mBServiceAppThreshold) && (true == mAllowLowerMemLevel)
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }

        incrementProcStateSeqAndNotifyAppsLocked();

        mNumServiceProcs = mNewNumServiceProcs;

        boolean allChanged = updateLowMemStateLocked(numCached, numEmpty, numTrimming);

        if (mAlwaysFinishActivities) {
            // Need to do this on its own message because the stack may not
            // be in a consistent state at this point.
            mAtmInternal.scheduleDestroyAllActivities(""always-finish"");
        }

        if (allChanged) {
            requestPssAllProcsLocked(now, false, mProcessStats.isMemFactorLowered());
        }

        ArrayList<UidRecord> becameIdle = null;

        // Update from any uid changes.
        if (mLocalPowerManager != null) {
            mLocalPowerManager.startUidChanges();
        }
        for (int i=mActiveUids.size()-1; i>=0; i--) {
            final UidRecord uidRec = mActiveUids.valueAt(i);
            int uidChange = UidRecord.CHANGE_PROCSTATE;
            if (uidRec.getCurProcState() != PROCESS_STATE_NONEXISTENT
                    && (uidRec.setProcState != uidRec.getCurProcState()
                           || uidRec.setWhitelist != uidRec.curWhitelist)) {
                if (DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS, ""Changes in "" + uidRec
                        + "": proc state from "" + uidRec.setProcState + "" to ""
                        + uidRec.getCurProcState() + "", whitelist from "" + uidRec.setWhitelist
                        + "" to "" + uidRec.curWhitelist);
                if (ActivityManager.isProcStateBackground(uidRec.getCurProcState())
                        && !uidRec.curWhitelist) {
                    // UID is now in the background (and not on the temp whitelist).  Was it
                    // previously in the foreground (or on the temp whitelist)?
                    if (!ActivityManager.isProcStateBackground(uidRec.setProcState)
                            || uidRec.setWhitelist) {
                        uidRec.lastBackgroundTime = nowElapsed;
                        if (!mHandler.hasMessages(IDLE_UIDS_MSG)) {
                            // Note: the background settle time is in elapsed realtime, while
                            // the handler time base is uptime.  All this means is that we may
                            // stop background uids later than we had intended, but that only
                            // happens because the device was sleeping so we are okay anyway.
                            mHandler.sendEmptyMessageDelayed(IDLE_UIDS_MSG,
                                    mConstants.BACKGROUND_SETTLE_TIME);
                        }
                    }
                    if (uidRec.idle && !uidRec.setIdle) {
                        uidChange = UidRecord.CHANGE_IDLE;
                        if (becameIdle == null) {
                            becameIdle = new ArrayList<>();
                        }
                        becameIdle.add(uidRec);
                    }
                } else {
                    if (uidRec.idle) {
                        uidChange = UidRecord.CHANGE_ACTIVE;
                        EventLogTags.writeAmUidActive(uidRec.uid);
                        uidRec.idle = false;
                    }
                    uidRec.lastBackgroundTime = 0;
                }
                final boolean wasCached = uidRec.setProcState
                        > ActivityManager.PROCESS_STATE_RECEIVER;
                final boolean isCached = uidRec.getCurProcState()
                        > ActivityManager.PROCESS_STATE_RECEIVER;
                if (wasCached != isCached || uidRec.setProcState == PROCESS_STATE_NONEXISTENT) {
                    uidChange |= isCached ? UidRecord.CHANGE_CACHED : UidRecord.CHANGE_UNCACHED;
                }
                uidRec.setProcState = uidRec.getCurProcState();
                uidRec.setWhitelist = uidRec.curWhitelist;
                uidRec.setIdle = uidRec.idle;
                enqueueUidChangeLocked(uidRec, -1, uidChange);
                noteUidProcessState(uidRec.uid, uidRec.getCurProcState());
                if (uidRec.foregroundServices) {
                    mServices.foregroundServiceProcStateChangedLocked(uidRec);
                }
            }
        }
        if (mLocalPowerManager != null) {
            mLocalPowerManager.finishUidChanges();
        }

        if (becameIdle != null) {
            // If we have any new uids that became idle this time, we need to make sure
            // they aren't left with running services.
            for (int i = becameIdle.size() - 1; i >= 0; i--) {
                mServices.stopInBackgroundLocked(becameIdle.get(i).uid);
            }
        }

        if (mProcessStats.shouldWriteNowLocked(now)) {
            mHandler.post(new ProcStatsRunnable(ActivityManagerService.this, mProcessStats));
        }

        // Run this after making sure all procstates are updated.
        mProcessStats.updateTrackingAssociationsLocked(mAdjSeq, now);

        if (DEBUG_OOM_ADJ) {
            final long duration = SystemClock.uptimeMillis() - now;
            if (false) {
                Slog.d(TAG_OOM_ADJ, ""Did OOM ADJ in "" + duration + ""ms"",
                        new RuntimeException(""here"").fillInStackTrace());
            } else {
                Slog.d(TAG_OOM_ADJ, ""Did OOM ADJ in "" + duration + ""ms"");
            }
        }
        mOomAdjProfiler.oomAdjEnded();
"
512,services/core/java/com/android/server/am/ActivityManagerService.java,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'dfd2f7fed77160af2c57edfa20f1768b42aaa8da']",2,"        public int startActivityAsUserEmpty(Bundle options) {
            return ActivityManagerService.this.startActivityAsUserEmpty(options);
"
513,services/core/java/com/android/server/am/ActivityManagerService.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"        public int startActivityAsUserEmpty(Bundle options) {
            return ActivityManagerService.this.startActivityAsUserEmpty(options);
        }

        @Override
        public void killForegroundAppsForUser(int userHandle) {
"
514,services/core/java/com/android/server/am/ActivityManagerService.java,['1581c348fc5d6cbf1673b3dbc5960637f891d488'],1,"        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
                resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,
                true /*validateIncomingUser*/);
    }

    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,
            boolean validateIncomingUser) {
        enforceNotIsolatedCaller(""startActivity"");

        userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,
                Binder.getCallingPid(), Binder.getCallingUid(), ""startActivityAsUser"");

        // TODO: Switch to user app stacks here.
        return mActivityStartController.obtainStarter(intent, ""startActivityAsUser"")
                .setCaller(caller)
                .setCallingPackage(callingPackage)
                .setResolvedType(resolvedType)
                .setResultTo(resultTo)
                .setResultWho(resultWho)
                .setRequestCode(requestCode)
                .setStartFlags(startFlags)
                .setProfilerInfo(profilerInfo)
                .setActivityOptions(bOptions)
                .setMayWait(userId)
                .execute();

    }

    final int startActivityAsUserEmpty(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {
        ArrayList<String> pApps = options.getStringArrayList(""start_empty_apps"");
        if (pApps != null && pApps.size() > 0) {
            Iterator<String> apps_itr = pApps.iterator();
            while (apps_itr.hasNext()) {
                ProcessRecord empty_app = null;
                String app_str = apps_itr.next();
                if (app_str == null)
                    continue;
                synchronized (this) {
                    Intent intent_l = null;
                    try {
                        intent_l = mContext.getPackageManager().getLaunchIntentForPackage(app_str);
                        if (intent_l == null)
                            continue;
                        ActivityInfo aInfo = mStackSupervisor.resolveActivity(intent_l, null,
                                                                          0, null, 0, 0);
                        if (aInfo == null)
                            continue;
                        empty_app = startProcessLocked(app_str, aInfo.applicationInfo, false, 0,
                                                   ""activity"", null, false, false, true);
                        if (empty_app != null)
                            updateOomAdjLocked(empty_app, true);
                    } catch (Exception e) {
                        if (DEBUG_PROCESSES)
                            Slog.w(TAG, ""Exception raised trying to start app as empty "" + e);
                    }
                }
            }
        }
        return 1;
    }

    @Override
    public final int startActivityAsCaller(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, boolean ignoreTargetSecurity,
            int userId) {

        // This is very dangerous -- it allows you to perform a start activity (including
        // permission grants) as any app that may launch one of your own activities.  So
        // we will only allow this to be done from activities that are part of the core framework,
        // and then only when they are running as the system.
        final ActivityRecord sourceRecord;
        final int targetUid;
        final String targetPackage;
        final boolean isResolver;
        synchronized (this) {
            if (resultTo == null) {
                throw new SecurityException(""Must be called from an activity"");
            }
            sourceRecord = mStackSupervisor.isInAnyStackLocked(resultTo);
            if (sourceRecord == null) {
                throw new SecurityException(""Called with bad activity token: "" + resultTo);
            }
            if (!sourceRecord.info.packageName.equals(""android"")) {
                throw new SecurityException(
                        ""Must be called from an activity that is declared in the android package"");
            }
            if (sourceRecord.app == null) {
                throw new SecurityException(""Called without a process attached to activity"");
            }
            if (UserHandle.getAppId(sourceRecord.app.uid) != SYSTEM_UID) {
                // This is still okay, as long as this activity is running under the
                // uid of the original calling activity.
                if (sourceRecord.app.uid != sourceRecord.launchedFromUid) {
                    throw new SecurityException(
                            ""Calling activity in uid "" + sourceRecord.app.uid
                                    + "" must be system uid or original calling uid ""
                                    + sourceRecord.launchedFromUid);
                }
            }
            if (ignoreTargetSecurity) {
                if (intent.getComponent() == null) {
                    throw new SecurityException(
                            ""Component must be specified with ignoreTargetSecurity"");
                }
                if (intent.getSelector() != null) {
                    throw new SecurityException(
                            ""Selector not allowed with ignoreTargetSecurity"");
                }
            }
            targetUid = sourceRecord.launchedFromUid;
            targetPackage = sourceRecord.launchedFromPackage;
            isResolver = sourceRecord.isResolverOrChildActivity();
        }

        if (userId == UserHandle.USER_NULL) {
            userId = UserHandle.getUserId(sourceRecord.app.uid);
        }

        // TODO: Switch to user app stacks here.
        try {
            return mActivityStartController.obtainStarter(intent, ""startActivityAsCaller"")
                    .setCallingUid(targetUid)
                    .setCallingPackage(targetPackage)
                    .setResolvedType(resolvedType)
                    .setResultTo(resultTo)
                    .setResultWho(resultWho)
                    .setRequestCode(requestCode)
                    .setStartFlags(startFlags)
                    .setActivityOptions(bOptions)
                    .setMayWait(userId)
                    .setIgnoreTargetSecurity(ignoreTargetSecurity)
                    .setFilterCallingUid(isResolver ? 0 /* system */ : targetUid)
                    .execute();
        } catch (SecurityException e) {
            // XXX need to figure out how to propagate to original app.
            // A SecurityException here is generally actually a fault of the original
            // calling activity (such as a fairly granting permissions), so propagate it
            // back to them.
            /*
            StringBuilder msg = new StringBuilder();
            msg.append(""While launching"");
            msg.append(intent.toString());
            msg.append("": "");
            msg.append(e.getMessage());
            */
            throw e;
        }
    }

    @Override
    public final WaitResult startActivityAndWait(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller(""startActivityAndWait"");
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                userId, false, ALLOW_FULL_ONLY, ""startActivityAndWait"", null);
        WaitResult res = new WaitResult();
        // TODO: Switch to user app stacks here.
        mActivityStartController.obtainStarter(intent, ""startActivityAndWait"")
                .setCaller(caller)
                .setCallingPackage(callingPackage)
                .setResolvedType(resolvedType)
                .setResultTo(resultTo)
                .setResultWho(resultWho)
                .setRequestCode(requestCode)
                .setStartFlags(startFlags)
                .setActivityOptions(bOptions)
                .setMayWait(userId)
                .setProfilerInfo(profilerInfo)
                .setWaitResult(res)
                .execute();
        return res;
    }

    @Override
    public final int startActivityWithConfig(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, Configuration config, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller(""startActivityWithConfig"");
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                userId, false, ALLOW_FULL_ONLY, ""startActivityWithConfig"", null);
        // TODO: Switch to user app stacks here.
        return mActivityStartController.obtainStarter(intent, ""startActivityWithConfig"")
                .setCaller(caller)
                .setCallingPackage(callingPackage)
                .setResolvedType(resolvedType)
                .setResultTo(resultTo)
                .setResultWho(resultWho)
                .setRequestCode(requestCode)
                .setStartFlags(startFlags)
                .setGlobalConfiguration(config)
                .setActivityOptions(bOptions)
                .setMayWait(userId)
                .execute();
"
515,services/core/java/com/android/server/am/ActivityManagerService.java,"['4a30c150e58ec67edb92a7bec5ea48cebd6b90d4', '6fc85c43e31aad55eecd51d3b0de34715ae03810', '88b45c586d461df38b866d529bc98d1dfa3e8838']",3,"    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
"
516,services/core/java/com/android/server/am/ActivityManagerService.java,['4a30c150e58ec67edb92a7bec5ea48cebd6b90d4'],1,"    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();

    final OomAdjuster mOomAdjuster;
"
517,services/core/java/com/android/server/am/ActivityManagerService.java,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']",2,"    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
    public static boolean mForceStopKill = false;
"
518,services/core/java/com/android/server/am/ActivityManagerService.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"    /**
     * How long between a process kill and we actually receive its death recipient
     */
    private static final long PROC_KILL_TIMEOUT = 5000; // 5 seconds;

    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
    public static boolean mForceStopKill = false;

"
519,services/core/java/com/android/server/am/ActivityManagerService.java,['ba167de93776a7e5d1b347d1ee646e161cf24ce5'],1,"    @GuardedBy(""this"")
    private final void startProcessLocked(ProcessRecord app,
            String hostingType, String hostingNameStr) {
        startProcessLocked(app, hostingType, hostingNameStr, null /* abiOverride */);
    }

    @GuardedBy(""this"")
    private final boolean startProcessLocked(ProcessRecord app,
            String hostingType, String hostingNameStr, String abiOverride) {
        return startProcessLocked(app, hostingType, hostingNameStr,
                false /* disableHiddenApiChecks */, abiOverride);
    }

    /**
     * @return {@code true} if process start is successful, false otherwise.
     */
    @GuardedBy(""this"")
    private final boolean startProcessLocked(ProcessRecord app, String hostingType,
            String hostingNameStr, boolean disableHiddenApiChecks, String abiOverride) {
        if (app.pendingStart) {
            return true;
        }
        long startTime = SystemClock.elapsedRealtime();
        if (app.pid > 0 && app.pid != MY_PID) {
            checkTime(startTime, ""startProcess: removing from pids map"");
            synchronized (mPidsSelfLocked) {
                mPidsSelfLocked.remove(app.pid);
                mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
            }
            checkTime(startTime, ""startProcess: done removing from pids map"");
            app.setPid(0);
        }

        if (DEBUG_PROCESSES && mProcessesOnHold.contains(app)) Slog.v(TAG_PROCESSES,
                ""startProcessLocked removing on hold: "" + app);
        mProcessesOnHold.remove(app);

        checkTime(startTime, ""startProcess: starting to update cpu stats"");
        updateCpuStats();
        checkTime(startTime, ""startProcess: done updating cpu stats"");

        try {
            try {
                final int userId = UserHandle.getUserId(app.uid);
                AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }

            int uid = app.uid;
            int[] gids = null;
            int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
            if (!app.isolated) {
                int[] permGids = null;
                try {
                    checkTime(startTime, ""startProcess: getting gids from package manager"");
                    final IPackageManager pm = AppGlobals.getPackageManager();
                    permGids = pm.getPackageGids(app.info.packageName,
                            MATCH_DEBUG_TRIAGED_MISSING, app.userId);
                    StorageManagerInternal storageManagerInternal = LocalServices.getService(
                            StorageManagerInternal.class);
                    mountExternal = storageManagerInternal.getExternalStorageMountMode(uid,
                            app.info.packageName);
                } catch (RemoteException e) {
                    throw e.rethrowAsRuntimeException();
                }

                /*
                 * Add shared application and profile GIDs so applications can share some
                 * resources like shared libraries and access user-wide resources
                 */
                if (ArrayUtils.isEmpty(permGids)) {
                    gids = new int[3];
                } else {
                    gids = new int[permGids.length + 3];
                    System.arraycopy(permGids, 0, gids, 3, permGids.length);
                }
                gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
                gids[1] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid));
                gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid));

                // Replace any invalid GIDs
                if (gids[0] == UserHandle.ERR_GID) gids[0] = gids[2];
                if (gids[1] == UserHandle.ERR_GID) gids[1] = gids[2];
            }
            checkTime(startTime, ""startProcess: building args"");
            if (mAtmInternal.isFactoryTestProcess(app.getWindowProcessController())) {
                uid = 0;
            }
            int runtimeFlags = 0;
            if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_JDWP;
                runtimeFlags |= Zygote.DEBUG_JAVA_DEBUGGABLE;
                // Also turn on CheckJNI for debuggable apps. It's quite
                // awkward to turn on otherwise.
                runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
            }
            // Run the app in safe mode if its manifest requests so or the
            // system is booted in safe mode.
            if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 ||
                mSafeMode == true) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
            }
            if (""1"".equals(SystemProperties.get(""debug.checkjni""))) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
            }
            String genDebugInfoProperty = SystemProperties.get(""debug.generate-debug-info"");
            if (""1"".equals(genDebugInfoProperty) || ""true"".equals(genDebugInfoProperty)) {
                runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
            }
            String genMiniDebugInfoProperty = SystemProperties.get(""dalvik.vm.minidebuginfo"");
            if (""1"".equals(genMiniDebugInfoProperty) || ""true"".equals(genMiniDebugInfoProperty)) {
                runtimeFlags |= Zygote.DEBUG_GENERATE_MINI_DEBUG_INFO;
            }
            if (""1"".equals(SystemProperties.get(""debug.jni.logging""))) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
            }
            if (""1"".equals(SystemProperties.get(""debug.assert""))) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_ASSERT;
            }
            if (mNativeDebuggingApp != null && mNativeDebuggingApp.equals(app.processName)) {
                // Enable all debug flags required by the native debugger.
                runtimeFlags |= Zygote.DEBUG_ALWAYS_JIT;          // Don't interpret anything
                runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO; // Generate debug info
                runtimeFlags |= Zygote.DEBUG_NATIVE_DEBUGGABLE;   // Disbale optimizations
                mNativeDebuggingApp = null;
            }

            if (app.info.isPrivilegedApp() &&
                    DexManager.isPackageSelectedToRunOob(app.pkgList.mPkgList.keySet())) {
                runtimeFlags |= Zygote.ONLY_USE_SYSTEM_OAT_FILES;
            }

            if (!disableHiddenApiChecks && !mHiddenApiBlacklist.isDisabled()) {
                app.info.maybeUpdateHiddenApiEnforcementPolicy(
                        mHiddenApiBlacklist.getPolicyForPrePApps(),
                        mHiddenApiBlacklist.getPolicyForPApps());
                @HiddenApiEnforcementPolicy int policy =
                        app.info.getHiddenApiEnforcementPolicy();
                int policyBits = (policy << Zygote.API_ENFORCEMENT_POLICY_SHIFT);
                if ((policyBits & Zygote.API_ENFORCEMENT_POLICY_MASK) != policyBits) {
                    throw new IllegalStateException(""Invalid API policy: "" + policy);
                }
                runtimeFlags |= policyBits;
            }

            String invokeWith = null;
            if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
                // Debuggable apps may include a wrapper script with their library directory.
                String wrapperFileName = app.info.nativeLibraryDir + ""/wrap.sh"";
                StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
                try {
                    if (new File(wrapperFileName).exists()) {
                        invokeWith = ""/system/bin/logwrapper "" + wrapperFileName;
                    }
                } finally {
                    StrictMode.setThreadPolicy(oldPolicy);
                }
            }

            String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi;
            if (requiredAbi == null) {
                requiredAbi = Build.SUPPORTED_ABIS[0];
            }

            String instructionSet = null;
            if (app.info.primaryCpuAbi != null) {
                instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
            }

            app.gids = gids;
            app.setRequiredAbi(requiredAbi);
            app.instructionSet = instructionSet;

            // the per-user SELinux context must be set
            if (TextUtils.isEmpty(app.info.seInfoUser)) {
                Slog.wtf(TAG, ""SELinux tag not defined"",
                        new IllegalStateException(""SELinux tag not defined for ""
                        + app.info.packageName + "" (uid "" + app.uid + "")""));
            }
            final String seInfo = app.info.seInfo
                    + (TextUtils.isEmpty(app.info.seInfoUser) ? """" : app.info.seInfoUser);
            // Start the process.  It will either succeed and return a result containing
            // the PID of the new process, or else throw a RuntimeException.
            final String entryPoint = ""android.app.ActivityThread"";

            return startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids,
                    runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,
                    startTime);
        } catch (RuntimeException e) {
            Slog.e(TAG, ""Failure starting process "" + app.processName, e);

            // Something went very wrong while trying to start this process; one
            // common case is when the package is frozen due to an active
            // upgrade. To recover, clean up any active bookkeeping related to
            // starting this process. (We already invoked this method once when
            // the package was initially frozen through KILL_APPLICATION_MSG, so
            // it doesn't hurt to use it again.)
            forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false,
                    false, true, false, false, app.userId, ""start failure"");
            return false;
        }
    }

    @GuardedBy(""this"")
    private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint,
            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,
            String seInfo, String requiredAbi, String instructionSet, String invokeWith,
            long startTime) {
        app.pendingStart = true;
        app.killedByAm = false;
        app.removed = false;
        app.killed = false;
        final long startSeq = app.startSeq = ++mProcStartSeqCounter;
        app.setStartParams(uid, hostingType, hostingNameStr, seInfo, startTime);
        if (mConstants.FLAG_PROCESS_START_ASYNC) {
            if (DEBUG_PROCESSES) Slog.i(TAG_PROCESSES,
                    ""Posting procStart msg for "" + app.toShortString());
            mProcStartHandler.post(() -> {
                try {
                    synchronized (ActivityManagerService.this) {
                        final String reason = isProcStartValidLocked(app, startSeq);
                        if (reason != null) {
                            Slog.w(TAG_PROCESSES, app + "" not valid anymore,""
                                    + "" don't start process, "" + reason);
                            app.pendingStart = false;
                            return;
                        }
                        app.setUsingWrapper(invokeWith != null
                                || SystemProperties.get(""wrap."" + app.processName) != null);
                        mPendingStarts.put(startSeq, app);
                    }
                    final ProcessStartResult startResult = startProcess(app.hostingType, entryPoint,
                            app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo,
                            requiredAbi, instructionSet, invokeWith, app.startTime);
                    synchronized (ActivityManagerService.this) {
                        handleProcessStartedLocked(app, startResult, startSeq);
                    }
                } catch (RuntimeException e) {
                    synchronized (ActivityManagerService.this) {
                        Slog.e(TAG, ""Failure starting process "" + app.processName, e);
                        mPendingStarts.remove(startSeq);
                        app.pendingStart = false;
                        forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),
                                false, false, true, false, false, app.userId, ""start failure"");
                    }
                }
            });
            return true;
        } else {
            try {
                final ProcessStartResult startResult = startProcess(hostingType, entryPoint, app,
                        uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,
                        invokeWith, startTime);
                handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,
                        startSeq, false);
            } catch (RuntimeException e) {
                Slog.e(TAG, ""Failure starting process "" + app.processName, e);
                app.pendingStart = false;
                forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),
                        false, false, true, false, false, app.userId, ""start failure"");
            }
            return app.pid > 0;
        }
    }

    private ProcessStartResult startProcess(String hostingType, String entryPoint,
            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,
            String seInfo, String requiredAbi, String instructionSet, String invokeWith,
            long startTime) {
        try {
            final String[] packageNames = mContext.getPackageManager().getPackagesForUid(uid);
            final String[] visibleVolIds = LocalServices.getService(StorageManagerInternal.class)
                    .getVisibleVolumesForUser(UserHandle.getUserId(uid));
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""Start proc: "" +
                    app.processName);
            checkTime(startTime, ""startProcess: asking zygote to start proc"");
            final ProcessStartResult startResult;
            if (hostingType.equals(""webview_service"")) {
                startResult = startWebView(entryPoint,
                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, null, app.info.packageName,
                        packageNames, visibleVolIds,
                        new String[] {PROC_START_SEQ_IDENT + app.startSeq});
            }
            else {
                startResult = Process.start(entryPoint,
                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, invokeWith, app.info.packageName,
                        packageNames, visibleVolIds,
                        new String[] {PROC_START_SEQ_IDENT + app.startSeq});
            }

            if (mPerfServiceStartHint == null) {
                mPerfServiceStartHint = new BoostFramework();
            }
            if (mPerfServiceStartHint != null) {
                mPerfServiceStartHint.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST, app.processName, -1, BoostFramework.Launch.TYPE_SERVICE_START);
            }

            checkTime(startTime, ""startProcess: returned from zygote!"");
            return startResult;
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        }
    }

    @GuardedBy(""this"")
    private String isProcStartValidLocked(ProcessRecord app, long expectedStartSeq) {
        StringBuilder sb = null;
        if (app.killedByAm) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""killedByAm=true;"");
        }
        if (mProcessNames.get(app.processName, app.uid) != app) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""No entry in mProcessNames;"");
        }
        if (!app.pendingStart) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""pendingStart=false;"");
        }
        if (app.startSeq > expectedStartSeq) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""seq="" + app.startSeq + "",expected="" + expectedStartSeq + "";"");
        }
        return sb == null ? null : sb.toString();
    }

    @GuardedBy(""this"")
    private boolean handleProcessStartedLocked(ProcessRecord pending,
            ProcessStartResult startResult, long expectedStartSeq) {
        // Indicates that this process start has been taken care of.
        if (mPendingStarts.get(expectedStartSeq) == null) {
            if (pending.pid == startResult.pid) {
                pending.setUsingWrapper(startResult.usingWrapper);
                // TODO: Update already existing clients of usingWrapper
            }
            return false;
        }
        return handleProcessStartedLocked(pending, startResult.pid, startResult.usingWrapper,
                expectedStartSeq, false);
    }

    @GuardedBy(""this"")
    private boolean handleProcessStartedLocked(ProcessRecord app, int pid, boolean usingWrapper,
            long expectedStartSeq, boolean procAttached) {
        mPendingStarts.remove(expectedStartSeq);
        final String reason = isProcStartValidLocked(app, expectedStartSeq);
        if (reason != null) {
            Slog.w(TAG_PROCESSES, app + "" start not valid, killing pid="" + pid
                    + "", "" + reason);
            app.pendingStart = false;
            Process.killProcessQuiet(pid);
            Process.killProcessGroup(app.uid, app.pid);
            return false;
        }
        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        checkTime(app.startTime, ""startProcess: done updating battery stats"");

        EventLog.writeEvent(EventLogTags.AM_PROC_START,
                UserHandle.getUserId(app.startUid), pid, app.startUid,
                app.processName, app.hostingType,
                app.hostingNameStr != null ? app.hostingNameStr : """");

        try {
            AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid,
                    app.seInfo, app.info.sourceDir, pid);
        } catch (RemoteException ex) {
            // Ignore
        }

        if (app.isPersistent()) {
            Watchdog.getInstance().processStarted(app.processName, pid);
        }

        checkTime(app.startTime, ""startProcess: building log message"");
        StringBuilder buf = mStringBuilder;
        buf.setLength(0);
        buf.append(""Start proc "");
        buf.append(pid);
        buf.append(':');
        buf.append(app.processName);
        buf.append('/');
        UserHandle.formatUid(buf, app.startUid);
        if (app.isolatedEntryPoint != null) {
            buf.append("" ["");
            buf.append(app.isolatedEntryPoint);
            buf.append(""]"");
        }
        buf.append("" for "");
        buf.append(app.hostingType);
        if (app.hostingNameStr != null) {
            buf.append("" "");
            buf.append(app.hostingNameStr);
        }
        reportUidInfoMessageLocked(TAG, buf.toString(), app.startUid);
        app.setPid(pid);
        app.setUsingWrapper(usingWrapper);
        app.pendingStart = false;
        checkTime(app.startTime, ""startProcess: starting to update pids map"");
        ProcessRecord oldApp;
        synchronized (mPidsSelfLocked) {
            oldApp = mPidsSelfLocked.get(pid);
        }
        // If there is already an app occupying that pid that hasn't been cleaned up
        if (oldApp != null && !app.isolated) {
            // Clean up anything relating to this pid first
            Slog.w(TAG, ""Reusing pid "" + pid
                    + "" while app is still mapped to it"");
            cleanUpApplicationRecordLocked(oldApp, false, false, -1,
                    true /*replacingPid*/);
        }
        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(pid, app);
            if (!procAttached) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, usingWrapper
                        ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
        checkTime(app.startTime, ""startProcess: done updating pids map"");
        return true;
    }

"
520,services/core/java/com/android/server/am/ActivityManagerService.java,['1581c348fc5d6cbf1673b3dbc5960637f891d488'],1,"    SleepToken acquireSleepToken(String tag, int displayId) {
        synchronized (this) {
            final SleepToken token = mStackSupervisor.createSleepTokenLocked(tag, displayId);
            if (mEnableNetOpts) {
                ActivityStack stack = mStackSupervisor.getLastStack();
                if (stack != null) {
                    ActivityRecord r = stack.topRunningActivityLocked();
                    if (r != null) {
                        networkOptsCheck(1, r.processName);
                    }
                }
            }
            updateSleepIfNeededLocked();
            return token;
        }
    }

"
521,services/core/java/com/android/server/am/ActivityManagerService.java,['88b45c586d461df38b866d529bc98d1dfa3e8838'],1,"    private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now,
            long nowElapsed) {
        boolean success = true;

        if (app.getCurRawAdj() != app.setRawAdj) {
            app.setRawAdj = app.getCurRawAdj();
        }

        int changes = 0;

        if (app.curAdj != app.setAdj) {
            // don't compact during bootup
            if (mConstants.USE_COMPACTION && mBooted) {
                // Perform a minor compaction when a perceptible app becomes the prev/home app
                // Perform a major compaction when any app enters cached
                // reminder: here, setAdj is previous state, curAdj is upcoming state
                if (app.setAdj <= ProcessList.PERCEPTIBLE_APP_ADJ &&
                    (app.curAdj == ProcessList.PREVIOUS_APP_ADJ ||
                     app.curAdj == ProcessList.HOME_APP_ADJ)) {
                    mAppCompact.compactAppSome(app);
                } else if (app.setAdj < ProcessList.CACHED_APP_MIN_ADJ &&
                           app.curAdj >= ProcessList.CACHED_APP_MIN_ADJ) {
                    mAppCompact.compactAppFull(app);
                }
            }
            ProcessList.setOomAdj(app.pid, app.uid, app.curAdj);
            if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.info.uid) {
                String msg = ""Set "" + app.pid + "" "" + app.processName + "" adj ""
                        + app.curAdj + "": "" + app.adjType;
                reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
            }
            app.setAdj = app.curAdj;
            app.verifiedAdj = ProcessList.INVALID_ADJ;
        }

        final int curSchedGroup = app.getCurrentSchedulingGroup();
        if (app.setSchedGroup != curSchedGroup) {
            int oldSchedGroup = app.setSchedGroup;
            app.setSchedGroup = curSchedGroup;
            if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.uid) {
                String msg = ""Setting sched group of "" + app.processName
                        + "" to "" + curSchedGroup + "": "" + app.adjType;
                reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
            }
            if (app.waitingToKill != null && app.curReceivers.isEmpty()
                    && app.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND) {
                app.kill(app.waitingToKill, true);
                success = false;
            } else {
                int processGroup;
                switch (curSchedGroup) {
                    case ProcessList.SCHED_GROUP_BACKGROUND:
                        processGroup = THREAD_GROUP_BG_NONINTERACTIVE;
                        break;
                    case ProcessList.SCHED_GROUP_TOP_APP:
                    case ProcessList.SCHED_GROUP_TOP_APP_BOUND:
                        processGroup = THREAD_GROUP_TOP_APP;
                        break;
                    case ProcessList.SCHED_GROUP_RESTRICTED:
                        processGroup = THREAD_GROUP_RESTRICTED;
                        break;
                    default:
                        processGroup = THREAD_GROUP_DEFAULT;
                        break;
                }
                long oldId = Binder.clearCallingIdentity();
                try {
                    if (mEnableProcessGroupCgroupFollow) {
                        setCgroupProcsProcessGroup(app.info.uid, app.pid, processGroup);
                    } else {
                        setProcessGroup(app.pid, processGroup);
                    }
                    if (curSchedGroup == ProcessList.SCHED_GROUP_TOP_APP) {
                        // do nothing if we already switched to RT
                        if (oldSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) {
                            app.getWindowProcessController().onTopProcChanged();
                            if (mUseFifoUiScheduling) {
                                // Switch UI pipeline for app to SCHED_FIFO
                                app.savedPriority = Process.getThreadPriority(app.pid);
                                scheduleAsFifoPriority(app.pid, /* suppressLogs */true);
                                if (app.renderThreadTid != 0) {
                                    scheduleAsFifoPriority(app.renderThreadTid,
                                        /* suppressLogs */true);
                                    if (DEBUG_OOM_ADJ) {
                                        Slog.d(""UI_FIFO"", ""Set RenderThread (TID "" +
                                            app.renderThreadTid + "") to FIFO"");
                                    }
                                } else {
                                    if (DEBUG_OOM_ADJ) {
                                        Slog.d(""UI_FIFO"", ""Not setting RenderThread TID"");
                                    }
                                }
                            } else {
                                // Boost priority for top app UI and render threads
                                setThreadPriority(app.pid, TOP_APP_PRIORITY_BOOST);
                                if (app.renderThreadTid != 0) {
                                    try {
                                        setThreadPriority(app.renderThreadTid,
                                                TOP_APP_PRIORITY_BOOST);
                                    } catch (IllegalArgumentException e) {
                                        // thread died, ignore
                                    }
                                }
                            }
                        }
                    } else if (oldSchedGroup == ProcessList.SCHED_GROUP_TOP_APP &&
                            curSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) {
                        app.getWindowProcessController().onTopProcChanged();
                        if (mUseFifoUiScheduling) {
                            try {
                                // Reset UI pipeline to SCHED_OTHER
                                setThreadScheduler(app.pid, SCHED_OTHER, 0);
                                setThreadPriority(app.pid, app.savedPriority);
                                if (app.renderThreadTid != 0) {
                                    setThreadScheduler(app.renderThreadTid,
                                        SCHED_OTHER, 0);
                                    setThreadPriority(app.renderThreadTid, -4);
                                }
                            } catch (IllegalArgumentException e) {
                                Slog.w(TAG,
                                        ""Failed to set scheduling policy, thread does not exist:\n""
                                                + e);
                            } catch (SecurityException e) {
                                Slog.w(TAG, ""Failed to set scheduling policy, not allowed:\n"" + e);
                            }
                        } else {
                            // Reset priority for top app UI and render threads
                            setThreadPriority(app.pid, 0);
                            if (app.renderThreadTid != 0) {
                                setThreadPriority(app.renderThreadTid, 0);
                            }
                        }
                    }
                } catch (Exception e) {
                    if (false) {
                        Slog.w(TAG, ""Failed setting process group of "" + app.pid
                                + "" to "" + app.getCurrentSchedulingGroup());
                        Slog.w(TAG, ""at location"", e);
                    }
                } finally {
                    Binder.restoreCallingIdentity(oldId);
                }
            }
        }
        if (app.repForegroundActivities != app.hasForegroundActivities()) {
            app.repForegroundActivities = app.hasForegroundActivities();
            changes |= ProcessChangeItem.CHANGE_ACTIVITIES;
        }
        if (app.getReportedProcState() != app.getCurProcState()) {
            app.setReportedProcState(app.getCurProcState());
            if (app.thread != null) {
                try {
                    if (false) {
                        //RuntimeException h = new RuntimeException(""here"");
                        Slog.i(TAG, ""Sending new process state "" + app.getReportedProcState()
                                + "" to "" + app /*, h*/);
                    }
                    app.thread.setProcessState(app.getReportedProcState());
                } catch (RemoteException e) {
                }
            }
        }
        if (app.setProcState == PROCESS_STATE_NONEXISTENT
                || ProcessList.procStatesDifferForMem(app.getCurProcState(), app.setProcState)) {
            if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now-200)) {
                // Experimental code to more aggressively collect pss while
                // running test...  the problem is that this tends to collect
                // the data right when a process is transitioning between process
                // states, which will tend to give noisy data.
                long start = SystemClock.uptimeMillis();
                long startTime = SystemClock.currentThreadTimeMillis();
                long pss = Debug.getPss(app.pid, mTmpLong, null);
                long endTime = SystemClock.currentThreadTimeMillis();
                recordPssSampleLocked(app, app.getCurProcState(), pss, mTmpLong[0], mTmpLong[1],
                        mTmpLong[2], ProcessStats.ADD_PSS_INTERNAL_SINGLE, endTime-startTime, now);
                mPendingPssProcesses.remove(app);
                Slog.i(TAG, ""Recorded pss for "" + app + "" state "" + app.setProcState
                        + "" to "" + app.getCurProcState() + "": ""
                        + (SystemClock.uptimeMillis()-start) + ""ms"");
            }
            app.lastStateTime = now;
            app.nextPssTime = ProcessList.computeNextPssTime(app.getCurProcState(),
                    app.procStateMemTracker, mTestPssMode, mAtmInternal.isSleeping(), now);
            if (DEBUG_PSS) Slog.d(TAG_PSS, ""Process state change from ""
                    + ProcessList.makeProcStateString(app.setProcState) + "" to ""
                    + ProcessList.makeProcStateString(app.getCurProcState()) + "" next pss in ""
                    + (app.nextPssTime-now) + "": "" + app);
        } else {
            if (now > app.nextPssTime || (now > (app.lastPssTime+ProcessList.PSS_MAX_INTERVAL)
                    && now > (app.lastStateTime+ProcessList.minTimeFromStateChange(
                    mTestPssMode)))) {
                if (requestPssLocked(app, app.setProcState)) {
                    app.nextPssTime = ProcessList.computeNextPssTime(app.getCurProcState(),
                            app.procStateMemTracker, mTestPssMode, mAtmInternal.isSleeping(), now);
                }
            } else if (false && DEBUG_PSS) Slog.d(TAG_PSS,
                    ""Not requesting pss of "" + app + "": next="" + (app.nextPssTime-now));
        }
        if (app.setProcState != app.getCurProcState()) {
            if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.uid) {
                String msg = ""Proc state change of "" + app.processName
                        + "" to "" + ProcessList.makeProcStateString(app.getCurProcState())
                        + "" ("" + app.getCurProcState() + "")"" + "": "" + app.adjType;
                reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
            }
            boolean setImportant = app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
            boolean curImportant = app.getCurProcState() < ActivityManager.PROCESS_STATE_SERVICE;
            if (setImportant && !curImportant) {
                // This app is no longer something we consider important enough to allow to use
                // arbitrary amounts of battery power. Note its current CPU time to later know to
                // kill it if it is not behaving well.
                app.setWhenUnimportant(now);
                app.lastCpuTime = 0;
            }
            // Inform UsageStats of important process state change
            // Must be called before updating setProcState
            maybeUpdateUsageStatsLocked(app, nowElapsed);

            maybeUpdateLastTopTime(app, now);

            app.setProcState = app.getCurProcState();
            if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
                app.notCachedSinceIdle = false;
            }
            if (!doingAll) {
                setProcessTrackerStateLocked(app, mProcessStats.getMemFactorLocked(), now);
            } else {
                app.procStateChanged = true;
            }
        } else if (app.reportedInteraction && (nowElapsed - app.getInteractionEventTime())
                > mConstants.USAGE_STATS_INTERACTION_INTERVAL) {
            // For apps that sit around for a long time in the interactive state, we need
            // to report this at least once a day so they don't go idle.
            maybeUpdateUsageStatsLocked(app, nowElapsed);
        }

        if (changes != 0) {
            if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                    ""Changes in "" + app + "": "" + changes);
            int i = mPendingProcessChanges.size()-1;
            ProcessChangeItem item = null;
            while (i >= 0) {
                item = mPendingProcessChanges.get(i);
                if (item.pid == app.pid) {
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""Re-using existing item: "" + item);
                    break;
                }
                i--;
            }
            if (i < 0) {
                // No existing item in pending changes; need a new one.
                final int NA = mAvailProcessChanges.size();
                if (NA > 0) {
                    item = mAvailProcessChanges.remove(NA-1);
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""Retrieving available item: "" + item);
                } else {
                    item = new ProcessChangeItem();
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""Allocating new item: "" + item);
                }
                item.changes = 0;
                item.pid = app.pid;
                item.uid = app.info.uid;
                if (mPendingProcessChanges.size() == 0) {
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""*** Enqueueing dispatch processes changed!"");
                    mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED_UI_MSG).sendToTarget();
                }
                mPendingProcessChanges.add(item);
            }
            item.changes |= changes;
            item.foregroundActivities = app.repForegroundActivities;
            if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                    ""Item "" + Integer.toHexString(System.identityHashCode(item))
                    + "" "" + app.toShortString() + "": changes="" + item.changes
                    + "" foreground="" + item.foregroundActivities
                    + "" type="" + app.adjType + "" source="" + app.adjSource
                    + "" target="" + app.adjTarget);
        }

        return success;
    }

"
522,services/core/java/com/android/server/am/ActivityManagerService.java,['59a28bc92ad55fd0c19ce28047f205978aed52ca'],1,"    public final void networkOptsCheck(int flag, String packageName) {
        mHandler.sendMessage(mHandler.obtainMessage(NETWORK_OPTS_CHECK_MSG, flag, 0, packageName));
"
523,services/core/java/com/android/server/am/ActivityManagerService.java,['ba167de93776a7e5d1b347d1ee646e161cf24ce5'],1,"    static ServiceThread sKillThread = null;
    static KillHandler sKillHandler = null;
    static final ActivityTrigger mActivityTrigger = new ActivityTrigger();

"
524,services/core/java/com/android/server/am/ActivityManagerService.java,['1581c348fc5d6cbf1673b3dbc5960637f891d488'],1,"import android.metrics.LogMaker;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
"
525,services/core/java/com/android/server/am/ActivityManagerService.java,['4f3815fffae8119b8607fe1e7ec8f00b095962ea'],1,"import android.util.BoostFramework;

"
526,services/core/java/com/android/server/am/ActivityManagerService.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"import android.view.autofill.AutofillManagerInternal;

"
527,services/core/java/com/android/server/am/ActivityManagerService.java,"['2775a5a9b030266a910301e8b464811acafcd5fa', 'e85435d4d9a2f7122bd5c97ad0a25c768d124a0e']",2,"import com.android.internal.app.ActivityTrigger;
"
528,services/core/java/com/android/server/am/ActivityManagerService.java,['1581c348fc5d6cbf1673b3dbc5960637f891d488'],1,"import com.android.internal.app.ActivityTrigger;
import com.android.internal.logging.MetricsLogger;
import com.android.internal.logging.nano.MetricsProto.MetricsEvent;
"
529,services/core/java/com/android/server/am/ActivityManagerService.java,['88b45c586d461df38b866d529bc98d1dfa3e8838'],1,"import static android.os.Process.setProcessGroup;
import static android.os.Process.setCgroupProcsProcessGroup;
"
530,services/core/java/com/android/server/am/CachedAppOptimizer.java,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']",2,"        Process.setThreadGroupAndCpuset(mCachedAppOptimizerThread.getThreadId(),
                Process.THREAD_GROUP_SYSTEM);
        setAppCompactProperties();
    }

    private void setAppCompactProperties() {
        boolean useCompaction =
                    Boolean.valueOf(mPerf.perfGetProp(""vendor.appcompact.enable_app_compact"",
                        ""false""));
        int someCompactionType =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.some_compact_type"",
                        String.valueOf(COMPACT_ACTION_ANON_FLAG)));
        int fullCompactionType =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.full_compact_type"",
                        String.valueOf(COMPACT_ACTION_ANON_FLAG)));
        int compactThrottleSomeSome =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_somesome"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_1)));
        int compactThrottleSomeFull =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_somefull"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_2)));
        int compactThrottleFullSome =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_fullsome"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_3)));
        int compactThrottleFullFull =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_fullfull"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_4)));
        int compactThrottleBfgs =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_bfgs"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_5)));
        int compactThrottlePersistent =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_persistent"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_6)));
        int fullRssThrottleKB =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.rss_throttle_kb"",
                        String.valueOf(DEFAULT_COMPACT_FULL_RSS_THROTTLE_KB)));
        int deltaRssThrottleKB =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.delta_rss_throttle_kb"",
                        String.valueOf(DEFAULT_COMPACT_FULL_DELTA_RSS_THROTTLE_KB)));

        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_ACTION_1,
                        String.valueOf(someCompactionType), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_ACTION_2,
                        String.valueOf(fullCompactionType), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_1,
                        String.valueOf(compactThrottleSomeSome), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_2,
                        String.valueOf(compactThrottleSomeFull), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_3,
                        String.valueOf(compactThrottleFullSome), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_4,
                        String.valueOf(compactThrottleFullFull), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_5,
                        String.valueOf(compactThrottleBfgs), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_6,
                        String.valueOf(compactThrottlePersistent), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_FULL_RSS_THROTTLE_KB,
                        String.valueOf(fullRssThrottleKB), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_FULL_DELTA_RSS_THROTTLE_KB,
                        String.valueOf(deltaRssThrottleKB), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_USE_COMPACTION,
                        String.valueOf(useCompaction), true);
"
531,services/core/java/com/android/server/am/CachedAppOptimizer.java,['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c'],1,"    @VisibleForTesting static Boolean DEFAULT_USE_COMPACTION = false;
"
532,services/core/java/com/android/server/am/CachedAppOptimizer.java,['a9736185db896fe2edde0281d71102b35327b7f8'],1,"    public static BoostFramework mPerf = new BoostFramework();

    public CachedAppOptimizer(ActivityManagerService am) {
        mAm = am;
        mCachedAppOptimizerThread = new ServiceThread(""CachedAppOptimizerThread"",
                THREAD_PRIORITY_FOREGROUND, true);
        mProcStateThrottle = new HashSet<>();
        isLowRAM = SystemProperties.getBoolean(""ro.config.low_ram"", false);

        if (isLowRAM == true)
            DEFAULT_USE_COMPACTION = true;
"
533,services/core/java/com/android/server/am/OomAdjuster.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"        if ((numBServices > mBServiceAppThreshold) && (true == mService.mAllowLowerMemLevel)
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }

        mService.incrementProcStateSeqAndNotifyAppsLocked();

        mNumServiceProcs = mNewNumServiceProcs;

        boolean allChanged = mService.updateLowMemStateLocked(numCached, numEmpty, numTrimming);
"
534,services/core/java/com/android/server/am/OomAdjuster.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"        if(mPerf != null) {
            mMinBServiceAgingTime = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bservice_age"", ""5000""));
            mBServiceAppThreshold = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bservice_limit"", ""5""));
            mEnableBServicePropagation = Boolean.parseBoolean(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bservice_enable"", ""false""));
        }

        // The process group is usually critical to the response time of foreground app, so the
        // setter should apply it as soon as possible.
        final ServiceThread adjusterThread = new ServiceThread(TAG, TOP_APP_PRIORITY_BOOST,
                false /* allowIo */);
        adjusterThread.start();
        Process.setThreadGroupAndCpuset(adjusterThread.getThreadId(), THREAD_GROUP_TOP_APP);
"
535,services/core/java/com/android/server/am/OomAdjuster.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"        mNumNonCachedProcs = 0;
        mNumCachedHiddenProcs = 0;

        // First update the OOM adjustment for each of the
        // application processes based on their current state.
        int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;
        int nextCachedAdj = curCachedAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        int curCachedImpAdj = 0;
        int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ + ProcessList.CACHED_APP_IMPORTANCE_LEVELS;
        int nextEmptyAdj = curEmptyAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        ProcessRecord selectedAppRecord = null;
        long serviceLastActivity = 0;
        int numBServices = 0;

        boolean retryCycles = false;

        // need to reset cycle state before calling computeOomAdjLocked because of service conns
        for (int i = N - 1; i >= 0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            app.containsCycle = false;
            app.setCurRawProcState(PROCESS_STATE_CACHED_EMPTY);
            app.setCurRawAdj(ProcessList.UNKNOWN_ADJ);
        }
        for (int i = N - 1; i >= 0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            if (mEnableBServicePropagation && app.serviceb
                    && (app.curAdj == ProcessList.SERVICE_B_ADJ)) {
                numBServices++;
                for (int s = app.services.size() - 1; s >= 0; s--) {
                    ServiceRecord sr = app.services.valueAt(s);
                    if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + app.processName
                            + "" serviceb = "" + app.serviceb + "" s = "" + s + "" sr.lastActivity = ""
                            + sr.lastActivity + "" packageName = "" + sr.packageName
                            + "" processName = "" + sr.processName);
                    if (SystemClock.uptimeMillis() - sr.lastActivity
                            < mMinBServiceAgingTime) {
                        if (DEBUG_OOM_ADJ) {
                            Slog.d(TAG,""Not aged enough!!!"");
                        }
                        continue;
                    }
                    if (serviceLastActivity == 0) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    } else if (sr.lastActivity < serviceLastActivity) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    }
                }
            }
            if (DEBUG_OOM_ADJ && selectedAppRecord != null) Slog.d(TAG,
                    ""Identified app.processName = "" + selectedAppRecord.processName
                    + "" app.pid = "" + selectedAppRecord.pid);

            if (!app.killedByAm && app.thread != null) {
                app.procStateChanged = false;
                computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now, false);

                // if any app encountered a cycle, we need to perform an additional loop later
                retryCycles |= app.containsCycle;

                // If we haven't yet assigned the final cached adj
                // to the process, do that now.
                if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
                    switch (app.getCurProcState()) {
                        case PROCESS_STATE_CACHED_ACTIVITY:
                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                        case ActivityManager.PROCESS_STATE_CACHED_RECENT:
                            // Figure out the next cached level, taking into account groups.
                            boolean inGroup = false;
                            if (app.connectionGroup != 0) {
                                if (lastCachedGroupUid == app.uid
                                        && lastCachedGroup == app.connectionGroup) {
                                    // This is in the same group as the last process, just tweak
                                    // adjustment by importance.
                                    if (app.connectionImportance > lastCachedGroupImportance) {
                                        lastCachedGroupImportance = app.connectionImportance;
                                        if (curCachedAdj < nextCachedAdj
                                                && curCachedAdj < ProcessList.CACHED_APP_MAX_ADJ) {
                                            curCachedImpAdj++;
                                        }
                                    }
                                    inGroup = true;
                                } else {
                                    lastCachedGroupUid = app.uid;
                                    lastCachedGroup = app.connectionGroup;
"
536,services/core/java/com/android/server/am/OomAdjuster.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    // Min aging threshold in milliseconds to consider a B-service
    int mMinBServiceAgingTime = 5000;
    // Threshold for B-services when in memory pressure
    int mBServiceAppThreshold = 5;
    // Enable B-service aging propagation on memory pressure.
    boolean mEnableBServicePropagation = false;

    public static BoostFramework mPerf = new BoostFramework();
"
537,services/core/java/com/android/server/am/OomAdjuster.java,"['337095f9d277c566cb888bc3adbac16576f1ae70', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']",2,")
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }

        m"
538,services/core/java/com/android/server/am/ProcessList.java,"['337095f9d277c566cb888bc3adbac16576f1ae70', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,"    /**
     * BoostFramework Object
     */
    public static BoostFramework mPerfServiceStartHint = new BoostFramework();
"
539,services/core/java/com/android/server/am/ProcessList.java,['6f47ceafbe6febe54aa5c376baed3415cdf848ad'],1,"    interface LmkdKillListener {
        /**
         * Called when there is a process kill by lmkd.
         */
        void onLmkdKillOccurred(int pid, int uid);
    }

    /**
     * BoostFramework Object
     */
    public static BoostFramework mPerfServiceStartHint = new BoostFramework();
"
540,services/core/java/com/android/server/am/ProcessList.java,"['337095f9d277c566cb888bc3adbac16576f1ae70', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']",2,"import android.util.BoostFramework;
"
541,services/core/java/com/android/server/am/ProcessList.java,['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c'],1,"import android.util.StatsLog;
import android.util.BoostFramework;
"
542,services/core/java/com/android/server/am/ProcessRecord.java,['df73284a33506ba26aadbd20a1dbd01353820200'],1,"        String[] nativeProc = null;
        if (isSilentAnr()) {
"
543,services/core/java/com/android/server/am/ProcessRecord.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"import com.android.server.LocalServices;
import com.android.server.Watchdog;
import com.android.server.wm.WindowManagerInternal;
"
544,services/core/java/com/android/server/am/ProcessRecord.java,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c', '8faa0d981413f18b2468dde1b1fe71e248df0df1']",3,"import com.android.server.Watchdog;
"
545,services/core/java/com/android/server/audio/AudioDeviceBroker.java,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']",3,"                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
"
546,services/core/java/com/android/server/audio/AudioDeviceBroker.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"                } break;
                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
"
547,services/core/java/com/android/server/audio/AudioDeviceBroker.java,['ddc3dc79034f4570388245270b50ddad964c11f0'],1,"            case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT:
"
548,services/core/java/com/android/server/audio/AudioDeviceBroker.java,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",2,"            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isBluetoothScoOnForApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
"
549,services/core/java/com/android/server/audio/AudioDeviceBroker.java,"['449f659b21d039b8692602294b040038ac1e6ccb', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",3,"            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
"
550,services/core/java/com/android/server/audio/AudioDeviceBroker.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In setBluetoothScoOnByApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
"
551,services/core/java/com/android/server/audio/AudioDeviceBroker.java,['bb9ded46832af38a453b78b92ad2de32ef1cf845'],1,"            mForcedUseForCommExt = mForcedUseForComm;
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In setSpeakerphoneOn(), mForcedUseForCommExt: "" + mForcedUseForCommExt);
            }
            setForceUse_Async(AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, eventSource);
            return (wasOn != isSpeakerphoneOn());
"
552,services/core/java/com/android/server/audio/AudioDeviceBroker.java,"['24f36fd2514856aaafe6a32a99050e272a6bd361', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",3,"        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
"
553,services/core/java/com/android/server/audio/AudioDeviceBroker.java,"['24f36fd2514856aaafe6a32a99050e272a6bd361', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",2,"        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
        "
554,services/core/java/com/android/server/audio/AudioDeviceBroker.java,['24f36fd2514856aaafe6a32a99050e272a6bd361'],1,"        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
        //Log.i(TAG, ""setBluetoothScoOnInt: "" + on + "" "" + eventSource);
"
555,services/core/java/com/android/server/audio/AudioDeviceBroker.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
        synchronized (mDeviceStateLock) {
"
556,services/core/java/com/android/server/audio/AudioDeviceBroker.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"        synchronized (mDeviceStateLock) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In is"
557,services/core/java/com/android/server/audio/AudioDeviceBroker.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"        synchronized (mDeviceStateLock) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isBluetoothScoOnForApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
"
558,services/core/java/com/android/server/audio/AudioDeviceBroker.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"        synchronized (mDeviceStateLock) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
"
559,services/core/java/com/android/server/audio/AudioDeviceBroker.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"        synchronized (mDeviceStateLock) {
            if (on)
                mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
            else if (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO)
                mForcedUseForCommExt = AudioSystem.FORCE_NONE;
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In setBluetoothScoOnByApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
"
560,services/core/java/com/android/server/audio/AudioDeviceBroker.java,"['7fd6edc3a3ff37a750641d5e192835fe217f6050', 'dfd2f7fed77160af2c57edfa20f1768b42aaa8da']",2,"    // process external command to (dis)connect or change active A2DP device
    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = "
561,services/core/java/com/android/server/audio/AudioDeviceBroker.java,['dfd2f7fed77160af2c57edfa20f1768b42aaa8da'],1,"    // process external command to (dis)connect or change active A2DP device
    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = 32;
"
562,services/core/java/com/android/server/audio/AudioDeviceBroker.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4']",2,"    private static final int MSG_L_HEARING_AID_DEVICE_CONNECTION_CHANGE_EXT = 28;
    // process external command to (dis)connect or change active A2DP device
    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = 29;
    // a ScoClient died in BtHelper
    private static final int MSG_L_SCOCLIENT_DIED = 30;
"
563,services/core/java/com/android/server/audio/AudioDeviceBroker.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"    private static final int MSG_L_SCOCLIENT_DIED = 33;
"
564,services/core/java/com/android/server/audio/AudioDeviceBroker.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    }

    /*package*/ void postBluetoothA2dpDeviceConfigChangeExt(
            @NonNull BluetoothDevice device,
            @AudioService.BtProfileConnectionState int state, int profile,
            boolean suppressNoisyIntent, int a2dpVolume) {
         final BtDeviceConnectionInfo info = new BtDeviceConnectionInfo(device, state, profile,
                 suppressNoisyIntent, a2dpVolume);
         sendLMsgNoDelay(MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT, SENDMSG_QUEUE, info);
"
565,services/core/java/com/android/server/audio/AudioDeviceBroker.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"App(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
"
566,services/core/java/com/android/server/audio/AudioDeviceInventory.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4', '26017c68ee11d3f2d54ca731119c8dc4ddb842cf']",3,"            delay = SystemProperties.getInt(""audio.sys.noisy.broadcast.delay"", 700);
"
567,services/core/java/com/android/server/audio/AudioDeviceInventory.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"        final int res = AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
                                AudioSystem.DEVICE_STATE_AVAILABLE, address, name, a2dpCodec);
        if (res != AudioSystem.AUDIO_STATUS_OK) {
            Slog.e(TAG, ""not connecting device 0x""
                    + Integer.toHexString(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)
                    + "" due to command error "" + res);
            return;
        }
        mConnectedDevices.put(
                DeviceInfo.makeDeviceListKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, address),
                new DeviceInfo(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, name,
                        address, a2dpCodec));
"
568,services/core/java/com/android/server/audio/AudioService.java,['b0fb644c3eaa60930300e3689e6652de7c21d4f7'],1,"
        Slog.i(TAG, ""handleBtScoActiveDeviceChange: isActive "" + isActive +
             "" outDevice "" + outDevice + "" address "" + address + "" btDevicename "" + btDeviceName);

        boolean result = handleDeviceConnection(isActive, outDevice, address, btDeviceName);
        Slog.i(TAG, ""for outDevice "" + outDevice + "" result is "" + result);

        /* When BT process is killed, getting device class may fail during cleanup.
         * This results in outDevice assigned to DEVICE_OUT_BLUETOOTH_SCO. If
         * outDevice was added as different device than DEVICE_OUT_BLUETOOTH_SCO
         * during connection, removal will fail during disconnection. Attempt to
         * remove outDevice with other possible SCO devices.
         */
        if (isActive == false && result == false) {
           outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
           Slog.w(TAG, ""handleBtScoActiveDeviceChange: retrying with outDevice "" + outDevice);

           result = handleDeviceConnection(isActive, outDevice, address, btDeviceName);

           Slog.w(TAG, ""for outDevice ""+ outDevice + "" result is "" + result);
        }

        if (isActive == false && result == false) {
           outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
           Slog.w(TAG, ""handleBtScoActiveDeviceChange: retrying with outDevice "" + outDevice);

           result = handleDeviceConnection(isActive, outDevice, address, btDeviceName);

           Slog.w(TAG, ""for outDevice ""+ outDevice + "" result is "" + result);
        }

"
569,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"                    boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED,
                                                        0);
                }
            }
        }

        public void clearCount(boolean stopSco) {
            synchronized(mScoClients) {
                Log.i(TAG, ""In clearCount(), stopSco: "" + stopSco +
                            "", mStartcount: "" + mStartcount);
                if (mStartcount != 0) {
                    try {
                        mCb.unlinkToDeath(this, 0);
                    } catch (NoSuchElementException e) {
                        Log.w(TAG, ""clearCount() mStartcount: ""+mStartcount+"" != 0 but not registered to binder"");
                    }
                }
                mStartcount = 0;
                if (stopSco) {
                    boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED,
                                                        0);
"
570,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"                    break;

                case MSG_BTA2DP_DOCK_TIMEOUT:
                    // msg.obj  == address of BTA2DP device
                    synchronized (mConnectedDevices) {
                        makeA2dpDeviceUnavailableNow((String) msg.obj, msg.arg1);
                    }
                    mAudioEventWakeLock.release();
                    break;

                case MSG_SET_FORCE_USE:
                case MSG_SET_FORCE_BT_A2DP_USE:
                    setForceUse(msg.arg1, msg.arg2, (String) msg.obj);
                    break;

                case MSG_BT_HEADSET_CNCT_FAILED:
                    Log.i(TAG, ""In handleMessage(), calling resetBluetoothSco()"");
                    resetBluetoothSco();
                    break;

                case MSG_SET_WIRED_DEVICE_CONNECTION_STATE:
                    {   WiredDeviceConnectionState connectState =
                            (WiredDeviceConnectionState)msg.obj;
                        mDeviceLogger.log(new WiredDevConnectEvent(connectState));
                        onSetWiredDeviceConnectionState(connectState.mType, connectState.mState,
                                connectState.mAddress, connectState.mName, connectState.mCaller);
                        mAudioEventWakeLock.release();
                    }
                    break;

                case MSG_SET_A2DP_SRC_CONNECTION_STATE:
                    onSetA2dpSourceConnectionState((BluetoothA2dpDeviceInfo) msg.obj, msg.arg1);
                    mAudioEventWakeLock.release();
                    break;

                case MSG_SET_A2DP_SINK_CONNECTION_STATE:
                    onSetA2dpSinkConnectionState((BluetoothA2dpDeviceInfo) msg.obj, msg.arg1);
                    mAudioEventWakeLock.release();
                    break;

                case MSG_SET_HEARING_AID_CONNECTION_STATE:
                    onSetHearingAidConnectionState((BluetoothDevice)msg.obj, msg.arg1);
                    mAudioEventWakeLock.release();
                    break;

                case MSG_A2DP_DEVICE_CONFIG_CHANGE:
                    onBluetoothA2dpDeviceConfigChange((BluetoothA2dpDeviceInfo) msg.obj);
                    mAudioEventWakeLock.release();
"
571,services/core/java/com/android/server/audio/AudioService.java,['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0'],1,"                .append("") from u/pid:"").append(Binder.getCallingUid()).append(""/"")
                .append(Binder.getCallingPid()).toString();
        Log.i(TAG, ""In set"
572,services/core/java/com/android/server/audio/AudioService.java,['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0'],1,"                .append("") from u/pid:"").append(Binder.getCallingUid()).append(""/"")
                .append(Binder.getCallingPid()).toString();
        Log.i(TAG, ""In setBluetoothScoOn(), eventSource: "" + eventSource);
"
573,services/core/java/com/android/server/audio/AudioService.java,['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0'],1,"                .append("") from u/pid:"").append(Binder.getCallingUid()).append(""/"")
                .append(Binder.getCallingPid()).toString();
        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

"
574,services/core/java/com/android/server/audio/AudioService.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
"
575,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"                final long ident = Binder.clearCallingIdentity();
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                disconnectBluetoothSco(newModeOwnerPid);
                Binder.restoreCallingIdentity(ident);
"
576,services/core/java/com/android/server/audio/AudioService.java,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']",2,"            Log.i(TAG, ""In binderDied(), calling setModeOwnerPid()"");
            mDeviceBroker.postSetModeOwnerPid(newModeOwnerPid);
"
577,services/core/java/com/android/server/audio/AudioService.java,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '1581c348fc5d6cbf1673b3dbc5960637f891d488']",2,"            Log.i(TAG, ""In setBluetoothScoOn(), on: ""+on+"". The calling application Uid: ""
                  + Binder.getCallingUid() + "", is greater than FIRST_APPLICATION_UID""
                  + "" exiting from setBluetoothScoOn()"");
            if (on)
                mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
            else if (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO)
                mForcedUseForCommExt = AudioSystem.FORCE_NONE;
            Log.i(TAG, ""In setbluetoothScoOn(), mForcedUseForCommExt: ""
                        + mForcedUseForCommExt);
"
578,services/core/java/com/android/server/audio/AudioService.java,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']",2,"            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
"
579,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
            disconnectBluetoothSco(newModeOwnerPid);
"
580,services/core/java/com/android/server/audio/AudioService.java,['a9736185db896fe2edde0281d71102b35327b7f8'],1,"            String callingPackage, String caller, int uid) {
        if (DEBUG_VOL) Log.d(TAG, ""adjustStreamVolume() stream="" + streamType + "", dir="" + direction
                + "", flags="" + flags + "", caller="" + caller);

        /* If MirrorLink audio is playing, then disable volume changes */
        String value = SystemProperties.get(""vendor.mls.audio.session.status"", ""default"");
        if (true == value.equals(""started"")){
            Log.e(TAG, ""adjustStreamVolume() Ignore volume change during MirrorLink session"");
            return;
        }

"
581,services/core/java/com/android/server/audio/AudioService.java,"['bb9ded46832af38a453b78b92ad2de32ef1cf845', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",2,"            if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
"
582,services/core/java/com/android/server/audio/AudioService.java,['bb9ded46832af38a453b78b92ad2de32ef1cf845'],1,"            if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
            }
"
583,services/core/java/com/android/server/audio/AudioService.java,['2e25c298c5c5a069e5525397e99952d4d7f01b8b'],1,"            if (DEBUG_VOL) Log.d(TAG, ""adjustSuggestedStreamVolume() stream="" + suggestedStreamType
                    + "", flags="" + flags + "", caller="" + caller
                    + "", volControlStream="" + mVolumeControlStream
                    + "", userSelect="" + mUserSelectedVolumeControlStream);
"
584,services/core/java/com/android/server/audio/AudioService.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"            }
            // when entering RINGTONE, IN_CALL or IN_COMMUNICATION mode, clear all
            // SCO connections not started by the application changing the mode when pid changes
            if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
"
585,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"            } else if (action.equals(BluetoothHeadset.ACTION_ACTIVE_DEVICE_CHANGED)) {
                BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                Log.i(TAG, ""In onReceive(), calling setBtScoActiveDevice() with ""
                      + ""btDevice: "" + btDevice);
                setBtScoActiveDevice(btDevice);
            } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
                boolean broadcast = false;
                int scoAudioState = AudioManager.SCO_AUDIO_STATE_ERROR;
                synchronized (mScoClients) {
                    int btState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
                    // broadcast intent if the connection was initated by AudioService
                    if (!mScoClients.isEmpty() &&
                            (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL ||
                             mScoAudioState == SCO_STATE_ACTIVATE_REQ ||
                             mScoAudioState == SCO_STATE_DEACTIVATE_REQ ||
                             mScoAudioState == SCO_STATE_DEACTIVATING)) {
                        broadcast = true;
                    }
                    switch (btState) {
                        case BluetoothHeadset.STATE_AUDIO_CONNECTED:
                            if (checkAndUpdatTwsPlusScoState(intent,
                                    BluetoothHeadset.STATE_AUDIO_CONNECTED)) {
                                scoAudioState = AudioManager.SCO_AUDIO_STATE_CONNECTED;
                                if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL &&
                                    mScoAudioState != SCO_STATE_DEACTIVATE_REQ) {
                                    mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                                }
                                setBluetoothScoOn(true);
                                Log.i(TAG, ""Audio-path brought-up"");
                            }
                            break;
                        case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
                            if (checkAndUpdatTwsPlusScoState(intent,
                                   BluetoothHeadset.STATE_AUDIO_DISCONNECTED)) {
                                setBluetoothScoOn(false);
                                scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                                // startBluetoothSco called after stopBluetoothSco
                                if (mScoAudioState == SCO_STATE_ACTIVATE_REQ) {
                                    if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null
                                            && connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                            mBluetoothHeadsetDevice, mScoAudioMode)) {
                                        mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                                        broadcast = false;
                                        break;
                                    }
                                }
                                // Tear down SCO if disconnected from external
                                clearAllScoClients(0, mScoAudioState == SCO_STATE_ACTIVE_INTERNAL);
                                mScoAudioState = SCO_STATE_INACTIVE;
                                Log.i(TAG, ""Audio-path brought-down"");
                            }
                            break;
                        case BluetoothHeadset.STATE_AUDIO_CONNECTING:
                            if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL &&
                                mScoAudioState != SCO_STATE_DEACTIVATE_REQ) {
                                mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                            }
                        default:
                            // do not broadcast CONNECTING or invalid state
                            broadcast = false;
                            break;
                    }
                }
                Log.i(TAG, ""In onReceive(), mScoAudioState: "" + mScoAudioState
                      + "", broadcast: "" + broadcast);
                if (broadcast) {
                    broadcastScoConnectionState(scoAudioState);
                    //FIXME: this is to maintain compatibility with deprecated intent
                    // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
                    Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
                    newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, scoAudioState);
                    sendStickyBroadcastToAll(newIntent);
                }
"
586,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"        Log.i(TAG, ""In isBluetoothScoOn(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        return (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO);
"
587,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"        Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        return (mForcedUseForCommExt == AudioSystem.FORCE_SPEAKER);
"
588,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"        Log.i(TAG, ""In setBluetoothScoOn(), eventSource: "" + eventSource);
        setBluetoothScoOnInt(on, eventSource);
    }

    private boolean isBluetoothAudioNotConnectedToEarbud() {
       //default value as true so that
       //non-twsplus device case returns true
       boolean ret = true;
       if (mBluetoothHeadsetDevice != null
              && mBluetoothHeadsetDevice.isTwsPlusDevice()) {
           //If It is TWSplus Device, check for TWS pair device
           //Sco state
           String pDevAddr = mBluetoothHeadsetDevice.getTwsPlusPeerAddress();
           if (pDevAddr != null) {
               BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
               BluetoothDevice peerDev = adapter.getRemoteDevice(pDevAddr);
               Log.d(TAG, ""peer device audio State: "" + mBluetoothHeadset.getAudioState(peerDev));
               if (mBluetoothHeadset.getAudioState(peerDev)
                     == BluetoothHeadset.STATE_AUDIO_CONNECTED ||
                     mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice)
                       == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                           Log.w(TAG, ""TwsPLus Case: one of eb SCO is connected"");
                   ret = false;
               }
           }
       }
       Log.d(TAG, ""isBluetoothAudioConnectedToEarbud returns: "" + ret);
       return ret;
    }

    public void setBluetoothScoOnInt(boolean on, String eventSource) {
        Log.i(TAG, ""setBluetoothScoOnInt: "" + on + "" "" + eventSource);
        if (on) {
            // do not accept SCO ON if SCO audio is not connected
            synchronized (mScoClients) {
                if ((mBluetoothHeadset != null)
                        && (mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice)
                            != BluetoothHeadset.STATE_AUDIO_CONNECTED)) {
                    if (isBluetoothAudioNotConnectedToEarbud()) {
                        mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
                        Log.w(TAG, ""setBluetoothScoOnInt(true) failed because ""
                                + mBluetoothHeadsetDevice + "" is not in audio connected mode"");
                        return;
                    }
                }
            }
            mForcedUseForComm = AudioSystem.FORCE_BT_SCO;
        } else if (mForcedUseForComm == AudioSystem.FORCE_BT_SCO) {
            mForcedUseForComm = AudioSystem.FORCE_NONE;
        }
        mForcedUseForCommExt = mForcedUseForComm;
        Log.i(TAG, ""In setbluetoothScoOnInt(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        AudioSystem.setParameters(""BT_SCO=""+ (on ? ""on"" : ""off""));
        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, eventSource, 0);
        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                AudioSystem.FOR_RECORD, mForcedUseForComm, eventSource, 0);
        // Un-mute ringtone stream volume
        setRingerModeInt(getRingerModeInternal(), false);
"
589,services/core/java/com/android/server/audio/AudioService.java,"['2775a5a9b030266a910301e8b464811acafcd5fa', 'bb9ded46832af38a453b78b92ad2de32ef1cf845', '449f659b21d039b8692602294b040038ac1e6ccb']",3,"        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        "
590,services/core/java/com/android/server/audio/AudioService.java,"['449f659b21d039b8692602294b040038ac1e6ccb', 'bb9ded46832af38a453b78b92ad2de32ef1cf845']",2,"        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        final boolean stateChanged = mDeviceBroker.setSpeakerphoneOn("
591,services/core/java/com/android/server/audio/AudioService.java,['bb9ded46832af38a453b78b92ad2de32ef1cf845'],1,"        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        final boolean stateChanged = mDeviceBroker.setSpeakerphoneOn(on, eventSource);
"
592,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        if (on) {
            if (mForcedUseForComm == AudioSystem.FORCE_BT_SCO) {
                    sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                            AudioSystem.FOR_RECORD, AudioSystem.FORCE_NONE,
                            eventSource, 0);
            }
            mForcedUseForComm = AudioSystem.FORCE_SPEAKER;
        } else if (mForcedUseForComm == AudioSystem.FORCE_SPEAKER){
            mForcedUseForComm = AudioSystem.FORCE_NONE;
        }

        mForcedUseForCommExt = mForcedUseForComm;
        Log.i(TAG, ""In setSpeakerphoneOn(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, eventSource, 0);
"
593,services/core/java/com/android/server/audio/AudioService.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        mDeviceBroker.setSpeakerphoneOn(on, eventSource);
"
594,services/core/java/com/android/server/audio/AudioService.java,"['3e8cb98421761bb7dfafe59a22a15fe2e176f272', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']",3,"        Log.i(TAG, ""In startBluetoothSco"
595,services/core/java/com/android/server/audio/AudioService.java,"['3e8cb98421761bb7dfafe59a22a15fe2e176f272', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']",2,"        Log.i(TAG, ""In startBluetoothSco()"");
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if ((adapter == null) || (adapter.getState() != BluetoothAdapter.STATE_ON)) {
             Log.i(TAG, ""startBluetoothSco(), BT is not turned ON or adapter is null"");
             return;
        }
"
596,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"        Log.i(TAG, ""In startBluetoothSco()"");
        int scoAudioMode =
"
597,services/core/java/com/android/server/audio/AudioService.java,['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0'],1,"        Log.i(TAG, ""In startBluetoothScoInt(), scoAudioMode: "" + scoAudioMode);
"
598,services/core/java/com/android/server/audio/AudioService.java,"['3e8cb98421761bb7dfafe59a22a15fe2e176f272', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']",2,"        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
"
599,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
        startBluetoothScoInt(cb, SCO_MODE_VIRTUAL_CALL);
    }

    void startBluetoothScoInt(IBinder cb, int scoAudioMode){
        Log.i(TAG, ""In startBluetoothScoInt(), scoAudioMode: "" + scoAudioMode);
"
600,services/core/java/com/android/server/audio/AudioService.java,"['24818fca475a6726f5ef0cae42149615079af6e9', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",4,"        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
"
601,services/core/java/com/android/server/audio/AudioService.java,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",2,"        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
        if (DEBUG_MODE) { Log.v(TAG, ""setMode(mode="" + mode + "", callingPackage="" + callingPackage + "")""); }
"
602,services/core/java/com/android/server/audio/AudioService.java,['1581c348fc5d6cbf1673b3dbc5960637f891d488'],1,"        if (Binder.getCallingUid() >= FIRST_APPLICATION_UID) {
            Log.i(TAG, ""In setBluetoothScoOn(), on: ""+on+"". The calling application Uid: ""
                  + Binder.getCallingUid() + "", is greater than FIRST_APPLICATION_UID""
                  + "" exiting from setBluetoothScoOn()"");
            if (on)
                mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
            else if (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO)
                mForcedUseForCommExt = AudioSystem.FORCE_NONE;
            Log.i(TAG, ""In setbluetoothScoOn(), mForcedUseForCommExt: ""
                        + mForcedUseForCommExt);
"
603,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"        mScoConnectionState = AudioManager.SCO_AUDIO_STATE_ERROR;
        Log.i(TAG, ""In onSystemReady(), calling resetBluetoothSco()"");
        resetBluetoothSco();
        getBluetoothHeadset();
        //FIXME: this is to maintain compatibility with deprecated intent
        // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
        Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
        newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,
                AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
        sendStickyBroadcastToAll(newIntent);

        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if (adapter != null) {
            adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
                                    BluetoothProfile.A2DP);
            adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
                                    BluetoothProfile.HEARING_AID);
        }
"
604,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"        mVolumeLogger.log(new VolumeEvent(VolumeEvent.VOL_ADJUST_SUGG_VOL, suggestedStreamType,
"
605,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"        public int totalCount() {
            synchronized(mScoClients) {
                int count = 0;
                for (ScoClient mScoClient : mScoClients) {
                    count += mScoClient.getCount();
                }
                Log.i(TAG, ""In totalCount(), count: "" + count);
                return count;
            }
        }

        private boolean requestScoState(int state, int scoAudioMode) {
            Log.i(TAG, ""In requestScoState(), state: "" + state + "", scoAudioMode: ""
                         + scoAudioMode);
            checkScoAudioState();
            int clientCount = totalCount();
            if (clientCount != 0) {
                Log.w(TAG, ""requestScoState: returning with state="" + state + "", scoAudioMode="" +
                             scoAudioMode + "", clientCount="" + clientCount);
                return false;
            }
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                // Make sure that the state transitions to CONNECTING even if we cannot initiate
                // the connection.
                broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_CONNECTING);
                // Accept SCO audio activation only in NORMAL audio mode or if the mode is
                // currently controlled by the same client process.
                synchronized(mSetModeDeathHandlers) {
                    int modeOwnerPid =  mSetModeDeathHandlers.isEmpty()
                            ? 0 : mSetModeDeathHandlers.get(0).getPid();
                    if (modeOwnerPid != 0 && (modeOwnerPid != mCreatorPid)) {
                        Log.w(TAG, ""requestScoState: audio mode is not NORMAL and modeOwnerPid ""
                                + modeOwnerPid + "" != creatorPid "" + mCreatorPid);
                        broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        return false;
                    }
                    switch (mScoAudioState) {
                        case SCO_STATE_INACTIVE:
                            mScoAudioMode = scoAudioMode;
                            if (scoAudioMode == SCO_MODE_UNDEFINED) {
                                mScoAudioMode = SCO_MODE_VIRTUAL_CALL;
                                if (mBluetoothHeadsetDevice != null) {
                                    mScoAudioMode = Settings.Global.getInt(mContentResolver,
                                            ""bluetooth_sco_channel_""
                                                    + mBluetoothHeadsetDevice.getAddress(),
                                            SCO_MODE_VIRTUAL_CALL);
                                    if (mScoAudioMode > SCO_MODE_MAX || mScoAudioMode < 0) {
                                        mScoAudioMode = SCO_MODE_VIRTUAL_CALL;
                                    }
                                }
                            }
                            if (mBluetoothHeadset == null) {
                                if (getBluetoothHeadset()) {
                                    mScoAudioState = SCO_STATE_ACTIVATE_REQ;
                                } else {
                                    Log.w(TAG, ""requestScoState: getBluetoothHeadset failed during""
                                            + "" connection, mScoAudioMode="" + mScoAudioMode);
                                    broadcastScoConnectionState(
                                            AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                    return false;
                                }
                                break;
                            }
                            if (mBluetoothHeadsetDevice == null) {
                                Log.w(TAG, ""requestScoState: no active device while connecting,""
                                        + "" mScoAudioMode="" + mScoAudioMode);
                                broadcastScoConnectionState(
                                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                return false;
                            }
                            if (connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                    mBluetoothHeadsetDevice, mScoAudioMode)) {
                                mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                            } else {
                                Log.w(TAG, ""requestScoState: connect to "" + mBluetoothHeadsetDevice
                                        + "" failed, mScoAudioMode="" + mScoAudioMode);
                                broadcastScoConnectionState(
                                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                return false;
                            }
                            break;
                        case SCO_STATE_DEACTIVATING:
                            mScoAudioState = SCO_STATE_ACTIVATE_REQ;
                            break;
                        case SCO_STATE_DEACTIVATE_REQ:
                            mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_CONNECTED);
                            break;
                        default:
                            Log.w(TAG, ""requestScoState: failed to connect in state ""
                                    + mScoAudioState + "", scoAudioMode="" + scoAudioMode);
                            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                            return false;

                    }
                }
            } else if (state == BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
                switch (mScoAudioState) {
                    case SCO_STATE_ACTIVE_INTERNAL:
                        if (mBluetoothHeadset == null) {
                            if (getBluetoothHeadset()) {
                                mScoAudioState = SCO_STATE_DEACTIVATE_REQ;
                            } else {
                                Log.w(TAG, ""requestScoState: getBluetoothHeadset failed during""
                                        + "" disconnection, mScoAudioMode="" + mScoAudioMode);
                                mScoAudioState = SCO_STATE_INACTIVE;
                                broadcastScoConnectionState(
                                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                return false;
                            }
                            break;
                        }
                        if (mBluetoothHeadsetDevice == null) {
                            mScoAudioState = SCO_STATE_INACTIVE;
                            broadcastScoConnectionState(
                                    AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                            break;
                        }
                        if (disconnectBluetoothScoAudioHelper(mBluetoothHeadset,
                                mBluetoothHeadsetDevice, mScoAudioMode)) {
                            mScoAudioState = SCO_STATE_DEACTIVATING;
                        } else {
                            mScoAudioState = SCO_STATE_INACTIVE;
                            broadcastScoConnectionState(
                                    AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        }
                        break;
                    case SCO_STATE_ACTIVATE_REQ:
                        mScoAudioState = SCO_STATE_INACTIVE;
                        broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        break;
                    default:
                        Log.w(TAG, ""requestScoState: failed to disconnect in state ""
                                + mScoAudioState + "", scoAudioMode="" + scoAudioMode);
                        broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        return false;
                }
"
606,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"        public void incCount(int scoAudioMode) {
            synchronized(mScoClients) {
                Log.i(TAG, ""In incCount(), mStartcount = "" + mStartcount);
                boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_CONNECTED,
                                                    scoAudioMode);
                if (!ScoState) {
                    Log.e(TAG, ""In incCount(), requestScoState failed returning"");
                    return;
                }
                if (mStartcount == 0) {
                    try {
                        mCb.linkToDeath(this, 0);
                    } catch (RemoteException e) {
                        // client has already died!
                        Log.w(TAG, ""ScoClient incCount() could not link to ""+mCb+"" binder death"");
                    }
                }
                //mStartCount should always be either 0 or 1 only if the startBluetoothSco
                //is called by the same app multiple times by mistake. This will ensure that
                //SCO gets disconnected when app calls stopBluetoothSco only once.
                //Also, if SCO is already there, we just need to select the SCO devices by
                //calling setBluetoothScoOn(true) in system context.
                if (mStartcount == 1) {
                    Log.i(TAG, ""mStartcount is 1, calling setBluetoothScoOn(true)""
                                + ""in system context"");
                    setBluetoothScoOn(true);
                } else if (mStartcount == 0) {
                    mStartcount++;
                    Log.i(TAG, ""mStartcount is 0, incrementing by 1"");
                }
            }
        }

        public void decCount() {
            synchronized(mScoClients) {
                Log.i(TAG, ""In decCount(), mStartcount: "" + mStartcount);
                if (mStartcount == 0) {
                    Log.w(TAG, ""ScoClient.decCount() already 0"");
                } else {
                    mStartcount--;
                    if (mStartcount == 0) {
                        try {
                            mCb.unlinkToDeath(this, 0);
                        } catch (NoSuchElementException e) {
                            Log.w(TAG, ""decCount() going to 0 but not registered to binder"");
"
607,services/core/java/com/android/server/audio/AudioService.java,['b576b28ececdf87e488eaf196c28e48371784746'],1,"        sVolumeLogger.log(new VolumeEvent(VolumeEvent.VOL_ADJUST_SUGG_VOL, suggestedStreamType,
                direction/*val1*/, flags/*val2*/, new StringBuilder(callingPackage)
                        .append(""/"").append(caller).append("" uid:"").append(uid).toString()));
"
608,services/core/java/com/android/server/audio/AudioService.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"        }
        // when entering RINGTONE, IN_CALL or IN_COMMUNICATION mode, clear all
        // SCO connections not started by the application changing the mode when pid changes
        if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
            mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
"
609,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"        }
    }

    private boolean handleDeviceConnection(boolean connect, int device, String address,
            String deviceName) {
        if (DEBUG_DEVICES) {
            Slog.i(TAG, ""handleDeviceConnection("" + connect + "" dev:"" + Integer.toHexString(device)
                    + "" address:"" + address + "" name:"" + deviceName + "")"");
        }
        synchronized (mConnectedDevices) {
            String deviceKey = makeDeviceListKey(device, address);
            if (DEBUG_DEVICES) {
                Slog.i(TAG, ""deviceKey:"" + deviceKey);
            }
            DeviceListSpec deviceSpec = mConnectedDevices.get(deviceKey);
            boolean isConnected = deviceSpec != null;
            if (DEBUG_DEVICES) {
                Slog.i(TAG, ""deviceSpec:"" + deviceSpec + "" is(already)Connected:"" + isConnected);
            }
            if (connect && !isConnected) {
                final int res = AudioSystem.setDeviceConnectionState(device,
                        AudioSystem.DEVICE_STATE_AVAILABLE, address, deviceName,
                        AudioSystem.AUDIO_FORMAT_DEFAULT);
                if (res != AudioSystem.AUDIO_STATUS_OK) {
                    Slog.e(TAG, ""not connecting device 0x"" + Integer.toHexString(device) +
                            "" due to command error "" + res );
                    return false;
                }
                mConnectedDevices.put(deviceKey, new DeviceListSpec(device,
                                deviceName, address, AudioSystem.AUDIO_FORMAT_DEFAULT));
                sendMsg(mAudioHandler, MSG_ACCESSORY_PLUG_MEDIA_UNMUTE, SENDMSG_QUEUE,
                        device, 0, null, 0);
                return true;
            } else if (!connect && isConnected) {
                AudioSystem.setDeviceConnectionState(device,
                        AudioSystem.DEVICE_STATE_UNAVAILABLE, address, deviceName,
                        AudioSystem.AUDIO_FORMAT_DEFAULT);
                // always remove even if disconnection failed
                mConnectedDevices.remove(deviceKey);
                return true;
            }
            Log.w(TAG, ""handleDeviceConnection() failed, deviceKey="" + deviceKey + "", deviceSpec=""
                       + deviceSpec + "", connect="" + connect);
        }

        Slog.e(TAG, ""handleDeviceConnection: returning false"");
        return false;
    }

    // Devices which removal triggers intent ACTION_AUDIO_BECOMING_NOISY. The intent is only
    // sent if:
    // - none of these devices are connected anymore after one is disconnected AND
    // - the device being disconnected is actually used for music.
    // Access synchronized on mConnectedDevices
    int mBecomingNoisyIntentDevices =
            AudioSystem.DEVICE_OUT_WIRED_HEADSET | AudioSystem.DEVICE_OUT_WIRED_HEADPHONE |
            AudioSystem.DEVICE_OUT_ALL_A2DP | AudioSystem.DEVICE_OUT_HDMI |
            AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET | AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET |
            AudioSystem.DEVICE_OUT_ALL_USB | AudioSystem.DEVICE_OUT_LINE |
            AudioSystem.DEVICE_OUT_HEARING_AID;

    // must be called before removing the device from mConnectedDevices
    // Called synchronized on mConnectedDevices
    // musicDevice argument is used when not AudioSystem.DEVICE_NONE instead of querying
    // from AudioSystem
    private int checkSendBecomingNoisyIntent(int device, int state, int musicDevice) {
        int delay = 0;
        if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
            int devices = 0;
            for (int i = 0; i < mConnectedDevices.size(); i++) {
                int dev = mConnectedDevices.valueAt(i).mDeviceType;
                if (((dev & AudioSystem.DEVICE_BIT_IN) == 0)
                        && ((dev & mBecomingNoisyIntentDevices) != 0)) {
                    devices |= dev;
                }
            }
            if (musicDevice == AudioSystem.DEVICE_NONE) {
                musicDevice = getDeviceForStream(AudioSystem.STREAM_MUSIC);
            }
            // ignore condition on device being actually used for music when in communication
            // because music routing is altered in this case.
            // also checks whether media routing if affected by a dynamic policy
            if (((device == musicDevice) || isInCommunication()) && (device == devices)
                    && !hasMediaDynamicPolicy()) {
                mAudioHandler.removeMessages(MSG_BROADCAST_AUDIO_BECOMING_NOISY);
                sendMsg(mAudioHandler,
                        MSG_BROADCAST_AUDIO_BECOMING_NOISY,
                        SENDMSG_REPLACE,
                        0,
                        0,
                        null,
                        0);
                delay = SystemProperties.getInt(""vendor.audio.noisy.broadcast.delay"", 700);
            }
        }

        return delay;
"
610,services/core/java/com/android/server/audio/AudioService.java,['6fc85c43e31aad55eecd51d3b0de34715ae03810'],1,"    /**
     * @see AudioManager#handleBluetoothA2dpActiveDeviceChange(BluetoothDevice, int, int,
     *                                                        boolean, int)
     */
    public void handleBluetoothA2dpActiveDeviceChange(
            BluetoothDevice device, int state, int profile, boolean suppressNoisyIntent,
            int a2dpVolume) {
        if (device == null) {
                throw new IllegalArgumentException(""Illegal null device"");
        }
        if (profile != BluetoothProfile.A2DP && profile != BluetoothProfile.A2DP_SINK) {
            throw new IllegalArgumentException(""invalid profile "" + profile);
        }
        if (state != BluetoothProfile.STATE_CONNECTED
                && state != BluetoothProfile.STATE_DISCONNECTED) {
            throw new IllegalArgumentException(""Invalid state "" + state);
        }
        mDeviceBroker.postBluetoothA2dpDeviceConfigChangeExt(device, state, profile,
                suppressNoisyIntent, a2dpVolume);
    }

    private static final int DEVICE_MEDIA_UNMUTED_ON_PLUG =
            AudioSystem.DEVICE_OUT_WIRED_HEADSET | AudioSystem.DEVICE_OUT_WIRED_HEADPHONE |
            AudioSystem.DEVICE_OUT_LINE |
            AudioSystem.DEVICE_OUT_ALL_A2DP |
            AudioSystem.DEVICE_OUT_ALL_USB |
            AudioSystem.DEVICE_OUT_HDMI;
"
611,services/core/java/com/android/server/audio/AudioService.java,['6fc85c43e31aad55eecd51d3b0de34715ae03810'],1,"    private static final int MSG_ACCESSORY_PLUG_MEDIA_MUTE = 30;
"
612,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"    private void checkScoAudioState() {
        synchronized (mScoClients) {
            if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null &&
                    mScoAudioState == SCO_STATE_INACTIVE &&
                    mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice)
                            != BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
                mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
            }
        }
        Log.i(TAG, ""In checkScoAudioState(), mScoAudioState: "" + mScoAudioState);
    }
"
613,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"    public void clearAllScoClients(int exceptPid, boolean stopSco) {
        synchronized(mScoClients) {
            ScoClient savedClient = null;
            for (ScoClient cl : mScoClients) {
                if (cl.getPid() != exceptPid) {
                    cl.clearCount(stopSco);
                } else {
                    savedClient = cl;
                }
            }
            mScoClients.clear();
            if (savedClient != null) {
                mScoClients.add(savedClient);
            }
        }
    }

    private boolean getBluetoothHeadset() {
        boolean result = false;
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if (adapter != null) {
            result = adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
                                    BluetoothProfile.HEADSET);
        }
        // If we could not get a bluetooth headset proxy, send a failure message
        // without delay to reset the SCO audio state and clear SCO clients.
        // If we could get a proxy, send a delayed failure message that will reset our state
        // in case we don't receive onServiceConnected().
        sendMsg(mAudioHandler, MSG_BT_HEADSET_CNCT_FAILED,
                SENDMSG_REPLACE, 0, 0, null, result ? BT_HEADSET_CNCT_TIMEOUT_MS : 0);
        return result;
    }

    /**
     * Disconnect all SCO connections started by {@link AudioManager} except those started by
     * {@param exceptPid}
     *
     * @param exceptPid pid whose SCO connections through {@link AudioManager} should be kept
     */
    private void disconnectBluetoothSco(int exceptPid) {
        Log.i(TAG, ""In disconnectBluetoothSco(), exceptPid: "" + exceptPid);
        synchronized(mScoClients) {
            checkScoAudioState();
            if (mScoAudioState == SCO_STATE_ACTIVE_EXTERNAL) {
                return;
            }
            clearAllScoClients(exceptPid, true);
        }
    }

    private static boolean disconnectBluetoothScoAudioHelper(BluetoothHeadset bluetoothHeadset,
            BluetoothDevice device, int scoAudioMode) {
        Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), scoAudioMode: "" + scoAudioMode +
               "", bluetoothHeadset: "" + bluetoothHeadset + "", BluetoothDevice: "" + device);
        switch (scoAudioMode) {
            case SCO_MODE_RAW:
                Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), calling disconnectAudio()"");
                return bluetoothHeadset.disconnectAudio();
            case SCO_MODE_VIRTUAL_CALL:
                Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), calling "" +
                           ""stopScoUsingVirtualVoiceCall()"");
                return bluetoothHeadset.stopScoUsingVirtualVoiceCall();
            case SCO_MODE_VR:
                Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), calling "" +
                           ""stopVoiceRecognition()"");
                return bluetoothHeadset.stopVoiceRecognition(device);
            default:
                return false;
        }
    }

    private static boolean connectBluetoothScoAudioHelper(BluetoothHeadset bluetoothHeadset,
            BluetoothDevice device, int scoAudioMode) {
        Log.i(TAG, ""In connectBluetoothScoAudioHelper(), scoAudioMode: "" + scoAudioMode +
               "", bluetoothHeadset: "" + bluetoothHeadset + "", BluetoothDevice: "" + device);
        switch (scoAudioMode) {
            case SCO_MODE_RAW:
                Log.i(TAG, ""In connectBluetoothScoAudioHelper(), calling connectAudio()"");
                return bluetoothHeadset.connectAudio();
            case SCO_MODE_VIRTUAL_CALL:
                Log.i(TAG, ""In connectBluetoothScoAudioHelper(), calling ""
                       + ""startScoUsingVirtualVoiceCall()"");
                return bluetoothHeadset.startScoUsingVirtualVoiceCall();
            case SCO_MODE_VR:
                Log.i(TAG, ""In connectBluetoothScoAudioHelper(), calling ""
                       + ""startVoiceRecognition()"");
                return bluetoothHeadset.startVoiceRecognition(device);
            default:
                return false;
        }
    }

    private void resetBluetoothSco() {
        synchronized(mScoClients) {
            Log.i(TAG, ""In resetBluetoothSco(), calling clearAllScoClients()"");
            clearAllScoClients(0, false);
            mScoAudioState = SCO_STATE_INACTIVE;
            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
        }
        mScoClientDevices.clear();
        AudioSystem.setParameters(""A2dpSuspended=false"");
        setBluetoothScoOnInt(false, ""resetBluetoothSco"");
    }

    private void broadcastScoConnectionState(int state) {
        sendMsg(mAudioHandler, MSG_BROADCAST_BT_CONNECTION_STATE,
                SENDMSG_QUEUE, state, 0, null, 0);
    }

    private void onBroadcastScoConnectionState(int state) {
        if (state != mScoConnectionState) {
            Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_UPDATED);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, state);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_PREVIOUS_STATE,
                    mScoConnectionState);
            sendStickyBroadcastToAll(newIntent);
            mScoConnectionState = state;
        }
    }

    private boolean handleBtScoActiveDeviceChange(BluetoothDevice btDevice, boolean isActive) {
        if (btDevice == null) {
            return true;
        }

        String address = btDevice.getAddress();
        BluetoothClass btClass = btDevice.getBluetoothClass();
        int inDevice = AudioSystem.DEVICE_IN_BLUETOOTH_SCO_HEADSET;
        int[] outDeviceTypes = {
            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,
            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET,
            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT
        };
        if (btClass != null) {
            switch (btClass.getDeviceClass()) {
                case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
                case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                    outDeviceTypes = new int[] { AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET };
                    break;
                case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                    outDeviceTypes = new int[] { AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT };
                    break;
            }
        }
        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
            address = """";
        }
        String btDeviceName =  btDevice.getName();
        if (btDeviceName == null) {
            Slog.i(TAG, ""handleBtScoActiveDeviceChange: btDeviceName is null,"" +
                       "" sending empty string"");
            btDeviceName = """";
        }

        boolean result = false;
        if (isActive) {
            result |= handleDeviceConnection(isActive, outDeviceTypes[0], address, btDeviceName);
        } else {
            for (int outDeviceType : outDeviceTypes) {
                result |= handleDeviceConnection(isActive, outDeviceType, address, btDeviceName);
            }
        }

        // handleDeviceConnection() && result to make sure the method get executed
        result = handleDeviceConnection(isActive, inDevice, address, btDeviceName) && result;
        Slog.i(TAG, ""for inDevice"" + inDevice + "" result is "" + result);
        return result;
    }

    private void setBtScoActiveDevice(BluetoothDevice btDevice) {
        synchronized (mScoClients) {
            Log.i(TAG, ""setBtScoActiveDevice: "" + mBluetoothHeadsetDevice + "" -> "" + btDevice);
            final BluetoothDevice previousActiveDevice = mBluetoothHeadsetDevice;
            if (mBluetoothHeadsetDevice != null && mBluetoothHeadsetDevice.isTwsPlusDevice()
               && btDevice != null
               && Objects.equals(mBluetoothHeadsetDevice.getTwsPlusPeerAddress(), btDevice.getAddress())) {
                Log.i(TAG, ""setBtScoActiveDevice: Active device switch between twsplus devices"");
                //Keep the same mBluetoothHeadsetDevice as current Active so
                //that It tears down when active becomes null
                return;
            }
            if (!Objects.equals(btDevice, previousActiveDevice)) {
                if (!handleBtScoActiveDeviceChange(previousActiveDevice, false)) {
                    Log.w(TAG, ""setBtScoActiveDevice() failed to remove previous device ""
                            + previousActiveDevice);
                }
                if (!handleBtScoActiveDeviceChange(btDevice, true)) {
                    Log.e(TAG, ""setBtScoActiveDevice() failed to add new device "" + btDevice);
                    // set mBluetoothHeadsetDevice to null when failing to add new device
                    btDevice = null;
                }
                mBluetoothHeadsetDevice = btDevice;
                if (mBluetoothHeadsetDevice == null) {
                    Log.i(TAG, ""In setBtScoActiveDevice(), calling resetBluetoothSco()"");
                    resetBluetoothSco();
                }
            }
        }
    }

    private BluetoothProfile.ServiceListener mBluetoothProfileServiceListener =
        new BluetoothProfile.ServiceListener() {
        public void onServiceConnected(int profile, BluetoothProfile proxy) {
            Log.i(TAG, ""In onServiceConnected(), profile: "" + profile +
                  "", proxy: "" + proxy);
            BluetoothDevice btDevice;
            List<BluetoothDevice> deviceList;
            switch(profile) {
            case BluetoothProfile.A2DP:
                synchronized (mConnectedDevices) {
                    synchronized (mA2dpAvrcpLock) {
                        mA2dp = (BluetoothA2dp) proxy;
                        deviceList = mA2dp.getConnectedDevices();
                        if (deviceList.size() > 0) {
                            btDevice = deviceList.get(0);
                            int state = mA2dp.getConnectionState(btDevice);
                            int intState = (state == BluetoothA2dp.STATE_CONNECTED) ? 1 : 0;
                            int delay = checkSendBecomingNoisyIntent(
                                    AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, intState,
                                    AudioSystem.DEVICE_NONE);
                            final String addr = btDevice == null ? ""null"" : btDevice.getAddress();
                            mDeviceLogger.log(new AudioEventLogger.StringEvent(
                                    ""A2DP service connected: device addr="" + addr
                                    + "" state="" + state));
                            queueMsgUnderWakeLock(mAudioHandler,
                                    MSG_SET_A2DP_SINK_CONNECTION_STATE,
                                    state,
                                    0 /* arg2 unused */,
                                    new BluetoothA2dpDeviceInfo(btDevice),
                                    delay);
                        }
                    }
                }
                break;

            case BluetoothProfile.A2DP_SINK:
                deviceList = proxy.getConnectedDevices();
                if (deviceList.size() > 0) {
                    btDevice = deviceList.get(0);
                    synchronized (mConnectedDevices) {
                        int state = proxy.getConnectionState(btDevice);
                        queueMsgUnderWakeLock(mAudioHandler,
                                MSG_SET_A2DP_SRC_CONNECTION_STATE,
                                state,
                                0 /* arg2 unused */,
                                new BluetoothA2dpDeviceInfo(btDevice),
                                0 /* delay */);
                    }
                }
                break;

            case BluetoothProfile.HEADSET:
                synchronized (mScoClients) {
                    // Discard timeout message
                    mAudioHandler.removeMessages(MSG_BT_HEADSET_CNCT_FAILED);
                    mBluetoothHeadset = (BluetoothHeadset) proxy;
                    setBtScoActiveDevice(mBluetoothHeadset.getActiveDevice());
                    // Refresh SCO audio state
                    checkScoAudioState();
                    Log.i(TAG, ""In HEADSET profile, mScoAudioState: "" + mScoAudioState
                          + "", mScoAudioMode: "" + mScoAudioMode);
                    // Continue pending action if any
                    if (mScoAudioState == SCO_STATE_ACTIVATE_REQ ||
                            mScoAudioState == SCO_STATE_DEACTIVATE_REQ) {
                        boolean status = false;
                        if (mBluetoothHeadsetDevice != null) {
                            // Get correct mScoAudioMode
                            mScoAudioMode = new Integer(Settings.Global.getInt(
                                                        mContentResolver,
                                                        ""bluetooth_sco_channel_""+
                                                        mBluetoothHeadsetDevice.getAddress(),
                                                        SCO_MODE_VIRTUAL_CALL));
                            if (mScoAudioMode > SCO_MODE_MAX || mScoAudioMode < 0) {
                                Log.i(TAG, ""Resetting the mScoAudioMode to "" +
                                      ""SCO_MODE_VIRTUAL_CALL"");
                                mScoAudioMode = SCO_MODE_VIRTUAL_CALL;
                            }
                            switch (mScoAudioState) {
                                case SCO_STATE_ACTIVATE_REQ:
                                    Log.i(TAG, ""In HEADSET profile, calling connectBluetoothScoAudioHelper()"");
                                    status = connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                            mBluetoothHeadsetDevice, mScoAudioMode);
                                    if (status) {
                                        mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                                    }
                                    break;
                                case SCO_STATE_DEACTIVATE_REQ:
                                    Log.i(TAG, ""In HEADSET profile, calling disconnectBluetoothScoAudioHelper()"");
                                    status = disconnectBluetoothScoAudioHelper(mBluetoothHeadset,
                                            mBluetoothHeadsetDevice, mScoAudioMode);
                                    if (status) {
                                        mScoAudioState = SCO_STATE_DEACTIVATING;
                                    }
                                    break;
                            }
                        }
                        if (!status) {
                            mScoAudioState = SCO_STATE_INACTIVE;
                            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        }
                    }
                }
                break;

            case BluetoothProfile.HEARING_AID:
                synchronized (mConnectedDevices) {
                    synchronized (mHearingAidLock) {
                        mHearingAid = (BluetoothHearingAid) proxy;
                        deviceList = mHearingAid.getConnectedDevices();
                        if (deviceList.size() > 0) {
                            btDevice = deviceList.get(0);
                            int state = mHearingAid.getConnectionState(btDevice);
                            int intState = (state == BluetoothHearingAid.STATE_CONNECTED) ? 1 : 0;
                            int delay = checkSendBecomingNoisyIntent(
                                    AudioSystem.DEVICE_OUT_HEARING_AID, intState,
                                    AudioSystem.DEVICE_NONE);
                            queueMsgUnderWakeLock(mAudioHandler,
                                    MSG_SET_HEARING_AID_CONNECTION_STATE,
                                    state,
                                    0 /* arg2 unused */,
                                    btDevice,
                                    delay);
                        }
                    }
                }

                break;

            default:
                break;
            }
        }
        public void onServiceDisconnected(int profile) {

            switch (profile) {
            case BluetoothProfile.A2DP:
                disconnectA2dp();
                break;

            case BluetoothProfile.A2DP_SINK:
                disconnectA2dpSink();
                break;

            case BluetoothProfile.HEADSET:
                 Log.i(TAG, ""In onServiceDisconnected(), calling disconnectHeadset()"");
                disconnectHeadset();
                break;

            case BluetoothProfile.HEARING_AID:
                disconnectHearingAid();
                break;

            default:
                break;
            }
        }
    };

    void disconnectAllBluetoothProfiles() {
        disconnectA2dp();
        disconnectA2dpSink();
        disconnectHeadset();
        disconnectHearingAid();
    }

    void disconnectA2dp() {
        synchronized (mConnectedDevices) {
            synchronized (mA2dpAvrcpLock) {
                ArraySet<String> toRemove = null;
                // Disconnect ALL DEVICE_OUT_BLUETOOTH_A2DP devices
                for (int i = 0; i < mConnectedDevices.size(); i++) {
                    DeviceListSpec deviceSpec = mConnectedDevices.valueAt(i);
                    if (deviceSpec.mDeviceType == AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) {
                        toRemove = toRemove != null ? toRemove : new ArraySet<String>();
                        toRemove.add(deviceSpec.mDeviceAddress);
                    }
                }
                if (toRemove != null) {
                    int delay = checkSendBecomingNoisyIntent(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
                            0, AudioSystem.DEVICE_NONE);
                    for (int i = 0; i < toRemove.size(); i++) {
                        makeA2dpDeviceUnavailableLater(toRemove.valueAt(i), delay);
                    }
                }
            }
        }
    }

    void disconnectA2dpSink() {
        synchronized (mConnectedDevices) {
            ArraySet<String> toRemove = null;
            // Disconnect ALL DEVICE_IN_BLUETOOTH_A2DP devices
            for(int i = 0; i < mConnectedDevices.size(); i++) {
                DeviceListSpec deviceSpec = mConnectedDevices.valueAt(i);
                if (deviceSpec.mDeviceType == AudioSystem.DEVICE_IN_BLUETOOTH_A2DP) {
                    toRemove = toRemove != null ? toRemove : new ArraySet<String>();
                    toRemove.add(deviceSpec.mDeviceAddress);
                }
            }
            if (toRemove != null) {
                for (int i = 0; i < toRemove.size(); i++) {
                    makeA2dpSrcUnavailable(toRemove.valueAt(i));
                }
            }
        }
    }

    void disconnectHeadset() {
        synchronized (mScoClients) {
            setBtScoActiveDevice(null);
            mBluetoothHeadset = null;
        }
    }

    void disconnectHearingAid() {
        synchronized (mConnectedDevices) {
            synchronized (mHearingAidLock) {
                ArraySet<String> toRemove = null;
                // Disconnect ALL DEVICE_OUT_HEARING_AID devices
                for (int i = 0; i < mConnectedDevices.size(); i++) {
                    DeviceListSpec deviceSpec = mConnectedDevices.valueAt(i);
                    if (deviceSpec.mDeviceType == AudioSystem.DEVICE_OUT_HEARING_AID) {
                        toRemove = toRemove != null ? toRemove : new ArraySet<String>();
                        toRemove.add(deviceSpec.mDeviceAddress);
                    }
                }
                if (toRemove != null) {
                    int delay = checkSendBecomingNoisyIntent(AudioSystem.DEVICE_OUT_HEARING_AID,
                            0, AudioSystem.DEVICE_NONE);
                    for (int i = 0; i < toRemove.size(); i++) {
                        makeHearingAidDeviceUnavailable(toRemove.valueAt(i) /*, delay*/);
                    }
                }
            }
        }
    }

    private void onCheckMusicActive(String caller) {
        synchronized (mSafeMediaVolumeStateLock) {
            if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_INACTIVE) {
                int device = getDeviceForStream(AudioSystem.STREAM_MUSIC);

                if ((device & mSafeMediaVolumeDevices) != 0) {
                    sendMsg(mAudioHandler,
                            MSG_CHECK_MUSIC_ACTIVE,
                            SENDMSG_REPLACE,
                            0,
                            0,
                            caller,
                            MUSIC_ACTIVE_POLL_PERIOD_MS);
                    int index = mStreamStates[AudioSystem.STREAM_MUSIC].getIndex(device);
                    if (AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC, 0) &&
                            (index > safeMediaVolumeIndex(device))) {
                        // Approximate cumulative active music time
                        mMusicActiveMs += MUSIC_ACTIVE_POLL_PERIOD_MS;
                        if (mMusicActiveMs > UNSAFE_VOLUME_MUSIC_ACTIVE_MS_MAX) {
                            setSafeMediaVolumeEnabled(true, caller);
                            mMusicActiveMs = 0;
                        }
                        saveMusicActiveMs();
                    }
                }
            }
        }
    }

    private void saveMusicActiveMs() {
        mAudioHandler.obtainMessage(MSG_PERSIST_MUSIC_ACTIVE_MS, mMusicActiveMs, 0).sendToTarget();
    }

    private int getSafeUsbMediaVolumeIndex()
    {
        // determine UI volume index corresponding to the wanted safe gain in dBFS
        int min = MIN_STREAM_VOLUME[AudioSystem.STREAM_MUSIC];
        int max = MAX_STREAM_VOLUME[AudioSystem.STREAM_MUSIC];

        mSafeUsbMediaVolumeDbfs = mContext.getResources().getInteger(
                com.android.internal.R.integer.config_safe_media_volume_usb_mB) / 100.0f;

        while (Math.abs(max-min) > 1) {
            int index = (max + min) / 2;
            float gainDB = AudioSystem.getStreamVolumeDB(
                    AudioSystem.STREAM_MUSIC, index, AudioSystem.DEVICE_OUT_USB_HEADSET);
            if (Float.isNaN(gainDB)) {
                //keep last min in case of read error
                break;
            } else if (gainDB == mSafeUsbMediaVolumeDbfs) {
                min = index;
                break;
            } else if (gainDB < mSafeUsbMediaVolumeDbfs) {
                min = index;
            } else {
                max = index;
            }
        }
        return min * 10;
    }

    private void onConfigureSafeVolume(boolean force, String caller) {
        synchronized (mSafeMediaVolumeStateLock) {
            int mcc = mContext.getResources().getConfiguration().mcc;
            if ((mMcc != mcc) || ((mMcc == 0) && force)) {
                mSafeMediaVolumeIndex = mContext.getResources().getInteger(
                        com.android.internal.R.integer.config_safe_media_volume_index) * 10;

                mSafeUsbMediaVolumeIndex = getSafeUsbMediaVolumeIndex();

                boolean safeMediaVolumeEnabled =
                        SystemProperties.getBoolean(""audio.safemedia.force"", false)
                        || mContext.getResources().getBoolean(
                                com.android.internal.R.bool.config_safe_media_volume_enabled);

"
614,services/core/java/com/android/server/audio/AudioService.java,['567b4cf7b54062947b5eabe6ecef7b70fbb7301b'],1,"On(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        return (mForcedUseForCommExt == AudioSystem.FORCE_"
615,services/core/java/com/android/server/audio/BtHelper.java,['29c143c9ac800bdd15598250e6f2207f05c9a5b0'],1,"                    if (checkAndUpdatTwsPlusScoState(intent,
                           BluetoothHeadset.STATE_AUDIO_DISCONNECTED)) {
                        mDeviceBroker.setBluetoothScoOn(false, ""BtHelper.receiveBtEvent"");
                        scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                        // startBluetoothSco called after stopBluetoothSco
                        if (mScoAudioState == SCO_STATE_ACTIVATE_REQ) {
                            if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null
                                    && connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                    mBluetoothHeadsetDevice, mScoAudioMode)) {
                                mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                                broadcast = false;
                                break;
                            }
"
616,services/core/java/com/android/server/audio/BtHelper.java,"['24f36fd2514856aaafe6a32a99050e272a6bd361', '4a30c150e58ec67edb92a7bec5ea48cebd6b90d4']",2,            return false
617,services/core/java/com/android/server/audio/BtHelper.java,"['24f36fd2514856aaafe6a32a99050e272a6bd361', '4a30c150e58ec67edb92a7bec5ea48cebd6b90d4']",2,"            return false;
"
618,services/core/java/com/android/server/audio/BtHelper.java,['24f36fd2514856aaafe6a32a99050e272a6bd361'],1,"        // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
        // @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
        @GuardedBy(""BtHelper.this"")
        void incCount(int scoAudioMode) {
            Log.i(TAG, ""In incCount(), mStartcount = "" + mStartcount);
            if (!requestScoState(BluetoothHeadset.STATE_AUDIO_CONNECTED, scoAudioMode)) {
                Log.e(TAG, ""Request sco connected with scoAudioMode(""
                        + scoAudioMode + "") failed"");
                return;
            }
            if (mStartcount == 0) {
                try {
                    mCb.linkToDeath(this, 0);
                } catch (RemoteException e) {
                    // client has already died!
                    Log.w(TAG, ""ScoClient incCount() could not link to ""+mCb+"" binder death"");
                }
            }
            //mStartCount should always be either 0 or 1 only if the startBluetoothSco
            //is called by the same app multiple times by mistake. This will ensure that
            //SCO gets disconnected when app calls stopBluetoothSco only once.
            //Also, if SCO is already there, we just need to select the SCO devices by
            //calling setBluetoothScoOn(true) in system context.
            if (mStartcount == 1) {
                Log.i(TAG, ""mStartcount is 1, calling setBluetoothScoOn(true)""
                            + ""in system context"");
                mDeviceBroker.setBluetoothScoOn(true, ""BtHelper.incCount"");
            } else if (mStartcount == 0) {
                mStartcount++;
                Log.i(TAG, ""mStartcount is 0, incrementing by 1"");
            }
        }

        // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
        // @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
        @GuardedBy(""BtHelper.this"")
        void decCount() {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In decCount(), mStartcount: "" + mStartcount);
            }
            if (mStartcount == 0) {
                Log.w(TAG, ""ScoClient.decCount() already 0"");
            } else {
                mStartcount--;
                if (mStartcount == 0) {
                    try {
                        mCb.unlinkToDeath(this, 0);
                    } catch (NoSuchElementException e) {
                        Log.w(TAG, ""decCount() going to 0 but not registered to binder"");
                    }
                }
                if (!requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED, 0)) {
                    Log.w(TAG, ""Request sco disconnected with scoAudioMode(0) failed"");
                }
            }
        }

        // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
        // @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
        @GuardedBy(""BtHelper.this"")
        void clearCount(boolean stopSco) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In clearCount(), stopSco: "" + stopSco + "", mStartcount: ""
                            + mStartcount);
            }
            if (mStartcount != 0) {
                try {
                    mCb.unlinkToDeath(this, 0);
                } catch (NoSuchElementException e) {
                    Log.w(TAG, ""clearCount() mStartcount: ""
                            + mStartcount + "" != 0 but not registered to binder"");
                }
            }
            mStartcount = 0;
            if (stopSco) {
                boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED, 0);
"
619,services/core/java/com/android/server/audio/BtHelper.java,['24f36fd2514856aaafe6a32a99050e272a6bd361'],1,"        private int totalCount() {
            int count = 0;
            for (ScoClient mScoClient : mScoClients) {
                count += mScoClient.getCount();
            }
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In totalCount(), count: "" + count);
            }
            return count;
        }

"
620,services/core/java/com/android/server/audio/BtHelper.java,"['b576b28ececdf87e488eaf196c28e48371784746', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",3,"    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

"
621,services/core/java/com/android/server/audio/BtHelper.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

    // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
    @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
"
622,services/core/java/com/android/server/audio/BtHelper.java,['dfd2f7fed77160af2c57edfa20f1768b42aaa8da'],1,"    private int mapBluetoothCodecToAudioFormat(int btCodecType) {
        switch (btCodecType) {
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_SBC:
                return AudioSystem.AUDIO_FORMAT_SBC;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_AAC:
                return AudioSystem.AUDIO_FORMAT_AAC;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX:
                return AudioSystem.AUDIO_FORMAT_APTX;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_HD:
                return AudioSystem.AUDIO_FORMAT_APTX_HD;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC:
                return AudioSystem.AUDIO_FORMAT_LDAC;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_CELT:
                return AudioSystem.AUDIO_FORMAT_CELT;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_ADAPTIVE:
                return AudioSystem.AUDIO_FORMAT_APTX_ADAPTIVE;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_TWSP:
                return AudioSystem.AUDIO_FORMAT_APTX_TWSP;
            default:
                return AudioSystem.AUDIO_FORMAT_DEFAULT;
        }
    }

"
623,services/core/java/com/android/server/connectivity/Nat464Xlat.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        // Only support clat on mobile and wifi for now, because these are the only IPv6-only
        // networks we can connect to.
        boolean doXlat = SystemProperties.getBoolean(""persist.vendor.net.doxlat"", true);
        if(!doXlat) {
            Slog.i(TAG, ""Android Xlat is disabled"");
        }
        return supported && connected && !hasIPv4Address
               && ArrayUtils.contains(NETWORK_TYPES, netType)
               && ((netType == ConnectivityManager.TYPE_MOBILE) ? doXlat : true);
"
624,services/core/java/com/android/server/connectivity/Nat464Xlat.java,['3a5272699e3e16fbfdc397480898bb27abeb2caa'],1,"import android.os.SystemProperties;
"
625,services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,['88b45c586d461df38b866d529bc98d1dfa3e8838'],1,"        if (Nat464Xlat.requiresClat(this) &&
            ( this.networkCapabilities.hasCapability(NET_CAPABILITY_INTERNET) ||
              this.networkCapabilities.hasCapability(NET_CAPABILITY_MMS) )) {
            maybeStartClat(netd);
"
626,services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,['3a5272699e3e16fbfdc397480898bb27abeb2caa'],1,"    public void updateClat(INetworkManagementService netd) {
        if (Nat464Xlat.requiresClat(this) &&
            ( this.networkCapabilities.hasCapability(NET_CAPABILITY_INTERNET) ||
              this.networkCapabilities.hasCapability(NET_CAPABILITY_MMS) )) {
            maybeStartClat();
        } else {
            maybeStopClat();
        }
    }

    /** Ensure clat has started for this network. */
    public void maybeStartClat() {
        if (clatd != null && clatd.isStarted()) {
            return;
        }
        clatd = new Nat464Xlat(this, mNetd, mNMS);
        clatd.start();
    }

    /** Ensure clat has stopped for this network. */
    public void maybeStopClat() {
        if (clatd == null) {
            return;
        }
        clatd.stop();
        clatd = null;
    }

"
627,services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '3d2fc559e13b7293212955f1858d443f4fe8234e', '24f36fd2514856aaafe6a32a99050e272a6bd361', '88b45c586d461df38b866d529bc98d1dfa3e8838', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",5,"import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
"
628,services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '8faa0d981413f18b2468dde1b1fe71e248df0df1', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c', '88b45c586d461df38b866d529bc98d1dfa3e8838']",4,"import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_"
629,services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
"
630,services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c', '88b45c586d461df38b866d529bc98d1dfa3e8838']",3,"import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
"
631,services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '88b45c586d461df38b866d529bc98d1dfa3e8838']",2,"import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

"
632,services/core/java/com/android/server/connectivity/Vpn.java,"['f2b53072aa24c3f9f84e762d313f85f5f179e4a4', '8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",3,"                    switch (ikeException.getErrorType()) {
                        case IkeProtocolException.ERROR_TYPE_NO_PROPOSAL_CHOSEN: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_INVALID_KE_PAYLOAD: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_AUTHENTICATION_FAILED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_SINGLE_PAIR_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_FAILED_CP_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_TS_UNACCEPTABLE:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_NOT_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                            markFailedAndDisconnect(exception);
                            return;
                        // All other cases possibly recoverable.
                        default:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                    }
                } else if (exception instanceof IllegalArgumentException) {
                    // Failed to build IKE/ChildSessionParams; fatal profile configuration error
                    markFailedAndDisconnect(exception);
                    return;
                } else if (exception instanceof IkeNetworkLostException) {
                    // TODO(b/230548427): Remove SDK check once VPN related stuff are
                    //  decoupled from ConnectivityServiceTest.
                    if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                        sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                VpnManager.ERROR_CLASS_RECOVERABLE,
                                VpnManager.ERROR_CODE_NETWORK_LOST,
                                getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                mActiveNetwork,
                                getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                        mUnderlyingNetworkCapabilities),
                                getRedactedLinkPropertiesOfUnderlyingNetwork(
                                        mUnderlyingLinkProperties));
                    }
                } else if (exception instanceof IkeNonProtocolException) {
                    if (exception.getCause() instanceof UnknownHostException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_UNKNOWN_HOST,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IkeTimeoutException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_PROTOCOL_TIMEOUT,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IOException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_IO,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    }
                } else if (exception != null) {
                    Log.wtf(TAG, ""onSessionLost: exception = "" + exception);
"
633,services/core/java/com/android/server/display/DisplayModeDirector.java,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']",2,"                mAmbientFilter.addValue(now, mLastSensorData);
"
634,services/core/java/com/android/server/display/DisplayModeDirector.java,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']",2,"            if (DEBUG) {
                Slog.d(TAG, ""Display brightness "" + brightness + "", ambient lux "" +  mAmbientLux +
                        "", Vote "" + vote);
"
635,services/core/java/com/android/server/display/DisplayModeDirector.java,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']",2,"            if (mShouldObserveAmbientChange && mScreenOn && !mLowPowerModeEnabled
                    && mRefreshRateChangeable) {
"
636,services/core/java/com/android/server/display/DisplayModeDirector.java,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']",2,"            pw.println(""    mRefreshRateInZone: "" + mRefreshRateInZone);
"
637,services/core/java/com/android/server/display/DisplayModeDirector.java,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']",2,"        private boolean isDefaultDisplayOn() {
            final Display display = mContext.getSystemService(DisplayManager.class)
                    .getDisplay(Display.DEFAULT_DISPLAY);
            return display.getState() != Display.STATE_OFF
                    && mContext.getSystemService(PowerManager.class).isInteractive();
"
638,services/core/java/com/android/server/display/DisplayModeDirector.java,"['a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6', '022e461c46ee3629d43ba134e977a0f3353c8782']",2,        private boolean m
639,services/core/java/com/android/server/display/DisplayModeDirector.java,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']",2,"        private boolean mScreenOn = false;
"
640,services/core/java/com/android/server/display/DisplayModeDirector.java,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']",2,"        private boolean mShouldObserveDisplayChange;
        private boolean mShouldObserveAmbientChange;
"
641,services/core/java/com/android/server/display/DisplayModeDirector.java,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']",2,"        private void onScreenOn(boolean on) {
            if (mScreenOn != on) {
                mScreenOn = on;
"
642,services/core/java/com/android/server/display/DisplayModeDirector.java,"['a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6', '022e461c46ee3629d43ba134e977a0f3353c8782']",2,"rightness + "", ambient lux "" +  mAmbientLux +
                        "", Vote "" + vote);
"
643,services/core/java/com/android/server/display/LocalDisplayAdapter.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"                    mInfo.type = Display.TYPE_BUILT_IN;
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                } else if (isBuiltIn) {
                    mInfo.type = Display.TYPE_BUILT_IN;
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                    mInfo.name = getContext().getResources().getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;

                    if (SystemProperties.getBoolean(
                                    ""vendor.display.builtin_presentation"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRESENTATION;
                    } else {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRIVATE;
                    }

                    if (!SystemProperties.getBoolean(
                                    ""vendor.display.builtin_mirroring"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_OWN_CONTENT_ONLY;
                    }

                    mInfo.setAssumedDensityForExternalDisplay(config.width, config.height);
"
644,services/core/java/com/android/server/display/LocalDisplayAdapter.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"                final boolean isBuiltIn = ((mInfo.address) != null) ?
                   (((DisplayAddress.Physical) mInfo.address).getPort() < 0) : false;
                if (mIsInternal) {
                    mInfo.name = res.getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_DEFAULT_DISPLAY
                            | DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;
"
645,services/core/java/com/android/server/display/LocalDisplayAdapter.java,['81b587a542e8381268a9ba8e7461712ef23cd11f'],1,"                int[] colorModes, int activeColorMode) {
            super(LocalDisplayAdapter.this, displayToken, UNIQUE_ID_PREFIX + builtInDisplayId,
                  builtInDisplayId);
            mBuiltInDisplayId = builtInDisplayId;
"
646,services/core/java/com/android/server/display/LocalDisplayAdapter.java,['e449737f6ea4d11d082f1cdec4d067f64d5ba95e'],1,"                int[] colorModes, int activeColorMode, boolean isInternal) {
            super(LocalDisplayAdapter.this, displayToken, UNIQUE_ID_PREFIX + physicalDisplayId,
                  physicalDisplayId);
"
647,services/core/java/com/android/server/display/LocalDisplayAdapter.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"            SurfaceControl.setAllowedDisplayConfigs(getDisplayTokenLocked(), allowedPhysIndexes);
            int activePhysIndex = SurfaceControl.getActiveConfig(getDisplayTokenLocked());
            if (activePhysIndex < 0) {
                return false;
            }
            return updateActiveModeLocked(activePhysIndex);
        }

        public boolean requestColorModeLocked(int colorMode) {
            if (mActiveColorMode == colorMode) {
                return false;
            }
            if (!mSupportedColorModes.contains(colorMode)) {
                Slog.w(TAG, ""Unable to find color mode "" + colorMode
                        + "", ignoring request."");
                return false;
            }
            SurfaceControl.setActiveColorMode(getDisplayTokenLocked(), colorMode);
            mActiveColorMode = colorMode;
            mActiveColorModeInvalid = false;
            return true;
"
648,services/core/java/com/android/server/display/LocalDisplayAdapter.java,"['26017c68ee11d3f2d54ca731119c8dc4ddb842cf', '3d2fc559e13b7293212955f1858d443f4fe8234e']",2,";
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                    mInfo.name = getContext().getResources().getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;

                    if (SystemProperties.getBoolean(
                                    ""vendor.display.builtin_presentation"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRESENTATION;
                    } else {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRIVATE;
                    }

                    if (!SystemProperties.getBoolean(
                                    ""vendor.display.builtin_mirroring"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_OWN_CONTENT_ONLY;
                    }

                    mInfo.setAssumedDensityForExternalDisplay("
649,services/core/java/com/android/server/display/LocalDisplayAdapter.java,"['337095f9d277c566cb888bc3adbac16576f1ae70', '3d2fc559e13b7293212955f1858d443f4fe8234e']",2,";
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                    mInfo.name = getContext().getResources().getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;

                    if (SystemProperties.getBoolean(
                                    ""vendor.display.builtin_presentation"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRESENTATION;
                    } else {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRIVATE;
                    }

                    if (!SystemProperties.getBoolean(
                                    ""vendor.display.builtin_mirroring"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_OWN_CONTENT_ONLY;
                    }

                    mInfo.setAssumedDensityForExternalDisplay(config.width, config.height);
"
650,services/core/java/com/android/server/display/WifiDisplayController.java,['5358a994b854c7a6627858c48d6947e8acff6ea9'],1,"                mWifiP2pManager.setWFDInfo(getWifiP2pChannel(), wfdInfo, new ActionListener() {
"
651,services/core/java/com/android/server/display/WifiDisplayController.java,['af02bd5317cc0cced0a7646d5bbf407a181dda9c'],1,"                wfdInfo.setWfdEnabled(false);
                mWifiP2pManager.setWfdInfo(getWifiP2pChannel(), wfdInfo, new ActionListener() {
"
652,services/core/java/com/android/server/display/WifiDisplayController.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"        mWifiP2pManager = (WifiP2pManager)context.getSystemService(Context.WIFI_P2P_SERVICE);

"
653,services/core/java/com/android/server/display/WifiDisplayController.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"    private Channel getWifiP2pChannel() {
        if(mWifiP2pChannel == null) {
            mWifiP2pChannel = mWifiP2pManager.initialize(mContext, mHandler.getLooper(), null);
            if(DEBUG) {
                Slog.d(TAG, ""Creating WifiP2pChannel"");
            }
        }
        return mWifiP2pChannel;
"
654,services/core/java/com/android/server/display/WifiDisplayController.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"    private final WifiP2pManager mWifiP2pManager;
"
655,services/core/java/com/android/server/locksettings/LockSettingsService.java,['4a30c150e58ec67edb92a7bec5ea48cebd6b90d4'],1,"            // during boot.
            clearUserKeyAuth(userId, null, auth.deriveDiskEncryptionKey());
"
656,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            @CredentialType int credentialType, boolean hasChallenge, long challenge, int userId,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""spBasedDoVerifyCredential: user="" + userId);
"
657,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            GateKeeperResponse gkResponse = getGateKeeperService()
                    .verifyChallenge(userId, 0, willStore.hash, credential);
"
658,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
        checkPasswordReadPermission(userId);
        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        false, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
"
659,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            Map<Integer, byte[]> profilePasswordMap) throws RemoteException {
"
660,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            boolean allowUntrustedChange, boolean isLockTiedToParent) throws RemoteException {
"
661,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            boolean hasChallenge, long challenge, int userId,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
"
662,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            boolean isLockTiedToParent) throws RemoteException {
"
663,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            byte[] credential, boolean hasChallenge, long challenge,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
"
664,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            byte[] credential, int credentialType, int requestedQuality,
            int userId) throws RemoteException {
"
665,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            byte[] enrolledCredential, byte[] toEnroll, int userId)
            throws RemoteException {
        checkWritePermission(userId);
        GateKeeperResponse response = getGateKeeperService().enroll(userId, enrolledHandle,
                enrolledCredential, toEnroll);
"
666,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            byte[] token, int requestedQuality, int userId) throws RemoteException {
"
667,services/core/java/com/android/server/locksettings/LockSettingsService.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '4a30c150e58ec67edb92a7bec5ea48cebd6b90d4']",2,"            clearUserKeyAuth(userId, null, auth.deriveDiskEncryptionKey());
"
668,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            int userId) throws RemoteException {
"
669,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            long challenge, int userId) throws RemoteException {
"
670,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            long tokenHandle, byte[] token, int requestedQuality, int userId)
                    throws RemoteException {
"
671,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            try {
                final long handle = getSyntheticPasswordHandleLocked(userId);
                final byte[] noCredential = null;
                AuthenticationResult result =
                        mSpManager.unwrapPasswordBasedSyntheticPassword(
                                getGateKeeperService(), handle, noCredential, userId, null);
                if (result.authToken != null) {
                    Slog.i(TAG, ""Retrieved auth token for user "" + userId);
                    onAuthTokenKnownForUser(userId, result.authToken);
                } else {
                    Slog.e(TAG, ""Auth token not available for user "" + userId);
                }
            } catch (RemoteException e) {
                Slog.e(TAG, ""Failure retrieving auth token"", e);
"
672,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            try {
                return LockSettingsService.this.setLockCredentialWithToken(credential, type,
                        tokenHandle, token, requestedQuality, userId);
            } catch (RemoteException re) {
                throw re.rethrowFromSystemServer();
            }
"
673,services/core/java/com/android/server/locksettings/LockSettingsService.java,['2ac0c608ad88dc1f3372e099b5359013be7b14c7'],1,"        VerifyCredentialResponse response = doVerifyCredential(credential, CHALLENGE_NONE,
                                             0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use LockscreenCredential
                String credentialString = credential.isNone() ? null : new String(credential.getCredential());
                retainPassword(credentialString);
        }
        return response;
"
674,services/core/java/com/android/server/locksettings/LockSettingsService.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        CHALLENGE_NONE, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
"
675,services/core/java/com/android/server/locksettings/LockSettingsService.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']",3,"        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        false, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
"
676,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"        boolean shouldReEnrollBaseZero = storedHash.type == CREDENTIAL_TYPE_PATTERN
                && storedHash.isBaseZeroPattern;

        byte[] credentialToVerify;
        if (shouldReEnrollBaseZero) {
            credentialToVerify = LockPatternUtils.patternByteArrayToBaseZero(credential);
        } else {
            credentialToVerify = credential;
        }

        response = verifyCredential(userId, storedHash, credentialToVerify,
                hasChallenge, challenge, progressCallback);
"
677,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"        if (storedHash.version == CredentialHash.VERSION_LEGACY) {
            final byte[] hash;
            if (storedHash.type == CREDENTIAL_TYPE_PATTERN) {
                hash = LockPatternUtils.patternToHash(
                        LockPatternUtils.byteArrayToPattern(credential));
            } else {
                hash = mLockPatternUtils.legacyPasswordToHash(credential, userId).getBytes();
            }
            if (Arrays.equals(hash, storedHash.hash)) {
                if (storedHash.type == CREDENTIAL_TYPE_PATTERN) {
                    unlockKeystore(LockPatternUtils.patternByteArrayToBaseZero(credential), userId);
                } else {
                    unlockKeystore(credential, userId);
                }
                // Users with legacy credentials don't have credential-backed
                // FBE keys, so just pass through a fake token/secret
                Slog.i(TAG, ""Unlocking user with fake token: "" + userId);
                final byte[] fakeToken = String.valueOf(userId).getBytes();
                unlockUser(userId, fakeToken, fakeToken);

                // migrate credential to GateKeeper
                setLockCredentialInternal(credential, storedHash.type, null,
                        storedHash.type == CREDENTIAL_TYPE_PATTERN
                                ? DevicePolicyManager.PASSWORD_QUALITY_SOMETHING
                                : DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC
                                /* TODO(roosa): keep the same password quality */,
                        userId, false, /* isLockTiedToParent= */ false);
                if (!hasChallenge) {
                    notifyActivePasswordMetricsAvailable(storedHash.type, credential, userId);
                    // Use credentials to create recoverable keystore snapshot.
                    sendCredentialsOnUnlockIfRequired(storedHash.type, credential, userId);
                    return VerifyCredentialResponse.OK;
                }
                // Fall through to get the auth token. Technically this should never happen,
                // as a user that had a legacy credential would have to unlock their device
                // before getting to a flow with a challenge, but supporting for consistency.
            } else {
                return VerifyCredentialResponse.ERROR;
            }
        }
        GateKeeperResponse gateKeeperResponse = getGateKeeperService()
                .verifyChallenge(userId, challenge, storedHash.hash, credential);
"
678,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"        } catch (NoSuchAlgorithmException | RemoteException e) {
"
679,services/core/java/com/android/server/locksettings/LockSettingsService.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '3a5272699e3e16fbfdc397480898bb27abeb2caa']",2,"    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential("
680,services/core/java/com/android/server/locksettings/LockSettingsService.java,['3a5272699e3e16fbfdc397480898bb27abeb2caa'],1,"    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(String credential) throws RemoteException {
"
681,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(byte[] credential) throws RemoteException {
"
682,services/core/java/com/android/server/locksettings/LockSettingsService.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } catch (RemoteException e) {
            throw new IllegalStateException(""clearUserKeyAuth failed user="" + userId);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(byte[] credential) {
"
683,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"    private void setUserKeyProtection(int userId, byte[] credential, VerifyCredentialResponse vcr)
            throws RemoteException {
"
684,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"    public byte[] getHashFactor(byte[] currentCredential, int userId) throws RemoteException {
"
685,services/core/java/com/android/server/locksettings/LockSettingsService.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '3a5272699e3e16fbfdc397480898bb27abeb2caa', '2051462f672b5986ef321bf1de3657e7653864e8']",3,"    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission."
686,services/core/java/com/android/server/locksettings/LockSettingsService.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '3a5272699e3e16fbfdc397480898bb27abeb2caa']",2,"    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

"
687,services/core/java/com/android/server/locksettings/LockSettingsService.java,['3a5272699e3e16fbfdc397480898bb27abeb2caa'],1,"    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

    private void setKeystorePassword(String password, int userHandle) {
"
688,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1," boolean hasChallenge, long challenge, int userId,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
"
689,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1," boolean isLockTiedToParent) throws RemoteException {
"
690,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1," int userId) throws RemoteException {
"
691,services/core/java/com/android/server/locksettings/LockSettingsService.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '3a5272699e3e16fbfdc397480898bb27abeb2caa', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']",3," {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } "
692,services/core/java/com/android/server/locksettings/LockSettingsService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,",
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
"
693,services/core/java/com/android/server/locksettings/LockSettingsService.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']",4,", 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
"
694,services/core/java/com/android/server/media/MediaSessionRecord.java,"['20b50bcf2cdd722955040b713056399f0ec17bd2', '74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",4,"        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
"
695,services/core/java/com/android/server/net/NetworkPolicyManagerService.java,['6e44ad255823e1b7f2b23386d61af655c19adb49'],1,"                        String.format(""%s %s"", bres.value, bres.units));
"
696,services/core/java/com/android/server/pm/PackageManagerService.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"                    if (mOptionalVerifierPackage != null) {
                        final Intent optionalIntent = new Intent(verification);
                        optionalIntent.setAction(""com.qualcomm.qti.intent.action.PACKAGE_NEEDS_OPTIONAL_VERIFICATION"");
                        final List<ResolveInfo> optional_receivers = queryIntentReceiversInternal(optionalIntent,
                            PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(), false /*allowDynamicSplits*/);
                        final ComponentName optionalVerifierComponent = matchComponentForVerifier(
                            mOptionalVerifierPackage, optional_receivers);
                        optionalIntent.setComponent(optionalVerifierComponent);
                        verificationState.addOptionalVerifier(optionalUid);
                        if (mRequiredVerifierPackage != null) {
                            mContext.sendBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT);
                        } else {
                            mContext.sendOrderedBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,
                            new BroadcastReceiver() {
                                @Override
                                public void onReceive(Context context, Intent intent) {
                                    final Message msg = mHandler.obtainMessage(CHECK_PENDING_VERIFICATION);
                                    msg.arg1 = verificationId;
                                    mHandler.sendMessageDelayed(msg, getVerificationTimeout());
                                }
                            }, null, 0, null, null);

                            /*
                             * We don't want the copy to proceed until
                             * verification succeeds.
                             */
                            mVerificationCompleted = false;
                        }
                    }
                    if (ret == PackageManager.INSTALL_SUCCEEDED
                            && mRequiredVerifierPackage != null) {
                        final ComponentName requiredVerifierComponent = matchComponentForVerifier(
                                mRequiredVerifierPackage, receivers);
                        Trace.asyncTraceBegin(
                                TRACE_TAG_PACKAGE_MANAGER, ""verification"", verificationId);
                        /*
                         * Send the intent to the required verification agent,
                         * but only start the verification timeout after the
                         * target BroadcastReceivers have run.
                         */
                        verification.setComponent(requiredVerifierComponent);
                        idleController.addPowerSaveTempWhitelistApp(Process.myUid(),
                                mRequiredVerifierPackage, idleDuration,
                                verifierUser.getIdentifier(), false, ""package verifier"");
                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,
                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,
                                new BroadcastReceiver() {
                                    @Override
                                    public void onReceive(Context context, Intent intent) {
                                        final Message msg = mHandler
                                                .obtainMessage(CHECK_PENDING_VERIFICATION);
                                        msg.arg1 = verificationId;
                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());
                                    }
                                }, null, 0, null, null);

                        /*
                         * We don't want the copy to proceed until verification
                         * succeeds.
                         */
                        mVerificationCompleted = false;
"
697,services/core/java/com/android/server/pm/PackageManagerService.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"                // TODO: http://b/22976637
                // Apps installed for ""all"" users use the device owner to verify the app
                UserHandle verifierUser = getUser();
                if (verifierUser == UserHandle.ALL) {
                    verifierUser = UserHandle.SYSTEM;
                }

                /*
                 * Determine if we have any installed package verifiers. If we
                 * do, then we'll defer to them to verify the packages.
                 */
                final int requiredUid = mRequiredVerifierPackage == null ? -1
                        : getPackageUid(mRequiredVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING,
                                verifierUser.getIdentifier());

                final int optionalUid = mOptionalVerifierPackage == null ? -1
                        : getPackageUid(mOptionalVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING,
                                verifierUser.getIdentifier());

                final int installerUid =
                        verificationInfo == null ? -1 : verificationInfo.installerUid;
                if (!origin.existing && (requiredUid != -1 || optionalUid != -1)
                        && isVerificationEnabled(
                                verifierUser.getIdentifier(), installFlags, installerUid)) {
                    final Intent verification = new Intent(
                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);
                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),
                            PACKAGE_MIME_TYPE);
                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);

                    // Query all live verifiers based on current user state
                    final List<ResolveInfo> receivers = queryIntentReceiversInternal(verification,
                            PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(),
                            false /*allowDynamicSplits*/);

                    if (DEBUG_VERIFY) {
                        Slog.d(TAG, ""Found "" + receivers.size() + "" verifiers for intent ""
                                + verification.toString() + "" with "" + pkgLite.verifiers.length
                                + "" optional verifiers"");
                    }

                    final int verificationId = mPendingVerificationToken++;

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,
                            installSource.installerPackageName);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,
                            installFlags);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,
                            pkgLite.packageName);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,
                            pkgLite.versionCode);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_LONG_VERSION_CODE,
                            pkgLite.getLongVersionCode());

                    if (verificationInfo != null) {
                        if (verificationInfo.originatingUri != null) {
                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,
                                    verificationInfo.originatingUri);
                        }
                        if (verificationInfo.referrer != null) {
                            verification.putExtra(Intent.EXTRA_REFERRER,
                                    verificationInfo.referrer);
                        }
                        if (verificationInfo.originatingUid >= 0) {
                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,
                                    verificationInfo.originatingUid);
                        }
                        if (verificationInfo.installerUid >= 0) {
                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,
                                    verificationInfo.installerUid);
                        }
                    }

                    final PackageVerificationState verificationState = new PackageVerificationState(
                            requiredUid, this);
"
698,services/core/java/com/android/server/pm/PackageManagerService.java,['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf'],1,"                if (mOptionalVerifierPackage != null) {
                    final Intent optionalIntent = new Intent(verification);
                    optionalIntent.setAction(""com.qualcomm.qti.intent.action.PACKAGE_NEEDS_OPTIONAL_VERIFICATION"");
                    final List<ResolveInfo> optional_receivers = queryIntentReceiversInternal(optionalIntent,
                        PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(), false /*allowDynamicSplits*/);
                    final ComponentName optionalVerifierComponent = matchComponentForVerifier(
                        mOptionalVerifierPackage, optional_receivers);
                    optionalIntent.setComponent(optionalVerifierComponent);
                    verificationState.addOptionalVerifier(optionalUid);
                    if (mRequiredVerifierPackage != null) {
                        mContext.sendBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT);
                    } else {
                        mContext.sendOrderedBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,
                        new BroadcastReceiver() {
                            @Override
                            public void onReceive(Context context, Intent intent) {
                                final Message msg = mHandler.obtainMessage(CHECK_PENDING_VERIFICATION);
                                msg.arg1 = verificationId;
                                mHandler.sendMessageDelayed(msg, getVerificationTimeout());
                            }
                        }, null, 0, null, null);
                        /*
                         * We don't want the copy to proceed until
                         * verification succeeds.
                         */
                        mVerificationCompleted = false;
                    }
                }
"
699,services/core/java/com/android/server/pm/PackageManagerService.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"            // Collect all Regionalization packages form Carrier's res packages.
            if (RegionalizationEnvironment.isSupported()) {
                Log.d(TAG, ""Load Regionalization vendor apks"");
                final List<File> RegionalizationDirs =
                        RegionalizationEnvironment.getAllPackageDirectories();
                for (File f : RegionalizationDirs) {
                    File RegionalizationSystemDir = new File(f, ""system"");
                    // Collect packages in <Package>/system/app
                    scanDirLI(new File(RegionalizationSystemDir, ""app""),
                            PackageParser.PARSE_IS_SYSTEM_DIR,
                            scanFlags
                            | SCAN_AS_SYSTEM,
                            0);
                    // Collect overlay in <Package>/system/vendor
                    scanDirLI(new File(RegionalizationSystemDir, ""vendor/overlay""),
                            PackageParser.PARSE_IS_SYSTEM_DIR,
                            scanFlags
                            | SCAN_AS_SYSTEM
                            | SCAN_AS_VENDOR,
                            0);
                }
            }

"
700,services/core/java/com/android/server/pm/PackageManagerService.java,['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf'],1,"            if (!origin.existing && (requiredUid != -1 || optionalUid != -1)
                    && isVerificationEnabled(
                            pkgLite, verifierUser.getIdentifier(), installFlags, installerUid)) {
"
701,services/core/java/com/android/server/pm/PackageManagerService.java,"['b6d6690a3594cd78966e26508247d4ab1b66776f', '3e8cb98421761bb7dfafe59a22a15fe2e176f272', 'e15313dd5c01373f4e046366a36472a1913e3e39']",3,            if (umInternal.isUserUnlockingOrUnlocked(user
702,services/core/java/com/android/server/pm/PackageManagerService.java,"['b6d6690a3594cd78966e26508247d4ab1b66776f', '3e8cb98421761bb7dfafe59a22a15fe2e176f272', 'e15313dd5c01373f4e046366a36472a1913e3e39']",3,"            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
"
703,services/core/java/com/android/server/pm/PackageManagerService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"        final StorageManager sm = mContext.getSystemService(StorageManager.class);
        final UserManager um = mContext.getSystemService(UserManager.class);
        UserManagerInternal umInternal = getUserManagerInternal();
        for (UserInfo user : um.getUsers()) {
            int flags = 0;
"
704,services/core/java/com/android/server/pm/PackageManagerService.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"        if (DEBUG_INSTALL) Slog.d(TAG, ""New package installed in "" + pkg.codePath);
        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
"
705,services/core/java/com/android/server/pm/PackageManagerService.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']",3,"        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
"
706,services/core/java/com/android/server/pm/PackageManagerService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
        synchronized (mPackages) {
"
707,services/core/java/com/android/server/pm/PackageManagerService.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"        }

        // writer
        synchronized (mPackages) {
            // Remove the parent package
            mPackages.remove(pkg.applicationInfo.packageName);
            cleanPackageDataStructuresLILPw(pkg, chatty);

            // Remove the child packages
            final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = pkg.childPackages.get(i);
                mPackages.remove(childPkg.applicationInfo.packageName);
                cleanPackageDataStructuresLILPw(childPkg, chatty);
            }
        }
    }

    void cleanPackageDataStructuresLILPw(PackageParser.Package pkg, boolean chatty) {
        mComponentResolver.removeAllComponents(pkg, chatty);

        final ArrayList<String> allPackageNames = new ArrayList<>(mPackages.keySet());
        mPermissionManager.removeAllPermissions(pkg, allPackageNames, mPermissionCallback, chatty);

        final int instrumentationSize = pkg.instrumentation.size();
        StringBuilder r = null;
        int i;
        for (i = 0; i < instrumentationSize; i++) {
            PackageParser.Instrumentation a = pkg.instrumentation.get(i);
            mInstrumentation.remove(a.getComponentName());
            if (DEBUG_REMOVE && chatty) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_REMOVE) Log.d(TAG, ""  Instrumentation: "" + r);
        }

        r = null;
        if ((pkg.applicationInfo.flags&ApplicationInfo.FLAG_SYSTEM) != 0) {
            // Only system apps can hold shared libraries.
            if (pkg.libraryNames != null) {
                final int libraryNamesSize = pkg.libraryNames.size();
                for (i = 0; i < libraryNamesSize; i++) {
                    String name = pkg.libraryNames.get(i);
                    if (removeSharedLibraryLPw(name, 0)) {
                        if (DEBUG_REMOVE && chatty) {
                            if (r == null) {
                                r = new StringBuilder(256);
                            } else {
                                r.append(' ');
                            }
                            r.append(name);
                        }
                    }
                }
            }
        }

        r = null;

"
708,services/core/java/com/android/server/pm/PackageManagerService.java,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']",2,");
        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
"
709,services/core/java/com/android/server/pm/PackageManagerService.java,['2edeff882ab756e76b3a028a1568d8774ddc0257'],1,"import com.android.internal.os.IParcelFileDescriptorFactory;
import com.android.internal.os.RegionalizationEnvironment;
"
710,services/core/java/com/android/server/pm/PackageVerificationState.java,['657230bb5e95ec8560c534360cac5a25fd743129'],1,"    public boolean isInstallAllowed() {
        if (mRequiredVerifierUid != -1 && !mRequiredVerificationPassed) {
            return false;
        }

        if (mHasOptionalVerifier && !mOptionalVerificationPassed) {
"
711,services/core/java/com/android/server/pm/PackageVerificationState.java,['657230bb5e95ec8560c534360cac5a25fd743129'],1,"    public boolean isVerificationComplete() {
        if (mRequiredVerifierUid != -1 && !mRequiredVerificationComplete) {
            return false;
        }

        if (mHasOptionalVerifier && !mOptionalVerificationComplete) {
"
712,services/core/java/com/android/server/policy/PhoneWindowManager.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"                        if(SCROLL_BOOST_SS_ENABLE && mPerfBoostFling!= null
                                            && mIsPerfBoostFlingAcquired) {
                            mPerfBoostFling.perfLockRelease();
                            mIsPerfBoostFlingAcquired = false;
                        }
"
713,services/core/java/com/android/server/policy/PhoneWindowManager.java,['8d21ad0d966c1e9f96e5a65144efad2582391957'],1,"        // monitor for system gestures
        // TODO(multi-display): Needs to be display specific.
        mSystemGestures = new SystemGesturesPointerEventListener(context,
                new SystemGesturesPointerEventListener.Callbacks() {
                    @Override
                    public void onSwipeFromTop() {
                        if (mStatusBar != null) {
                            requestTransientBars(mStatusBar);
                        }
                    }
                    @Override
                    public void onSwipeFromBottom() {
                        if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                            requestTransientBars(mNavigationBar);
                        }
                    }
                    @Override
                    public void onSwipeFromRight() {
                        if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                            requestTransientBars(mNavigationBar);
                        }
                    }
                    @Override
                    public void onSwipeFromLeft() {
                        if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                            requestTransientBars(mNavigationBar);
                        }
                    }
                    @Override
                    public void onFling(int duration) {
                        if (mPowerManagerInternal != null) {
                            mPowerManagerInternal.powerHint(
                                    PowerHint.INTERACTION, duration);
                        }
                    }
                    @Override
                    public void onVerticalFling(int duration) {
                        String currentPackage = mContext.getPackageName();
                        boolean isGame = isTopAppGame();
                        if (SCROLL_BOOST_SS_ENABLE && !isGame) {
                            if (mPerfBoostFling == null) {
                                mPerfBoostFling = new BoostFramework();
                                mIsPerfBoostFlingAcquired = false;
                            }
                            if (mPerfBoostFling == null) {
                                Slog.e(TAG, ""Error: boost object null"");
                                return;
                            }

                            mPerfBoostFling.perfHint(BoostFramework.VENDOR_HINT_SCROLL_BOOST,
                                currentPackage, duration + 160, BoostFramework.Scroll.VERTICAL);
                            mIsPerfBoostFlingAcquired = true;
                        }
                    }
                    @Override
                    public void onScroll(boolean started) {
                        String currentPackage = mContext.getPackageName();
                        boolean isGame = isTopAppGame();
                        if (mPerfBoostDrag == null) {
                            mPerfBoostDrag = new BoostFramework();
                        }
                        if (mPerfBoostDrag == null) {
                            Slog.e(TAG, ""Error: boost object null"");
                            return;
                        }
                        if (SCROLL_BOOST_SS_ENABLE && !isGame) {
                            if (mPerfBoostPrefling == null) {
                                mPerfBoostPrefling = new BoostFramework();
                            }
                            if (mPerfBoostPrefling == null) {
                                Slog.e(TAG, ""Error: boost object null"");
                                return;
                            }
                            mPerfBoostPrefling.perfHint(BoostFramework.VENDOR_HINT_SCROLL_BOOST,
                                    currentPackage, -1, BoostFramework.Scroll.PREFILING);
                        }
                        if (!isGame && started) {
                            mPerfBoostDrag.perfHint(BoostFramework.VENDOR_HINT_DRAG_BOOST,
                                            currentPackage, -1, 1);
                        } else {
                            mPerfBoostDrag.perfLockRelease();
                        }
                    }

                    @Override
                    public void onDebug() {
                        // no-op
                    }
                    @Override
                    public void onDown() {
                        mDefaultOrientationListener.onTouchStart();
                        if(SCROLL_BOOST_SS_ENABLE && mPerfBoostFling!= null
                                            && mIsPerfBoostFlingAcquired) {
                            mPerfBoostFling.perfLockRelease();
                            mIsPerfBoostFlingAcquired = false;
                        }
                    }
                    @Override
                    public void onUpOrCancel() {
                        mDefaultOrientationListener.onTouchEnd();
                    }
                    @Override
                    public void onMouseHoverAtTop() {
                        mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
                        Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
                        msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
                        mHandler.sendMessageDelayed(msg, 500);
                    }
                    @Override
                    public void onMouseHoverAtBottom() {
                        mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
                        Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
                        msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
                        mHandler.sendMessageDelayed(msg, 500);
                    }
                    @Override
                    public void onMouseLeaveFromEdge() {
                        mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
                    }
                });
        mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
        //TODO (b/111365687) : make system context per display.
        mWindowManagerFuncs.registerPointerEventListener(mSystemGestures, DEFAULT_DISPLAY);

"
714,services/core/java/com/android/server/policy/PhoneWindowManager.java,['8d21ad0d966c1e9f96e5a65144efad2582391957'],1,"    /**
     * Broadcast Action: WiFi Display video is enabled or disabled
     *
     * <p>The intent will have the following extra values:</p>
     * <ul>
     *    <li><em>state</em> - 0 for disabled, 1 for enabled. </li>
     * </ul>
     */

    private static final String ACTION_WIFI_DISPLAY_VIDEO =
                                        ""org.codeaurora.intent.action.WIFI_DISPLAY_VIDEO"";


    // The panic gesture may become active only after the keyguard is dismissed and the immersive
    // app shows again. If that doesn't happen for 30s we drop the gesture.
    private static final long PANIC_GESTURE_EXPIRATION = 30000;

    private static final String SYSUI_PACKAGE = ""com.android.systemui"";
    private static final String SYSUI_SCREENSHOT_SERVICE =
            ""com.android.systemui.screenshot.TakeScreenshotService"";
    private static final String SYSUI_SCREENSHOT_ERROR_RECEIVER =
            ""com.android.systemui.screenshot.ScreenshotServiceErrorReceiver"";

"
715,services/core/java/com/android/server/policy/PhoneWindowManager.java,['8d21ad0d966c1e9f96e5a65144efad2582391957'],1,"    private final Runnable mHiddenNavPanic = new Runnable() {
        @Override
        public void run() {
            synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
                if (!isUserSetupComplete()) {
                    // Swipe-up for navigation bar is disabled during setup
                    return;
                }
                mPendingPanicGestureUptime = SystemClock.uptimeMillis();
                if (!isNavBarEmpty(mLastSystemUiFlags)) {
                    mNavigationBarController.showTransient();
                }
            }
        }
    };

    private void requestTransientBars(WindowState swipeTarget) {
        synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
            if (!isUserSetupComplete()) {
                // Swipe-up for navigation bar is disabled during setup
                return;
            }
            boolean sb = mStatusBarController.checkShowTransientBarLw();
            boolean nb = mNavigationBarController.checkShowTransientBarLw()
                    && !isNavBarEmpty(mLastSystemUiFlags);
            if (sb || nb) {
                // Don't show status bar when swiping on already visible navigation bar
                if (!nb && swipeTarget == mNavigationBar) {
                    if (DEBUG) Slog.d(TAG, ""Not showing transient bar, wrong swipe target"");
                    return;
                }
                if (sb) mStatusBarController.showTransient();
                if (nb) mNavigationBarController.showTransient();
                mImmersiveModeConfirmation.confirmCurrentPrompt();
                updateSystemUiVisibilityLw();
            }
        }
    }


    BroadcastReceiver mWifiDisplayReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (action.equals(ACTION_WIFI_DISPLAY_VIDEO)) {
                int state = intent.getIntExtra(""state"", 0);
                if(state == 1) {
                    mWifiDisplayConnected = true;
                } else {
                    mWifiDisplayConnected = false;
                }
                mWifiDisplayCustomRotation =
                    intent.getIntExtra(""wfd_UIBC_rot"", -1);
                updateRotation(true);
            }
        }
    };

"
716,services/core/java/com/android/server/policy/PhoneWindowManager.java,['8d21ad0d966c1e9f96e5a65144efad2582391957'],1,"    private static final int MSG_UPDATE_DREAMING_SLEEP_TOKEN = 15;
    private static final int MSG_REQUEST_TRANSIENT_BARS = 16;
    private static final int MSG_SHOW_PICTURE_IN_PICTURE_MENU = 17;
    private static final int MSG_BACK_LONG_PRESS = 18;
    private static final int MSG_DISPOSE_INPUT_CONSUMER = 19;
    private static final int MSG_ACCESSIBILITY_SHORTCUT = 20;
    private static final int MSG_BUGREPORT_TV = 21;
    private static final int MSG_ACCESSIBILITY_TV = 22;
    private static final int MSG_DISPATCH_BACK_KEY_TO_AUTOFILL = 23;
    private static final int MSG_SYSTEM_KEY_PRESS = 24;
    private static final int MSG_HANDLE_ALL_APPS = 25;
    private static final int MSG_LAUNCH_ASSIST = 26;
    private static final int MSG_LAUNCH_ASSIST_LONG_PRESS = 27;
    private static final int MSG_POWER_VERY_LONG_PRESS = 28;
    private static final int MSG_NOTIFY_USER_ACTIVITY = 29;
    private static final int MSG_RINGER_TOGGLE_CHORD = 30;

    private static final int MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS = 0;
    private static final int MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION = 1;
    private boolean mWifiDisplayConnected = false;
    private int mWifiDisplayCustomRotation = -1;
"
717,services/core/java/com/android/server/policy/PhoneWindowManager.java,['8d21ad0d966c1e9f96e5a65144efad2582391957'],1,"import android.util.BoostFramework;
import android.util.ArraySet;
"
718,services/core/java/com/android/server/policy/PhoneWindowManager.java,['8d21ad0d966c1e9f96e5a65144efad2582391957'],1,"import static android.app.WindowConfiguration.ACTIVITY_TYPE_HOME;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_STANDARD;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_RECENTS;
import static android.app.WindowConfiguration.WINDOWING_MODE_FREEFORM;
import static android.app.WindowConfiguration.WINDOWING_MODE_FULLSCREEN;
"
719,services/core/java/com/android/server/statusbar/StatusBarManagerService.java,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']",2,"    @Override
    public void startAssist(Bundle args) {
        enforceStatusBarService();
        if (mBar != null) {
            try {
                mBar.startAssist(args);
            } catch (RemoteException ex) {
"
720,services/core/java/com/android/server/statusbar/StatusBarManagerService.java,['b6292e3e1ba3616eac1032737a91925391d94b92'],1,"import com.android.server.UiThread;
import com.android.server.wm.WindowManagerService;
"
721,services/core/java/com/android/server/wm/ActivityMetricsLogger.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"        final boolean otherWindowModesLaunching =
                mWindowingModeTransitionInfo.size() > 0 && info == null;
        if ((!isLoggableResultCode(resultCode) || launchedActivity == null
                || windowingMode == WINDOWING_MODE_UNDEFINED) && !otherWindowModesLaunching) {
            // Failed to launch or it was not a process switch, so we don't care about the timing.
            abort(info, ""failed to launch or not a process switch"");
"
722,services/core/java/com/android/server/wm/ActivityMetricsLogger.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"    private void logAppTransitionMultiEvents() {
        if (DEBUG_METRICS) Slog.i(TAG, ""logging transition events"");
        for (int index = mWindowingModeTransitionInfo.size() - 1; index >= 0; index--) {
            final WindowingModeTransitionInfo info = mWindowingModeTransitionInfo.valueAt(index);
            final int type = getTransitionType(info);
            if (type == INVALID_TRANSITION_TYPE) {
                if (DEBUG_METRICS) {
                    Slog.i(TAG, ""invalid transition type""
                            + "" processRunning="" + info.currentTransitionProcessRunning
                            + "" startResult="" + info.startResult);
                }
                return;
            }

            mLaunchedActivity = info.launchedActivity;

            // Take a snapshot of the transition info before sending it to the handler for logging.
            // This will avoid any races with other operations that modify the ActivityRecord.
            final WindowingModeTransitionInfoSnapshot infoSnapshot =
                     new WindowingModeTransitionInfoSnapshot(info);
            final int currentTransitionDeviceUptime = mCurrentTransitionDeviceUptime;
            final int currentTransitionDelayMs = mCurrentTransitionDelayMs;
            BackgroundThread.getHandler().post(() -> logAppTransition(
                    currentTransitionDeviceUptime, currentTransitionDelayMs, infoSnapshot));
            BackgroundThread.getHandler().post(() -> logAppDisplayed(infoSnapshot));
            if (info.pendingFullyDrawn != null) {
                info.pendingFullyDrawn.run();
            }

            info.launchedActivity.info.launchToken = null;
"
723,services/core/java/com/android/server/wm/ActivityMetricsLogger.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"import android.util.BoostFramework;
"
724,services/core/java/com/android/server/wm/ActivityRecord.java,"['24818fca475a6726f5ef0cae42149615079af6e9', '71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",3,"
        if (mPerf == null)
            mPerf = new BoostFramework();
"
725,services/core/java/com/android/server/wm/ActivityRecord.java,['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c'],1,"
        return lockTaskLaunchMode;
"
726,services/core/java/com/android/server/wm/ActivityRecord.java,['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c'],1,"            // Gets launch display id from options. It returns INVALID_DISPLAY if not set.
            mHandoverLaunchDisplayId = options.getLaunchDisplayId();
        }

        if (mPerf == null)
            mPerf = new BoostFramework();
    }

    static int getLockTaskLaunchMode(ActivityInfo aInfo, @Nullable ActivityOptions options) {
        int lockTaskLaunchMode = aInfo.lockTaskLaunchMode;
        if (aInfo.applicationInfo.isPrivilegedApp()
                && (lockTaskLaunchMode == LOCK_TASK_LAUNCH_MODE_ALWAYS
                || lockTaskLaunchMode == LOCK_TASK_LAUNCH_MODE_NEVER)) {
            lockTaskLaunchMode = LOCK_TASK_LAUNCH_MODE_DEFAULT;
        }
        if (options != null) {
            final boolean useLockTask = options.getLockTaskMode();
"
727,services/core/java/com/android/server/wm/ActivityRecord.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"            mStackSupervisor.updateHomeProcess(task.getChildAt(0).app);
            try {
                mStackSupervisor.new PreferredAppsTask().execute();
            } catch (Exception e) {
                Slog.v (TAG, ""Exception: "" + e);
            }
"
728,services/core/java/com/android/server/wm/ActivityRecord.java,"['b03d6d43646266d456c22154a1f6fd945bf79f83', '71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']",3,"        if (mPerf == null)
            mPerf = new BoostFramework();
"
729,services/core/java/com/android/server/wm/ActivityRecord.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        launching = false;
        final ActivityStack stack = getActivityStack();
        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0
                || (info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0) {
"
730,services/core/java/com/android/server/wm/ActivityRecord.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    /** Called when the windows associated app window container are visible. */
    public void onWindowsVisible() {
        synchronized (mAtmService.mGlobalLock) {
            mStackSupervisor.stopWaitingForActivityVisible(this);
            if (DEBUG_SWITCH) Log.v(TAG_SWITCH, ""windowsVisibleLocked(): "" + this);
            if (!nowVisible) {
                nowVisible = true;
                launching = false;
                lastVisibleTime = SystemClock.uptimeMillis();
                mAtmService.scheduleAppGcsLocked();
            }
        }
    }

    /** Called when the windows associated app window container are no longer visible. */
    public void onWindowsGone() {
        synchronized (mAtmService.mGlobalLock) {
            if (DEBUG_SWITCH) Log.v(TAG_SWITCH, ""windowsGone(): "" + this);
            nowVisible = false;
            launching = false;
"
731,services/core/java/com/android/server/wm/ActivityRecord.java,['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c'],1,"    boolean sleeping;       // have we told the activity to sleep?
    public boolean launching;      // is activity launch in progress?
"
732,services/core/java/com/android/server/wm/ActivityRecord.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    public BoostFramework mPerf = null;
    public BoostFramework mPerf_iop = null;

    // A hint to override the window specified rotation animation, or -1
    // to use the window specified value. We use this so that
    // we can select the right animation in the cases of starting
    // windows, where the app hasn't had time to set a value
    // on the window.
    int mRotationAnimationHint = -1;
"
733,services/core/java/com/android/server/wm/ActivityRecord.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    public final String packageName; // the package implementing intent's component
"
734,services/core/java/com/android/server/wm/ActivityRecord.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"    public int isAppInfoGame() {
        int isGame = 0;
        if (info.applicationInfo != null) {
            isGame = (info.applicationInfo.category == ApplicationInfo.CATEGORY_GAME ||
                      (info.applicationInfo.flags & ApplicationInfo.FLAG_IS_GAME) == ApplicationInfo.FLAG_IS_GAME) ? 1 : 0;
        }
        return isGame;
    }

    /**
     * Creates a layer to apply crop to an animation.
     */
    private SurfaceControl createAnimationBoundsLayer(Transaction t) {
        ProtoLog.i(WM_DEBUG_APP_TRANSITIONS_ANIM, ""Creating animation bounds layer"");
        final SurfaceControl.Builder builder = makeAnimationLeash()
                .setParent(getAnimationLeashParent())
                .setName(getSurfaceControl() + "" - animation-bounds"");
        final SurfaceControl boundsLayer = builder.build();
        t.show(boundsLayer);
        return boundsLayer;
"
735,services/core/java/com/android/server/wm/ActivityRecord.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"    public int isAppInfoGame() {
        int isGame = 0;
        if (info.applicationInfo != null) {
            isGame = (info.applicationInfo.category == ApplicationInfo.CATEGORY_GAME ||
                      (info.applicationInfo.flags & ApplicationInfo.FLAG_IS_GAME) == ApplicationInfo.FLAG_IS_GAME) ? 1 : 0;
        }
        return isGame;
    }

    @Override
    boolean isChangingAppTransition() {
        return task != null ? task.isChangingAppTransition() : super.isChangingAppTransition();
    }

"
736,services/core/java/com/android/server/wm/ActivityRecord.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"    public int perfActivityBoostHandler = -1; //perflock handler when activity is created.
    private TaskRecord task;        // the task this is in.
"
737,services/core/java/com/android/server/wm/ActivityRecord.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    void completeResumeLocked() {
        final boolean wasVisible = visible;
        setVisible(true);
        if (!wasVisible) {
            // Visibility has changed, so take a note of it so we call the TaskStackChangedListener
            mStackSupervisor.mAppVisibilitiesChangedSinceLastPause = true;
        }
        idle = false;
        results = null;
        newIntents = null;
        stopped = false;

        if (isActivityTypeHome()) {
            mStackSupervisor.updateHomeProcess(task.mActivities.get(0).app);
            try {
                mStackSupervisor.new PreferredAppsTask().execute();
            } catch (Exception e) {
                Slog.v (TAG, ""Exception: "" + e);
            }
        }
        if (nowVisible) {
            mStackSupervisor.stopWaitingForActivityVisible(this);
"
738,services/core/java/com/android/server/wm/ActivityRecord.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    void stopIfPossible() {
        if (DEBUG_SWITCH) Slog.d(TAG_SWITCH, ""Stopping: "" + this);
        launching = false;
        final ActivityStack stack = getActivityStack();
        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0
                || (info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0) {
            if (!finishing) {
                if (!stack.shouldSleepActivities()) {
                    if (DEBUG_STATES) Slog.d(TAG_STATES, ""no-history finish of "" + this);
                    if (finishIfPossible(""stop-no-history"", false /* oomAdj */)
                            != FINISH_RESULT_CANCELLED) {
                        resumeKeyDispatchingLocked();
                        return;
                    }
                } else {
                    if (DEBUG_STATES) {
                        Slog.d(TAG_STATES, ""Not finishing noHistory "" + this
                                + "" on stop because we're just sleeping"");
                    }
                }
            }
        }
"
739,services/core/java/com/android/server/wm/ActivityRecord.java,"['3933f277a025be704e68ea593536e492831a7e05', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']",2," // have we told the activity to sleep?
    public boolean launching;      // is activity launch in progress?
"
740,services/core/java/com/android/server/wm/ActivityRecord.java,"['ac442e0398fe7344f66cbbd4d2af15b1bfdbf46b', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']",2,").app);
            try {
                mStackSupervisor.new PreferredAppsTask().execute();
            } catch (Exception e) {
                Slog.v (TAG, ""Exception: "" + e);
            }
"
741,services/core/java/com/android/server/wm/ActivityRecord.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '784ecc8e9194775f58ad5a45422ed16570bcbee6']",2,"import android.util.BoostFramework;
"
742,services/core/java/com/android/server/wm/ActivityRecord.java,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '8d21ad0d966c1e9f96e5a65144efad2582391957']",2,public final class ActivityRecord extends ConfigurationContainer 
743,services/core/java/com/android/server/wm/ActivityRecord.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"public final class ActivityRecord extends ConfigurationContainer {
"
744,services/core/java/com/android/server/wm/ActivityStack.java,['24f36fd2514856aaafe6a32a99050e272a6bd361'],1,"        final DisplayContent dc = display.mDisplayContent;
        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
"
745,services/core/java/com/android/server/wm/ActivityStack.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"        final DisplayContent dc = getDisplay().mDisplayContent;
        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
"
746,services/core/java/com/android/server/wm/ActivityStack.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4']",2,"        if (mActivityPluginDelegate != null) {
            mActivityPluginDelegate.activityInvokeNotification
                (r.appInfo.packageName, r.fullscreen);
        }

        if (!isHomeOrRecentsStack() || numActivities() > 0) {
"
747,services/core/java/com/android/server/wm/ActivityStack.java,['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c'],1,"        mStackSupervisor.mGoingToSleepActivities.remove(next);
        next.sleeping = false;
        next.launching = true;
"
748,services/core/java/com/android/server/wm/ActivityStack.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"        return stack;
    }

    final void stopActivityLocked(ActivityRecord r) {
        if (DEBUG_SWITCH) Slog.d(TAG_SWITCH, ""Stopping: "" + r);
        r.launching = false;
        if ((r.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_HISTORY) != 0
                || (r.info.flags&ActivityInfo.FLAG_NO_HISTORY) != 0) {
            if (!r.finishing) {
                if (!shouldSleepActivities()) {
                    if (DEBUG_STATES) Slog.d(TAG_STATES, ""no-history finish of "" + r);
                    if (r.finishIfPossible(""stop-no-history"", false /* oomAdj */)
                            != FINISH_RESULT_CANCELLED) {
                        // {@link adjustFocusedActivityStack} must have been already called.
                        r.resumeKeyDispatchingLocked();
                        return;
                    }
                } else {
                    if (DEBUG_STATES) Slog.d(TAG_STATES, ""Not finishing noHistory "" + r
                            + "" on stop because we're just sleeping"");
                }
            }
        }

        if (r.attachedToProcess()) {
            adjustFocusedActivityStack(r, ""stopActivity"");
            r.resumeKeyDispatchingLocked();
            try {
                r.stopped = false;

                if (DEBUG_STATES) Slog.v(TAG_STATES,
                        ""Moving to STOPPING: "" + r + "" (stop requested)"");
                r.setState(STOPPING, ""stopActivityLocked"");

                if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
                    mActivityPluginDelegate.activitySuspendNotification
                        (r.info.applicationInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
                }
                if (DEBUG_VISIBILITY) Slog.v(TAG_VISIBILITY,
                        ""Stopping visible="" + r.visible + "" for "" + r);

                if (mActivityTrigger != null) {
                    mActivityTrigger.activityStopTrigger(r.intent, r.info, r.info.applicationInfo);
                }

                if (!r.visible) {
                    r.setVisible(false);
                }
                EventLogTags.writeAmStopActivity(
                        r.mUserId, System.identityHashCode(r), r.shortComponentName);
                mService.getLifecycleManager().scheduleTransaction(r.app.getThread(), r.appToken,
                        StopActivityItem.obtain(r.visible, r.configChangeFlags));
                if (shouldSleepOrShutDownActivities()) {
                    r.setSleeping(true);
                }
                Message msg = mHandler.obtainMessage(STOP_TIMEOUT_MSG, r);
                mHandler.sendMessageDelayed(msg, STOP_TIMEOUT);
            } catch (Exception e) {
                // Maybe just ignore exceptions here...  if the process
                // has crashed, our death notification will clean things
                // up.
                Slog.w(TAG, ""Exception thrown during pause"", e);
                // Just in case, assume it to be stopped.
                r.stopped = true;
                if (DEBUG_STATES) Slog.v(TAG_STATES, ""Stop failed; moving to STOPPED: "" + r);
                r.setState(STOPPED, ""stopActivityLocked"");
                if (r.deferRelaunchUntilPaused) {
                    destroyActivityLocked(r, true, ""stop-except"");
                }
            }
"
749,services/core/java/com/android/server/wm/ActivityStack.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"        task.setFrontOfTask();

        if (mActivityPluginDelegate != null) {
            mActivityPluginDelegate.activityInvokeNotification
                (r.appInfo.packageName, r.fullscreen);
        }

        if (!isHomeOrRecentsStack() || numActivities() > 0) {
"
750,services/core/java/com/android/server/wm/ActivityStack.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"    @Override
    public int setBounds(Rect bounds) {
        return super.setBounds(!inMultiWindowMode() ? null : bounds);
    }

    public ActivityRecord topRunningActivityLocked() {
"
751,services/core/java/com/android/server/wm/ActivityStack.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"    @Override
    void getAnimationFrames(Rect outFrame, Rect outInsets, Rect outStableInsets,
            Rect outSurfaceInsets) {
        final Task task = getTopMostTask();
        if (task != null) {
            task.getAnimationFrames(outFrame, outInsets, outStableInsets, outSurfaceInsets);
        } else {
            super.getAnimationFrames(outFrame, outInsets, outStableInsets, outSurfaceInsets);
        }
    }

    @Override
    RemoteAnimationTarget createRemoteAnimationTarget(
            RemoteAnimationController.RemoteAnimationRecord record) {
        final Task task = getTopMostTask();
        return task != null ? task.createRemoteAnimationTarget(record) : null;
    }

    public void onARStopTriggered(ActivityRecord r) {
        if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
                            mActivityPluginDelegate.activitySuspendNotification
                                (r.info.applicationInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
                        }
    }

    @Override
    public String toString() {
        return ""ActivityStack{"" + Integer.toHexString(System.identityHashCode(this))
                + "" stackId="" + mStackId + "" type="" + activityTypeToString(getActivityType())
                + "" mode="" + windowingModeToString(getWindowingMode())
                + "" visible="" + shouldBeVisible(null /* starting */)
                + "" translucent="" + isStackTranslucent(null /* starting */)
                + "", ""
                + getChildCount() + "" tasks}"";
    }

"
752,services/core/java/com/android/server/wm/ActivityStack.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"    final ActivityTaskManagerService mAtmService;

    public BoostFramework mPerf = null;

    /**
     * When we are in the process of pausing an activity, before starting the
     * next one, this variable holds the activity that is currently being paused.
     */
    ActivityRecord mPausingActivity = null;

    /**
     * This is the last activity that we put into the paused state.  This is
     * used to determine if we need to do an activity transition while sleeping,
     * when we normally hold the top activity paused.
     */
    ActivityRecord mLastPausedActivity = null;

    /**
     * Activities that specify No History must be removed once the user navigates away from them.
     * If the device goes to sleep with such an activity in the paused state then we save it here
     * and finish it later if another activity replaces it on wakeup.
     */
    ActivityRecord mLastNoHistoryActivity = null;

    /**
     * Current activity that is resumed, or null if there is none.
     */
    ActivityRecord mResumedActivity = null;

"
753,services/core/java/com/android/server/wm/ActivityStack.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"    final ActivityTaskManagerService mService;
    final WindowManagerService mWindowManager;

    public BoostFramework mPerf = null;
    /**
     * List of running activities, sorted by recent usage.
     * The first entry in the list is the least recently used.
     * It contains HistoryRecord objects.
     */
    private final ArrayList<ActivityRecord> mLruActivities = new ArrayList<>();
"
754,services/core/java/com/android/server/wm/ActivityStack.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"    final boolean finishActivityAffinityLocked(ActivityRecord r) {
        ArrayList<ActivityRecord> activities = r.getTaskRecord().mActivities;
        for (int index = activities.indexOf(r); index >= 0; --index) {
            ActivityRecord cur = activities.get(index);
            if (!Objects.equals(cur.taskAffinity, r.taskAffinity)) {
                break;
            }
            finishActivityLocked(cur, Activity.RESULT_CANCELED, null, ""request-affinity"", true);
        }
        return true;
    }

    private void finishActivityResultsLocked(ActivityRecord r, int resultCode, Intent resultData) {
        // send the result
        ActivityRecord resultTo = r.resultTo;
        if (resultTo != null) {
            if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, ""Adding result to "" + resultTo
                    + "" who="" + r.resultWho + "" req="" + r.requestCode
                    + "" res="" + resultCode + "" data="" + resultData);
            if (resultTo.mUserId != r.mUserId) {
                if (resultData != null) {
                    resultData.prepareToLeaveUser(r.mUserId);
                }
            }
            if (r.info.applicationInfo.uid > 0) {
                mService.mUgmInternal.grantUriPermissionFromIntent(r.info.applicationInfo.uid,
                        resultTo.packageName, resultData,
                        resultTo.getUriPermissionsLocked(), resultTo.mUserId);
            }
            resultTo.addResultLocked(r, r.resultWho, r.requestCode, resultCode, resultData);
            r.resultTo = null;
        }
        else if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, ""No result destination from "" + r);

        // Make sure this HistoryRecord is not holding on to other resources,
        // because clients have remote IPC references to this object so we
        // can't assume that will go away and want to avoid circular IPC refs.
        r.results = null;
        r.pendingResults = null;
        r.newIntents = null;
        r.icicle = null;
    }

    /**
     * See {@link #finishActivityLocked(ActivityRecord, int, Intent, String, boolean, boolean)}
     */
    final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData,
            String reason, boolean oomAdj) {
        return finishActivityLocked(r, resultCode, resultData, reason, oomAdj, !PAUSE_IMMEDIATELY);
    }

    /**
     * @return Returns true if this activity has been removed from the history
     * list, or false if it is still in the list and will be removed later.
     */
    final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData,
            String reason, boolean oomAdj, boolean pauseImmediately) {
        if (r.finishing) {
            Slog.w(TAG, ""Duplicate finish request for "" + r);
            return false;
        }

        mWindowManager.deferSurfaceLayout();
        try {
            r.makeFinishingLocked();
            final TaskRecord task = r.getTaskRecord();
            EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,
                    r.mUserId, System.identityHashCode(r),
                    task.taskId, r.shortComponentName, reason);
            final ArrayList<ActivityRecord> activities = task.mActivities;
            final int index = activities.indexOf(r);
            if (index < (activities.size() - 1)) {
                task.setFrontOfTask();
                if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) {
                    // If the caller asked that this activity (and all above it)
                    // be cleared when the task is reset, don't lose that information,
                    // but propagate it up to the next activity.
                    ActivityRecord next = activities.get(index+1);
                    next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
                }
            }

            r.pauseKeyDispatchingLocked();

            adjustFocusedActivityStack(r, ""finishActivity"");

            finishActivityResultsLocked(r, resultCode, resultData);

            final boolean endTask = index <= 0 && !task.isClearingToReuseTask();
            final int transit = endTask ? TRANSIT_TASK_CLOSE : TRANSIT_ACTIVITY_CLOSE;
            if (mResumedActivity == r) {
                if (DEBUG_VISIBILITY || DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,
                        ""Prepare close transition: finishing "" + r);
                if (endTask) {
                    mService.getTaskChangeNotificationController().notifyTaskRemovalStarted(
                            task.getTaskInfo());
                }
                getDisplay().mDisplayContent.prepareAppTransition(transit, false);

                // Tell window manager to prepare for this one to be removed.
                r.setVisibility(false);

                if (mPausingActivity == null) {
                    if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, ""Finish needs to pause: "" + r);
                    if (DEBUG_USER_LEAVING) Slog.v(TAG_USER_LEAVING,
                            ""finish() => pause with userLeaving=false"");
                    startPausingLocked(false, false, null, pauseImmediately);
                }

                if (endTask) {
                    mService.getLockTaskController().clearLockedTask(task);
                }
            } else if (!r.isState(PAUSING)) {
                // If the activity is PAUSING, we will complete the finish once
                // it is done pausing; else we can just directly finish it here.
                if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, ""Finish not pausing: "" + r);
                if (r.visible) {
                    prepareActivityHideTransitionAnimation(r, transit);
                }

                final int finishMode = (r.visible || r.nowVisible) ? FINISH_AFTER_VISIBLE
                        : FINISH_AFTER_PAUSE;
                final boolean removedActivity = finishCurrentActivityLocked(r, finishMode, oomAdj,
                        ""finishActivityLocked"") == null;

                // The following code is an optimization. When the last non-task overlay activity
                // is removed from the task, we remove the entire task from the stack. However,
                // since that is done after the scheduled destroy callback from the activity, that
                // call to change the visibility of the task overlay activities would be out of
                // sync with the activitiy visibility being set for this finishing activity above.
                // In this case, we can set the visibility of all the task overlay activities when
                // we detect the last one is finishing to keep them in sync.
                if (task.onlyHasTaskOverlayActivities(true /* excludeFinishing */)) {
                    for (ActivityRecord taskOverlay : task.mActivities) {
                        if (!taskOverlay.mTaskOverlay) {
                            continue;
                        }
                        prepareActivityHideTransitionAnimation(taskOverlay, transit);
                    }
                }
                return removedActivity;
            } else {
                if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, ""Finish waiting for pause of: "" + r);
            }

            return false;
        } finally {
            mWindowManager.continueSurfaceLayout();
        }
    }

    private void prepareActivityHideTransitionAnimation(ActivityRecord r, int transit) {
        final DisplayContent dc = getDisplay().mDisplayContent;
        dc.prepareAppTransition(transit, false);
        r.setVisibility(false);
        dc.executeAppTransition();
    }

    static final int FINISH_IMMEDIATELY = 0;
    static final int FINISH_AFTER_PAUSE = 1;
    static final int FINISH_AFTER_VISIBLE = 2;

    final ActivityRecord finishCurrentActivityLocked(ActivityRecord r, int mode, boolean oomAdj,
            String reason) {
        // First things first: if this activity is currently visible,
        // and the resumed activity is not yet visible, then hold off on
        // finishing until the resumed one becomes visible.

        // The activity that we are finishing may be over the lock screen. In this case, we do not
        // want to consider activities that cannot be shown on the lock screen as running and should
        // proceed with finishing the activity if there is no valid next top running activity.
        // Note that if this finishing activity is floating task, we don't need to wait the
        // next activity resume and can destroy it directly.
        final ActivityDisplay display = getDisplay();
        final ActivityRecord next = display.topRunningActivity(true /* considerKeyguardState */);
        final boolean isFloating = r.getConfiguration().windowConfiguration.tasksAreFloating();

        if (mode == FINISH_AFTER_VISIBLE && (r.visible || r.nowVisible)
                && next != null && !next.nowVisible && !isFloating) {
            if (!mStackSupervisor.mStoppingActivities.contains(r)) {
                addToStopping(r, false /* scheduleIdle */, false /* idleDelayed */,
                        ""finishCurrentActivityLocked"");
            }
            if (DEBUG_STATES) Slog.v(TAG_STATES,
                    ""Moving to STOPPING: ""+ r + "" (finish requested)"");
            if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
                mActivityPluginDelegate.activitySuspendNotification
                    (r.appInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
            }
            r.setState(STOPPING, ""finishCurrentActivityLocked"");
            if (oomAdj) {
                mService.updateOomAdj();
            }
            return r;
        }

        // make sure the record is cleaned out of other places.
        mStackSupervisor.mStoppingActivities.remove(r);
        mStackSupervisor.mGoingToSleepActivities.remove(r);
        final ActivityState prevState = r.getState();
        if (DEBUG_STATES) Slog.v(TAG_STATES, ""Moving to FINISHING: "" + r);

        if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
            mActivityPluginDelegate.activitySuspendNotification
                (r.appInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
        }

        r.setState(FINISHING, ""finishCurrentActivityLocked"");

        // Don't destroy activity immediately if the display contains home stack, although there is
        // no next activity at the moment but another home activity should be started later. Keep
        // this activity alive until next home activity is resumed then user won't see a temporary
        // black screen.
        final boolean noRunningStack = next == null && display.topRunningActivity() == null
                && display.getHomeStack() == null;
        final boolean noFocusedStack = r.getActivityStack() != display.getFocusedStack();
        final boolean finishingInNonFocusedStackOrNoRunning = mode == FINISH_AFTER_VISIBLE
                && prevState == PAUSED && (noFocusedStack || noRunningStack);

        if (mode == FINISH_IMMEDIATELY
                || (prevState == PAUSED
                    && (mode == FINISH_AFTER_PAUSE || inPinnedWindowingMode()))
                || finishingInNonFocusedStackOrNoRunning
                || prevState == STOPPING
                || prevState == STOPPED
                || prevState == ActivityState.INITIALIZING) {
            r.makeFinishingLocked();
            boolean activityRemoved = destroyActivityLocked(r, true, ""finish-imm:"" + reason);

            if (finishingInNonFocusedStackOrNoRunning) {
                // Finishing activity that was in paused state and it was in not currently focused
                // stack, need to make something visible in its place. Also if the display does not
                // have running activity, the configuration may need to be updated for restoring
                // original orientation of the display.
                mRootActivityContainer.ensureVisibilityAndConfig(next, mDisplayId,
                        false /* markFrozenIfConfigChanged */, true /* deferResume */);
            }
            if (activityRemoved) {
                mRootActivityContainer.resumeFocusedStacksTopActivities();
            }
            if (DEBUG_CONTAINERS) Slog.d(TAG_CONTAINERS,
                    ""destroyActivityLocked: finishCurrentActivityLocked r="" + r +
                    "" destroy returned removed="" + activityRemoved);
            return activityRemoved ? null : r;
        }

        // Need to go through the full pause cycle to get this
        // activity into the stopped state and then finish it.
        if (DEBUG_ALL) Slog.v(TAG, ""Enqueueing pending finish: "" + r);
        mStackSupervisor.mFinishingActivities.add(r);
        r.resumeKeyDispatchingLocked();
        mRootActivityContainer.resumeFocusedStacksTopActivities();
        // If activity was not paused at this point - explicitly pause it to start finishing
        // process. Finishing will be completed once it reports pause back.
        if (r.isState(RESUMED) && mPausingActivity != null) {
            startPausingLocked(false /* userLeaving */, false /* uiSleeping */, next /* resuming */,
                    false /* dontWait */);
        }
        return r;
    }

    void finishAllActivitiesLocked(boolean immediately) {
"
755,services/core/java/com/android/server/wm/ActivityStack.java,['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0'],1,"    public ActivityRecord topRunningActivity() {
        return topRunningActivity(false /* focusableOnly */);
    }

    ActivityRecord topRunningActivity(boolean focusableOnly) {
        // Split into 2 to avoid object creation due to variable capture.
        if (focusableOnly) {
            return getActivity((r) -> r.canBeTopRunning() && r.isFocusable());
        } else {
            return getActivity(ActivityRecord::canBeTopRunning);
        }
    }

    private ActivityRecord topRunningNonOverlayTaskActivity() {
        return getActivity((r) -> (r.canBeTopRunning() && !r.isTaskOverlay()));
    }

    ActivityRecord topRunningNonDelayedActivityLocked(ActivityRecord notTop) {
        final PooledPredicate p = PooledLambda.obtainPredicate(ActivityStack::isTopRunningNonDelayed
                , PooledLambda.__(ActivityRecord.class), notTop);
        final ActivityRecord r = getActivity(p);
        p.recycle();
        return r;
    }

    private static boolean isTopRunningNonDelayed(ActivityRecord r, ActivityRecord notTop) {
        return !r.delayedResume && r != notTop && r.canBeTopRunning();
    }

    /**
     * This is a simplified version of topRunningActivity that provides a number of
     * optional skip-over modes.  It is intended for use with the ActivityController hook only.
     *
     * @param token If non-null, any history records matching this token will be skipped.
     * @param taskId If non-zero, we'll attempt to skip over records with the same task ID.
     *
     * @return Returns the HistoryRecord of the next activity on the stack.
     */
    ActivityRecord topRunningActivity(IBinder token, int taskId) {
        final PooledPredicate p = PooledLambda.obtainPredicate(ActivityStack::isTopRunning,
                PooledLambda.__(ActivityRecord.class), taskId, token);
        final ActivityRecord r = getActivity(p);
        p.recycle();
        return r;
    }

    private static boolean isTopRunning(ActivityRecord r, int taskId, IBinder notTop) {
        return r.getTask().mTaskId != taskId && r.appToken != notTop && r.canBeTopRunning();
    }

    ActivityRecord isInStackLocked(ActivityRecord r) {
        if (r == null) {
            return null;
        }
        final Task task = r.getRootTask();
        if (task != null && r.isDescendantOf(task)) {
            if (task != this) Slog.w(TAG, ""Illegal state! task does not point to stack it is in. ""
                    + ""stack="" + this + "" task="" + task + "" r="" + r
                    + "" callers="" + Debug.getCallers(15, ""\n""));
            return r;
        }
        return null;
    }

"
756,services/core/java/com/android/server/wm/ActivityStack.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"    public ActivityRecord topRunningActivityLocked() {
        return topRunningActivityLocked(false /* focusableOnly */);
"
757,services/core/java/com/android/server/wm/ActivityStack.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '24f36fd2514856aaafe6a32a99050e272a6bd361']",2,".mDisplayContent;
        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
"
758,services/core/java/com/android/server/wm/ActivityStack.java,['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0'],1,"import android.view.SurfaceControl;
import com.android.internal.app.ActivityTrigger;

"
759,services/core/java/com/android/server/wm/ActivityStack.java,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']",2,"import com.android.internal.app.ActivityTrigger;

"
760,services/core/java/com/android/server/wm/ActivityStack.java,"['edb6252578f9b76151e5125a7fb1b16823a68418', '5358a994b854c7a6627858c48d6947e8acff6ea9']",2,public class ActivityStack extends 
761,services/core/java/com/android/server/wm/ActivityStack.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"public class ActivityStack extends ConfigurationContainer {
"
762,services/core/java/com/android/server/wm/ActivityStack.java,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '8faa0d981413f18b2468dde1b1fe71e248df0df1']",2,public class ActivityStack extends Task
763,services/core/java/com/android/server/wm/ActivityStack.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"public class ActivityStack extends Task implements BoundsAnimationTarget {
"
764,services/core/java/com/android/server/wm/ActivityStack.java,['5358a994b854c7a6627858c48d6947e8acff6ea9'],1,"public class ActivityStack extends TaskStack {
"
765,services/core/java/com/android/server/wm/ActivityStack.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"public class ActivityStack extends WindowContainer<Task> implements BoundsAnimationTarget,
        ConfigurationContainerListener {
"
766,services/core/java/com/android/server/wm/ActivityStack.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"public class ActivityStack extends WindowContainer<WindowContainer> implements BoundsAnimationTarget {
"
767,services/core/java/com/android/server/wm/ActivityStackSupervisor.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"    public RootActivityContainer mRootActivityContainer;
"
768,services/core/java/com/android/server/wm/ActivityStackSupervisor.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"    static final int TOP_RESUMED_STATE_LOSS_TIMEOUT = 500;

    static final int IDLE_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG;
    static final int IDLE_NOW_MSG = FIRST_SUPERVISOR_STACK_MSG + 1;
    static final int RESUME_TOP_ACTIVITY_MSG = FIRST_SUPERVISOR_STACK_MSG + 2;
    static final int SLEEP_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 3;
    static final int LAUNCH_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 4;

    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = new BoostFramework();
    public BoostFramework mUxPerf = new BoostFramework();

    static final int LAUNCH_TASK_BEHIND_COMPLETE = FIRST_SUPERVISOR_STACK_MSG + 12;
    static final int RESTART_ACTIVITY_PROCESS_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 13;
    static final int REPORT_MULTI_WINDOW_MODE_CHANGED_MSG = FIRST_SUPERVISOR_STACK_MSG + 14;
    static final int REPORT_PIP_MODE_CHANGED_MSG = FIRST_SUPERVISOR_STACK_MSG + 15;
    static final int REPORT_HOME_CHANGED_MSG = FIRST_SUPERVISOR_STACK_MSG + 16;
    static final int TOP_RESUMED_STATE_LOSS_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 17;
"
769,services/core/java/com/android/server/wm/ActivityStackSupervisor.java,"['edb6252578f9b76151e5125a7fb1b16823a68418', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,"import static com.android.server.wm.ActivityStack.ActivityState.DESTROYED;
"
770,services/core/java/com/android/server/wm/ActivityStackSupervisor.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"import static com.android.server.wm.ActivityStack.ActivityState.DESTROYED;
import static com.android.server.wm.ActivityStack.REMOVE_TASK_MODE_MOVING;
"
771,services/core/java/com/android/server/wm/ActivityStarter.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"            final TaskRecord taskToAffiliate = (mLaunchTaskBehind && mSourceRecord != null)
                    ? mSourceRecord.getTaskRecord() : null;
            String packageName= mService.mContext.getPackageName();
            if (mPerf != null) {
                mStartActivity.perfActivityBoostHandler =
                    mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                        packageName, -1, BoostFramework.Launch.BOOST_V1);
            }
"
772,services/core/java/com/android/server/wm/ActivityStarter.java,"['edb6252578f9b76151e5125a7fb1b16823a68418', '8d21ad0d966c1e9f96e5a65144efad2582391957']",2,"        String packageName= mService.mContext.getPackageName();
        if (mPerf != null) {
            mStartActivity.perfActivityBoostHandler =
                mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                    packageName, -1, BoostFramework.Launch.BOOST_V1);
        }
        "
773,services/core/java/com/android/server/wm/ActivityStarter.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"        boolean newTask = false;
        final TaskRecord taskToAffiliate = (mLaunchTaskBehind && mSourceRecord != null)
                ? mSourceRecord.getTaskRecord() : null;

        // Should this be considered a new task?
        int result = START_SUCCESS;
        if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask
                && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {
            newTask = true;
            String packageName= mService.mContext.getPackageName();
            if (mPerf != null) {
                mStartActivity.perfActivityBoostHandler =
                    mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                        packageName, -1, BoostFramework.Launch.BOOST_V1);
            }
            result = setTaskFromReuseOrCreateNewTask(taskToAffiliate);
        } else if (mSourceRecord != null) {
            result = setTaskFromSourceRecord();
        } else if (mInTask != null) {
            result = setTaskFromInTask();
        } else {
            // This not being started from an existing activity, and not part of a new task...
            // just put it in the top task, though these days this case should never happen.
            result = setTaskToCurrentTopOrCreateNewTask();
"
774,services/core/java/com/android/server/wm/ActivityStarter.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"    private int setTaskFromSourceRecord() {
        if (mService.getLockTaskController().isLockTaskModeViolation(
                mSourceRecord.getTaskRecord())) {
            Slog.e(TAG, ""Attempted Lock Task Mode violation mStartActivity="" + mStartActivity);
            return START_RETURN_LOCK_TASK_MODE_VIOLATION;
        }
        String packageName= mService.mContext.getPackageName();
        if (mPerf != null) {
            mStartActivity.perfActivityBoostHandler =
                mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                    packageName, -1, BoostFramework.Launch.BOOST_V1);
        }

        final TaskRecord sourceTask = mSourceRecord.getTaskRecord();
        final ActivityStack sourceStack = mSourceRecord.getActivityStack();
        if (mRestrictedBgActivity && !sourceTask.containsAppUid(mCallingUid)) {
            if (handleBackgroundActivityAbort(mStartActivity)) {
                return START_ABORTED;
            }
        }
        // We only want to allow changing stack in two cases:
        // 1. If the target task is not the top one. Otherwise we would move the launching task to
        //    the other side, rather than show two side by side.
        // 2. If activity is not allowed on target display.
        final int targetDisplayId = mTargetStack != null ? mTargetStack.mDisplayId
                : sourceStack.mDisplayId;
        final boolean moveStackAllowed = sourceStack.topTask() != sourceTask
                || !mStartActivity.canBeLaunchedOnDisplay(targetDisplayId);
        if (moveStackAllowed) {
            mTargetStack = getLaunchStack(mStartActivity, mLaunchFlags,
                    mStartActivity.getTaskRecord(), mOptions);
            // If target stack is not found now - we can't just rely on the source stack, as it may
            // be not suitable. Let's check other displays.
            if (mTargetStack == null && targetDisplayId != sourceStack.mDisplayId) {
                // Can't use target display, lets find a stack on the source display.
                mTargetStack = mRootActivityContainer.getValidLaunchStackOnDisplay(
                        sourceStack.mDisplayId, mStartActivity, mOptions, mLaunchParams);
            }
            if (mTargetStack == null) {
                // There are no suitable stacks on the target and source display(s). Look on all
                // displays.
                mTargetStack = mRootActivityContainer.getNextValidLaunchStack(
                        mStartActivity, -1 /* currentFocus */);
            }
        }

        if (mTargetStack == null) {
            mTargetStack = sourceStack;
        } else if (mTargetStack != sourceStack) {
            sourceTask.reparent(mTargetStack, ON_TOP, REPARENT_MOVE_STACK_TO_FRONT, !ANIMATE,
                    DEFER_RESUME, ""launchToSide"");
        }

        final TaskRecord topTask = mTargetStack.topTask();
        if (topTask != sourceTask && !mAvoidMoveToFront) {
            mTargetStack.moveTaskToFrontLocked(sourceTask, mNoAnimation, mOptions,
                    mStartActivity.appTimeTracker, ""sourceTaskToFront"");
        } else if (mDoResume) {
            mTargetStack.moveToFront(""sourceStackToFront"");
        }

        if (!mAddingToTask && (mLaunchFlags & FLAG_ACTIVITY_CLEAR_TOP) != 0) {
            // In this case, we are adding the activity to an existing task, but the caller has
            // asked to clear that task if the activity is already running.
            ActivityRecord top = sourceTask.performClearTaskLocked(mStartActivity, mLaunchFlags);
            mKeepCurTransition = true;
            if (top != null) {
                ActivityStack.logStartActivity(AM_NEW_INTENT, mStartActivity, top.getTaskRecord());
                deliverNewIntent(top);
                // For paranoia, make sure we have correctly resumed the top activity.
                mTargetStack.mLastPausedActivity = null;
                if (mDoResume) {
                    mRootActivityContainer.resumeFocusedStacksTopActivities();
                }
                ActivityOptions.abort(mOptions);
                return START_DELIVERED_TO_TOP;
            }
        } else if (!mAddingToTask && (mLaunchFlags & FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
            // In this case, we are launching an activity in our own task that may already be
            // running somewhere in the history, and we want to shuffle it to the front of the
            // stack if so.
            final ActivityRecord top = sourceTask.findActivityInHistoryLocked(mStartActivity);
            if (top != null) {
                final TaskRecord task = top.getTaskRecord();
                task.moveActivityToFrontLocked(top);
                top.updateOptionsLocked(mOptions);
                ActivityStack.logStartActivity(AM_NEW_INTENT, mStartActivity, task);
                deliverNewIntent(top);
                mTargetStack.mLastPausedActivity = null;
                if (mDoResume) {
                    mRootActivityContainer.resumeFocusedStacksTopActivities();
                }
                return START_DELIVERED_TO_TOP;
            }
        }

        // An existing activity is starting this new activity, so we want to keep the new one in
        // the same task as the one that is starting it.
        addOrReparentStartingActivity(sourceTask, ""setTaskFromSourceRecord"");
        if (DEBUG_TASKS) Slog.v(TAG_TASKS, ""Starting new activity "" + mStartActivity
                + "" in existing task "" + mStartActivity.getTaskRecord()
                + "" from source "" + mSourceRecord);
        return START_SUCCESS;
    }

    private int setTaskFromInTask() {
        // The caller is asking that the new activity be started in an explicit
        // task it has provided to us.
        if (mService.getLockTaskController().isLockTaskModeViolation(mInTask)) {
            Slog.e(TAG, ""Attempted Lock Task Mode violation mStartActivity="" + mStartActivity);
            return START_RETURN_LOCK_TASK_MODE_VIOLATION;
        }

        mTargetStack = mInTask.getStack();

        // Check whether we should actually launch the new activity in to the task,
        // or just reuse the current activity on top.
        ActivityRecord top = mInTask.getTopActivity();
        if (top != null && top.mActivityComponent.equals(mStartActivity.mActivityComponent)
                && top.mUserId == mStartActivity.mUserId) {
            if ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0
                    || isLaunchModeOneOf(LAUNCH_SINGLE_TOP, LAUNCH_SINGLE_TASK)) {
                mTargetStack.moveTaskToFrontLocked(mInTask, mNoAnimation, mOptions,
                        mStartActivity.appTimeTracker, ""inTaskToFront"");
                if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {
                    // We don't need to start a new activity, and the client said not to do
                    // anything if that is the case, so this is it!
                    return START_RETURN_INTENT_TO_CALLER;
                }
                deliverNewIntent(top);
                return START_DELIVERED_TO_TOP;
            }
        }

        if (!mAddingToTask) {
            mTargetStack.moveTaskToFrontLocked(mInTask, mNoAnimation, mOptions,
                    mStartActivity.appTimeTracker, ""inTaskToFront"");
            // We don't actually want to have this activity added to the task, so just
            // stop here but still tell the caller that we consumed the intent.
            ActivityOptions.abort(mOptions);
            return START_TASK_TO_FRONT;
        }

        if (!mLaunchParams.mBounds.isEmpty()) {
            // TODO: Shouldn't we already know what stack to use by the time we get here?
            ActivityStack stack = mRootActivityContainer.getLaunchStack(
                    null, null, mInTask, ON_TOP);
            if (stack != mInTask.getStack()) {
                mInTask.reparent(stack, ON_TOP, REPARENT_KEEP_STACK_AT_FRONT, !ANIMATE,
                        DEFER_RESUME, ""inTaskToFront"");
                mTargetStack = mInTask.getStack();
            }

            updateBounds(mInTask, mLaunchParams.mBounds);
        }

        mTargetStack.moveTaskToFrontLocked(
                mInTask, mNoAnimation, mOptions, mStartActivity.appTimeTracker, ""inTaskToFront"");

        addOrReparentStartingActivity(mInTask, ""setTaskFromInTask"");
        if (DEBUG_TASKS) Slog.v(TAG_TASKS, ""Starting new activity "" + mStartActivity
                + "" in explicit task "" + mStartActivity.getTaskRecord());

        return START_SUCCESS;
    }

"
775,services/core/java/com/android/server/wm/ActivityStarter.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"    private void addOrReparentStartingActivity(TaskRecord parent, String reason) {
        String packageName= mService.mContext.getPackageName();
        if (mPerf != null) {
            mStartActivity.perfActivityBoostHandler =
                mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                    packageName, -1, BoostFramework.Launch.BOOST_V1);
        }
        if (mStartActivity.getTaskRecord() == null || mStartActivity.getTaskRecord() == parent) {
"
776,services/core/java/com/android/server/wm/ActivityTaskManagerService.java,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b', 'ac442e0398fe7344f66cbbd4d2af15b1bfdbf46b', '8d21ad0d966c1e9f96e5a65144efad2582391957']",4,"    public ActivityStackSupervisor mStackSupervisor;
"
777,services/core/java/com/android/server/wm/DisplayPolicy.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"import static android.app.WindowConfiguration.ACTIVITY_TYPE_RECENTS;
"
778,services/core/java/com/android/server/wm/DisplayRotation.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"    /**
     * Broadcast Action: WiFi Display video is enabled or disabled
     *
     * <p>The intent will have the following extra values:</p>
     * <ul>
     *    <li><em>state</em> - 0 for disabled, 1 for enabled. </li>
     * </ul>
     */

    private static final String ACTION_WIFI_DISPLAY_VIDEO =
                    ""org.codeaurora.intent.action.WIFI_DISPLAY_VIDEO"";

    /**
     * Wifi Display specific variables
     */
    private boolean mWifiDisplayConnected = false;
    private int mWifiDisplayRotation = -1;
"
779,services/core/java/com/android/server/wm/ScreenRotationAnimation.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"            if (mPerf != null && mIsPerfLockAcquired) {
                mPerf.perfLockRelease();
                mIsPerfLockAcquired = false;
            }
        }

        if (!mMoreRotateEnter) {
            if (mRotateEnterAnimation != null) {
                mRotateEnterAnimation.cancel();
                mRotateEnterAnimation = null;
                mRotateEnterTransformation.clear();
"
780,services/core/java/com/android/server/wm/ScreenRotationAnimation.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"            mAnimRunning = true;
            mHalfwayPoint = now + mRotateEnterAnimation.getDuration() / 2;
            if (mPerf != null && !mIsPerfLockAcquired) {
                mPerf.perfHint(BoostFramework.VENDOR_HINT_ROTATION_ANIM_BOOST, null);
                mIsPerfLockAcquired = true;
            }
"
781,services/core/java/com/android/server/wm/ScreenRotationAnimation.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"        if (USE_CUSTOM_BLACK_FRAME && !mMoreStartFrame && !mMoreRotateFrame && !mMoreFinishFrame) {
            if (mStartFrameAnimation != null) {
                if (DEBUG_STATE) Slog.v(TAG, ""Frame animations done, clearing start frame anim!"");
                mStartFrameAnimation.cancel();
                mStartFrameAnimation = null;
                mStartFrameTransformation.clear();
            }
            if (mFinishFrameAnimation != null) {
                if (DEBUG_STATE) Slog.v(TAG, ""Frame animations done, clearing finish frame anim!"");
                mFinishFrameAnimation.cancel();
                mFinishFrameAnimation = null;
                mFinishFrameTransformation.clear();
            }
            if (mRotateFrameAnimation != null) {
                if (DEBUG_STATE) Slog.v(TAG, ""Frame animations done, clearing rotate frame anim!"");
                mRotateFrameAnimation.cancel();
                mRotateFrameAnimation = null;
                mRotateFrameTransformation.clear();
            }
            if (mPerf != null && mIsPerfLockAcquired) {
                mPerf.perfLockRelease();
                mIsPerfLockAcquired = false;
            }
        }

"
782,services/core/java/com/android/server/wm/ScreenRotationAnimation.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"        if (mPerf != null && mIsPerfLockAcquired) {
            mPerf.perfLockRelease();
            mIsPerfLockAcquired = false;
"
783,services/core/java/com/android/server/wm/ScreenRotationAnimation.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"    static final int SCREEN_FREEZE_LAYER_BASE       = WINDOW_FREEZE_LAYER + TYPE_LAYER_MULTIPLIER;
    static final int SCREEN_FREEZE_LAYER_ENTER      = SCREEN_FREEZE_LAYER_BASE;
    static final int SCREEN_FREEZE_LAYER_SCREENSHOT = SCREEN_FREEZE_LAYER_BASE + 1;
    static final int SCREEN_FREEZE_LAYER_EXIT       = SCREEN_FREEZE_LAYER_BASE + 2;
    static final int SCREEN_FREEZE_LAYER_CUSTOM     = SCREEN_FREEZE_LAYER_BASE + 3;

    private BoostFramework mPerf = null;
    private boolean mIsPerfLockAcquired = false;
    final Context mContext;
    final DisplayContent mDisplayContent;
    SurfaceControl mSurfaceControl;
    BlackFrame mCustomBlackFrame;
    BlackFrame mExitingBlackFrame;
    BlackFrame mEnteringBlackFrame;
    int mWidth, mHeight;

    int mOriginalRotation;
    int mOriginalWidth, mOriginalHeight;
    int mCurRotation;
    Rect mOriginalDisplayRect = new Rect();
    Rect mCurrentDisplayRect = new Rect();

    // For all animations, ""exit"" is for the UI elements that are going
    // away (that is the snapshot of the old screen), and ""enter"" is for
    // the new UI elements that are appearing (that is the active windows
    // in their final orientation).

    // The starting animation for the exiting and entering elements.  This
    // animation applies a transformation while the rotation is in progress.
    // It is started immediately, before the new entering UI is ready.
    Animation mStartExitAnimation;
    final Transformation mStartExitTransformation = new Transformation();
    Animation mStartEnterAnimation;
    final Transformation mStartEnterTransformation = new Transformation();
    Animation mStartFrameAnimation;
    final Transformation mStartFrameTransformation = new Transformation();
"
784,services/core/java/com/android/server/wm/ScreenRotationAnimation.java,['2edeff882ab756e76b3a028a1568d8774ddc0257'],1,"import android.os.IBinder;
import android.util.BoostFramework;
"
785,services/core/java/com/android/server/wm/ScreenRotationAnimation.java,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '6f47ceafbe6febe54aa5c376baed3415cdf848ad']",2,"import android.util.BoostFramework;
"
786,services/core/java/com/android/server/wm/TaskDisplayArea.java,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '69bee5bb55994d647b678b2cb2ce1becd3d77b32']",2,"    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = null;
    public BoostFramework mUxPerf = null;
"
787,services/core/java/com/android/server/wm/TaskDisplayArea.java,"['449f659b21d039b8692602294b040038ac1e6ccb', '69bee5bb55994d647b678b2cb2ce1becd3d77b32']",2,"    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = null;
    public BoostFramework mUxPerf = null;

"
788,services/core/java/com/android/server/wm/TaskDisplayArea.java,['69bee5bb55994d647b678b2cb2ce1becd3d77b32'],1,"    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = null;
    public BoostFramework mUxPerf = null;

    TaskDisplayArea(DisplayContent displayContent, WindowManagerService service) {
        super(service, Type.ANY, ""TaskContainers"", FEATURE_TASK_CONTAINER);
"
789,services/core/java/com/android/server/wm/TaskDisplayArea.java,['fd65619dfea934f9f1f28a80e9599e2d8e3e77f3'],1,"import android.util.BoostFramework;
"
790,services/core/java/com/android/server/wm/TaskTapPointerEventListener.java,['ddcaa93e851eb5e57692799446f2ef3fe31436ae'],1,"        if (mPerfObj == null) {
            mPerfObj = new BoostFramework();
        }
"
791,services/core/java/com/android/server/wm/TaskTapPointerEventListener.java,['6e44ad255823e1b7f2b23386d61af655c19adb49'],1,"        mHandler = new Handler(mService.mH.getLooper());
        mMoveDisplayToTop = () -> {
            int x;
            int y;
            synchronized (this) {
                x = mLastDownX;
                y = mLastDownY;
            }
            synchronized (mService.mGlobalLock) {
                if (!mService.mPerDisplayFocusEnabled
                        && mService.mRoot.getTopFocusedDisplayContent() != mDisplayContent
                        && inputMethodWindowContains(x, y)) {
                    // In a single focus system, if the input method window and the input method
                    // target window are on the different displays, when the user is tapping on the
                    // input method window, we don't move its display to top. Otherwise, the input
                    // method target window will lose the focus.
                    return;
                }
                final Region windowTapExcludeRegion = Region.obtain();
                mDisplayContent.amendWindowTapExcludeRegion(windowTapExcludeRegion);
                if (windowTapExcludeRegion.contains(x, y)) {
                    windowTapExcludeRegion.recycle();
                    // The user is tapping on the window tap exclude region. We don't move this
                    // display to top. A window tap exclude region, for example, may be set by an
                    // ActivityView, and the region would match the bounds of both the ActivityView
                    // and the virtual display in it. In this case, we would take the tap that is on
                    // the embedded virtual display instead of this display.
                    return;
                }
                windowTapExcludeRegion.recycle();
                WindowContainer parent = mDisplayContent.getParent();
                if (parent != null && parent.getTopChild() != mDisplayContent) {
                    parent.positionChildAt(WindowContainer.POSITION_TOP, mDisplayContent,
                            true /* includingParents */);
                    // For compatibility, only the topmost activity is allowed to be resumed for
                    // pre-Q app. Ensure the topmost activities are resumed whenever a display is
                    // moved to top.
                    // TODO(b/123761773): Investigate whether we can move this into
                    // RootActivityContainer#updateTopResumedActivityIfNeeded(). Currently, it is
                    // risky to do so because it seems possible to resume activities as part of a
                    // larger transaction and it's too early to resume based on current order
                    // when performing updateTopResumedActivityIfNeeded().
                    mDisplayContent.mAcitvityDisplay.ensureActivitiesVisible(null /* starting */,
                            0 /* configChanges */, !PRESERVE_WINDOWS, true /* notifyClients */);
                }
            }
        };
        if (mPerfObj == null) {
            mPerfObj = new BoostFramework();
        }
"
792,services/core/java/com/android/server/wm/TaskTapPointerEventListener.java,['6e44ad255823e1b7f2b23386d61af655c19adb49'],1,"    private int mLastDownX;
    private int mLastDownY;
    public BoostFramework mPerfObj = null;
"
793,services/core/java/com/android/server/wm/WindowManagerService.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
        if (mPerf != null) {
            mPerf.perfHint(BoostFramework.VENDOR_HINT_ROTATION_LATENCY_BOOST, null);
        }
"
794,services/core/java/com/android/server/wm/WindowManagerService.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
        if (mPerf != null) {
            mPerf.perfHint(BoostFramework.VENDOR_HINT_ROTATION_LATENCY_BOOST, null);
        }
        if (CUSTOM_SCREEN_ROTATION) {
            mExitAnimId = exitAnim;
            mEnterAnimId = enterAnim;
            ScreenRotationAnimation screenRotationAnimation =
                    mAnimator.getScreenRotationAnimationLocked(mFrozenDisplayId);
            if (screenRotationAnimation != null) {
                screenRotationAnimation.kill();
            }
"
795,services/core/java/com/android/server/wm/WindowManagerService.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        mFocusingActivity = attrs.getTitle().toString();

        synchronized(mWindowMap) {
"
796,services/core/java/com/android/server/wm/WindowManagerService.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        synchronized(mWindowMap) {
            return animationScalesCheck(ANIMATION_DURATION_SCALE);
"
797,services/core/java/com/android/server/wm/WindowManagerService.java,['af02bd5317cc0cced0a7646d5bbf407a181dda9c'],1,"    private BoostFramework mPerf = null;
"
798,services/core/java/com/android/server/wm/WindowManagerService.java,"['26017c68ee11d3f2d54ca731119c8dc4ddb842cf', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",2,"    static WindowState mFocusingWindow;
    String mFocusingActivity;
"
799,services/core/java/com/android/server/wm/WindowManagerService.java,['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2'],1,"    static final boolean localLOGV = DEBUG;
    static WindowState mFocusingWindow;
    String mFocusingActivity;
"
800,services/core/java/com/android/server/wm/WindowManagerService.java,"['1730c08a2fd38f0ff8135692a855ada865130939', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']",2,"import com.android.internal.app.ActivityTrigger;
"
801,services/java/com/android/server/SystemServer.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '2775a5a9b030266a910301e8b464811acafcd5fa']",2,"            if (enableWigig) {
                try {
                    Slog.i(TAG, ""Wigig Service"");
                    String wigigClassPath =
                        ""/system/framework/wigig-service.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.supptunnel-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.netperftuner-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.capabilityconfigstore-V1.0-java.jar"";
                    PathClassLoader wigigClassLoader =
                            new PathClassLoader(wigigClassPath, getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl"");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigP2pServiceImpl class"");
                    ServiceManager.addService(""wigigp2p"", (IBinder) wigigP2pService);

                    Class wigigClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.WigigService"");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigService class"");
                    ServiceManager.addService(""wigig"", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf(""starting WigigService"", e);
                }
            }

"
802,services/java/com/android/server/SystemServer.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"            if (enableWigig) {
                try {
                    Slog.i(TAG, ""Wigig Service"");
                    String wigigClassPath =
                        ""/system/framework/wigig-service.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.supptunnel-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.netperftuner-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.capabilityconfigstore-V1.0-java.jar"";
                    PathClassLoader wigigClassLoader =
                            new PathClassLoader(wigigClassPath, getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl"");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigP2pServiceImpl class"");
                    ServiceManager.addService(""wigigp2p"", (IBinder) wigigP2pService);

                    Class wigigClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.WigigService"");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigService class"");
                    ServiceManager.addService(""wigig"", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf(""starting WigigService"", e);
                }
            }

            traceBeginAndSlog(""StartNsdService"");
"
803,services/java/com/android/server/SystemServer.java,['2775a5a9b030266a910301e8b464811acafcd5fa'],1,"            traceBeginAndSlog(""StartNetworkStack"");
            try {
                NetworkStackClient.getInstance().start(context);
            } catch (Throwable e) {
                reportWtf(""starting Network Stack"", e);
            }
            traceEnd();

            if (enableWigig) {
                try {
                    Slog.i(TAG, ""Wigig Service"");
                    String wigigClassPath =
                        ""/system/framework/wigig-service.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.supptunnel-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.netperftuner-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.capabilityconfigstore-V1.0-java.jar"";
                    PathClassLoader wigigClassLoader =
                            new PathClassLoader(wigigClassPath, getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl"");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigP2pServiceImpl class"");
                    ServiceManager.addService(""wigigp2p"", (IBinder) wigigP2pService);

                    Class wigigClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.WigigService"");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigService class"");
                    ServiceManager.addService(""wigig"", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf(""starting WigigService"", e);
                }
            }

"
804,services/java/com/android/server/SystemServer.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"        // Wigig services are not registered as system services because of class loader
        // limitations, send boot phase notification separately
        if (enableWigig) {
            try {
                Slog.i(TAG, ""calling onBootPhase for Wigig Services"");
                Class wigigP2pClass = wigigP2pService.getClass();
                Method m = wigigP2pClass.getMethod(""onBootPhase"", int.class);
                m.invoke(wigigP2pService, new Integer(
                    SystemService.PHASE_SYSTEM_SERVICES_READY));

                Class wigigClass = wigigService.getClass();
                m = wigigClass.getMethod(""onBootPhase"", int.class);
                m.invoke(wigigService, new Integer(
                    SystemService.PHASE_SYSTEM_SERVICES_READY));
            } catch (Throwable e) {
                reportWtf(""Wigig services ready"", e);
            }
        }

        traceBeginAndSlog(""MakeWindowManagerServiceReady"");

"
805,services/usb/java/com/android/server/usb/UsbDeviceManager.java,['af01b38e0a0664bc87b649248b0c13fbe0925193'],1,"        private String getChargingFunctions() {
            String func = SystemProperties.get(getPersistProp(true),
                    UsbManager.USB_FUNCTION_NONE);
            if (UsbManager.USB_FUNCTION_NONE.equals(func)) {
                func = UsbManager.USB_FUNCTION_MTP;
"
806,telecomm/java/android/telecom/Call.java,['4e4914b22b779e6376bb00ae20636175b2a70d8c'],1,"            if (can(capabilities, CAPABILITY_ADD_PARTICIPANT)) {
                builder.append("" CAPABILITY_ADD_PARTICIPANT"");
"
807,telecomm/java/android/telecom/Call.java,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', '3d2fc559e13b7293212955f1858d443f4fe8234e']",2,"            if (can(capabilities, CAPABILITY_SUPPORTS_RTT_REMOTE)) {
                builder.append("" CAPABILITY_SUPPORTS_RTT_REMOTE"");
"
808,telecomm/java/android/telecom/Call.java,['af02bd5317cc0cced0a7646d5bbf407a181dda9c'],1,"         * Remote device supports RTT.
         * @hide
         */

        public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x04000000;

        //******************************************************************************************
        // Next CAPABILITY value: 0x08000000
"
809,telecomm/java/android/telecom/Call.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"         * Remote device supports RTT.
         * @hide
         */
        public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x04000000;

        //******************************************************************************************
        // Next CAPABILITY value: 0x08000000
"
810,telecomm/java/android/telecom/Call.java,['4e4914b22b779e6376bb00ae20636175b2a70d8c'],1,"        /**
         * Add participant in an active or conference call option
         * @hide
         */
        public static final int CAPABILITY_ADD_PARTICIPANT = 0x01000000;
"
811,telecomm/java/android/telecom/Connection.java,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', '3d2fc559e13b7293212955f1858d443f4fe8234e']",2,"        if ((capabilities & CAPABILITY_SUPPORTS_RTT_REMOTE) == CAPABILITY_SUPPORTS_RTT_REMOTE) {
            builder.append(isLong ? "" CAPABILITY_SUPPORTS_RTT_REMOTE"" : "" sup_rtt"");
"
812,telecomm/java/android/telecom/Connection.java,"['657230bb5e95ec8560c534360cac5a25fd743129', '88b45c586d461df38b866d529bc98d1dfa3e8838']",2,"     * Connection event used to inform an {@link InCallService} that the call session property
     * has changed
     * @hide
     */
    public static final String EVENT_CALL_PROPERTY_CHANGED =
            ""android.telecom.event.EVENT_CALL_PROPERTY_CHANGED"";
"
813,telecomm/java/android/telecom/Connection.java,['88b45c586d461df38b866d529bc98d1dfa3e8838'],1,"     * Integer connection extra key on a {@link Connection} to indicate that there is an updated
     * call property
     * @hide
     */
    public static final String EXTRA_CALL_PROPERTY =
            ""android.telecom.extra.EXTRA_CALL_PROPERTY"";
"
814,telecomm/java/android/telecom/Connection.java,['af02bd5317cc0cced0a7646d5bbf407a181dda9c'],1,"     * Remote device supports RTT.
     * @hide
     */

    public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x08000000;

    //**********************************************************************************************
    // Next CAPABILITY value: 0x10000000
"
815,telecomm/java/android/telecom/Connection.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"     * Remote device supports RTT.
     * @hide
     */
    public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x08000000;

    //**********************************************************************************************
    // Next CAPABILITY value: 0x10000000
"
816,telecomm/java/android/telecom/Connection.java,['4e4914b22b779e6376bb00ae20636175b2a70d8c'],1,"    /**
     * Add participant in an active or conference call option
     *
     * @hide
     */
    public static final int CAPABILITY_ADD_PARTICIPANT = 0x02000000;

"
817,telecomm/java/android/telecom/ConnectionService.java,"['3d2fc559e13b7293212955f1858d443f4fe8234e', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']",4,"    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
"
818,telephony/java/android/telephony/AccessNetworkConstants.java,"['f2b53072aa24c3f9f84e762d313f85f5f179e4a4', '8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']",3,"            switch (str.toUpperCase()) {
"
819,telephony/java/android/telephony/CellInfoNr.java,['6fc85c43e31aad55eecd51d3b0de34715ae03810'],1,"        final android.hardware.radio.V1_4.CellInfoNr cin = ci.info.nr();
        mCellIdentity = new CellIdentityNr(cin.cellidentity);
        mCellSignalStrength = new CellSignalStrengthNr(cin.signalStrength);
"
820,telephony/java/android/telephony/DisconnectCause.java,"['160034a542fd4cfe183b93b3a4888dc7c4f68b65', '18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4', '6fc85c43e31aad55eecd51d3b0de34715ae03810', '7fe8671fd7b5388dd9be6295dbea6d31209468f9', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae', 'b76115be4efabffaa6febc57cec47acc2f933c79', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']",8,"        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
"
821,telephony/java/android/telephony/DisconnectCause.java,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '6fc85c43e31aad55eecd51d3b0de34715ae03810']",2,"    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 80;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 81;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 82;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 85;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 86;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 87;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 88;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 89;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 90;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 91;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 94;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 95;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 96;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 97;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 98;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 99;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 100;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 101;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 102;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 103;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 106;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 107;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 108;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 109;
    /** @hide */
    public static final int CALL_REJECTED = 110;
    /** @hide */
    public static final int NUMBER_CHANGED = 111;
    /** @hide */
    public static final int PREEMPTION = 112;
    /** @hide */
    public static final int FACILITY_REJECTED = 113;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 114;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 115;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 116;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 117;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 118;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 119;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 120;
"
822,telephony/java/android/telephony/DisconnectCause.java,['6fc85c43e31aad55eecd51d3b0de34715ae03810'],1,"    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 80;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 81;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 82;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 85;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 86;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 87;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 88;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 89;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 90;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 91;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 94;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 95;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 96;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 97;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 98;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 99;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 100;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 101;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 102;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 103;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 106;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 107;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 108;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 109;
    /** @hide */
    public static final int CALL_REJECTED = 110;
    /** @hide */
    public static final int NUMBER_CHANGED = 111;
    /** @hide */
    public static final int PREEMPTION = 112;
    /** @hide */
    public static final int FACILITY_REJECTED = 113;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 114;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 115;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 116;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 117;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 118;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 119;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 120;
    /** @hide */
    public static final int QOS_UNAVAILABLE = 121;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 122;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 123;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 124;
"
823,telephony/java/android/telephony/DisconnectCause.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 81;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 82;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 83;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 85;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 86;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 87;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 88;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 89;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 90;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 91;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 92;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 94;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 95;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 96;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 97;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 98;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 99;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 100;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 101;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 102;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 103;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 104;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 106;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 107;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 108;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 109;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 110;
    /** @hide */
    public static final int CALL_REJECTED = 111;
    /** @hide */
    public static final int NUMBER_CHANGED = 112;
    /** @hide */
    public static final int PREEMPTION = 113;
    /** @hide */
    public static final int FACILITY_REJECTED = 114;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 115;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 116;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 117;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 118;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 119;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 120;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 121;
    /** @hide */
    public static final int QOS_UNAVAILABLE = 122;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 123;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 124;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 125;
"
824,telephony/java/android/telephony/DisconnectCause.java,"['7fe8671fd7b5388dd9be6295dbea6d31209468f9', 'efe5cc44da2c1772c733a6740a761b3b42969db4', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']",3,"    /** @hide */
    public static final int QOS_UNAVAILABLE = 77;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 78;
    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 79;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 80;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 81;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 82;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 84;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 85;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 86;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 87;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 88;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 89;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 90;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 91;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 93;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 94;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 95;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 96;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 97;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 98;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 99;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 100;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 101;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 102;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 103;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 105;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 106;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 107;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 108;
    /** @hide */
    public static final int CALL_REJECTED = 109;
    /** @hide */
    public static final int NUMBER_CHANGED = 110;
    /** @hide */
    public static final int PREEMPTION = 111;
    /** @hide */
    public static final int FACILITY_REJECTED = 112;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 113;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 114;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 115;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 116;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 117;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 118;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 119;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 120;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 121;
"
825,telephony/java/android/telephony/DisconnectCause.java,['18970c4d9d55a44040fe6fb762dac93a077c64b5'],1,"    /** @hide */
    public static final int QOS_UNAVAILABLE = 78;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 79;
    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 80;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 81;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 82;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 85;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 86;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 87;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 88;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 89;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 90;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 91;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 94;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 95;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 96;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 97;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 98;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 99;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 100;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 101;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 102;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 103;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 106;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 107;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 108;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 109;
    /** @hide */
    public static final int CALL_REJECTED = 110;
    /** @hide */
    public static final int NUMBER_CHANGED = 111;
    /** @hide */
    public static final int PREEMPTION = 112;
    /** @hide */
    public static final int FACILITY_REJECTED = 113;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 114;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 115;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 116;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 117;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 118;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 119;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 120;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 121;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 122;
"
826,telephony/java/android/telephony/DisconnectCause.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"    public static final int QOS_UNAVAILABLE = 76;
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 77;
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 78;
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 79;
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 80;
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 81;
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 82;
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 83;
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 84;
    public static final int INVALID_TRANSACTION_IDENTIFIER = 85;
    public static final int USER_NOT_MEMBER_OF_CUG = 86;
    public static final int INCOMPATIBLE_DESTINATION = 87;
    public static final int INVALID_TRANSIT_NW_SELECTION = 88;
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 89;
    public static final int INVALID_MANDATORY_INFORMATION = 90;
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 91;
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 92;
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 93;
    public static final int CONDITIONAL_IE_ERROR = 94;
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 95;
    public static final int RECOVERY_ON_TIMER_EXPIRED = 96;
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 97;
    public static final int INTERWORKING_UNSPECIFIED = 98;
    public static final int LOCAL_LOW_BATTERY = 99;
    public static final int NO_CIRCUIT_AVAIL = 100;
    public static final int NO_ROUTE_TO_DESTINATION = 101;
    public static final int OPERATOR_DETERMINED_BARRING = 102;
    public static final int CALL_FAIL_NO_USER_RESPONDING = 103;
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 104;
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 105;
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 106;
    public static final int CHANNEL_UNACCEPTABLE = 107;
    public static final int CALL_REJECTED = 108;
    public static final int NUMBER_CHANGED = 109;
    public static final int PREEMPTION = 110;
    public static final int FACILITY_REJECTED = 111;
    public static final int RESP_TO_STATUS_ENQUIRY = 112;
    public static final int NETWORK_OUT_OF_ORDER = 113;
    public static final int TEMPORARY_FAILURE = 114;
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 115;
    public static final int ACCESS_INFORMATION_DISCARDED = 116;
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 117;
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 118;

    /** call failed due to LTE to 3G/2G handover not feasible */
    public static final int HO_NOT_FEASIBLE = 119;
    public static final int NON_SELECTED_USER_CLEARING = 120;
"
827,telephony/java/android/telephony/ServiceState.java,"['b7ff81acc796b2957f68c9412cef71b9b47e67de', '799030b703da27e7117eba75c2ca753b0e976a8d', '8943bbe92bfbc3ead44f63a6a3c145a135548b7c', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']",4,"                rtString = ""NR"";
"
828,telephony/java/android/telephony/SmsManager.java,['9caf34febf01086c96266e38d024f7a0315b892d'],1,"        if (isSmsSimPickActivityNeeded) {
            Log.d(TAG, ""getSubscriptionId isSmsSimPickActivityNeeded is true"");
            // ask the user for a default SMS SIM.
            Intent intent = new Intent();
            intent.setClassName(""com.qualcomm.qti.simsettings"",
                    ""com.qualcomm.qti.simsettings.SimDialogActivity"");
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            intent.putExtra(DIALOG_TYPE_KEY, SMS_PICK);
"
829,telephony/java/android/telephony/SmsManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"     * A variant of {@link SmsManager#sendDataMessage} that allows self to be the caller. This is
     * for internal use only.
     *
     * <p class=""note""><strong>Note:</strong> This method is intended for internal use by carrier
     * applications or the Telephony framework and will never trigger an SMS disambiguation
     * dialog. If this method is called on a device that has multiple active subscriptions, this
     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined
     * default subscription is defined, the subscription ID associated with this message will be
     * INVALID, which will result in the SMS being sent on the subscription associated with logical
     * slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is sent on the
     * correct subscription.
     * </p>
     *
     * @hide
     */
    public void sendDataMessageWithSelfPermissions(
            String destinationAddress, String scAddress, short destinationPort,
            byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
        android.util.SeempLog.record_str(73, destinationAddress);
        if (TextUtils.isEmpty(destinationAddress)) {
            throw new IllegalArgumentException(""Invalid destinationAddress"");
        }

        if (data == null || data.length == 0) {
            throw new IllegalArgumentException(""Invalid message data"");
        }

        try {
            ISms iSms = getISmsServiceOrThrow();
            iSms.sendDataForSubscriberWithSelfPermissions(getSubscriptionId(),
                    ActivityThread.currentPackageName(), destinationAddress, scAddress,
                    destinationPort & 0xFFFF, data, sentIntent, deliveryIntent);
        } catch (RemoteException e) {
            Log.e(TAG, ""sendDataMessageWithSelfPermissions: Couldn't send SMS - Exception: ""
                    + e.getMessage());
            notifySmsGenericError(sentIntent);
        }
    }

    /**
"
830,telephony/java/android/telephony/SmsManager.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"     * Get the capacity count of sms on Icc card
     *
     * @return the capacity count of sms on Icc card
     * @hide
     */
    public int getSmsCapacityOnIcc() {
        int ret = -1;
"
831,telephony/java/android/telephony/SmsManager.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    /**
     * A variant of {@link SmsManager#sendTextMessage} that allows self to be the caller. This is
     * for internal use only.
     *
     * <p class=""note""><strong>Note:</strong> This method is intended for internal use by carrier
     * applications or the Telephony framework and will never trigger an SMS disambiguation
     * dialog. If this method is called on a device that has multiple active subscriptions, this
     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined
     * default subscription is defined, the subscription ID associated with this message will be
     * INVALID, which will result in the SMS being sent on the subscription associated with logical
     * slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is sent on the
     * correct subscription.
     * </p>
     *
     * @param persistMessage whether to persist the sent message in the SMS app. the caller must be
     * the Phone process if set to false.
     *
     * @hide
     */
    public void sendTextMessageWithSelfPermissions(
            String destinationAddress, String scAddress, String text,
            PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage) {
        android.util.SeempLog.record_str(75, destinationAddress);
        if (TextUtils.isEmpty(destinationAddress)) {
            throw new IllegalArgumentException(""Invalid destinationAddress"");
        }

        if (TextUtils.isEmpty(text)) {
            throw new IllegalArgumentException(""Invalid message body"");
        }

        try {
            ISms iSms = getISmsServiceOrThrow();
            iSms.sendTextForSubscriberWithSelfPermissions(getSubscriptionId(),
                    ActivityThread.currentPackageName(),
                    destinationAddress,
                    scAddress, text, sentIntent, deliveryIntent, persistMessage);
        } catch (RemoteException ex) {
            notifySmsGenericError(sentIntent);
        }
    }

    /**
     * Send a text based SMS with messaging options.
     *
     * <p class=""note""><strong>Note:</strong> If {@link #getDefault()} is used to instantiate this
     * manager on a multi-SIM device, this operation may fail sending the SMS message because no
     * suitable default subscription could be found. In this case, if {@code sentIntent} is
     * non-null, then the {@link PendingIntent} will be sent with an error code
     * {@code RESULT_ERROR_GENERIC_FAILURE} and an extra string {@code ""noDefault""} containing the
     * boolean value {@code true}. See {@link #getDefault()} for more information on the conditions
     * where this operation may fail.
     * </p>
     *
     * @param destinationAddress the address to send the message to
     * @param scAddress is the service center address or null to use
     *  the current default SMSC
     * @param text the body of the message to send
     * @param sentIntent if not NULL this <code>PendingIntent</code> is
     *  broadcast when the message is successfully sent, or failed.
     *  The result code will be <code>Activity.RESULT_OK</code> for success,
     *  or one of these errors:<br>
     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
     *  <code>RESULT_ERROR_RADIO_OFF</code><br>
     *  <code>RESULT_ERROR_NULL_PDU</code><br>
     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
     *  the extra ""errorCode"" containing a radio technology specific value,
     *  generally only useful for troubleshooting.<br>
     *  The per-application based SMS control checks sentIntent. If sentIntent
     *  is NULL the caller will be checked against all unknown applications,
     *  which cause smaller number of SMS to be sent in checking period.
     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
     *  broadcast when the message is delivered to the recipient.  The
     *  raw pdu of the status report is in the extended data (""pdu"").
     * @param priority Priority level of the message
     *  Refer specification See 3GPP2 C.S0015-B, v2.0, table 4.5.9-1
     *  ---------------------------------
     *  PRIORITY      | Level of Priority
     *  ---------------------------------
     *      '00'      |     Normal
     *      '01'      |     Interactive
     *      '10'      |     Urgent
     *      '11'      |     Emergency
     *  ----------------------------------
     *  Any Other values included Negative considered as Invalid Priority Indicator of the message.
     * @param expectMore is a boolean to indicate the sending messages through same link or not.
     * @param validityPeriod Validity Period of the message in mins.
     *  Refer specification 3GPP TS 23.040 V6.8.1 section 9.2.3.12.1.
     *  Validity Period(Minimum) -> 5 mins
     *  Validity Period(Maximum) -> 635040 mins(i.e.63 weeks).
     *  Any Other values included Negative considered as Invalid Validity Period of the message.
     *
     * @throws IllegalArgumentException if destinationAddress or text are empty
     * {@hide}
     */
    @UnsupportedAppUsage
    public void sendTextMessage(
            String destinationAddress, String scAddress, String text,
            PendingIntent sentIntent, PendingIntent deliveryIntent,
            int priority, boolean expectMore, int validityPeriod) {
        sendTextMessageInternal(destinationAddress, scAddress, text, sentIntent, deliveryIntent,
                true /* persistMessage*/, priority, expectMore, validityPeriod);
    }

"
832,telephony/java/android/telephony/SmsManager.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"    @UnsupportedAppUsage
    public boolean
    deleteMessageFromIcc(int messageIndex) {
        android.util.SeempLog.record(80);
"
833,telephony/java/android/telephony/SmsManager.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"    @UnsupportedAppUsage
    public boolean copyMessageToIcc(byte[] smsc, byte[] pdu,int status) {
        android.util.SeempLog.record(79);
"
834,telephony/java/android/telephony/TelephonyManager.java,['89ca8eb6845aeb5da5c69c25c3fb5c31e0d827d7'],1,"            // This is a temporary change awaiting a proper rework from Google (b/156203930).
            // Just log the exception instead of rethrowing as a DeadSystemException, which causes
            // framework reboot. Keeping the original code around since we do not know the actual
            // motive of putting this here in the first place.
            Log.e(TAG, ""notifyUserActivity RemoteException"", e);
            // throw e.rethrowFromSystemServer();
"
835,telephony/java/android/telephony/data/ApnSetting.java,['240d78276b3206717587bea012131945c6f60179'],1,"    // Equal or one is null or """".
"
836,telephony/java/android/telephony/ims/ImsCallSession.java,['88b45c586d461df38b866d529bc98d1dfa3e8838'],1,"         * While in call, there has been a change in the call session
         * property.
         * @param property - an integer containing masks for different properties
         * {e.g. @see Connection#PROPERTY_RTT_AUDIO_SPEECH}
         */
        "
837,telephony/java/android/telephony/ims/ImsCallSession.java,['88b45c586d461df38b866d529bc98d1dfa3e8838'],1,"         * While in call, there has been a change in the call session
         * property.
         * @param property - an integer containing masks for different properties
         * {e.g. @see Connection#PROPERTY_RTT_AUDIO_SPEECH}
         */
        @Override
        public void callSessionPropertyChanged(int property) {
            if (mListener != null) {
                mListener.callSessionPropertyChanged(property);
"
838,telephony/java/android/telephony/ims/ImsCallSession.java,['88b45c586d461df38b866d529bc98d1dfa3e8838'],1,"         * While in call, there has been a change in the call session
         * property.
         * @param property - an integer containing masks for different properties
         * {e.g. @see Connection#PROPERTY_RTT_AUDIO_SPEECH}
         */
        public void callSessionPropertyChanged(int property) {
"
839,telephony/java/android/telephony/ims/feature/MmTelFeature.java,['1581c348fc5d6cbf1673b3dbc5960637f891d488'],1,"import android.telephony.ims.ImsCallProfile;
import android.telephony.ims.ImsReasonInfo;
"
840,telephony/java/com/android/internal/telephony/uicc/IccUtils.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"    static byte[]
    stringToAdnStringField(String alphaTag) {
        boolean isUcs2 = false;
        try {
           for(int i = 0; i < alphaTag.length(); i++) {
               GsmAlphabet.countGsmSeptets(alphaTag.charAt(i), true);
           }
        } catch (EncodeException e) {
            isUcs2 = true;
        }
        return stringToAdnStringField(alphaTag, isUcs2);
    }

    static byte[]
    stringToAdnStringField(String alphaTag, boolean isUcs2) {
        if (!isUcs2) {
            return GsmAlphabet.stringToGsm8BitPacked(alphaTag);
        }
        byte[] alphaTagBytes = alphaTag.getBytes(Charset.forName(""UTF-16BE""));
        byte[] ret = new byte[1 + alphaTagBytes.length];
        ret[0] = (byte)0x80;
        System.arraycopy(alphaTagBytes, 0, ret, 1, alphaTagBytes.length);

        return ret;
"
841,telephony/java/com/android/internal/telephony/uicc/IccUtils.java,['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2'],1,"import com.android.internal.telephony.EncodeException;
"
842,telephony/java/com/android/internal/telephony/uicc/IccUtils.java,"['24818fca475a6726f5ef0cae42149615079af6e9', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']",2,"import java.nio.charset.Charset;
"
843,wifi/java/android/net/wifi/ScanResult.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"        public static final int EID_EXTENSION = 255;
        public static final int EID_EXT_HE_CAPABILITIES = 35;
"
844,wifi/java/android/net/wifi/ScanResult.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"     * Security key management scheme: DPP.
     */
    public static final int KEY_MGMT_DPP = 13;
    /**
     * @hide
     * Security key management scheme: FILS_SHA256.
     */
    public static final int KEY_MGMT_FILS_SHA256 = 14;
    /**
     * @hide
     * Security key management scheme: FILS_SHA384.
     */
    public static final int KEY_MGMT_FILS_SHA384 = 15;
"
845,wifi/java/android/net/wifi/ScanResult.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"     * Security key management scheme: DPP.
     */
    public static final int KEY_MGMT_DPP = 15;
    /**
     * @hide
     * Security key management scheme: FILS_SHA256.
     */
    public static final int KEY_MGMT_FILS_SHA256 = 16;
"
846,wifi/java/android/net/wifi/ScanResult.java,['ae1b3a8f3221dbe692fd90d414cfe5040538c264'],1,"    public boolean is60GHz() {
        return ScanResult.is60GHz(frequency);
    }

    /**
     * @hide
     * TODO: makes real freq boundaries
     */
    public static boolean is60GHz(int freq) {
        return freq >= 58320 && freq <= 70200;
"
847,wifi/java/android/net/wifi/ScanResult.java,"['b76115be4efabffaa6febc57cec47acc2f933c79', '8faa0d981413f18b2468dde1b1fe71e248df0df1']",2,    public static final int 
848,wifi/java/android/net/wifi/ScanResult.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"    public static final int KEY_MGMT_FILS_SHA384 = 17;
"
849,wifi/java/android/net/wifi/SoftApConfiguration.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,                    in.read
850,wifi/java/android/net/wifi/SoftApConfiguration.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"                    in.readInt(), in.readString());
"
851,wifi/java/android/net/wifi/SoftApConfiguration.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"                    in.readString());
"
852,wifi/java/android/net/wifi/SoftApConfiguration.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"                    mShutdownTimeoutMillis, mClientControlByUser, mBlockedClientList,
                    mAllowedClientList, mOweTransIfaceName);
"
853,wifi/java/android/net/wifi/SoftApConfiguration.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,"                && mOweTransIfaceName == other.mOweTransIfaceName;
"
854,wifi/java/android/net/wifi/SoftApConfiguration.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"                mBand, mChannel, mSecurityType, mMaxNumberOfClients, mShutdownTimeoutMillis,
                mClientControlByUser, mBlockedClientList, mAllowedClientList, mOweTransIfaceName);
"
855,wifi/java/android/net/wifi/SoftApConfiguration.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"                mBand, mChannel, mSecurityType, mOweTransIfaceName);
"
856,wifi/java/android/net/wifi/SoftApConfiguration.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"                mHiddenSsid, mBand, mChannel, setSecurityType(), mOweTransIfaceName);
"
857,wifi/java/android/net/wifi/SoftApConfiguration.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"            @Nullable String wpa2Passphrase, boolean hiddenSsid, @BandType int band, int channel,
            @SecurityType int securityType, int maxNumberOfClients, @Nullable String oweTransIfaceName) {
"
858,wifi/java/android/net/wifi/SoftApConfiguration.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"            @SecurityType int securityType, @Nullable String oweTransIfaceName) {
"
859,wifi/java/android/net/wifi/SoftApConfiguration.java,['3d2fc559e13b7293212955f1858d443f4fe8234e'],1,"            @SecurityType int securityType, int maxNumberOfClients, int shutdownTimeoutMillis,
            boolean clientControlByUser, @NonNull List<MacAddress> blockedList,
            @NonNull List<MacAddress> allowedList, @Nullable String oweTransIfaceName) {
"
860,wifi/java/android/net/wifi/SoftApConfiguration.java,['a33382db0bb0bc29bab84f1e5ee36d682bea593e'],1,"            int shutdownTimeoutMillis, boolean clientControlByUser,
            @NonNull List<MacAddress> blockedList, @NonNull List<MacAddress> allowedList,
            @Nullable String oweTransIfaceName) {
"
861,wifi/java/android/net/wifi/SoftApConfiguration.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,            mOweTransIfaceName = 
862,wifi/java/android/net/wifi/SoftApConfiguration.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,"            mOweTransIfaceName = null;
"
863,wifi/java/android/net/wifi/SoftApConfiguration.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,"            mOweTransIfaceName = other.mOweTransIfaceName;
"
864,wifi/java/android/net/wifi/SoftApConfiguration.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"            return new SoftApConfiguration(mSsid, mBssid, mWpa2Passphrase,
                mHiddenSsid, mBand, mChannel, setSecurityType(), mMaxNumberOfClients, mOweTransIfaceName);
"
865,wifi/java/android/net/wifi/SoftApConfiguration.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,"         * Specifies an iface name for OWE transition mode for the AP.
         * <p>
         * <li>If not set, defaults to null.</li>
         *
         * @param oweTransIfaceName iface name for OWE transition mode.
         * @return Builder for chaining.
         *
         * @hide
         */
        @NonNull
        public Builder setOweTransIfaceName(@Nullable String oweTransIfaceName) {
            mOweTransIfaceName = oweTransIfaceName;
"
866,wifi/java/android/net/wifi/SoftApConfiguration.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        SECURITY_TYPE_OWE,
        SECURITY_TYPE_SAE,
"
867,wifi/java/android/net/wifi/SoftApConfiguration.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,"        dest.writeString(mOweTransIfaceName);
"
868,wifi/java/android/net/wifi/SoftApConfiguration.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,        mOweTransIfaceName = 
869,wifi/java/android/net/wifi/SoftApConfiguration.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,        mOweTransIfaceName = o
870,wifi/java/android/net/wifi/SoftApConfiguration.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,"        mOweTransIfaceName = oweTransIfaceName;
"
871,wifi/java/android/net/wifi/SoftApConfiguration.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"        private String mOweTransIfaceName;
"
872,wifi/java/android/net/wifi/SoftApConfiguration.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        private String mOweTransIfaceName;

        private int setSecurityType() {
            int securityType = SECURITY_TYPE_OPEN;
            if (!TextUtils.isEmpty(mWpa2Passphrase)) { // WPA2-PSK network.
                securityType = SECURITY_TYPE_WPA2_PSK;
            }
            return securityType;
        }

        private void clearAllPassphrase() {
            mWpa2Passphrase = null;
        }
"
873,wifi/java/android/net/wifi/SoftApConfiguration.java,['71998c3d8b36220df1be12fe6e1ba7eda81cde41'],1,"        return Objects.hash(mSsid, mBssid, mWpa2Passphrase, mHiddenSsid,
                mBand, mChannel, mSecurityType, mMaxNumberOfClients, mOweTransIfaceName);
"
874,wifi/java/android/net/wifi/SoftApConfiguration.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,"        sbuf.append("" \n OWE Transition mode Iface ="").append(mOweTransIfaceName);
"
875,wifi/java/android/net/wifi/SoftApConfiguration.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,"     * Return the iface name for OWE transition mode for the AP.
     * {@link #setOweTransIfaceName(String)}.
     *
     * @hide
     */
    @Nullable
    public String getOweTransIfaceName() {
      return mOweTransIfaceName;
"
876,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"                        ""TKIP"", ""CCMP"", ""GTK_NOT_USED"", ""GCMP"" };
"
877,wifi/java/android/net/wifi/WifiConfiguration.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"                ""FILS_SHA256"", ""FILS_SHA384"", ""DPP"",
        };
"
878,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"                ""IEEE8021X"", ""WPA2_PSK"", ""OSEN"", ""FT_PSK"", ""FT_EAP"", ""FILS_SHA256"",
                ""FILS_SHA384"", ""DPP"", ""SAE"", ""OWE"", ""SUITE_B_192""};
"
879,wifi/java/android/net/wifi/WifiConfiguration.java,['88b45c586d461df38b866d529bc98d1dfa3e8838'],1,"                ""SAE"", ""OWE"", ""SUITE_B_192"", ""FILS_SHA256"", ""FILS_SHA384"", ""DPP""};
"
880,wifi/java/android/net/wifi/WifiConfiguration.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"                ""WAPI_PSK"", ""WAPI_CERT"", ""FILS_SHA256"", ""FILS_SHA384"", ""DPP"", };
"
881,wifi/java/android/net/wifi/WifiConfiguration.java,['240d78276b3206717587bea012131945c6f60179'],1,"                .append("" OWE Transition mode Iface: "").append(this.oweTransIfaceName)
"
882,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"                config.allowedGroupMgmtCiphers    = readBitSet(in);
                config.allowedSuiteBCiphers    = readBitSet(in);
"
883,wifi/java/android/net/wifi/WifiConfiguration.java,['6fc85c43e31aad55eecd51d3b0de34715ae03810'],1,"                config.clonedNetworkConfigKey = in.readString();
                config.oweTransIfaceName = in.readString();
"
884,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"                config.dppConnector = in.readString();
                config.dppNetAccessKey = in.readString();
                config.dppNetAccessKeyExpiry = in.readInt();
                config.dppCsign = in.readString();
"
885,wifi/java/android/net/wifi/WifiConfiguration.java,"['5358a994b854c7a6627858c48d6947e8acff6ea9', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",2,"                config.oweTransIfaceName = in.readString();
"
886,wifi/java/android/net/wifi/WifiConfiguration.java,['240d78276b3206717587bea012131945c6f60179'],1,"                config.randomizedMacLastModifiedTimeMs = in.readLong();
                config.oweTransIfaceName = in.readString();
"
887,wifi/java/android/net/wifi/WifiConfiguration.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"            SECURITY_TYPE_FILS_SHA256,
            SECURITY_TYPE_FILS_SHA384
"
888,wifi/java/android/net/wifi/WifiConfiguration.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"            case SECURITY_TYPE_FILS_SHA256:
                allowedKeyManagement.set(WifiConfiguration.KeyMgmt.FILS_SHA256);
                break;
            case SECURITY_TYPE_FILS_SHA384:
                allowedKeyManagement.set(WifiConfiguration.KeyMgmt.FILS_SHA384);
"
889,wifi/java/android/net/wifi/WifiConfiguration.java,['6fc85c43e31aad55eecd51d3b0de34715ae03810'],1,"            clonedNetworkConfigKey = source.clonedNetworkConfigKey;
            oweTransIfaceName = source.oweTransIfaceName;
"
890,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"            dppConnector = source.dppConnector;
            dppNetAccessKey = source.dppNetAccessKey;
            dppNetAccessKeyExpiry = source.dppNetAccessKeyExpiry;
            dppCsign = source.dppCsign;

"
891,wifi/java/android/net/wifi/WifiConfiguration.java,['6e44ad255823e1b7f2b23386d61af655c19adb49'],1,"            if (allowedKeyManagement.get(KeyMgmt.WPA_PSK)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.WPA_PSK];
            } else if (allowedKeyManagement.get(KeyMgmt.WPA_EAP) ||
                    allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.WPA_EAP];
            } else if (wepKeys[0] != null) {
                key = SSID + ""WEP"";
            } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
            } else if (allowedKeyManagement.get(KeyMgmt.OWE)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.OWE];
            } else if (allowedKeyManagement.get(KeyMgmt.SAE)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.SAE];
            } else if (allowedKeyManagement.get(KeyMgmt.SUITE_B_192)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.SUITE_B_192];
            } else {
                key = SSID + KeyMgmt.strings[KeyMgmt.NONE];
            }
"
892,wifi/java/android/net/wifi/WifiConfiguration.java,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '240d78276b3206717587bea012131945c6f60179']",2,"            oweTransIfaceName = source.oweTransIfaceName;
"
893,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"            } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
"
894,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"          * @hide
"
895,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"         * @hide
         */
        public static final int GCMP = 3;

        public static final String varName = ""pairwise"";

        public static final String[] strings = { ""NONE"", ""TKIP"", ""CCMP"", ""GCMP"" };
"
896,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"         * @hide
         */
        public static final int GCMP = 5;
"
897,wifi/java/android/net/wifi/WifiConfiguration.java,['88b45c586d461df38b866d529bc98d1dfa3e8838'],1,"        * IEEE 802.11ai FILS SK with SHA256
         * @hide
        */
        public static final int FILS_SHA256 = 11;
        /**
         * IEEE 802.11ai FILS SK with SHA384:
         * @hide
         */
        public static final int FILS_SHA384 = 12;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        public static final int DPP = 13;
"
898,wifi/java/android/net/wifi/WifiConfiguration.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"        * IEEE 802.11ai FILS SK with SHA256
         * @hide
        */
        public static final int FILS_SHA256 = 13;
        /**
         * IEEE 802.11ai FILS SK with SHA384:
         * @hide
         */
        public static final int FILS_SHA384 = 14;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        public static final int DPP = 15;
"
899,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        * IEEE 802.11ai FILS SK with SHA256
         * @hide
        */
        public static final int FILS_SHA256 = 8;
        /**
         * IEEE 802.11ai FILS SK with SHA384:
         * @hide
         */
        public static final int FILS_SHA384 = 9;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        public static final int DPP = 10;

        /**
         * Simultaneous Authentication of Equals
         * @hide
         */
        public static final int SAE = 11;
        /**
         * Opportunististic Wireless Encryption
         * @hide
         */
        public static final int OWE = 12;

        /**
         * SUITE_B_192 192 bit level
         * @hide
         */
        public static final int SUITE_B_192 = 13;
"
900,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        /** CMAC = Cipher-based Message Authentication Code */
        public static final int CMAC = 0;

        /** GMAC = Galois Message Authentication Code */
        public static final int GMAC = 1;

        public static final String varName = ""groupMgmt"";

        public static final String[] strings =
                { ""CMAC"", ""GMAC"" };
    }
"
901,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        /** ECDHE_ECDSA */
        public static final int ECDHE_ECDSA = 0;

        /** ECDHE_RSA */
        public static final int ECDHE_RSA = 1;

        public static final String varName = ""SuiteB"";

        public static final String[] strings =
                { ""ECDHE_ECDSA"", ""ECDHE_RSA"" };
"
902,wifi/java/android/net/wifi/WifiConfiguration.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"        @SystemApi
        public static final int FILS_SHA384 = 16;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        @SystemApi
        public static final int DPP = 17;
"
903,wifi/java/android/net/wifi/WifiConfiguration.java,['6fc85c43e31aad55eecd51d3b0de34715ae03810'],1,"        clonedNetworkConfigKey = null;
        dppConnector = null;
        dppNetAccessKey = null;
        dppNetAccessKeyExpiry = -1;
        dppCsign = null;
        oweTransIfaceName = null;
"
904,wifi/java/android/net/wifi/WifiConfiguration.java,['240d78276b3206717587bea012131945c6f60179'],1,"        dest.writeLong(randomizedMacLastModifiedTimeMs);
        dest.writeString(oweTransIfaceName);
"
905,wifi/java/android/net/wifi/WifiConfiguration.java,['6fc85c43e31aad55eecd51d3b0de34715ae03810'],1,"        dest.writeString(clonedNetworkConfigKey);
        dest.writeString(oweTransIfaceName);
"
906,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        dest.writeString(dppConnector);
        dest.writeString(dppNetAccessKey);
        dest.writeInt(dppNetAccessKeyExpiry);
        dest.writeString(dppCsign);
"
907,wifi/java/android/net/wifi/WifiConfiguration.java,"['5358a994b854c7a6627858c48d6947e8acff6ea9', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']",2,"        dest.writeString(oweTransIfaceName);
"
908,wifi/java/android/net/wifi/WifiConfiguration.java,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '6fc85c43e31aad55eecd51d3b0de34715ae03810']",2,"        dppConnector = null;
        dppNetAccessKey = null;
        dppNetAccessKeyExpiry = -1;
        dppCsign = null;
        oweTransIfaceName = null;
"
909,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        sbuf.append('\n').append("" PSK: "");
"
910,wifi/java/android/net/wifi/WifiConfiguration.java,"['b76115be4efabffaa6febc57cec47acc2f933c79', '43ceded8caaffead0a2a1967f42a4ef4bb658ced', '8faa0d981413f18b2468dde1b1fe71e248df0df1']",3,"        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            "
911,wifi/java/android/net/wifi/WifiConfiguration.java,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '8faa0d981413f18b2468dde1b1fe71e248df0df1']",2,"        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
"
912,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            return KeyMgmt.DPP;
"
913,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"     * CMAC = Cipher-based Message Authentication Code
     * GMAC = Galois Message Authentication Code
     * </pre>
     * @hide
"
914,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"     * GCMP = AES in Galois/Counter Mode
"
915,wifi/java/android/net/wifi/WifiConfiguration.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"     * See {@link SuiteBCipher} for descriptions of the values.
     * @hide
     */
    public BitSet allowedSuiteBCiphers;
     /** {@hide} */
    public static final String erpVarName = ""erp"";
"
916,wifi/java/android/net/wifi/WifiConfiguration.java,['8faa0d981413f18b2468dde1b1fe71e248df0df1'],1,"    @SystemApi
"
917,wifi/java/android/net/wifi/WifiConfiguration.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"    public static final int SECURITY_TYPE_FILS_SHA256 = 7;
    /** @hide */
    public static final int SECURITY_TYPE_FILS_SHA384 = 8;
"
918,wifi/java/android/net/wifi/WifiConfiguration.java,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '240d78276b3206717587bea012131945c6f60179']",2,"ng();
                config.oweTransIfaceName = in.readString();
"
919,wifi/java/android/net/wifi/WifiEnterpriseConfig.java,['43ceded8caaffead0a2a1967f42a4ef4bb658ced'],1,"    /** @hide */
    public static final String EAP_ERP             = ""eap_erp"";
    /** @hide */
    public static final String KEY_SIMNUM          = ""sim_num"";
"
920,wifi/java/android/net/wifi/WifiEnterpriseConfig.java,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '8faa0d981413f18b2468dde1b1fe71e248df0df1']",2,"    /** @hide */
    public static final String KEY_SIMNUM          = ""sim_num"";
"
921,wifi/java/android/net/wifi/WifiEnterpriseConfig.java,"['f6f595c8a4c17ed2347482c43e2cccc89531224e', '8faa0d981413f18b2468dde1b1fe71e248df0df1']",2,"    public static final String KEY_SIMNUM          = ""sim_num"";
"
922,wifi/java/android/net/wifi/WifiInfo.java,['af02bd5317cc0cced0a7646d5bbf407a181dda9c'],1,"
    private int mWifiGeneration;

    private boolean mVhtMax8SpatialStreamsSupport;

    private boolean mTwtSupport;

"
923,wifi/java/android/net/wifi/WifiInfo.java,"['edb6252578f9b76151e5125a7fb1b16823a68418', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']",2,"                .append("", Wifi Generation: "").append(mWifiGeneration)
                .append("", TWT support: "").append(mTwtSupport)
                .append("", Eight Max VHT Spatial streams support: "").append(mVhtMax8SpatialStreamsSupport)
"
924,wifi/java/android/net/wifi/WifiInfo.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"                .append("", Wifi Generation: "").append(mWifiGeneration)
                .append("", TWT support: "").append(mTwtSupport)
                .append("", Eight Max VHT Spatial streams support: "").append(mVhtMax8SpatialStreamsSupport)
                .append("", Wi-Fi technology: "").append(mWifiTechnology)
"
925,wifi/java/android/net/wifi/WifiInfo.java,"['edb6252578f9b76151e5125a7fb1b16823a68418', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']",2,"                info.mWifiGeneration = in.readInt();
                info.mVhtMax8SpatialStreamsSupport = in.readInt() != 0;
                info.mTwtSupport = in.readInt() != 0;
"
926,wifi/java/android/net/wifi/WifiInfo.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"                info.mWifiGeneration = in.readInt();
                info.mVhtMax8SpatialStreamsSupport = in.readInt() != 0;
                info.mTwtSupport = in.readInt() != 0;
                info.mWifiTechnology = in.readInt();
"
927,wifi/java/android/net/wifi/WifiInfo.java,"['edb6252578f9b76151e5125a7fb1b16823a68418', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']",2,"        dest.writeInt(mWifiGeneration);
        dest.writeInt(mVhtMax8SpatialStreamsSupport ? 1 : 0);
        dest.writeInt(mTwtSupport ? 1 : 0);
"
928,wifi/java/android/net/wifi/WifiInfo.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"        dest.writeInt(mWifiGeneration);
        dest.writeInt(mVhtMax8SpatialStreamsSupport ? 1 : 0);
        dest.writeInt(mTwtSupport ? 1 : 0);
        dest.writeInt(mWifiTechnology);
"
929,wifi/java/android/net/wifi/WifiInfo.java,['af02bd5317cc0cced0a7646d5bbf407a181dda9c'],1,"        setWifiGeneration(-1);
        setTwtSupport(false);
        setVhtMax8SpatialStreamsSupport(false);
"
930,wifi/java/android/net/wifi/WifiInfo.java,['6fc85c43e31aad55eecd51d3b0de34715ae03810'],1,"    /** @hide */
    public void setWifiGeneration(int generation) {
        mWifiGeneration = generation;
    }

    /** @hide */
    public int getWifiGeneration() {
        return mWifiGeneration;
    }

    /** @hide */
    public void setVhtMax8SpatialStreamsSupport(boolean vhtMax8SpatialStreamsSupport) {
        mVhtMax8SpatialStreamsSupport = vhtMax8SpatialStreamsSupport;
    }

    /** @hide */
    public boolean isVhtMax8SpatialStreamsSupported() {
        return mVhtMax8SpatialStreamsSupport;
    }

    /** @hide */
    public void setTwtSupport(boolean twtSupport) {
        mTwtSupport = twtSupport;
    }

    /** @hide */
    public boolean isTwtSupported() {
        return mTwtSupport;
    }

    /** {@hide} */
    @UnsupportedAppUsage
    public static String removeDoubleQuotes(String string) {
"
931,wifi/java/android/net/wifi/WifiManager.java,['1730c08a2fd38f0ff8135692a855ada865130939'],1,"
    /**
     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config  bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0  Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config  dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
"
932,wifi/java/android/net/wifi/WifiManager.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,"         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(@NonNull String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(@NonNull String Macaddr, int numClients);
"
933,wifi/java/android/net/wifi/WifiManager.java,"['edb6252578f9b76151e5125a7fb1b16823a68418', '240d78276b3206717587bea012131945c6f60179']",2,"         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(String Macaddr, int numClients);
"
934,wifi/java/android/net/wifi/WifiManager.java,['240d78276b3206717587bea012131945c6f60179'],1,"        public abstract void onNumClientsChanged(int numClients);

        /**
         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(String Macaddr, int numClients);
"
935,wifi/java/android/net/wifi/WifiManager.java,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']",2,"        public void onStaConnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaConnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaConnected(Macaddr, numClients);
            });
        }

        @Override
        public void onStaDisconnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaDisconnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaDisconnected(Macaddr, numClients);
"
936,wifi/java/android/net/wifi/WifiManager.java,['edb6252578f9b76151e5125a7fb1b16823a68418'],1,"        public void onStaConnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaConnected Macaddr ="" + Macaddr);
            mHandler.post(() -> {
                mCallback.onStaConnected(Macaddr, numClients);
            });
        }

        @Override
        public void onStaDisconnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaDisconnected Macaddr ="" + Macaddr);
            mHandler.post(() -> {
                mCallback.onStaDisconnected(Macaddr, numClients);
"
937,wifi/java/android/net/wifi/WifiManager.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"     * Broadcast intent action indicating that WifiCountryCode was updated with new
     * country code.
     *
     * @see #EXTRA_COUNTRY_CODE
     *
     * @hide
     */
    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
    public static final String WIFI_COUNTRY_CODE_CHANGED_ACTION =
            ""android.net.wifi.COUNTRY_CODE_CHANGED"";

    /**
     * The lookup key for a string that indicates the 2 char new country code
     *
     * @hide
     */
    public static final String EXTRA_COUNTRY_CODE = ""country_code"";

    /**
     * Broadcast intent action indicating that the user initiated Wifi OFF
     * or APM ON and Wifi disconnection is in progress
     * Actual Wifi disconnection happens after mDisconnectDelayDuration seconds.
     * @hide
     */
    public static final String  ACTION_WIFI_DISCONNECT_IN_PROGRESS =
            ""com.qualcomm.qti.net.wifi.WIFI_DISCONNECT_IN_PROGRESS"";
"
938,wifi/java/android/net/wifi/WifiManager.java,"['1730c08a2fd38f0ff8135692a855ada865130939', '2edeff882ab756e76b3a028a1568d8774ddc0257', 'b76115be4efabffaa6febc57cec47acc2f933c79']",3,"     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config  bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0  Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config  dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
"
939,wifi/java/android/net/wifi/p2p/WifiP2pManager.java,['b76115be4efabffaa6febc57cec47acc2f933c79'],1,"    public static final int SET_WFDR2_INFO                          = BASE + 82;
    /** @hide */
    public static final int SET_WFDR2_INFO_FAILED                   = BASE + 83;
    /** @hide */
    public static final int SET_WFDR2_INFO_SUCCEEDED                = BASE + 84;

"
940,wifi/java/android/net/wifi/p2p/WifiP2pManager.java,['8d21ad0d966c1e9f96e5a65144efad2582391957'],1,"    public static final int SET_WFDR2_INFO                          = BASE + 90;
    /** @hide */
    public static final int SET_WFDR2_INFO_FAILED                   = BASE + 91;
    /** @hide */
    public static final int SET_WFDR2_INFO_SUCCEEDED                = BASE + 92;
"
941,wifi/java/android/net/wifi/p2p/WifiP2pWfdInfo.java,['5358a994b854c7a6627858c48d6947e8acff6ea9'],1,"    private int mR2DeviceInfo;

    public static final int WFD_SOURCE              = 0;
    public static final int PRIMARY_SINK            = 1;
    public static final int SECONDARY_SINK          = 2;
    public static final int SOURCE_OR_PRIMARY_SINK  = 3;

    /* Device information bitmap */
    /** One of {@link #WFD_SOURCE}, {@link #PRIMARY_SINK}, {@link #SECONDARY_SINK}
     * or {@link #SOURCE_OR_PRIMARY_SINK}
"
942,wifi/java/android/net/wifi/p2p/WifiP2pWfdInfo.java,['5358a994b854c7a6627858c48d6947e8acff6ea9'],1,"    public String getR2DeviceInfoHex() {
        return String.format(
                Locale.US, ""%04x%04x"", 2, mR2DeviceInfo);
    }
"
943,wifi/java/android/net/wifi/p2p/WifiP2pWfdInfo.java,['5358a994b854c7a6627858c48d6947e8acff6ea9'],1,"    public boolean isWfdR2Supported() {
        return (mR2DeviceInfo<0?false:true);
    }

    @UnsupportedAppUsage
"
944,wifi/java/android/net/wifi/p2p/WifiP2pWfdInfo.java,['5358a994b854c7a6627858c48d6947e8acff6ea9'],1,"    public void setWfdR2Device(int r2DeviceInfo) {
        mR2DeviceInfo = r2DeviceInfo;
    }

    @UnsupportedAppUsage
"
