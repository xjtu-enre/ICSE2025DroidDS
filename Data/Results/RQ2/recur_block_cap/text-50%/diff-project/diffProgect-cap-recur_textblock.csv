id,merge_commitid,recurBlockSrc,file,Loc_details,block_text_1,block_text_2,recur_segment,proportion
2,"['1452baeffa18c2760dac56bee26c20fa12a499a3', '1452baeffa18c2760dac56bee26c20fa12a499a3']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(5941, 5999, 59), (5941, 5999, 59)]","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }
","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }
","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }
","[1.0, 1.0]"
3,"['1452baeffa18c2760dac56bee26c20fa12a499a3', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(5941, 5999, 59), (6040, 6108, 69)]","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }
","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }
}
","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }
","[1.0, 0.871]"
4,"['1452baeffa18c2760dac56bee26c20fa12a499a3', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(5941, 5999, 59), (5923, 5990, 68)]","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }
","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }
","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }
","[1.0, 0.872]"
5,"['1452baeffa18c2760dac56bee26c20fa12a499a3', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(5941, 5999, 59), (5961, 6026, 66)]","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }
","[1.0, 0.874]"
9,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(6040, 6108, 69), (6040, 6108, 69)]","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }
}
","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }
}
","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }
}
","[1.0, 1.0]"
10,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3265, 3274, 10), (3265, 3274, 10)]","        if (Binder.getCallingUid() >= FIRST_APPLICATION_UID) {
            Log.i(TAG, ""In setBluetoothScoOn(), on: ""+on+"". The calling application Uid: ""
                  + Binder.getCallingUid() + "", is greater than FIRST_APPLICATION_UID""
                  + "" exiting from setBluetoothScoOn()"");
            if (on)
                mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
            else if (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO)
                mForcedUseForCommExt = AudioSystem.FORCE_NONE;
            Log.i(TAG, ""In setbluetoothScoOn(), mForcedUseForCommExt: ""
                        + mForcedUseForCommExt);
","        if (Binder.getCallingUid() >= FIRST_APPLICATION_UID) {
            Log.i(TAG, ""In setBluetoothScoOn(), on: ""+on+"". The calling application Uid: ""
                  + Binder.getCallingUid() + "", is greater than FIRST_APPLICATION_UID""
                  + "" exiting from setBluetoothScoOn()"");
            if (on)
                mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
            else if (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO)
                mForcedUseForCommExt = AudioSystem.FORCE_NONE;
            Log.i(TAG, ""In setbluetoothScoOn(), mForcedUseForCommExt: ""
                        + mForcedUseForCommExt);
","        if (Binder.getCallingUid() >= FIRST_APPLICATION_UID) {
            Log.i(TAG, ""In setBluetoothScoOn(), on: ""+on+"". The calling application Uid: ""
                  + Binder.getCallingUid() + "", is greater than FIRST_APPLICATION_UID""
                  + "" exiting from setBluetoothScoOn()"");
            if (on)
                mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
            else if (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO)
                mForcedUseForCommExt = AudioSystem.FORCE_NONE;
            Log.i(TAG, ""In setbluetoothScoOn(), mForcedUseForCommExt: ""
                        + mForcedUseForCommExt);
","[1.0, 1.0]"
11,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(32, 33, 2), (32, 33, 2)]","import android.support.annotation.VisibleForTesting;
import android.os.SystemProperties;
","import android.support.annotation.VisibleForTesting;
import android.os.SystemProperties;
","import android.support.annotation.VisibleForTesting;
import android.os.SystemProperties;
","[1.0, 1.0]"
12,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(1228, 1231, 4), (1228, 1231, 4)]","        A2dpSinkProfile a2dpSinkProfile = mProfileManager.getA2dpSinkProfile();
        Log.i(TAG, ""a2dpProfile :"" + a2dpProfile + "" a2dpSinkProfile :"" + a2dpSinkProfile);
        if (a2dpProfile != null) {
            return a2dpProfile.getConnectionStatus(mDevice) ==
","        A2dpSinkProfile a2dpSinkProfile = mProfileManager.getA2dpSinkProfile();
        Log.i(TAG, ""a2dpProfile :"" + a2dpProfile + "" a2dpSinkProfile :"" + a2dpSinkProfile);
        if (a2dpProfile != null) {
            return a2dpProfile.getConnectionStatus(mDevice) ==
","        A2dpSinkProfile a2dpSinkProfile = mProfileManager.getA2dpSinkProfile();
        Log.i(TAG, ""a2dpProfile :"" + a2dpProfile + "" a2dpSinkProfile :"" + a2dpSinkProfile);
        if (a2dpProfile != null) {
            return a2dpProfile.getConnectionStatus(mDevice) ==
","[1.0, 1.0]"
13,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/ims/feature/MmTelFeature.java,"[(37, 38, 2), (37, 38, 2)]","import android.telephony.ims.ImsCallProfile;
import android.telephony.ims.ImsReasonInfo;
","import android.telephony.ims.ImsCallProfile;
import android.telephony.ims.ImsReasonInfo;
","import android.telephony.ims.ImsCallProfile;
import android.telephony.ims.ImsReasonInfo;
","[1.0, 1.0]"
14,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/StatusBarMobileView.java,"[(216, 216, 1), (216, 216, 1)]","        updateFiveGState(state);
","        updateFiveGState(state);
","        updateFiveGState(state);
","[1.0, 1.0]"
15,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/StorageManagerService.java,"[(128, 131, 4), (128, 131, 4)]","import com.android.internal.widget.ILockSettings;

import libcore.io.IoUtils;
import libcore.util.EmptyArray;
","import com.android.internal.widget.ILockSettings;

import libcore.io.IoUtils;
import libcore.util.EmptyArray;
","import com.android.internal.widget.ILockSettings;

import libcore.io.IoUtils;
import libcore.util.EmptyArray;
","[1.0, 1.0]"
16,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(52, 52, 1), (52, 52, 1)]","import java.io.BufferedReader;
","import java.io.BufferedReader;
","import java.io.BufferedReader;
","[1.0, 1.0]"
17,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8050, 8050, 1), (8050, 8050, 1)]","            WIFI_DISCONNECT_DELAY_DURATION
","            WIFI_DISCONNECT_DELAY_DURATION
","            WIFI_DISCONNECT_DELAY_DURATION
","[1.0, 1.0]"
18,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8199, 8199, 1), (8199, 8199, 1)]","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","[1.0, 1.0]"
19,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(316, 318, 3), (316, 318, 3)]","import android.metrics.LogMaker;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
","import android.metrics.LogMaker;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
","import android.metrics.LogMaker;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
","[1.0, 1.0]"
20,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(414, 416, 3), (414, 416, 3)]","import com.android.internal.app.ActivityTrigger;
import com.android.internal.logging.MetricsLogger;
import com.android.internal.logging.nano.MetricsProto.MetricsEvent;
","import com.android.internal.app.ActivityTrigger;
import com.android.internal.logging.MetricsLogger;
import com.android.internal.logging.nano.MetricsProto.MetricsEvent;
","import com.android.internal.app.ActivityTrigger;
import com.android.internal.logging.MetricsLogger;
import com.android.internal.logging.nano.MetricsProto.MetricsEvent;
","[1.0, 1.0]"
21,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(5169, 5367, 199), (5169, 5367, 199)]","        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
                resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,
                true /*validateIncomingUser*/);
    }

    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,
            boolean validateIncomingUser) {
        enforceNotIsolatedCaller(""startActivity"");

        userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,
                Binder.getCallingPid(), Binder.getCallingUid(), ""startActivityAsUser"");

        // TODO: Switch to user app stacks here.
        return mActivityStartController.obtainStarter(intent, ""startActivityAsUser"")
                .setCaller(caller)
                .setCallingPackage(callingPackage)
                .setResolvedType(resolvedType)
                .setResultTo(resultTo)
                .setResultWho(resultWho)
                .setRequestCode(requestCode)
                .setStartFlags(startFlags)
                .setProfilerInfo(profilerInfo)
                .setActivityOptions(bOptions)
                .setMayWait(userId)
                .execute();

    }

    final int startActivityAsUserEmpty(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {
        ArrayList<String> pApps = options.getStringArrayList(""start_empty_apps"");
        if (pApps != null && pApps.size() > 0) {
            Iterator<String> apps_itr = pApps.iterator();
            while (apps_itr.hasNext()) {
                ProcessRecord empty_app = null;
                String app_str = apps_itr.next();
                if (app_str == null)
                    continue;
                synchronized (this) {
                    Intent intent_l = null;
                    try {
                        intent_l = mContext.getPackageManager().getLaunchIntentForPackage(app_str);
                        if (intent_l == null)
                            continue;
                        ActivityInfo aInfo = mStackSupervisor.resolveActivity(intent_l, null,
                                                                          0, null, 0, 0);
                        if (aInfo == null)
                            continue;
                        empty_app = startProcessLocked(app_str, aInfo.applicationInfo, false, 0,
                                                   ""activity"", null, false, false, true);
                        if (empty_app != null)
                            updateOomAdjLocked(empty_app, true);
                    } catch (Exception e) {
                        if (DEBUG_PROCESSES)
                            Slog.w(TAG, ""Exception raised trying to start app as empty "" + e);
                    }
                }
            }
        }
        return 1;
    }

    @Override
    public final int startActivityAsCaller(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, boolean ignoreTargetSecurity,
            int userId) {

        // This is very dangerous -- it allows you to perform a start activity (including
        // permission grants) as any app that may launch one of your own activities.  So
        // we will only allow this to be done from activities that are part of the core framework,
        // and then only when they are running as the system.
        final ActivityRecord sourceRecord;
        final int targetUid;
        final String targetPackage;
        final boolean isResolver;
        synchronized (this) {
            if (resultTo == null) {
                throw new SecurityException(""Must be called from an activity"");
            }
            sourceRecord = mStackSupervisor.isInAnyStackLocked(resultTo);
            if (sourceRecord == null) {
                throw new SecurityException(""Called with bad activity token: "" + resultTo);
            }
            if (!sourceRecord.info.packageName.equals(""android"")) {
                throw new SecurityException(
                        ""Must be called from an activity that is declared in the android package"");
            }
            if (sourceRecord.app == null) {
                throw new SecurityException(""Called without a process attached to activity"");
            }
            if (UserHandle.getAppId(sourceRecord.app.uid) != SYSTEM_UID) {
                // This is still okay, as long as this activity is running under the
                // uid of the original calling activity.
                if (sourceRecord.app.uid != sourceRecord.launchedFromUid) {
                    throw new SecurityException(
                            ""Calling activity in uid "" + sourceRecord.app.uid
                                    + "" must be system uid or original calling uid ""
                                    + sourceRecord.launchedFromUid);
                }
            }
            if (ignoreTargetSecurity) {
                if (intent.getComponent() == null) {
                    throw new SecurityException(
                            ""Component must be specified with ignoreTargetSecurity"");
                }
                if (intent.getSelector() != null) {
                    throw new SecurityException(
                            ""Selector not allowed with ignoreTargetSecurity"");
                }
            }
            targetUid = sourceRecord.launchedFromUid;
            targetPackage = sourceRecord.launchedFromPackage;
            isResolver = sourceRecord.isResolverOrChildActivity();
        }

        if (userId == UserHandle.USER_NULL) {
            userId = UserHandle.getUserId(sourceRecord.app.uid);
        }

        // TODO: Switch to user app stacks here.
        try {
            return mActivityStartController.obtainStarter(intent, ""startActivityAsCaller"")
                    .setCallingUid(targetUid)
                    .setCallingPackage(targetPackage)
                    .setResolvedType(resolvedType)
                    .setResultTo(resultTo)
                    .setResultWho(resultWho)
                    .setRequestCode(requestCode)
                    .setStartFlags(startFlags)
                    .setActivityOptions(bOptions)
                    .setMayWait(userId)
                    .setIgnoreTargetSecurity(ignoreTargetSecurity)
                    .setFilterCallingUid(isResolver ? 0 /* system */ : targetUid)
                    .execute();
        } catch (SecurityException e) {
            // XXX need to figure out how to propagate to original app.
            // A SecurityException here is generally actually a fault of the original
            // calling activity (such as a fairly granting permissions), so propagate it
            // back to them.
            /*
            StringBuilder msg = new StringBuilder();
            msg.append(""While launching"");
            msg.append(intent.toString());
            msg.append("": "");
            msg.append(e.getMessage());
            */
            throw e;
        }
    }

    @Override
    public final WaitResult startActivityAndWait(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller(""startActivityAndWait"");
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                userId, false, ALLOW_FULL_ONLY, ""startActivityAndWait"", null);
        WaitResult res = new WaitResult();
        // TODO: Switch to user app stacks here.
        mActivityStartController.obtainStarter(intent, ""startActivityAndWait"")
                .setCaller(caller)
                .setCallingPackage(callingPackage)
                .setResolvedType(resolvedType)
                .setResultTo(resultTo)
                .setResultWho(resultWho)
                .setRequestCode(requestCode)
                .setStartFlags(startFlags)
                .setActivityOptions(bOptions)
                .setMayWait(userId)
                .setProfilerInfo(profilerInfo)
                .setWaitResult(res)
                .execute();
        return res;
    }

    @Override
    public final int startActivityWithConfig(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, Configuration config, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller(""startActivityWithConfig"");
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                userId, false, ALLOW_FULL_ONLY, ""startActivityWithConfig"", null);
        // TODO: Switch to user app stacks here.
        return mActivityStartController.obtainStarter(intent, ""startActivityWithConfig"")
                .setCaller(caller)
                .setCallingPackage(callingPackage)
                .setResolvedType(resolvedType)
                .setResultTo(resultTo)
                .setResultWho(resultWho)
                .setRequestCode(requestCode)
                .setStartFlags(startFlags)
                .setGlobalConfiguration(config)
                .setActivityOptions(bOptions)
                .setMayWait(userId)
                .execute();
","        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
                resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,
                true /*validateIncomingUser*/);
    }

    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,
            boolean validateIncomingUser) {
        enforceNotIsolatedCaller(""startActivity"");

        userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,
                Binder.getCallingPid(), Binder.getCallingUid(), ""startActivityAsUser"");

        // TODO: Switch to user app stacks here.
        return mActivityStartController.obtainStarter(intent, ""startActivityAsUser"")
                .setCaller(caller)
                .setCallingPackage(callingPackage)
                .setResolvedType(resolvedType)
                .setResultTo(resultTo)
                .setResultWho(resultWho)
                .setRequestCode(requestCode)
                .setStartFlags(startFlags)
                .setProfilerInfo(profilerInfo)
                .setActivityOptions(bOptions)
                .setMayWait(userId)
                .execute();

    }

    final int startActivityAsUserEmpty(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {
        ArrayList<String> pApps = options.getStringArrayList(""start_empty_apps"");
        if (pApps != null && pApps.size() > 0) {
            Iterator<String> apps_itr = pApps.iterator();
            while (apps_itr.hasNext()) {
                ProcessRecord empty_app = null;
                String app_str = apps_itr.next();
                if (app_str == null)
                    continue;
                synchronized (this) {
                    Intent intent_l = null;
                    try {
                        intent_l = mContext.getPackageManager().getLaunchIntentForPackage(app_str);
                        if (intent_l == null)
                            continue;
                        ActivityInfo aInfo = mStackSupervisor.resolveActivity(intent_l, null,
                                                                          0, null, 0, 0);
                        if (aInfo == null)
                            continue;
                        empty_app = startProcessLocked(app_str, aInfo.applicationInfo, false, 0,
                                                   ""activity"", null, false, false, true);
                        if (empty_app != null)
                            updateOomAdjLocked(empty_app, true);
                    } catch (Exception e) {
                        if (DEBUG_PROCESSES)
                            Slog.w(TAG, ""Exception raised trying to start app as empty "" + e);
                    }
                }
            }
        }
        return 1;
    }

    @Override
    public final int startActivityAsCaller(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, boolean ignoreTargetSecurity,
            int userId) {

        // This is very dangerous -- it allows you to perform a start activity (including
        // permission grants) as any app that may launch one of your own activities.  So
        // we will only allow this to be done from activities that are part of the core framework,
        // and then only when they are running as the system.
        final ActivityRecord sourceRecord;
        final int targetUid;
        final String targetPackage;
        final boolean isResolver;
        synchronized (this) {
            if (resultTo == null) {
                throw new SecurityException(""Must be called from an activity"");
            }
            sourceRecord = mStackSupervisor.isInAnyStackLocked(resultTo);
            if (sourceRecord == null) {
                throw new SecurityException(""Called with bad activity token: "" + resultTo);
            }
            if (!sourceRecord.info.packageName.equals(""android"")) {
                throw new SecurityException(
                        ""Must be called from an activity that is declared in the android package"");
            }
            if (sourceRecord.app == null) {
                throw new SecurityException(""Called without a process attached to activity"");
            }
            if (UserHandle.getAppId(sourceRecord.app.uid) != SYSTEM_UID) {
                // This is still okay, as long as this activity is running under the
                // uid of the original calling activity.
                if (sourceRecord.app.uid != sourceRecord.launchedFromUid) {
                    throw new SecurityException(
                            ""Calling activity in uid "" + sourceRecord.app.uid
                                    + "" must be system uid or original calling uid ""
                                    + sourceRecord.launchedFromUid);
                }
            }
            if (ignoreTargetSecurity) {
                if (intent.getComponent() == null) {
                    throw new SecurityException(
                            ""Component must be specified with ignoreTargetSecurity"");
                }
                if (intent.getSelector() != null) {
                    throw new SecurityException(
                            ""Selector not allowed with ignoreTargetSecurity"");
                }
            }
            targetUid = sourceRecord.launchedFromUid;
            targetPackage = sourceRecord.launchedFromPackage;
            isResolver = sourceRecord.isResolverOrChildActivity();
        }

        if (userId == UserHandle.USER_NULL) {
            userId = UserHandle.getUserId(sourceRecord.app.uid);
        }

        // TODO: Switch to user app stacks here.
        try {
            return mActivityStartController.obtainStarter(intent, ""startActivityAsCaller"")
                    .setCallingUid(targetUid)
                    .setCallingPackage(targetPackage)
                    .setResolvedType(resolvedType)
                    .setResultTo(resultTo)
                    .setResultWho(resultWho)
                    .setRequestCode(requestCode)
                    .setStartFlags(startFlags)
                    .setActivityOptions(bOptions)
                    .setMayWait(userId)
                    .setIgnoreTargetSecurity(ignoreTargetSecurity)
                    .setFilterCallingUid(isResolver ? 0 /* system */ : targetUid)
                    .execute();
        } catch (SecurityException e) {
            // XXX need to figure out how to propagate to original app.
            // A SecurityException here is generally actually a fault of the original
            // calling activity (such as a fairly granting permissions), so propagate it
            // back to them.
            /*
            StringBuilder msg = new StringBuilder();
            msg.append(""While launching"");
            msg.append(intent.toString());
            msg.append("": "");
            msg.append(e.getMessage());
            */
            throw e;
        }
    }

    @Override
    public final WaitResult startActivityAndWait(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller(""startActivityAndWait"");
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                userId, false, ALLOW_FULL_ONLY, ""startActivityAndWait"", null);
        WaitResult res = new WaitResult();
        // TODO: Switch to user app stacks here.
        mActivityStartController.obtainStarter(intent, ""startActivityAndWait"")
                .setCaller(caller)
                .setCallingPackage(callingPackage)
                .setResolvedType(resolvedType)
                .setResultTo(resultTo)
                .setResultWho(resultWho)
                .setRequestCode(requestCode)
                .setStartFlags(startFlags)
                .setActivityOptions(bOptions)
                .setMayWait(userId)
                .setProfilerInfo(profilerInfo)
                .setWaitResult(res)
                .execute();
        return res;
    }

    @Override
    public final int startActivityWithConfig(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, Configuration config, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller(""startActivityWithConfig"");
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                userId, false, ALLOW_FULL_ONLY, ""startActivityWithConfig"", null);
        // TODO: Switch to user app stacks here.
        return mActivityStartController.obtainStarter(intent, ""startActivityWithConfig"")
                .setCaller(caller)
                .setCallingPackage(callingPackage)
                .setResolvedType(resolvedType)
                .setResultTo(resultTo)
                .setResultWho(resultWho)
                .setRequestCode(requestCode)
                .setStartFlags(startFlags)
                .setGlobalConfiguration(config)
                .setActivityOptions(bOptions)
                .setMayWait(userId)
                .execute();
","        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
                resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,
                true /*validateIncomingUser*/);
    }

    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,
            boolean validateIncomingUser) {
        enforceNotIsolatedCaller(""startActivity"");

        userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,
                Binder.getCallingPid(), Binder.getCallingUid(), ""startActivityAsUser"");

        // TODO: Switch to user app stacks here.
        return mActivityStartController.obtainStarter(intent, ""startActivityAsUser"")
                .setCaller(caller)
                .setCallingPackage(callingPackage)
                .setResolvedType(resolvedType)
                .setResultTo(resultTo)
                .setResultWho(resultWho)
                .setRequestCode(requestCode)
                .setStartFlags(startFlags)
                .setProfilerInfo(profilerInfo)
                .setActivityOptions(bOptions)
                .setMayWait(userId)
                .execute();

    }

    final int startActivityAsUserEmpty(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {
        ArrayList<String> pApps = options.getStringArrayList(""start_empty_apps"");
        if (pApps != null && pApps.size() > 0) {
            Iterator<String> apps_itr = pApps.iterator();
            while (apps_itr.hasNext()) {
                ProcessRecord empty_app = null;
                String app_str = apps_itr.next();
                if (app_str == null)
                    continue;
                synchronized (this) {
                    Intent intent_l = null;
                    try {
                        intent_l = mContext.getPackageManager().getLaunchIntentForPackage(app_str);
                        if (intent_l == null)
                            continue;
                        ActivityInfo aInfo = mStackSupervisor.resolveActivity(intent_l, null,
                                                                          0, null, 0, 0);
                        if (aInfo == null)
                            continue;
                        empty_app = startProcessLocked(app_str, aInfo.applicationInfo, false, 0,
                                                   ""activity"", null, false, false, true);
                        if (empty_app != null)
                            updateOomAdjLocked(empty_app, true);
                    } catch (Exception e) {
                        if (DEBUG_PROCESSES)
                            Slog.w(TAG, ""Exception raised trying to start app as empty "" + e);
                    }
                }
            }
        }
        return 1;
    }

    @Override
    public final int startActivityAsCaller(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, boolean ignoreTargetSecurity,
            int userId) {

        // This is very dangerous -- it allows you to perform a start activity (including
        // permission grants) as any app that may launch one of your own activities.  So
        // we will only allow this to be done from activities that are part of the core framework,
        // and then only when they are running as the system.
        final ActivityRecord sourceRecord;
        final int targetUid;
        final String targetPackage;
        final boolean isResolver;
        synchronized (this) {
            if (resultTo == null) {
                throw new SecurityException(""Must be called from an activity"");
            }
            sourceRecord = mStackSupervisor.isInAnyStackLocked(resultTo);
            if (sourceRecord == null) {
                throw new SecurityException(""Called with bad activity token: "" + resultTo);
            }
            if (!sourceRecord.info.packageName.equals(""android"")) {
                throw new SecurityException(
                        ""Must be called from an activity that is declared in the android package"");
            }
            if (sourceRecord.app == null) {
                throw new SecurityException(""Called without a process attached to activity"");
            }
            if (UserHandle.getAppId(sourceRecord.app.uid) != SYSTEM_UID) {
                // This is still okay, as long as this activity is running under the
                // uid of the original calling activity.
                if (sourceRecord.app.uid != sourceRecord.launchedFromUid) {
                    throw new SecurityException(
                            ""Calling activity in uid "" + sourceRecord.app.uid
                                    + "" must be system uid or original calling uid ""
                                    + sourceRecord.launchedFromUid);
                }
            }
            if (ignoreTargetSecurity) {
                if (intent.getComponent() == null) {
                    throw new SecurityException(
                            ""Component must be specified with ignoreTargetSecurity"");
                }
                if (intent.getSelector() != null) {
                    throw new SecurityException(
                            ""Selector not allowed with ignoreTargetSecurity"");
                }
            }
            targetUid = sourceRecord.launchedFromUid;
            targetPackage = sourceRecord.launchedFromPackage;
            isResolver = sourceRecord.isResolverOrChildActivity();
        }

        if (userId == UserHandle.USER_NULL) {
            userId = UserHandle.getUserId(sourceRecord.app.uid);
        }

        // TODO: Switch to user app stacks here.
        try {
            return mActivityStartController.obtainStarter(intent, ""startActivityAsCaller"")
                    .setCallingUid(targetUid)
                    .setCallingPackage(targetPackage)
                    .setResolvedType(resolvedType)
                    .setResultTo(resultTo)
                    .setResultWho(resultWho)
                    .setRequestCode(requestCode)
                    .setStartFlags(startFlags)
                    .setActivityOptions(bOptions)
                    .setMayWait(userId)
                    .setIgnoreTargetSecurity(ignoreTargetSecurity)
                    .setFilterCallingUid(isResolver ? 0 /* system */ : targetUid)
                    .execute();
        } catch (SecurityException e) {
            // XXX need to figure out how to propagate to original app.
            // A SecurityException here is generally actually a fault of the original
            // calling activity (such as a fairly granting permissions), so propagate it
            // back to them.
            /*
            StringBuilder msg = new StringBuilder();
            msg.append(""While launching"");
            msg.append(intent.toString());
            msg.append("": "");
            msg.append(e.getMessage());
            */
            throw e;
        }
    }

    @Override
    public final WaitResult startActivityAndWait(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller(""startActivityAndWait"");
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                userId, false, ALLOW_FULL_ONLY, ""startActivityAndWait"", null);
        WaitResult res = new WaitResult();
        // TODO: Switch to user app stacks here.
        mActivityStartController.obtainStarter(intent, ""startActivityAndWait"")
                .setCaller(caller)
                .setCallingPackage(callingPackage)
                .setResolvedType(resolvedType)
                .setResultTo(resultTo)
                .setResultWho(resultWho)
                .setRequestCode(requestCode)
                .setStartFlags(startFlags)
                .setActivityOptions(bOptions)
                .setMayWait(userId)
                .setProfilerInfo(profilerInfo)
                .setWaitResult(res)
                .execute();
        return res;
    }

    @Override
    public final int startActivityWithConfig(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, Configuration config, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller(""startActivityWithConfig"");
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                userId, false, ALLOW_FULL_ONLY, ""startActivityWithConfig"", null);
        // TODO: Switch to user app stacks here.
        return mActivityStartController.obtainStarter(intent, ""startActivityWithConfig"")
                .setCaller(caller)
                .setCallingPackage(callingPackage)
                .setResolvedType(resolvedType)
                .setResultTo(resultTo)
                .setResultWho(resultWho)
                .setRequestCode(requestCode)
                .setStartFlags(startFlags)
                .setGlobalConfiguration(config)
                .setActivityOptions(bOptions)
                .setMayWait(userId)
                .execute();
","[1.0, 1.0]"
22,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(16164, 16180, 17), (16164, 16180, 17)]","    SleepToken acquireSleepToken(String tag, int displayId) {
        synchronized (this) {
            final SleepToken token = mStackSupervisor.createSleepTokenLocked(tag, displayId);
            if (mEnableNetOpts) {
                ActivityStack stack = mStackSupervisor.getLastStack();
                if (stack != null) {
                    ActivityRecord r = stack.topRunningActivityLocked();
                    if (r != null) {
                        networkOptsCheck(1, r.processName);
                    }
                }
            }
            updateSleepIfNeededLocked();
            return token;
        }
    }

","    SleepToken acquireSleepToken(String tag, int displayId) {
        synchronized (this) {
            final SleepToken token = mStackSupervisor.createSleepTokenLocked(tag, displayId);
            if (mEnableNetOpts) {
                ActivityStack stack = mStackSupervisor.getLastStack();
                if (stack != null) {
                    ActivityRecord r = stack.topRunningActivityLocked();
                    if (r != null) {
                        networkOptsCheck(1, r.processName);
                    }
                }
            }
            updateSleepIfNeededLocked();
            return token;
        }
    }

","    SleepToken acquireSleepToken(String tag, int displayId) {
        synchronized (this) {
            final SleepToken token = mStackSupervisor.createSleepTokenLocked(tag, displayId);
            if (mEnableNetOpts) {
                ActivityStack stack = mStackSupervisor.getLastStack();
                if (stack != null) {
                    ActivityRecord r = stack.topRunningActivityLocked();
                    if (r != null) {
                        networkOptsCheck(1, r.processName);
                    }
                }
            }
            updateSleepIfNeededLocked();
            return token;
        }
    }

","[1.0, 1.0]"
23,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(24608, 24613, 6), (24608, 24613, 6)]","                    if (mEnableProcessGroupCgroupFollow) {
                        setCgroupProcsProcessGroup(app.info.uid, app.pid, processGroup);
                    } else {
                        setProcessGroup(app.pid, processGroup);
                    }
                    if (app.curSchedGroup == ProcessList.SCHED_GROUP_TOP_APP) {
","                    if (mEnableProcessGroupCgroupFollow) {
                        setCgroupProcsProcessGroup(app.info.uid, app.pid, processGroup);
                    } else {
                        setProcessGroup(app.pid, processGroup);
                    }
                    if (app.curSchedGroup == ProcessList.SCHED_GROUP_TOP_APP) {
","                    if (mEnableProcessGroupCgroupFollow) {
                        setCgroupProcsProcessGroup(app.info.uid, app.pid, processGroup);
                    } else {
                        setProcessGroup(app.pid, processGroup);
                    }
                    if (app.curSchedGroup == ProcessList.SCHED_GROUP_TOP_APP) {
","[1.0, 1.0]"
24,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActiveServices.java,"[(2547, 2552, 6), (2547, 2552, 6)]","                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortName + "" in "" + r.restartDelay + ""ms"");
                    }
","                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortName + "" in "" + r.restartDelay + ""ms"");
                    }
","                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortName + "" in "" + r.restartDelay + ""ms"");
                    }
","[1.0, 1.0]"
25,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/NetworkTimeUpdateService.java,"[(124, 328, 205), (124, 328, 205)]","    public void systemRunning() {
        registerForTelephonyIntents();
        registerForAlarms();

        HandlerThread thread = new HandlerThread(TAG);
        thread.start();
        mHandler = new MyHandler(thread.getLooper());
        mNetworkTimeUpdateCallback = new NetworkTimeUpdateCallback();
        mCM.registerDefaultNetworkCallback(mNetworkTimeUpdateCallback, mHandler);

        mSettingsObserver = new SettingsObserver(mHandler, EVENT_AUTO_TIME_CHANGED);
        mSettingsObserver.observe(mContext);
    }

    private void registerForTelephonyIntents() {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(TelephonyIntents.ACTION_NETWORK_SET_TIME);
        mContext.registerReceiver(mNitzReceiver, intentFilter);
    }

    private void registerForAlarms() {
        mContext.registerReceiver(
            new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    mHandler.obtainMessage(EVENT_POLL_NETWORK_TIME).sendToTarget();
                }
            }, new IntentFilter(ACTION_POLL));
    }

    private void onPollNetworkTime(int event) {
        // If Automatic time is not set, don't bother. Similarly, if we don't
        // have any default network, don't bother.
        if (mDefaultNetwork == null) return;
        mWakeLock.acquire();
        try {
            onPollNetworkTimeUnderWakeLock(event);
        } finally {
            mWakeLock.release();
        }
    }

    private void onPollNetworkTimeUnderWakeLock(int event) {
        // Force an NTP fix when outdated
        if (mTime.getCacheAge() >= mPollingIntervalMs) {
            if (DBG) Log.d(TAG, ""Stale NTP fix; forcing refresh"");
            mTime.forceSync();
        }

        if (mTime.getCacheAge() < mPollingIntervalMs) {
            // Obtained fresh fix; schedule next normal update
            resetAlarm(mPollingIntervalMs);
            if (isAutomaticTimeRequested()) {
                updateSystemClock(event);
            }

        } else {
            // No fresh fix; schedule retry
            mTryAgainCounter++;
            if (mTryAgainTimesMax < 0 || mTryAgainCounter <= mTryAgainTimesMax) {
                resetAlarm(mPollingIntervalShorterMs);
            } else {
                // Try much later
                mTryAgainCounter = 0;
                resetAlarm(mPollingIntervalMs);
            }
        }
    }

    private long getNitzAge() {
        if (mNitzTimeSetTime == NOT_SET) {
            return Long.MAX_VALUE;
        } else {
            return SystemClock.elapsedRealtime() - mNitzTimeSetTime;
        }
    }

    /**
     * Consider updating system clock based on current NTP fix, if requested by
     * user, significant enough delta, and we don't have a recent NITZ.
     */
    private void updateSystemClock(int event) {
        final boolean forceUpdate = (event == EVENT_AUTO_TIME_CHANGED);
        if (!forceUpdate) {
            if (getNitzAge() < mPollingIntervalMs) {
                if (DBG) Log.d(TAG, ""Ignoring NTP update due to recent NITZ"");
                return;
            }

            final long skew = Math.abs(mTime.currentTimeMillis() - System.currentTimeMillis());
            if (skew < mTimeErrorThresholdMs) {
                if (DBG) Log.d(TAG, ""Ignoring NTP update due to low skew"");
                return;
            }
        }

        SystemClock.setCurrentTimeMillis(mTime.currentTimeMillis());
    }

    /**
     * Cancel old alarm and starts a new one for the specified interval.
     *
     * @param interval when to trigger the alarm, starting from now.
     */
    private void resetAlarm(long interval) {
        mAlarmManager.cancel(mPendingPollIntent);
        long now = SystemClock.elapsedRealtime();
        long next = now + interval;
        mAlarmManager.set(AlarmManager.ELAPSED_REALTIME, next, mPendingPollIntent);
    }

    /**
     * Checks if the user prefers to automatically set the time.
     */
    private boolean isAutomaticTimeRequested() {
        return Settings.Global.getInt(
                mContext.getContentResolver(), Settings.Global.AUTO_TIME, 0) != 0;
    }

    /** Receiver for Nitz time events */
    private BroadcastReceiver mNitzReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (DBG) Log.d(TAG, ""Received "" + action);
            if (TelephonyIntents.ACTION_NETWORK_SET_TIME.equals(action)) {
                mNitzTimeSetTime = SystemClock.elapsedRealtime();
            }
        }
    };

    /** Handler to do the network accesses on */
    private class MyHandler extends Handler {

        public MyHandler(Looper l) {
            super(l);
        }

        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case EVENT_AUTO_TIME_CHANGED:
                case EVENT_POLL_NETWORK_TIME:
                case EVENT_NETWORK_CHANGED:
                    onPollNetworkTime(msg.what);
                    break;
            }
        }
    }

    private class NetworkTimeUpdateCallback extends NetworkCallback {
        @Override
        public void onAvailable(Network network) {
            Log.d(TAG, String.format(""New default network %s; checking time."", network));
            mDefaultNetwork = network;
            // Running on mHandler so invoke directly.
            onPollNetworkTime(EVENT_NETWORK_CHANGED);
        }

        @Override
        public void onLost(Network network) {
            if (network.equals(mDefaultNetwork)) mDefaultNetwork = null;
        }
    }

    /** Observer to watch for changes to the AUTO_TIME setting */
    private static class SettingsObserver extends ContentObserver {

        private int mMsg;
        private Handler mHandler;

        SettingsObserver(Handler handler, int msg) {
            super(handler);
            mHandler = handler;
            mMsg = msg;
        }

        void observe(Context context) {
            ContentResolver resolver = context.getContentResolver();
            resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.AUTO_TIME),
                    false, this);
        }

        @Override
        public void onChange(boolean selfChange) {
            mHandler.obtainMessage(mMsg).sendToTarget();
        }
    }

    @Override
    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;
        pw.print(""PollingIntervalMs: "");
        TimeUtils.formatDuration(mPollingIntervalMs, pw);
        pw.print(""\nPollingIntervalShorterMs: "");
        TimeUtils.formatDuration(mPollingIntervalShorterMs, pw);
        pw.println(""\nTryAgainTimesMax: "" + mTryAgainTimesMax);
        pw.print(""TimeErrorThresholdMs: "");
        TimeUtils.formatDuration(mTimeErrorThresholdMs, pw);
        pw.println(""\nTryAgainCounter: "" + mTryAgainCounter);
        pw.println(""NTP cache age: "" + mTime.getCacheAge());
        pw.println(""NTP cache certainty: "" + mTime.getCacheCertainty());
        pw.println();
    }
","    public void systemRunning() {
        registerForTelephonyIntents();
        registerForAlarms();

        HandlerThread thread = new HandlerThread(TAG);
        thread.start();
        mHandler = new MyHandler(thread.getLooper());
        mNetworkTimeUpdateCallback = new NetworkTimeUpdateCallback();
        mCM.registerDefaultNetworkCallback(mNetworkTimeUpdateCallback, mHandler);

        mSettingsObserver = new SettingsObserver(mHandler, EVENT_AUTO_TIME_CHANGED);
        mSettingsObserver.observe(mContext);
    }

    private void registerForTelephonyIntents() {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(TelephonyIntents.ACTION_NETWORK_SET_TIME);
        mContext.registerReceiver(mNitzReceiver, intentFilter);
    }

    private void registerForAlarms() {
        mContext.registerReceiver(
            new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    mHandler.obtainMessage(EVENT_POLL_NETWORK_TIME).sendToTarget();
                }
            }, new IntentFilter(ACTION_POLL));
    }

    private void onPollNetworkTime(int event) {
        // If Automatic time is not set, don't bother. Similarly, if we don't
        // have any default network, don't bother.
        if (mDefaultNetwork == null) return;
        mWakeLock.acquire();
        try {
            onPollNetworkTimeUnderWakeLock(event);
        } finally {
            mWakeLock.release();
        }
    }

    private void onPollNetworkTimeUnderWakeLock(int event) {
        // Force an NTP fix when outdated
        if (mTime.getCacheAge() >= mPollingIntervalMs) {
            if (DBG) Log.d(TAG, ""Stale NTP fix; forcing refresh"");
            mTime.forceSync();
        }

        if (mTime.getCacheAge() < mPollingIntervalMs) {
            // Obtained fresh fix; schedule next normal update
            resetAlarm(mPollingIntervalMs);
            if (isAutomaticTimeRequested()) {
                updateSystemClock(event);
            }

        } else {
            // No fresh fix; schedule retry
            mTryAgainCounter++;
            if (mTryAgainTimesMax < 0 || mTryAgainCounter <= mTryAgainTimesMax) {
                resetAlarm(mPollingIntervalShorterMs);
            } else {
                // Try much later
                mTryAgainCounter = 0;
                resetAlarm(mPollingIntervalMs);
            }
        }
    }

    private long getNitzAge() {
        if (mNitzTimeSetTime == NOT_SET) {
            return Long.MAX_VALUE;
        } else {
            return SystemClock.elapsedRealtime() - mNitzTimeSetTime;
        }
    }

    /**
     * Consider updating system clock based on current NTP fix, if requested by
     * user, significant enough delta, and we don't have a recent NITZ.
     */
    private void updateSystemClock(int event) {
        final boolean forceUpdate = (event == EVENT_AUTO_TIME_CHANGED);
        if (!forceUpdate) {
            if (getNitzAge() < mPollingIntervalMs) {
                if (DBG) Log.d(TAG, ""Ignoring NTP update due to recent NITZ"");
                return;
            }

            final long skew = Math.abs(mTime.currentTimeMillis() - System.currentTimeMillis());
            if (skew < mTimeErrorThresholdMs) {
                if (DBG) Log.d(TAG, ""Ignoring NTP update due to low skew"");
                return;
            }
        }

        SystemClock.setCurrentTimeMillis(mTime.currentTimeMillis());
    }

    /**
     * Cancel old alarm and starts a new one for the specified interval.
     *
     * @param interval when to trigger the alarm, starting from now.
     */
    private void resetAlarm(long interval) {
        mAlarmManager.cancel(mPendingPollIntent);
        long now = SystemClock.elapsedRealtime();
        long next = now + interval;
        mAlarmManager.set(AlarmManager.ELAPSED_REALTIME, next, mPendingPollIntent);
    }

    /**
     * Checks if the user prefers to automatically set the time.
     */
    private boolean isAutomaticTimeRequested() {
        return Settings.Global.getInt(
                mContext.getContentResolver(), Settings.Global.AUTO_TIME, 0) != 0;
    }

    /** Receiver for Nitz time events */
    private BroadcastReceiver mNitzReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (DBG) Log.d(TAG, ""Received "" + action);
            if (TelephonyIntents.ACTION_NETWORK_SET_TIME.equals(action)) {
                mNitzTimeSetTime = SystemClock.elapsedRealtime();
            }
        }
    };

    /** Handler to do the network accesses on */
    private class MyHandler extends Handler {

        public MyHandler(Looper l) {
            super(l);
        }

        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case EVENT_AUTO_TIME_CHANGED:
                case EVENT_POLL_NETWORK_TIME:
                case EVENT_NETWORK_CHANGED:
                    onPollNetworkTime(msg.what);
                    break;
            }
        }
    }

    private class NetworkTimeUpdateCallback extends NetworkCallback {
        @Override
        public void onAvailable(Network network) {
            Log.d(TAG, String.format(""New default network %s; checking time."", network));
            mDefaultNetwork = network;
            // Running on mHandler so invoke directly.
            onPollNetworkTime(EVENT_NETWORK_CHANGED);
        }

        @Override
        public void onLost(Network network) {
            if (network.equals(mDefaultNetwork)) mDefaultNetwork = null;
        }
    }

    /** Observer to watch for changes to the AUTO_TIME setting */
    private static class SettingsObserver extends ContentObserver {

        private int mMsg;
        private Handler mHandler;

        SettingsObserver(Handler handler, int msg) {
            super(handler);
            mHandler = handler;
            mMsg = msg;
        }

        void observe(Context context) {
            ContentResolver resolver = context.getContentResolver();
            resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.AUTO_TIME),
                    false, this);
        }

        @Override
        public void onChange(boolean selfChange) {
            mHandler.obtainMessage(mMsg).sendToTarget();
        }
    }

    @Override
    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;
        pw.print(""PollingIntervalMs: "");
        TimeUtils.formatDuration(mPollingIntervalMs, pw);
        pw.print(""\nPollingIntervalShorterMs: "");
        TimeUtils.formatDuration(mPollingIntervalShorterMs, pw);
        pw.println(""\nTryAgainTimesMax: "" + mTryAgainTimesMax);
        pw.print(""TimeErrorThresholdMs: "");
        TimeUtils.formatDuration(mTimeErrorThresholdMs, pw);
        pw.println(""\nTryAgainCounter: "" + mTryAgainCounter);
        pw.println(""NTP cache age: "" + mTime.getCacheAge());
        pw.println(""NTP cache certainty: "" + mTime.getCacheCertainty());
        pw.println();
    }
","    public void systemRunning() {
        registerForTelephonyIntents();
        registerForAlarms();

        HandlerThread thread = new HandlerThread(TAG);
        thread.start();
        mHandler = new MyHandler(thread.getLooper());
        mNetworkTimeUpdateCallback = new NetworkTimeUpdateCallback();
        mCM.registerDefaultNetworkCallback(mNetworkTimeUpdateCallback, mHandler);

        mSettingsObserver = new SettingsObserver(mHandler, EVENT_AUTO_TIME_CHANGED);
        mSettingsObserver.observe(mContext);
    }

    private void registerForTelephonyIntents() {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(TelephonyIntents.ACTION_NETWORK_SET_TIME);
        mContext.registerReceiver(mNitzReceiver, intentFilter);
    }

    private void registerForAlarms() {
        mContext.registerReceiver(
            new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    mHandler.obtainMessage(EVENT_POLL_NETWORK_TIME).sendToTarget();
                }
            }, new IntentFilter(ACTION_POLL));
    }

    private void onPollNetworkTime(int event) {
        // If Automatic time is not set, don't bother. Similarly, if we don't
        // have any default network, don't bother.
        if (mDefaultNetwork == null) return;
        mWakeLock.acquire();
        try {
            onPollNetworkTimeUnderWakeLock(event);
        } finally {
            mWakeLock.release();
        }
    }

    private void onPollNetworkTimeUnderWakeLock(int event) {
        // Force an NTP fix when outdated
        if (mTime.getCacheAge() >= mPollingIntervalMs) {
            if (DBG) Log.d(TAG, ""Stale NTP fix; forcing refresh"");
            mTime.forceSync();
        }

        if (mTime.getCacheAge() < mPollingIntervalMs) {
            // Obtained fresh fix; schedule next normal update
            resetAlarm(mPollingIntervalMs);
            if (isAutomaticTimeRequested()) {
                updateSystemClock(event);
            }

        } else {
            // No fresh fix; schedule retry
            mTryAgainCounter++;
            if (mTryAgainTimesMax < 0 || mTryAgainCounter <= mTryAgainTimesMax) {
                resetAlarm(mPollingIntervalShorterMs);
            } else {
                // Try much later
                mTryAgainCounter = 0;
                resetAlarm(mPollingIntervalMs);
            }
        }
    }

    private long getNitzAge() {
        if (mNitzTimeSetTime == NOT_SET) {
            return Long.MAX_VALUE;
        } else {
            return SystemClock.elapsedRealtime() - mNitzTimeSetTime;
        }
    }

    /**
     * Consider updating system clock based on current NTP fix, if requested by
     * user, significant enough delta, and we don't have a recent NITZ.
     */
    private void updateSystemClock(int event) {
        final boolean forceUpdate = (event == EVENT_AUTO_TIME_CHANGED);
        if (!forceUpdate) {
            if (getNitzAge() < mPollingIntervalMs) {
                if (DBG) Log.d(TAG, ""Ignoring NTP update due to recent NITZ"");
                return;
            }

            final long skew = Math.abs(mTime.currentTimeMillis() - System.currentTimeMillis());
            if (skew < mTimeErrorThresholdMs) {
                if (DBG) Log.d(TAG, ""Ignoring NTP update due to low skew"");
                return;
            }
        }

        SystemClock.setCurrentTimeMillis(mTime.currentTimeMillis());
    }

    /**
     * Cancel old alarm and starts a new one for the specified interval.
     *
     * @param interval when to trigger the alarm, starting from now.
     */
    private void resetAlarm(long interval) {
        mAlarmManager.cancel(mPendingPollIntent);
        long now = SystemClock.elapsedRealtime();
        long next = now + interval;
        mAlarmManager.set(AlarmManager.ELAPSED_REALTIME, next, mPendingPollIntent);
    }

    /**
     * Checks if the user prefers to automatically set the time.
     */
    private boolean isAutomaticTimeRequested() {
        return Settings.Global.getInt(
                mContext.getContentResolver(), Settings.Global.AUTO_TIME, 0) != 0;
    }

    /** Receiver for Nitz time events */
    private BroadcastReceiver mNitzReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (DBG) Log.d(TAG, ""Received "" + action);
            if (TelephonyIntents.ACTION_NETWORK_SET_TIME.equals(action)) {
                mNitzTimeSetTime = SystemClock.elapsedRealtime();
            }
        }
    };

    /** Handler to do the network accesses on */
    private class MyHandler extends Handler {

        public MyHandler(Looper l) {
            super(l);
        }

        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case EVENT_AUTO_TIME_CHANGED:
                case EVENT_POLL_NETWORK_TIME:
                case EVENT_NETWORK_CHANGED:
                    onPollNetworkTime(msg.what);
                    break;
            }
        }
    }

    private class NetworkTimeUpdateCallback extends NetworkCallback {
        @Override
        public void onAvailable(Network network) {
            Log.d(TAG, String.format(""New default network %s; checking time."", network));
            mDefaultNetwork = network;
            // Running on mHandler so invoke directly.
            onPollNetworkTime(EVENT_NETWORK_CHANGED);
        }

        @Override
        public void onLost(Network network) {
            if (network.equals(mDefaultNetwork)) mDefaultNetwork = null;
        }
    }

    /** Observer to watch for changes to the AUTO_TIME setting */
    private static class SettingsObserver extends ContentObserver {

        private int mMsg;
        private Handler mHandler;

        SettingsObserver(Handler handler, int msg) {
            super(handler);
            mHandler = handler;
            mMsg = msg;
        }

        void observe(Context context) {
            ContentResolver resolver = context.getContentResolver();
            resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.AUTO_TIME),
                    false, this);
        }

        @Override
        public void onChange(boolean selfChange) {
            mHandler.obtainMessage(mMsg).sendToTarget();
        }
    }

    @Override
    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;
        pw.print(""PollingIntervalMs: "");
        TimeUtils.formatDuration(mPollingIntervalMs, pw);
        pw.print(""\nPollingIntervalShorterMs: "");
        TimeUtils.formatDuration(mPollingIntervalShorterMs, pw);
        pw.println(""\nTryAgainTimesMax: "" + mTryAgainTimesMax);
        pw.print(""TimeErrorThresholdMs: "");
        TimeUtils.formatDuration(mTimeErrorThresholdMs, pw);
        pw.println(""\nTryAgainCounter: "" + mTryAgainCounter);
        pw.println(""NTP cache age: "" + mTime.getCacheAge());
        pw.println(""NTP cache certainty: "" + mTime.getCacheCertainty());
        pw.println();
    }
","[1.0, 1.0]"
26,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(6040, 6108, 69), (5923, 5990, 68)]","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }
}
","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }
","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }
","[0.999, 1.0]"
27,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8050, 8050, 1), (8201, 8201, 1)]","            WIFI_DISCONNECT_DELAY_DURATION
","            WIFI_DISCONNECT_DELAY_DURATION,
",            WIFI_DISCONNECT_DELAY_DURATION,"[0.977, 0.955]"
28,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8199, 8199, 1), (8355, 8355, 1)]","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","[1.0, 1.0]"
29,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8050, 8050, 1), (8201, 8201, 1)]","            WIFI_DISCONNECT_DELAY_DURATION
","            WIFI_DISCONNECT_DELAY_DURATION,
",            WIFI_DISCONNECT_DELAY_DURATION,"[0.977, 0.955]"
30,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8199, 8199, 1), (8355, 8355, 1)]","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","[1.0, 1.0]"
31,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActiveServices.java,"[(2547, 2552, 6), (3198, 3204, 7)]","                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortName + "" in "" + r.restartDelay + ""ms"");
                    }
","                    app.services.remove(r);
                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");
                    }
","                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.short","[0.815, 0.705]"
32,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(1228, 1231, 4), (1229, 1232, 4)]","        A2dpSinkProfile a2dpSinkProfile = mProfileManager.getA2dpSinkProfile();
        Log.i(TAG, ""a2dpProfile :"" + a2dpProfile + "" a2dpSinkProfile :"" + a2dpSinkProfile);
        if (a2dpProfile != null) {
            return a2dpProfile.getConnectionStatus(mDevice) ==
","        A2dpSinkProfile a2dpSinkProfile = mProfileManager.getA2dpSinkProfile();
        Log.i(TAG, ""a2dpProfile :"" + a2dpProfile + "" a2dpSinkProfile :"" + a2dpSinkProfile);
        if (a2dpProfile != null) {
            return a2dpProfile.getConnectionStatus(mDevice) ==
","        A2dpSinkProfile a2dpSinkProfile = mProfileManager.getA2dpSinkProfile();
        Log.i(TAG, ""a2dpProfile :"" + a2dpProfile + "" a2dpSinkProfile :"" + a2dpSinkProfile);
        if (a2dpProfile != null) {
            return a2dpProfile.getConnectionStatus(mDevice) ==
","[1.0, 1.0]"
33,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8199, 8199, 1), (8191, 8191, 1)]","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","[1.0, 1.0]"
34,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(52, 52, 1), (56, 56, 1)]","import java.io.BufferedReader;
","import java.io.BufferedReader;
","import java.io.BufferedReader;
","[1.0, 1.0]"
35,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(6040, 6108, 69), (5961, 6026, 66)]","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }
}
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","[0.997, 1.0]"
36,"['1581c348fc5d6cbf1673b3dbc5960637f891d488', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(32, 33, 2), (32, 34, 3)]","import android.support.annotation.VisibleForTesting;
import android.os.SystemProperties;
","import androidx.annotation.VisibleForTesting;
import android.os.SystemProperties;

",".annotation.VisibleForTesting;
import android.os.SystemProperties;
","[0.753, 0.807]"
38,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(5923, 5990, 68), (5923, 5990, 68)]","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }
","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }
","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }
","[1.0, 1.0]"
39,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(2720, 2742, 23), (2720, 2742, 23)]","            // Collect all Regionalization packages form Carrier's res packages.
            if (RegionalizationEnvironment.isSupported()) {
                Log.d(TAG, ""Load Regionalization vendor apks"");
                final List<File> RegionalizationDirs =
                        RegionalizationEnvironment.getAllPackageDirectories();
                for (File f : RegionalizationDirs) {
                    File RegionalizationSystemDir = new File(f, ""system"");
                    // Collect packages in <Package>/system/app
                    scanDirLI(new File(RegionalizationSystemDir, ""app""),
                            PackageParser.PARSE_IS_SYSTEM_DIR,
                            scanFlags
                            | SCAN_AS_SYSTEM,
                            0);
                    // Collect overlay in <Package>/system/vendor
                    scanDirLI(new File(RegionalizationSystemDir, ""vendor/overlay""),
                            PackageParser.PARSE_IS_SYSTEM_DIR,
                            scanFlags
                            | SCAN_AS_SYSTEM
                            | SCAN_AS_VENDOR,
                            0);
                }
            }

","            // Collect all Regionalization packages form Carrier's res packages.
            if (RegionalizationEnvironment.isSupported()) {
                Log.d(TAG, ""Load Regionalization vendor apks"");
                final List<File> RegionalizationDirs =
                        RegionalizationEnvironment.getAllPackageDirectories();
                for (File f : RegionalizationDirs) {
                    File RegionalizationSystemDir = new File(f, ""system"");
                    // Collect packages in <Package>/system/app
                    scanDirLI(new File(RegionalizationSystemDir, ""app""),
                            PackageParser.PARSE_IS_SYSTEM_DIR,
                            scanFlags
                            | SCAN_AS_SYSTEM,
                            0);
                    // Collect overlay in <Package>/system/vendor
                    scanDirLI(new File(RegionalizationSystemDir, ""vendor/overlay""),
                            PackageParser.PARSE_IS_SYSTEM_DIR,
                            scanFlags
                            | SCAN_AS_SYSTEM
                            | SCAN_AS_VENDOR,
                            0);
                }
            }

","            // Collect all Regionalization packages form Carrier's res packages.
            if (RegionalizationEnvironment.isSupported()) {
                Log.d(TAG, ""Load Regionalization vendor apks"");
                final List<File> RegionalizationDirs =
                        RegionalizationEnvironment.getAllPackageDirectories();
                for (File f : RegionalizationDirs) {
                    File RegionalizationSystemDir = new File(f, ""system"");
                    // Collect packages in <Package>/system/app
                    scanDirLI(new File(RegionalizationSystemDir, ""app""),
                            PackageParser.PARSE_IS_SYSTEM_DIR,
                            scanFlags
                            | SCAN_AS_SYSTEM,
                            0);
                    // Collect overlay in <Package>/system/vendor
                    scanDirLI(new File(RegionalizationSystemDir, ""vendor/overlay""),
                            PackageParser.PARSE_IS_SYSTEM_DIR,
                            scanFlags
                            | SCAN_AS_SYSTEM
                            | SCAN_AS_VENDOR,
                            0);
                }
            }

","[1.0, 1.0]"
40,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(12264, 12329, 66), (12264, 12329, 66)]","        }

        // writer
        synchronized (mPackages) {
            // Remove the parent package
            mPackages.remove(pkg.applicationInfo.packageName);
            cleanPackageDataStructuresLILPw(pkg, chatty);

            // Remove the child packages
            final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = pkg.childPackages.get(i);
                mPackages.remove(childPkg.applicationInfo.packageName);
                cleanPackageDataStructuresLILPw(childPkg, chatty);
            }
        }
    }

    void cleanPackageDataStructuresLILPw(PackageParser.Package pkg, boolean chatty) {
        mComponentResolver.removeAllComponents(pkg, chatty);

        final ArrayList<String> allPackageNames = new ArrayList<>(mPackages.keySet());
        mPermissionManager.removeAllPermissions(pkg, allPackageNames, mPermissionCallback, chatty);

        final int instrumentationSize = pkg.instrumentation.size();
        StringBuilder r = null;
        int i;
        for (i = 0; i < instrumentationSize; i++) {
            PackageParser.Instrumentation a = pkg.instrumentation.get(i);
            mInstrumentation.remove(a.getComponentName());
            if (DEBUG_REMOVE && chatty) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_REMOVE) Log.d(TAG, ""  Instrumentation: "" + r);
        }

        r = null;
        if ((pkg.applicationInfo.flags&ApplicationInfo.FLAG_SYSTEM) != 0) {
            // Only system apps can hold shared libraries.
            if (pkg.libraryNames != null) {
                final int libraryNamesSize = pkg.libraryNames.size();
                for (i = 0; i < libraryNamesSize; i++) {
                    String name = pkg.libraryNames.get(i);
                    if (removeSharedLibraryLPw(name, 0)) {
                        if (DEBUG_REMOVE && chatty) {
                            if (r == null) {
                                r = new StringBuilder(256);
                            } else {
                                r.append(' ');
                            }
                            r.append(name);
                        }
                    }
                }
            }
        }

        r = null;

","        }

        // writer
        synchronized (mPackages) {
            // Remove the parent package
            mPackages.remove(pkg.applicationInfo.packageName);
            cleanPackageDataStructuresLILPw(pkg, chatty);

            // Remove the child packages
            final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = pkg.childPackages.get(i);
                mPackages.remove(childPkg.applicationInfo.packageName);
                cleanPackageDataStructuresLILPw(childPkg, chatty);
            }
        }
    }

    void cleanPackageDataStructuresLILPw(PackageParser.Package pkg, boolean chatty) {
        mComponentResolver.removeAllComponents(pkg, chatty);

        final ArrayList<String> allPackageNames = new ArrayList<>(mPackages.keySet());
        mPermissionManager.removeAllPermissions(pkg, allPackageNames, mPermissionCallback, chatty);

        final int instrumentationSize = pkg.instrumentation.size();
        StringBuilder r = null;
        int i;
        for (i = 0; i < instrumentationSize; i++) {
            PackageParser.Instrumentation a = pkg.instrumentation.get(i);
            mInstrumentation.remove(a.getComponentName());
            if (DEBUG_REMOVE && chatty) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_REMOVE) Log.d(TAG, ""  Instrumentation: "" + r);
        }

        r = null;
        if ((pkg.applicationInfo.flags&ApplicationInfo.FLAG_SYSTEM) != 0) {
            // Only system apps can hold shared libraries.
            if (pkg.libraryNames != null) {
                final int libraryNamesSize = pkg.libraryNames.size();
                for (i = 0; i < libraryNamesSize; i++) {
                    String name = pkg.libraryNames.get(i);
                    if (removeSharedLibraryLPw(name, 0)) {
                        if (DEBUG_REMOVE && chatty) {
                            if (r == null) {
                                r = new StringBuilder(256);
                            } else {
                                r.append(' ');
                            }
                            r.append(name);
                        }
                    }
                }
            }
        }

        r = null;

","        }

        // writer
        synchronized (mPackages) {
            // Remove the parent package
            mPackages.remove(pkg.applicationInfo.packageName);
            cleanPackageDataStructuresLILPw(pkg, chatty);

            // Remove the child packages
            final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = pkg.childPackages.get(i);
                mPackages.remove(childPkg.applicationInfo.packageName);
                cleanPackageDataStructuresLILPw(childPkg, chatty);
            }
        }
    }

    void cleanPackageDataStructuresLILPw(PackageParser.Package pkg, boolean chatty) {
        mComponentResolver.removeAllComponents(pkg, chatty);

        final ArrayList<String> allPackageNames = new ArrayList<>(mPackages.keySet());
        mPermissionManager.removeAllPermissions(pkg, allPackageNames, mPermissionCallback, chatty);

        final int instrumentationSize = pkg.instrumentation.size();
        StringBuilder r = null;
        int i;
        for (i = 0; i < instrumentationSize; i++) {
            PackageParser.Instrumentation a = pkg.instrumentation.get(i);
            mInstrumentation.remove(a.getComponentName());
            if (DEBUG_REMOVE && chatty) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_REMOVE) Log.d(TAG, ""  Instrumentation: "" + r);
        }

        r = null;
        if ((pkg.applicationInfo.flags&ApplicationInfo.FLAG_SYSTEM) != 0) {
            // Only system apps can hold shared libraries.
            if (pkg.libraryNames != null) {
                final int libraryNamesSize = pkg.libraryNames.size();
                for (i = 0; i < libraryNamesSize; i++) {
                    String name = pkg.libraryNames.get(i);
                    if (removeSharedLibraryLPw(name, 0)) {
                        if (DEBUG_REMOVE && chatty) {
                            if (r == null) {
                                r = new StringBuilder(256);
                            } else {
                                r.append(' ');
                            }
                            r.append(name);
                        }
                    }
                }
            }
        }

        r = null;

","[1.0, 1.0]"
41,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(153, 153, 1), (153, 153, 1)]","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","[1.0, 1.0]"
42,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothEventManager.java,"[(212, 217, 6), (212, 217, 6)]","
    private void addHandler(String action, Handler handler) {
        mHandlerMap.put(action, handler);
        mAdapterIntentFilter.addAction(action);
    }

","
    private void addHandler(String action, Handler handler) {
        mHandlerMap.put(action, handler);
        mAdapterIntentFilter.addAction(action);
    }

","
    private void addHandler(String action, Handler handler) {
        mHandlerMap.put(action, handler);
        mAdapterIntentFilter.addAction(action);
    }

","[1.0, 1.0]"
43,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8201, 8201, 1), (8201, 8201, 1)]","            WIFI_DISCONNECT_DELAY_DURATION,
","            WIFI_DISCONNECT_DELAY_DURATION,
","            WIFI_DISCONNECT_DELAY_DURATION,
","[1.0, 1.0]"
44,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8355, 8355, 1), (8355, 8355, 1)]","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","[1.0, 1.0]"
45,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(302, 303, 2), (302, 303, 2)]","import android.view.autofill.AutofillManagerInternal;

","import android.view.autofill.AutofillManagerInternal;

","import android.view.autofill.AutofillManagerInternal;

","[1.0, 1.0]"
46,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"[(100, 100, 1), (100, 100, 1)]","    private DunServerProfile mDunProfile;
","    private DunServerProfile mDunProfile;
","    private DunServerProfile mDunProfile;
","[1.0, 1.0]"
47,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"[(222, 227, 6), (222, 227, 6)]","        }
        if (mDunProfile == null && supportedList.contains(BluetoothProfile.DUN)) {
            if(DEBUG) Log.d(TAG, ""Adding local DUN profile"");
            mDunProfile = new DunServerProfile(mContext);
            addProfile(mDunProfile, DunServerProfile.NAME,
                    BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);
","        }
        if (mDunProfile == null && supportedList.contains(BluetoothProfile.DUN)) {
            if(DEBUG) Log.d(TAG, ""Adding local DUN profile"");
            mDunProfile = new DunServerProfile(mContext);
            addProfile(mDunProfile, DunServerProfile.NAME,
                    BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);
","        }
        if (mDunProfile == null && supportedList.contains(BluetoothProfile.DUN)) {
            if(DEBUG) Log.d(TAG, ""Adding local DUN profile"");
            mDunProfile = new DunServerProfile(mContext);
            addProfile(mDunProfile, DunServerProfile.NAME,
                    BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);
","[1.0, 1.0]"
48,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/nfc/cardemulation/ApduServiceInfo.java,"[(62, 62, 1), (62, 62, 1)]","    protected  ResolveInfo mService;
","    protected  ResolveInfo mService;
","    protected  ResolveInfo mService;
","[1.0, 1.0]"
49,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/nfc/cardemulation/ApduServiceInfo.java,"[(78, 78, 1), (78, 78, 1)]","    protected  HashMap<String, AidGroup> mStaticAidGroups;
","    protected  HashMap<String, AidGroup> mStaticAidGroups;
","    protected  HashMap<String, AidGroup> mStaticAidGroups;
","[1.0, 1.0]"
50,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/nfc/cardemulation/ApduServiceInfo.java,"[(78, 78, 1), (84, 84, 1)]","    protected  HashMap<String, AidGroup> mStaticAidGroups;
","    protected  HashMap<String, AidGroup> mDynamicAidGroups;
","    protected  HashMap<String, AidGroup> m","[0.712, 0.7]"
51,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/nfc/cardemulation/ApduServiceInfo.java,"[(84, 84, 1), (84, 84, 1)]","    protected  HashMap<String, AidGroup> mDynamicAidGroups;
","    protected  HashMap<String, AidGroup> mDynamicAidGroups;
","    protected  HashMap<String, AidGroup> mDynamicAidGroups;
","[1.0, 1.0]"
52,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/BluetoothCodecConfig.java,"[(47, 49, 3), (47, 49, 3)]","    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 5;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_MAX = 6;
","    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 5;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_MAX = 6;
","    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 5;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_MAX = 6;
","[1.0, 1.0]"
53,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/WindowManagerService.java,"[(230, 230, 1), (230, 230, 1)]","import com.android.internal.app.ActivityTrigger;
","import com.android.internal.app.ActivityTrigger;
","import com.android.internal.app.ActivityTrigger;
","[1.0, 1.0]"
54,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/WindowManagerService.java,"[(5778, 5783, 6), (5778, 5783, 6)]","        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
        if (mPerf != null) {
            mPerf.perfHint(BoostFramework.VENDOR_HINT_ROTATION_LATENCY_BOOST, null);
        }
","        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
        if (mPerf != null) {
            mPerf.perfHint(BoostFramework.VENDOR_HINT_ROTATION_LATENCY_BOOST, null);
        }
","        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
        if (mPerf != null) {
            mPerf.perfHint(BoostFramework.VENDOR_HINT_ROTATION_LATENCY_BOOST, null);
        }
","[1.0, 1.0]"
55,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/policy/PhoneWindowManager.java,"[(2110, 2114, 5), (2110, 2114, 5)]","                        if(SCROLL_BOOST_SS_ENABLE && mPerfBoostFling!= null
                                            && mIsPerfBoostFlingAcquired) {
                            mPerfBoostFling.perfLockRelease();
                            mIsPerfBoostFlingAcquired = false;
                        }
","                        if(SCROLL_BOOST_SS_ENABLE && mPerfBoostFling!= null
                                            && mIsPerfBoostFlingAcquired) {
                            mPerfBoostFling.perfLockRelease();
                            mIsPerfBoostFlingAcquired = false;
                        }
","                        if(SCROLL_BOOST_SS_ENABLE && mPerfBoostFling!= null
                                            && mIsPerfBoostFlingAcquired) {
                            mPerfBoostFling.perfLockRelease();
                            mIsPerfBoostFlingAcquired = false;
                        }
","[1.0, 1.0]"
56,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(3996, 4180, 185), (3996, 4180, 185)]","
    /**
     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
","
    /**
     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
","
    /**
     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
","[1.0, 1.0]"
57,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/nfc/cardemulation/AidGroup.java,"[(53, 57, 5), (53, 57, 5)]","    protected List<String> aids;
    @UnsupportedAppUsage
    protected String category;
    @UnsupportedAppUsage
    protected String description;
","    protected List<String> aids;
    @UnsupportedAppUsage
    protected String category;
    @UnsupportedAppUsage
    protected String description;
","    protected List<String> aids;
    @UnsupportedAppUsage
    protected String category;
    @UnsupportedAppUsage
    protected String description;
","[1.0, 1.0]"
58,"['1730c08a2fd38f0ff8135692a855ada865130939', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,"[(56, 58, 3), (56, 58, 3)]","        if(wifiManager != null){
            wifiManager.registerTrafficStateCallback(new WifiTrafficStateCallback(),  null);
        }
","        if(wifiManager != null){
            wifiManager.registerTrafficStateCallback(new WifiTrafficStateCallback(),  null);
        }
","        if(wifiManager != null){
            wifiManager.registerTrafficStateCallback(new WifiTrafficStateCallback(),  null);
        }
","[1.0, 1.0]"
59,"['1730c08a2fd38f0ff8135692a855ada865130939', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8201, 8201, 1), (8201, 8201, 1)]","            WIFI_DISCONNECT_DELAY_DURATION,
","            WIFI_DISCONNECT_DELAY_DURATION,
","            WIFI_DISCONNECT_DELAY_DURATION,
","[1.0, 1.0]"
60,"['1730c08a2fd38f0ff8135692a855ada865130939', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8355, 8355, 1), (8355, 8355, 1)]","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","[1.0, 1.0]"
61,"['1730c08a2fd38f0ff8135692a855ada865130939', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(3996, 4180, 185), (3998, 4179, 182)]","
    /**
     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
","     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
","     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
","[0.997, 1.0]"
62,"['1730c08a2fd38f0ff8135692a855ada865130939', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(153, 153, 1), (144, 144, 1)]","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","[1.0, 1.0]"
63,"['1730c08a2fd38f0ff8135692a855ada865130939', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(153, 153, 1), (156, 156, 1)]","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","[1.0, 1.0]"
64,"['1730c08a2fd38f0ff8135692a855ada865130939', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,"[(56, 58, 3), (56, 57, 2)]","        if(wifiManager != null){
            wifiManager.registerTrafficStateCallback(new WifiTrafficStateCallback(),  null);
        }
","        if(wifiManager != null){
            wifiManager.registerTrafficStateCallback(new WifiTrafficStateCallback(),  null);
","        if(wifiManager != null){
            wifiManager.registerTrafficStateCallback(new WifiTrafficStateCallback(),  null);
","[0.926, 1.0]"
65,"['1730c08a2fd38f0ff8135692a855ada865130939', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(153, 153, 1), (151, 151, 1)]","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","[1.0, 1.0]"
66,"['1730c08a2fd38f0ff8135692a855ada865130939', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8355, 8355, 1), (8191, 8191, 1)]","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","[1.0, 1.0]"
67,"['1730c08a2fd38f0ff8135692a855ada865130939', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(3996, 4180, 185), (4012, 4193, 182)]","
    /**
     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
","     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
","     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
","[0.997, 1.0]"
68,"['1730c08a2fd38f0ff8135692a855ada865130939', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(5923, 5990, 68), (5961, 6026, 66)]","
    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","[0.997, 1.0]"
69,"['1730c08a2fd38f0ff8135692a855ada865130939', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"[(222, 227, 6), (216, 220, 5)]","        }
        if (mDunProfile == null && supportedList.contains(BluetoothProfile.DUN)) {
            if(DEBUG) Log.d(TAG, ""Adding local DUN profile"");
            mDunProfile = new DunServerProfile(mContext);
            addProfile(mDunProfile, DunServerProfile.NAME,
                    BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);
","        if (mDunProfile == null && supportedList.contains(BluetoothProfile.DUN)) {
            if(DEBUG) Log.d(TAG, ""Adding local DUN profile"");
            mDunProfile = new DunServerProfile(mContext);
            addProfile(mDunProfile, DunServerProfile.NAME,
                    BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);
","        if (mDunProfile == null && supportedList.contains(BluetoothProfile.DUN)) {
            if(DEBUG) Log.d(TAG, ""Adding local DUN profile"");
            mDunProfile = new DunServerProfile(mContext);
            addProfile(mDunProfile, DunServerProfile.NAME,
                    BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);
","[0.971, 1.0]"
70,"['1730c08a2fd38f0ff8135692a855ada865130939', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/WindowManagerService.java,"[(230, 230, 1), (230, 230, 1)]","import com.android.internal.app.ActivityTrigger;
","import com.android.internal.app.ActivityTrigger;
","import com.android.internal.app.ActivityTrigger;
","[1.0, 1.0]"
72,"['188a21cc8ac704f36fd3f2984b4da86307ab7949', '188a21cc8ac704f36fd3f2984b4da86307ab7949']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(868, 868, 1), (868, 868, 1)]","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","[1.0, 1.0]"
73,"['188a21cc8ac704f36fd3f2984b4da86307ab7949', '2b252c526c654de6d04ec0165b4b8f039b37f82b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(868, 868, 1), (817, 817, 1)]","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","[1.0, 1.0]"
74,"['188a21cc8ac704f36fd3f2984b4da86307ab7949', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(868, 868, 1), (887, 887, 1)]","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","[1.0, 1.0]"
75,"['188a21cc8ac704f36fd3f2984b4da86307ab7949', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(868, 868, 1), (900, 900, 1)]","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","[1.0, 1.0]"
76,"['1eef3e1566be8570a0f7a856f12f8992f7d34824', '1eef3e1566be8570a0f7a856f12f8992f7d34824']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1236, 1240, 5), (1236, 1240, 5)]","
            if (psc.getProxyCount() == 0) {
                Slog.w(TAG, ""psc.getProxyCount() returned 0, removing psc entry for profile ""
                       + bluetoothProfile);
                mProfileServices.remove(new Integer(bluetoothProfile));
","
            if (psc.getProxyCount() == 0) {
                Slog.w(TAG, ""psc.getProxyCount() returned 0, removing psc entry for profile ""
                       + bluetoothProfile);
                mProfileServices.remove(new Integer(bluetoothProfile));
","
            if (psc.getProxyCount() == 0) {
                Slog.w(TAG, ""psc.getProxyCount() returned 0, removing psc entry for profile ""
                       + bluetoothProfile);
                mProfileServices.remove(new Integer(bluetoothProfile));
","[1.0, 1.0]"
77,"['1eef3e1566be8570a0f7a856f12f8992f7d34824', '1eef3e1566be8570a0f7a856f12f8992f7d34824']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1417, 1423, 7), (1417, 1423, 7)]","        public int getProxyCount() {
            int retval = 0;
            if (mProxies != null) {
                retval = mProxies.getRegisteredCallbackCount();
            }
            Slog.w(TAG, ""getProxyCount(): returning retval "" + retval);
            return retval;
","        public int getProxyCount() {
            int retval = 0;
            if (mProxies != null) {
                retval = mProxies.getRegisteredCallbackCount();
            }
            Slog.w(TAG, ""getProxyCount(): returning retval "" + retval);
            return retval;
","        public int getProxyCount() {
            int retval = 0;
            if (mProxies != null) {
                retval = mProxies.getRegisteredCallbackCount();
            }
            Slog.w(TAG, ""getProxyCount(): returning retval "" + retval);
            return retval;
","[1.0, 1.0]"
78,"['1eef3e1566be8570a0f7a856f12f8992f7d34824', '1eef3e1566be8570a0f7a856f12f8992f7d34824']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/BluetoothHeadset.java,"[(393, 397, 5), (393, 397, 5)]","            try {
                 mAdapter.getBluetoothManager().unbindBluetoothProfileService(
                         BluetoothProfile.HEADSET, mConnection);
            } catch (RemoteException e) {
                Log.e(TAG, ""Unable to unbind HeadsetService"", e);
","            try {
                 mAdapter.getBluetoothManager().unbindBluetoothProfileService(
                         BluetoothProfile.HEADSET, mConnection);
            } catch (RemoteException e) {
                Log.e(TAG, ""Unable to unbind HeadsetService"", e);
","            try {
                 mAdapter.getBluetoothManager().unbindBluetoothProfileService(
                         BluetoothProfile.HEADSET, mConnection);
            } catch (RemoteException e) {
                Log.e(TAG, ""Unable to unbind HeadsetService"", e);
","[1.0, 1.0]"
79,"['1eef3e1566be8570a0f7a856f12f8992f7d34824', '1eef3e1566be8570a0f7a856f12f8992f7d34824']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/BluetoothHeadset.java,"[(1193, 1200, 8), (1193, 1200, 8)]","            try {
                mServiceLock.writeLock().lock();
                mService = null;
                mHandler.sendMessage(mHandler.obtainMessage(
                        MESSAGE_HEADSET_SERVICE_DISCONNECTED));
            } finally {
                mServiceLock.writeLock().unlock();
            }
","            try {
                mServiceLock.writeLock().lock();
                mService = null;
                mHandler.sendMessage(mHandler.obtainMessage(
                        MESSAGE_HEADSET_SERVICE_DISCONNECTED));
            } finally {
                mServiceLock.writeLock().unlock();
            }
","            try {
                mServiceLock.writeLock().lock();
                mService = null;
                mHandler.sendMessage(mHandler.obtainMessage(
                        MESSAGE_HEADSET_SERVICE_DISCONNECTED));
            } finally {
                mServiceLock.writeLock().unlock();
            }
","[1.0, 1.0]"
80,"['1eef3e1566be8570a0f7a856f12f8992f7d34824', '1eef3e1566be8570a0f7a856f12f8992f7d34824']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/tiles/HotspotTile.java,"[(141, 147, 7), (141, 147, 7)]","            state.icon = ResourceIcon.get(R.drawable.ic_hotspot_transient_animation);
        } else if (state.value) {
            if (mIeee80211axSupport) {
                state.icon = mWifi6EnabledStatic;
            } else if (mIeee80211acSupport) {
                state.icon = mWifi5EnabledStatic;
            }
","            state.icon = ResourceIcon.get(R.drawable.ic_hotspot_transient_animation);
        } else if (state.value) {
            if (mIeee80211axSupport) {
                state.icon = mWifi6EnabledStatic;
            } else if (mIeee80211acSupport) {
                state.icon = mWifi5EnabledStatic;
            }
","            state.icon = ResourceIcon.get(R.drawable.ic_hotspot_transient_animation);
        } else if (state.value) {
            if (mIeee80211axSupport) {
                state.icon = mWifi6EnabledStatic;
            } else if (mIeee80211acSupport) {
                state.icon = mWifi5EnabledStatic;
            }
","[1.0, 1.0]"
89,"['2775a5a9b030266a910301e8b464811acafcd5fa', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/java/com/android/server/SystemServer.java,"[(1382, 1417, 36), (1398, 1426, 29)]","            traceBeginAndSlog(""StartNetworkStack"");
            try {
                NetworkStackClient.getInstance().start(context);
            } catch (Throwable e) {
                reportWtf(""starting Network Stack"", e);
            }
            traceEnd();

            if (enableWigig) {
                try {
                    Slog.i(TAG, ""Wigig Service"");
                    String wigigClassPath =
                        ""/system/framework/wigig-service.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.supptunnel-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.netperftuner-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.capabilityconfigstore-V1.0-java.jar"";
                    PathClassLoader wigigClassLoader =
                            new PathClassLoader(wigigClassPath, getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl"");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigP2pServiceImpl class"");
                    ServiceManager.addService(""wigigp2p"", (IBinder) wigigP2pService);

                    Class wigigClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.WigigService"");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigService class"");
                    ServiceManager.addService(""wigig"", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf(""starting WigigService"", e);
                }
            }

","            if (enableWigig) {
                try {
                    Slog.i(TAG, ""Wigig Service"");
                    String wigigClassPath =
                        ""/system/framework/wigig-service.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.supptunnel-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.netperftuner-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.capabilityconfigstore-V1.0-java.jar"";
                    PathClassLoader wigigClassLoader =
                            new PathClassLoader(wigigClassPath, getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl"");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigP2pServiceImpl class"");
                    ServiceManager.addService(""wigigp2p"", (IBinder) wigigP2pService);

                    Class wigigClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.WigigService"");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigService class"");
                    ServiceManager.addService(""wigig"", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf(""starting WigigService"", e);
                }
            }

            traceBeginAndSlog(""StartNsdService"");
","            if (enableWigig) {
                try {
                    Slog.i(TAG, ""Wigig Service"");
                    String wigigClassPath =
                        ""/system/framework/wigig-service.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.supptunnel-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.netperftuner-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.capabilityconfigstore-V1.0-java.jar"";
                    PathClassLoader wigigClassLoader =
                            new PathClassLoader(wigigClassPath, getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl"");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigP2pServiceImpl class"");
                    ServiceManager.addService(""wigigp2p"", (IBinder) wigigP2pService);

                    Class wigigClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.WigigService"");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigService class"");
                    ServiceManager.addService(""wigig"", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf(""starting WigigService"", e);
                }
            }

","[0.867, 0.972]"
90,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/java/com/android/server/SystemServer.java,"[(1382, 1417, 36), (1382, 1417, 36)]","            traceBeginAndSlog(""StartNetworkStack"");
            try {
                NetworkStackClient.getInstance().start(context);
            } catch (Throwable e) {
                reportWtf(""starting Network Stack"", e);
            }
            traceEnd();

            if (enableWigig) {
                try {
                    Slog.i(TAG, ""Wigig Service"");
                    String wigigClassPath =
                        ""/system/framework/wigig-service.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.supptunnel-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.netperftuner-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.capabilityconfigstore-V1.0-java.jar"";
                    PathClassLoader wigigClassLoader =
                            new PathClassLoader(wigigClassPath, getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl"");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigP2pServiceImpl class"");
                    ServiceManager.addService(""wigigp2p"", (IBinder) wigigP2pService);

                    Class wigigClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.WigigService"");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigService class"");
                    ServiceManager.addService(""wigig"", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf(""starting WigigService"", e);
                }
            }

","            traceBeginAndSlog(""StartNetworkStack"");
            try {
                NetworkStackClient.getInstance().start(context);
            } catch (Throwable e) {
                reportWtf(""starting Network Stack"", e);
            }
            traceEnd();

            if (enableWigig) {
                try {
                    Slog.i(TAG, ""Wigig Service"");
                    String wigigClassPath =
                        ""/system/framework/wigig-service.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.supptunnel-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.netperftuner-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.capabilityconfigstore-V1.0-java.jar"";
                    PathClassLoader wigigClassLoader =
                            new PathClassLoader(wigigClassPath, getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl"");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigP2pServiceImpl class"");
                    ServiceManager.addService(""wigigp2p"", (IBinder) wigigP2pService);

                    Class wigigClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.WigigService"");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigService class"");
                    ServiceManager.addService(""wigig"", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf(""starting WigigService"", e);
                }
            }

","            traceBeginAndSlog(""StartNetworkStack"");
            try {
                NetworkStackClient.getInstance().start(context);
            } catch (Throwable e) {
                reportWtf(""starting Network Stack"", e);
            }
            traceEnd();

            if (enableWigig) {
                try {
                    Slog.i(TAG, ""Wigig Service"");
                    String wigigClassPath =
                        ""/system/framework/wigig-service.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.supptunnel-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.netperftuner-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.capabilityconfigstore-V1.0-java.jar"";
                    PathClassLoader wigigClassLoader =
                            new PathClassLoader(wigigClassPath, getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl"");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigP2pServiceImpl class"");
                    ServiceManager.addService(""wigigp2p"", (IBinder) wigigP2pService);

                    Class wigigClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.WigigService"");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigService class"");
                    ServiceManager.addService(""wigig"", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf(""starting WigigService"", e);
                }
            }

","[1.0, 1.0]"
91,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(575, 577, 3), (575, 577, 3)]","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            LocationListener listener) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            LocationListener listener) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            LocationListener listener) {
        android.util.SeempLog.record(47);
","[1.0, 1.0]"
92,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(575, 577, 3), (608, 610, 3)]","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            LocationListener listener) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            LocationListener listener, Looper looper) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            LocationListener listener","[0.733, 0.674]"
93,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(575, 577, 3), (671, 673, 3)]","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            LocationListener listener) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            PendingIntent intent) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            ","[0.587, 0.605]"
94,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(608, 610, 3), (608, 610, 3)]","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            LocationListener listener, Looper looper) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            LocationListener listener, Looper looper) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            LocationListener listener, Looper looper) {
        android.util.SeempLog.record(47);
","[1.0, 1.0]"
95,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(608, 610, 3), (642, 644, 3)]","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            LocationListener listener, Looper looper) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria,
            LocationListener listener, Looper looper) {
        android.util.SeempLog.record(47);
",",
            LocationListener listener, Looper looper) {
        android.util.SeempLog.record(47);
","[0.535, 0.529]"
96,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(608, 610, 3), (671, 673, 3)]","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            LocationListener listener, Looper looper) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            PendingIntent intent) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            ","[0.54, 0.605]"
97,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(642, 644, 3), (642, 644, 3)]","    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria,
            LocationListener listener, Looper looper) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria,
            LocationListener listener, Looper looper) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria,
            LocationListener listener, Looper looper) {
        android.util.SeempLog.record(47);
","[1.0, 1.0]"
98,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(642, 644, 3), (779, 781, 3)]","    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria,
            LocationListener listener, Looper looper) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria,
            PendingIntent intent) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria,
            ","[0.545, 0.609]"
99,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(671, 673, 3), (671, 673, 3)]","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            PendingIntent intent) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            PendingIntent intent) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(String provider, long minTime, float minDistance,
            PendingIntent intent) {
        android.util.SeempLog.record(47);
","[1.0, 1.0]"
100,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(779, 781, 3), (779, 781, 3)]","    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria,
            PendingIntent intent) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria,
            PendingIntent intent) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria,
            PendingIntent intent) {
        android.util.SeempLog.record(47);
","[1.0, 1.0]"
101,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(810, 811, 2), (810, 811, 2)]","    public void requestSingleUpdate(String provider, LocationListener listener, Looper looper) {
        android.util.SeempLog.record(64);
","    public void requestSingleUpdate(String provider, LocationListener listener, Looper looper) {
        android.util.SeempLog.record(64);
","    public void requestSingleUpdate(String provider, LocationListener listener, Looper looper) {
        android.util.SeempLog.record(64);
","[1.0, 1.0]"
102,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(810, 811, 2), (841, 842, 2)]","    public void requestSingleUpdate(String provider, LocationListener listener, Looper looper) {
        android.util.SeempLog.record(64);
","    public void requestSingleUpdate(Criteria criteria, LocationListener listener, Looper looper) {
        android.util.SeempLog.record(64);
",", LocationListener listener, Looper looper) {
        android.util.SeempLog.record(64);
","[0.633, 0.624]"
103,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(841, 842, 2), (841, 842, 2)]","    public void requestSingleUpdate(Criteria criteria, LocationListener listener, Looper looper) {
        android.util.SeempLog.record(64);
","    public void requestSingleUpdate(Criteria criteria, LocationListener listener, Looper looper) {
        android.util.SeempLog.record(64);
","    public void requestSingleUpdate(Criteria criteria, LocationListener listener, Looper looper) {
        android.util.SeempLog.record(64);
","[1.0, 1.0]"
104,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(865, 866, 2), (865, 866, 2)]","    public void requestSingleUpdate(String provider, PendingIntent intent) {
        android.util.SeempLog.record(64);
","    public void requestSingleUpdate(String provider, PendingIntent intent) {
        android.util.SeempLog.record(64);
","    public void requestSingleUpdate(String provider, PendingIntent intent) {
        android.util.SeempLog.record(64);
","[1.0, 1.0]"
105,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(865, 866, 2), (890, 891, 2)]","    public void requestSingleUpdate(String provider, PendingIntent intent) {
        android.util.SeempLog.record(64);
","    public void requestSingleUpdate(Criteria criteria, PendingIntent intent) {
        android.util.SeempLog.record(64);
",", PendingIntent intent) {
        android.util.SeempLog.record(64);
","[0.571, 0.562]"
106,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(865, 866, 2), (1148, 1149, 2)]","    public void requestSingleUpdate(String provider, PendingIntent intent) {
        android.util.SeempLog.record(64);
","            PendingIntent intent) {
        android.util.SeempLog.record(45);
"," PendingIntent intent) {
        android.util.SeempLog.record(","[0.521, 0.795]"
107,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(890, 891, 2), (890, 891, 2)]","    public void requestSingleUpdate(Criteria criteria, PendingIntent intent) {
        android.util.SeempLog.record(64);
","    public void requestSingleUpdate(Criteria criteria, PendingIntent intent) {
        android.util.SeempLog.record(64);
","    public void requestSingleUpdate(Criteria criteria, PendingIntent intent) {
        android.util.SeempLog.record(64);
","[1.0, 1.0]"
108,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(890, 891, 2), (1148, 1149, 2)]","    public void requestSingleUpdate(Criteria criteria, PendingIntent intent) {
        android.util.SeempLog.record(64);
","            PendingIntent intent) {
        android.util.SeempLog.record(45);
"," PendingIntent intent) {
        android.util.SeempLog.record(","[0.512, 0.795]"
109,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(960, 962, 3), (960, 962, 3)]","    public void requestLocationUpdates(LocationRequest request, LocationListener listener,
            Looper looper) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(LocationRequest request, LocationListener listener,
            Looper looper) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(LocationRequest request, LocationListener listener,
            Looper looper) {
        android.util.SeempLog.record(47);
","[1.0, 1.0]"
110,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(991, 992, 2), (991, 992, 2)]","    public void requestLocationUpdates(LocationRequest request, PendingIntent intent) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(LocationRequest request, PendingIntent intent) {
        android.util.SeempLog.record(47);
","    public void requestLocationUpdates(LocationRequest request, PendingIntent intent) {
        android.util.SeempLog.record(47);
","[1.0, 1.0]"
111,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1148, 1149, 2), (1148, 1149, 2)]","            PendingIntent intent) {
        android.util.SeempLog.record(45);
","            PendingIntent intent) {
        android.util.SeempLog.record(45);
","            PendingIntent intent) {
        android.util.SeempLog.record(45);
","[1.0, 1.0]"
112,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1450, 1451, 2), (1450, 1451, 2)]","    public Location getLastKnownLocation(String provider) {
        android.util.SeempLog.record(46);
","    public Location getLastKnownLocation(String provider) {
        android.util.SeempLog.record(46);
","    public Location getLastKnownLocation(String provider) {
        android.util.SeempLog.record(46);
","[1.0, 1.0]"
113,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1870, 1887, 18), (1870, 1887, 18)]","        android.util.SeempLog.record(43);
        boolean result;

        if (mGpsStatusListeners.get(listener) != null) {
            // listener is already registered
            return true;
        }
        try {
            GnssStatusListenerTransport transport = new GnssStatusListenerTransport(listener);
            result = mService.registerGnssStatusCallback(transport, mContext.getPackageName());
            if (result) {
                mGpsStatusListeners.put(listener, transport);
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }

        return result;
","        android.util.SeempLog.record(43);
        boolean result;

        if (mGpsStatusListeners.get(listener) != null) {
            // listener is already registered
            return true;
        }
        try {
            GnssStatusListenerTransport transport = new GnssStatusListenerTransport(listener);
            result = mService.registerGnssStatusCallback(transport, mContext.getPackageName());
            if (result) {
                mGpsStatusListeners.put(listener, transport);
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }

        return result;
","        android.util.SeempLog.record(43);
        boolean result;

        if (mGpsStatusListeners.get(listener) != null) {
            // listener is already registered
            return true;
        }
        try {
            GnssStatusListenerTransport transport = new GnssStatusListenerTransport(listener);
            result = mService.registerGnssStatusCallback(transport, mContext.getPackageName());
            if (result) {
                mGpsStatusListeners.put(listener, transport);
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }

        return result;
","[1.0, 1.0]"
114,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1982, 1999, 18), (1982, 1999, 18)]","        android.util.SeempLog.record(44);
        boolean result;

        if (mGpsNmeaListeners.get(listener) != null) {
            // listener is already registered
            return true;
        }
        try {
            GnssStatusListenerTransport transport = new GnssStatusListenerTransport(listener);
            result = mService.registerGnssStatusCallback(transport, mContext.getPackageName());
            if (result) {
                mGpsNmeaListeners.put(listener, transport);
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }

        return result;
","        android.util.SeempLog.record(44);
        boolean result;

        if (mGpsNmeaListeners.get(listener) != null) {
            // listener is already registered
            return true;
        }
        try {
            GnssStatusListenerTransport transport = new GnssStatusListenerTransport(listener);
            result = mService.registerGnssStatusCallback(transport, mContext.getPackageName());
            if (result) {
                mGpsNmeaListeners.put(listener, transport);
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }

        return result;
","        android.util.SeempLog.record(44);
        boolean result;

        if (mGpsNmeaListeners.get(listener) != null) {
            // listener is already registered
            return true;
        }
        try {
            GnssStatusListenerTransport transport = new GnssStatusListenerTransport(listener);
            result = mService.registerGnssStatusCallback(transport, mContext.getPackageName());
            if (result) {
                mGpsNmeaListeners.put(listener, transport);
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }

        return result;
","[1.0, 1.0]"
115,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(2398, 2399, 2), (2398, 2399, 2)]","    public boolean sendExtraCommand(String provider, String command, Bundle extras) {
        android.util.SeempLog.record(48);
","    public boolean sendExtraCommand(String provider, String command, Bundle extras) {
        android.util.SeempLog.record(48);
","    public boolean sendExtraCommand(String provider, String command, Bundle extras) {
        android.util.SeempLog.record(48);
","[1.0, 1.0]"
116,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(6881, 6950, 70), (6881, 6950, 70)]","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId())) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId())) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId())) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","[1.0, 1.0]"
117,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3357, 3359, 3), (3357, 3359, 3)]","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        mDeviceBroker.setSpeakerphoneOn(on, eventSource);
","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        mDeviceBroker.setSpeakerphoneOn(on, eventSource);
","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        mDeviceBroker.setSpeakerphoneOn(on, eventSource);
","[1.0, 1.0]"
118,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/content/pm/ApplicationInfo.java,"[(2052, 2054, 3), (2052, 2054, 3)]","    /** @hide */
    public int getOverrideDensity() {
        return overrideDensity;
","    /** @hide */
    public int getOverrideDensity() {
        return overrideDensity;
","    /** @hide */
    public int getOverrideDensity() {
        return overrideDensity;
","[1.0, 1.0]"
119,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(313, 313, 1), (313, 313, 1)]","import com.android.internal.app.ActivityTrigger;
","import com.android.internal.app.ActivityTrigger;
","import com.android.internal.app.ActivityTrigger;
","[1.0, 1.0]"
120,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActiveServices.java,"[(2486, 2516, 31), (2486, 2516, 31)]","            if(SERVICE_RESCHEDULE) {
                boolean shouldDelay = false;
                ActivityRecord top_rc = null;
                ActivityStack stack = mAm.mStackSupervisor.mRootActivityContainer.getTopDisplayFocusedStack();
                if(stack != null) {
                    top_rc = stack.topRunningActivityLocked();
                }

                boolean isPersistent
                        = !((r.serviceInfo.applicationInfo.flags&ApplicationInfo.FLAG_PERSISTENT) == 0);
                if(top_rc != null) {
                    if(top_rc.launching && !r.shortInstanceName.contains(top_rc.packageName)
                            && !isPersistent) {
                        shouldDelay = true;
                    }
                }
                if(!shouldDelay) {
                    bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false,
                            false);
                } else {
                    if (DEBUG_DELAYED_SERVICE) {
                        Slog.v(TAG, ""Reschedule service restart due to app launch""
                              +"" r.shortInstanceName ""+r.shortInstanceName+"" r.app = ""+r.app);
                    }
                    r.resetRestartCounter();
                    scheduleServiceRestartLocked(r, true);
                }
            } else {
                bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false,
                        false);
            }
","            if(SERVICE_RESCHEDULE) {
                boolean shouldDelay = false;
                ActivityRecord top_rc = null;
                ActivityStack stack = mAm.mStackSupervisor.mRootActivityContainer.getTopDisplayFocusedStack();
                if(stack != null) {
                    top_rc = stack.topRunningActivityLocked();
                }

                boolean isPersistent
                        = !((r.serviceInfo.applicationInfo.flags&ApplicationInfo.FLAG_PERSISTENT) == 0);
                if(top_rc != null) {
                    if(top_rc.launching && !r.shortInstanceName.contains(top_rc.packageName)
                            && !isPersistent) {
                        shouldDelay = true;
                    }
                }
                if(!shouldDelay) {
                    bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false,
                            false);
                } else {
                    if (DEBUG_DELAYED_SERVICE) {
                        Slog.v(TAG, ""Reschedule service restart due to app launch""
                              +"" r.shortInstanceName ""+r.shortInstanceName+"" r.app = ""+r.app);
                    }
                    r.resetRestartCounter();
                    scheduleServiceRestartLocked(r, true);
                }
            } else {
                bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false,
                        false);
            }
","            if(SERVICE_RESCHEDULE) {
                boolean shouldDelay = false;
                ActivityRecord top_rc = null;
                ActivityStack stack = mAm.mStackSupervisor.mRootActivityContainer.getTopDisplayFocusedStack();
                if(stack != null) {
                    top_rc = stack.topRunningActivityLocked();
                }

                boolean isPersistent
                        = !((r.serviceInfo.applicationInfo.flags&ApplicationInfo.FLAG_PERSISTENT) == 0);
                if(top_rc != null) {
                    if(top_rc.launching && !r.shortInstanceName.contains(top_rc.packageName)
                            && !isPersistent) {
                        shouldDelay = true;
                    }
                }
                if(!shouldDelay) {
                    bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false,
                            false);
                } else {
                    if (DEBUG_DELAYED_SERVICE) {
                        Slog.v(TAG, ""Reschedule service restart due to app launch""
                              +"" r.shortInstanceName ""+r.shortInstanceName+"" r.app = ""+r.app);
                    }
                    r.resetRestartCounter();
                    scheduleServiceRestartLocked(r, true);
                }
            } else {
                bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false,
                        false);
            }
","[1.0, 1.0]"
121,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(28, 30, 3), (28, 30, 3)]","import android.telephony.NetworkRegistrationState;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.NetworkRegistrationState;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.NetworkRegistrationState;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.feature.MmTelFeature;
","[1.0, 1.0]"
122,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(651, 653, 3), (651, 653, 3)]","        } else if (isDataDisabled() && !mConfig.alwaysShowDataRatIcon
                && !mConfig.alwaysShowNetworkTypeIcon) {
            mCurrentState.iconGroup = TelephonyIcons.DATA_DISABLED;
","        } else if (isDataDisabled() && !mConfig.alwaysShowDataRatIcon
                && !mConfig.alwaysShowNetworkTypeIcon) {
            mCurrentState.iconGroup = TelephonyIcons.DATA_DISABLED;
","        } else if (isDataDisabled() && !mConfig.alwaysShowDataRatIcon
                && !mConfig.alwaysShowNetworkTypeIcon) {
            mCurrentState.iconGroup = TelephonyIcons.DATA_DISABLED;
","[1.0, 1.0]"
123,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSFooterImpl.java,"[(455, 612, 158), (455, 612, 158)]","
    private void handleUpdateState() {
        for (int i = 0; i < SIM_SLOTS; i++) {
            mMobileGroups[i].setVisibility(mInfos[i].visible ? View.VISIBLE : View.GONE);
            if (mInfos[i].visible) {
                mMobileRoamings[i].setVisibility(mInfos[i].roaming ? View.VISIBLE : View.GONE);
                mMobileRoamings[i].setImageTintList(ColorStateList.valueOf(mColorForeground));
                SignalDrawable d = new SignalDrawable(mContext);
                d.setDarkIntensity(QuickStatusBarHeader.getColorIntensity(mColorForeground));
                mMobileSignals[i].setImageDrawable(d);
                mMobileSignals[i].setImageLevel(mInfos[i].mobileSignalIconId);

                StringBuilder contentDescription = new StringBuilder();
                if (mInfos[i].contentDescription != null) {
                    contentDescription.append(mInfos[i].contentDescription).append("", "");
                }
                if (mInfos[i].roaming) {
                    contentDescription
                            .append(mContext.getString(R.string.data_connection_roaming))
                            .append("", "");
                }
                // TODO: show mobile data off/no internet text for 5 seconds before carrier text
                if (TextUtils.equals(mInfos[i].typeContentDescription,
                        mContext.getString(R.string.data_connection_no_internet))
                        || TextUtils.equals(mInfos[i].typeContentDescription,
                        mContext.getString(R.string.cell_data_off_content_description))) {
                    contentDescription.append(mInfos[i].typeContentDescription);
                }
                mMobileSignals[i].setContentDescription(contentDescription);
            }
        }
        mCarrierDivider.setVisibility(
                mInfos[0].visible && mInfos[1].visible ? View.VISIBLE : View.GONE);
    }

    @VisibleForTesting
    protected int getSlotIndex(int subscriptionId) {
        return SubscriptionManager.getSlotIndex(subscriptionId);
    }

    @Override
    public void updateCarrierInfo(CarrierTextController.CarrierTextCallbackInfo info) {
        if (info.anySimReady) {
            boolean[] slotSeen = new boolean[SIM_SLOTS];
            if (info.listOfCarriers.length == info.subscriptionIds.length) {
                for (int i = 0; i < SIM_SLOTS && i < info.listOfCarriers.length; i++) {
                    int slot = getSlotIndex(info.subscriptionIds[i]);
                    if (slot >= SIM_SLOTS) {
                        Log.w(TAG, ""updateInfoCarrier - slot: "" + slot);
                        continue;
                    }
                    if (slot == SubscriptionManager.INVALID_SIM_SLOT_INDEX) {
                        Log.e(TAG,
                                ""Invalid SIM slot index for subscription: ""
                                        + info.subscriptionIds[i]);
                        continue;
                    }
                    mInfos[slot].visible = true;
                    slotSeen[slot] = true;
                    mCarrierTexts[slot].setText(info.listOfCarriers[i].toString().trim());
                    mCarrierGroups[slot].setVisibility(View.VISIBLE);
                }
                for (int i = 0; i < SIM_SLOTS; i++) {
                    if (!slotSeen[i]) {
                        mInfos[i].visible = false;
                        mCarrierGroups[i].setVisibility(View.GONE);
                    }
                }
            } else {
                Log.e(TAG, ""Carrier information arrays not of same length"");
            }
        } else {
            mInfos[0].visible = false;
            mCarrierTexts[0].setText(info.carrierText);
            mCarrierGroups[0].setVisibility(View.VISIBLE);
            for (int i = 1; i < SIM_SLOTS; i++) {
                mInfos[i].visible = false;
                mCarrierTexts[i].setText("""");
                mCarrierGroups[i].setVisibility(View.GONE);
            }
        }
        handleUpdateState();
    }

    @Override
    public void setMobileDataIndicators(NetworkController.IconState statusIcon,
            NetworkController.IconState qsIcon, int statusType,
            int qsType, boolean activityIn, boolean activityOut,
            int volteIcon, String typeContentDescription,
            String description, boolean isWide, int subId, boolean roaming) {
        int slotIndex = getSlotIndex(subId);
        if (slotIndex >= SIM_SLOTS) {
            Log.w(TAG, ""setMobileDataIndicators - slot: "" + slotIndex);
            return;
        }
        if (slotIndex == SubscriptionManager.INVALID_SIM_SLOT_INDEX) {
            Log.e(TAG, ""Invalid SIM slot index for subscription: "" + subId);
            return;
        }
        mInfos[slotIndex].visible = statusIcon.visible;
        mInfos[slotIndex].mobileSignalIconId = statusIcon.icon;
        mInfos[slotIndex].contentDescription = statusIcon.contentDescription;
        mInfos[slotIndex].typeContentDescription = typeContentDescription;
        mInfos[slotIndex].roaming = roaming;
        handleUpdateState();
    }

    @Override
    public void setNoSims(boolean hasNoSims, boolean simDetected) {
        if (hasNoSims) {
            mInfos[0].visible = false;
            mInfos[1].visible = false;
        }
        handleUpdateState();
    }

    private final class CellSignalState {
        boolean visible;
        int mobileSignalIconId;
        public String contentDescription;
        String typeContentDescription;
        boolean roaming;
    }

    /**
     * TextView that changes its ellipsize value with its visibility.
     */
    public static class QSCarrierText extends TextView {
        public QSCarrierText(Context context) {
            super(context);
        }

        public QSCarrierText(Context context, AttributeSet attrs) {
            super(context, attrs);
        }

        public QSCarrierText(Context context, AttributeSet attrs, int defStyleAttr) {
            super(context, attrs, defStyleAttr);
        }

        public QSCarrierText(Context context, AttributeSet attrs, int defStyleAttr,
                int defStyleRes) {
            super(context, attrs, defStyleAttr, defStyleRes);
        }

        @Override
        protected void onVisibilityChanged(View changedView, int visibility) {
            super.onVisibilityChanged(changedView, visibility);
            // Only show marquee when visible
            if (visibility == VISIBLE) {
                setEllipsize(TextUtils.TruncateAt.MARQUEE);
                setSelected(true);
            } else {
                setEllipsize(TextUtils.TruncateAt.END);
                setSelected(false);
            }
        }
    }
","
    private void handleUpdateState() {
        for (int i = 0; i < SIM_SLOTS; i++) {
            mMobileGroups[i].setVisibility(mInfos[i].visible ? View.VISIBLE : View.GONE);
            if (mInfos[i].visible) {
                mMobileRoamings[i].setVisibility(mInfos[i].roaming ? View.VISIBLE : View.GONE);
                mMobileRoamings[i].setImageTintList(ColorStateList.valueOf(mColorForeground));
                SignalDrawable d = new SignalDrawable(mContext);
                d.setDarkIntensity(QuickStatusBarHeader.getColorIntensity(mColorForeground));
                mMobileSignals[i].setImageDrawable(d);
                mMobileSignals[i].setImageLevel(mInfos[i].mobileSignalIconId);

                StringBuilder contentDescription = new StringBuilder();
                if (mInfos[i].contentDescription != null) {
                    contentDescription.append(mInfos[i].contentDescription).append("", "");
                }
                if (mInfos[i].roaming) {
                    contentDescription
                            .append(mContext.getString(R.string.data_connection_roaming))
                            .append("", "");
                }
                // TODO: show mobile data off/no internet text for 5 seconds before carrier text
                if (TextUtils.equals(mInfos[i].typeContentDescription,
                        mContext.getString(R.string.data_connection_no_internet))
                        || TextUtils.equals(mInfos[i].typeContentDescription,
                        mContext.getString(R.string.cell_data_off_content_description))) {
                    contentDescription.append(mInfos[i].typeContentDescription);
                }
                mMobileSignals[i].setContentDescription(contentDescription);
            }
        }
        mCarrierDivider.setVisibility(
                mInfos[0].visible && mInfos[1].visible ? View.VISIBLE : View.GONE);
    }

    @VisibleForTesting
    protected int getSlotIndex(int subscriptionId) {
        return SubscriptionManager.getSlotIndex(subscriptionId);
    }

    @Override
    public void updateCarrierInfo(CarrierTextController.CarrierTextCallbackInfo info) {
        if (info.anySimReady) {
            boolean[] slotSeen = new boolean[SIM_SLOTS];
            if (info.listOfCarriers.length == info.subscriptionIds.length) {
                for (int i = 0; i < SIM_SLOTS && i < info.listOfCarriers.length; i++) {
                    int slot = getSlotIndex(info.subscriptionIds[i]);
                    if (slot >= SIM_SLOTS) {
                        Log.w(TAG, ""updateInfoCarrier - slot: "" + slot);
                        continue;
                    }
                    if (slot == SubscriptionManager.INVALID_SIM_SLOT_INDEX) {
                        Log.e(TAG,
                                ""Invalid SIM slot index for subscription: ""
                                        + info.subscriptionIds[i]);
                        continue;
                    }
                    mInfos[slot].visible = true;
                    slotSeen[slot] = true;
                    mCarrierTexts[slot].setText(info.listOfCarriers[i].toString().trim());
                    mCarrierGroups[slot].setVisibility(View.VISIBLE);
                }
                for (int i = 0; i < SIM_SLOTS; i++) {
                    if (!slotSeen[i]) {
                        mInfos[i].visible = false;
                        mCarrierGroups[i].setVisibility(View.GONE);
                    }
                }
            } else {
                Log.e(TAG, ""Carrier information arrays not of same length"");
            }
        } else {
            mInfos[0].visible = false;
            mCarrierTexts[0].setText(info.carrierText);
            mCarrierGroups[0].setVisibility(View.VISIBLE);
            for (int i = 1; i < SIM_SLOTS; i++) {
                mInfos[i].visible = false;
                mCarrierTexts[i].setText("""");
                mCarrierGroups[i].setVisibility(View.GONE);
            }
        }
        handleUpdateState();
    }

    @Override
    public void setMobileDataIndicators(NetworkController.IconState statusIcon,
            NetworkController.IconState qsIcon, int statusType,
            int qsType, boolean activityIn, boolean activityOut,
            int volteIcon, String typeContentDescription,
            String description, boolean isWide, int subId, boolean roaming) {
        int slotIndex = getSlotIndex(subId);
        if (slotIndex >= SIM_SLOTS) {
            Log.w(TAG, ""setMobileDataIndicators - slot: "" + slotIndex);
            return;
        }
        if (slotIndex == SubscriptionManager.INVALID_SIM_SLOT_INDEX) {
            Log.e(TAG, ""Invalid SIM slot index for subscription: "" + subId);
            return;
        }
        mInfos[slotIndex].visible = statusIcon.visible;
        mInfos[slotIndex].mobileSignalIconId = statusIcon.icon;
        mInfos[slotIndex].contentDescription = statusIcon.contentDescription;
        mInfos[slotIndex].typeContentDescription = typeContentDescription;
        mInfos[slotIndex].roaming = roaming;
        handleUpdateState();
    }

    @Override
    public void setNoSims(boolean hasNoSims, boolean simDetected) {
        if (hasNoSims) {
            mInfos[0].visible = false;
            mInfos[1].visible = false;
        }
        handleUpdateState();
    }

    private final class CellSignalState {
        boolean visible;
        int mobileSignalIconId;
        public String contentDescription;
        String typeContentDescription;
        boolean roaming;
    }

    /**
     * TextView that changes its ellipsize value with its visibility.
     */
    public static class QSCarrierText extends TextView {
        public QSCarrierText(Context context) {
            super(context);
        }

        public QSCarrierText(Context context, AttributeSet attrs) {
            super(context, attrs);
        }

        public QSCarrierText(Context context, AttributeSet attrs, int defStyleAttr) {
            super(context, attrs, defStyleAttr);
        }

        public QSCarrierText(Context context, AttributeSet attrs, int defStyleAttr,
                int defStyleRes) {
            super(context, attrs, defStyleAttr, defStyleRes);
        }

        @Override
        protected void onVisibilityChanged(View changedView, int visibility) {
            super.onVisibilityChanged(changedView, visibility);
            // Only show marquee when visible
            if (visibility == VISIBLE) {
                setEllipsize(TextUtils.TruncateAt.MARQUEE);
                setSelected(true);
            } else {
                setEllipsize(TextUtils.TruncateAt.END);
                setSelected(false);
            }
        }
    }
","
    private void handleUpdateState() {
        for (int i = 0; i < SIM_SLOTS; i++) {
            mMobileGroups[i].setVisibility(mInfos[i].visible ? View.VISIBLE : View.GONE);
            if (mInfos[i].visible) {
                mMobileRoamings[i].setVisibility(mInfos[i].roaming ? View.VISIBLE : View.GONE);
                mMobileRoamings[i].setImageTintList(ColorStateList.valueOf(mColorForeground));
                SignalDrawable d = new SignalDrawable(mContext);
                d.setDarkIntensity(QuickStatusBarHeader.getColorIntensity(mColorForeground));
                mMobileSignals[i].setImageDrawable(d);
                mMobileSignals[i].setImageLevel(mInfos[i].mobileSignalIconId);

                StringBuilder contentDescription = new StringBuilder();
                if (mInfos[i].contentDescription != null) {
                    contentDescription.append(mInfos[i].contentDescription).append("", "");
                }
                if (mInfos[i].roaming) {
                    contentDescription
                            .append(mContext.getString(R.string.data_connection_roaming))
                            .append("", "");
                }
                // TODO: show mobile data off/no internet text for 5 seconds before carrier text
                if (TextUtils.equals(mInfos[i].typeContentDescription,
                        mContext.getString(R.string.data_connection_no_internet))
                        || TextUtils.equals(mInfos[i].typeContentDescription,
                        mContext.getString(R.string.cell_data_off_content_description))) {
                    contentDescription.append(mInfos[i].typeContentDescription);
                }
                mMobileSignals[i].setContentDescription(contentDescription);
            }
        }
        mCarrierDivider.setVisibility(
                mInfos[0].visible && mInfos[1].visible ? View.VISIBLE : View.GONE);
    }

    @VisibleForTesting
    protected int getSlotIndex(int subscriptionId) {
        return SubscriptionManager.getSlotIndex(subscriptionId);
    }

    @Override
    public void updateCarrierInfo(CarrierTextController.CarrierTextCallbackInfo info) {
        if (info.anySimReady) {
            boolean[] slotSeen = new boolean[SIM_SLOTS];
            if (info.listOfCarriers.length == info.subscriptionIds.length) {
                for (int i = 0; i < SIM_SLOTS && i < info.listOfCarriers.length; i++) {
                    int slot = getSlotIndex(info.subscriptionIds[i]);
                    if (slot >= SIM_SLOTS) {
                        Log.w(TAG, ""updateInfoCarrier - slot: "" + slot);
                        continue;
                    }
                    if (slot == SubscriptionManager.INVALID_SIM_SLOT_INDEX) {
                        Log.e(TAG,
                                ""Invalid SIM slot index for subscription: ""
                                        + info.subscriptionIds[i]);
                        continue;
                    }
                    mInfos[slot].visible = true;
                    slotSeen[slot] = true;
                    mCarrierTexts[slot].setText(info.listOfCarriers[i].toString().trim());
                    mCarrierGroups[slot].setVisibility(View.VISIBLE);
                }
                for (int i = 0; i < SIM_SLOTS; i++) {
                    if (!slotSeen[i]) {
                        mInfos[i].visible = false;
                        mCarrierGroups[i].setVisibility(View.GONE);
                    }
                }
            } else {
                Log.e(TAG, ""Carrier information arrays not of same length"");
            }
        } else {
            mInfos[0].visible = false;
            mCarrierTexts[0].setText(info.carrierText);
            mCarrierGroups[0].setVisibility(View.VISIBLE);
            for (int i = 1; i < SIM_SLOTS; i++) {
                mInfos[i].visible = false;
                mCarrierTexts[i].setText("""");
                mCarrierGroups[i].setVisibility(View.GONE);
            }
        }
        handleUpdateState();
    }

    @Override
    public void setMobileDataIndicators(NetworkController.IconState statusIcon,
            NetworkController.IconState qsIcon, int statusType,
            int qsType, boolean activityIn, boolean activityOut,
            int volteIcon, String typeContentDescription,
            String description, boolean isWide, int subId, boolean roaming) {
        int slotIndex = getSlotIndex(subId);
        if (slotIndex >= SIM_SLOTS) {
            Log.w(TAG, ""setMobileDataIndicators - slot: "" + slotIndex);
            return;
        }
        if (slotIndex == SubscriptionManager.INVALID_SIM_SLOT_INDEX) {
            Log.e(TAG, ""Invalid SIM slot index for subscription: "" + subId);
            return;
        }
        mInfos[slotIndex].visible = statusIcon.visible;
        mInfos[slotIndex].mobileSignalIconId = statusIcon.icon;
        mInfos[slotIndex].contentDescription = statusIcon.contentDescription;
        mInfos[slotIndex].typeContentDescription = typeContentDescription;
        mInfos[slotIndex].roaming = roaming;
        handleUpdateState();
    }

    @Override
    public void setNoSims(boolean hasNoSims, boolean simDetected) {
        if (hasNoSims) {
            mInfos[0].visible = false;
            mInfos[1].visible = false;
        }
        handleUpdateState();
    }

    private final class CellSignalState {
        boolean visible;
        int mobileSignalIconId;
        public String contentDescription;
        String typeContentDescription;
        boolean roaming;
    }

    /**
     * TextView that changes its ellipsize value with its visibility.
     */
    public static class QSCarrierText extends TextView {
        public QSCarrierText(Context context) {
            super(context);
        }

        public QSCarrierText(Context context, AttributeSet attrs) {
            super(context, attrs);
        }

        public QSCarrierText(Context context, AttributeSet attrs, int defStyleAttr) {
            super(context, attrs, defStyleAttr);
        }

        public QSCarrierText(Context context, AttributeSet attrs, int defStyleAttr,
                int defStyleRes) {
            super(context, attrs, defStyleAttr, defStyleRes);
        }

        @Override
        protected void onVisibilityChanged(View changedView, int visibility) {
            super.onVisibilityChanged(changedView, visibility);
            // Only show marquee when visible
            if (visibility == VISIBLE) {
                setEllipsize(TextUtils.TruncateAt.MARQUEE);
                setSelected(true);
            } else {
                setEllipsize(TextUtils.TruncateAt.END);
                setSelected(false);
            }
        }
    }
","[1.0, 1.0]"
124,"['2775a5a9b030266a910301e8b464811acafcd5fa', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/NetworkControllerBaseTest.java,"[(343, 344, 2), (343, 344, 2)]","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","[1.0, 1.0]"
125,"['2775a5a9b030266a910301e8b464811acafcd5fa', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(6881, 6950, 70), (6445, 6514, 70)]","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId())) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId())) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId())) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","[1.0, 1.0]"
126,"['2775a5a9b030266a910301e8b464811acafcd5fa', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(28, 30, 3), (28, 30, 3)]","import android.telephony.NetworkRegistrationState;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.stub.ImsRegistrationImplBase;
","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.","[0.507, 0.503]"
127,"['2775a5a9b030266a910301e8b464811acafcd5fa', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1148, 1149, 2), (1648, 1649, 2)]","            PendingIntent intent) {
        android.util.SeempLog.record(45);
","        android.util.SeempLog.record(45);
        checkPendingIntent(intent);
","        android.util.SeempLog.record(45);
","[0.538, 0.538]"
128,"['2775a5a9b030266a910301e8b464811acafcd5fa', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/NetworkControllerBaseTest.java,"[(343, 344, 2), (416, 417, 2)]","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","[1.0, 1.0]"
129,"['2775a5a9b030266a910301e8b464811acafcd5fa', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/NetworkControllerBaseTest.java,"[(343, 344, 2), (450, 452, 3)]","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                ArgumentCaptor.forClass(Integer.class).capture(),
                anyString(), anyString(), anyBoolean(),
                anyInt(), eq(roaming));
","                ArgumentCaptor.forClass(Integer.class).capture(),
                ","[0.529, 0.506]"
130,"['2775a5a9b030266a910301e8b464811acafcd5fa', 'bb9ded46832af38a453b78b92ad2de32ef1cf845']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3357, 3359, 3), (4018, 4020, 3)]","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        mDeviceBroker.setSpeakerphoneOn(on, eventSource);
","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        final boolean stateChanged = mDeviceBroker.setSpeakerphoneOn(on, eventSource);
","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        ","[0.667, 0.559]"
131,"['2775a5a9b030266a910301e8b464811acafcd5fa', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/NetworkControllerBaseTest.java,"[(343, 344, 2), (352, 353, 2)]","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","[1.0, 1.0]"
133,"['2b252c526c654de6d04ec0165b4b8f039b37f82b', '2b252c526c654de6d04ec0165b4b8f039b37f82b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java,"[(1112, 1116, 5), (1112, 1116, 5)]","        boolean readIconsFromXml;
        boolean showRsrpSignalLevelforLTE = false;
        boolean hideNoInternetState = false;
        boolean showVolteIcon = false;
        boolean alwaysShowNetworkTypeIcon = false;
","        boolean readIconsFromXml;
        boolean showRsrpSignalLevelforLTE = false;
        boolean hideNoInternetState = false;
        boolean showVolteIcon = false;
        boolean alwaysShowNetworkTypeIcon = false;
","        boolean readIconsFromXml;
        boolean showRsrpSignalLevelforLTE = false;
        boolean hideNoInternetState = false;
        boolean showVolteIcon = false;
        boolean alwaysShowNetworkTypeIcon = false;
","[1.0, 1.0]"
134,"['2b252c526c654de6d04ec0165b4b8f039b37f82b', '2b252c526c654de6d04ec0165b4b8f039b37f82b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(817, 817, 1), (817, 817, 1)]","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","[1.0, 1.0]"
135,"['2b252c526c654de6d04ec0165b4b8f039b37f82b', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(817, 817, 1), (887, 887, 1)]","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","[1.0, 1.0]"
136,"['2b252c526c654de6d04ec0165b4b8f039b37f82b', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(817, 817, 1), (900, 900, 1)]","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","[1.0, 1.0]"
137,"['2e25c298c5c5a069e5525397e99952d4d7f01b8b', '2e25c298c5c5a069e5525397e99952d4d7f01b8b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(1422, 1425, 4), (1422, 1425, 4)]","            if (DEBUG_VOL) Log.d(TAG, ""adjustSuggestedStreamVolume() stream="" + suggestedStreamType
                    + "", flags="" + flags + "", caller="" + caller
                    + "", volControlStream="" + mVolumeControlStream
                    + "", userSelect="" + mUserSelectedVolumeControlStream);
","            if (DEBUG_VOL) Log.d(TAG, ""adjustSuggestedStreamVolume() stream="" + suggestedStreamType
                    + "", flags="" + flags + "", caller="" + caller
                    + "", volControlStream="" + mVolumeControlStream
                    + "", userSelect="" + mUserSelectedVolumeControlStream);
","            if (DEBUG_VOL) Log.d(TAG, ""adjustSuggestedStreamVolume() stream="" + suggestedStreamType
                    + "", flags="" + flags + "", caller="" + caller
                    + "", volControlStream="" + mVolumeControlStream
                    + "", userSelect="" + mUserSelectedVolumeControlStream);
","[1.0, 1.0]"
140,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/le/ScanRecord.java,"[(98, 100, 3), (98, 100, 3)]","     * identify the bluetooth GATT services.
     * @hide
     */
","     * identify the bluetooth GATT services.
     * @hide
     */
","     * identify the bluetooth GATT services.
     * @hide
     */
","[1.0, 1.0]"
141,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/le/ScanRecord.java,"[(99, 99, 1), (99, 99, 1)]","     * @hide
","     * @hide
","     * @hide
","[1.0, 1.0]"
142,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(281, 282, 2), (281, 282, 2)]","import com.android.internal.os.IParcelFileDescriptorFactory;
import com.android.internal.os.RegionalizationEnvironment;
","import com.android.internal.os.IParcelFileDescriptorFactory;
import com.android.internal.os.RegionalizationEnvironment;
","import com.android.internal.os.IParcelFileDescriptorFactory;
import com.android.internal.os.RegionalizationEnvironment;
","[1.0, 1.0]"
143,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(492, 493, 2), (492, 493, 2)]","                            initialStack = ActivityManagerService.dumpStackTraces(true, pids,
                                    null, null, getInterestingNativePids());
","                            initialStack = ActivityManagerService.dumpStackTraces(true, pids,
                                    null, null, getInterestingNativePids());
","                            initialStack = ActivityManagerService.dumpStackTraces(true, pids,
                                    null, null, getInterestingNativePids());
","[1.0, 1.0]"
144,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(517, 520, 4), (517, 520, 4)]","            // Pass !waitedHalf so that just in case we somehow wind up here without having
            // dumped the halfway stacks, we properly re-initialize the trace file.
            final File finalStack = ActivityManagerService.dumpStackTraces(
                    !waitedHalf, pids, null, null, getInterestingNativePids());
","            // Pass !waitedHalf so that just in case we somehow wind up here without having
            // dumped the halfway stacks, we properly re-initialize the trace file.
            final File finalStack = ActivityManagerService.dumpStackTraces(
                    !waitedHalf, pids, null, null, getInterestingNativePids());
","            // Pass !waitedHalf so that just in case we somehow wind up here without having
            // dumped the halfway stacks, we properly re-initialize the trace file.
            final File finalStack = ActivityManagerService.dumpStackTraces(
                    !waitedHalf, pids, null, null, getInterestingNativePids());
","[1.0, 1.0]"
145,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",media/java/android/media/MediaFile.java,"[(50, 142, 93), (50, 142, 93)]","    private static final int LAST_AUDIO_FILE_TYPE = FILE_TYPE_FLAC;

    // More audio file types
    public static final int FILE_TYPE_DTS   = 210;
    public static final int FILE_TYPE_3GPA  = 211;
    public static final int FILE_TYPE_AC3   = 212;
    public static final int FILE_TYPE_QCP   = 213;
    public static final int FILE_TYPE_PCM   = 214;
    public static final int FILE_TYPE_EC3   = 215;
    public static final int FILE_TYPE_AIFF  = 216;
    public static final int FILE_TYPE_APE   = 217;
    public static final int FILE_TYPE_DSD   = 218;
    public static final int FILE_TYPE_MHAS  = 219;
    private static final int FIRST_AUDIO_FILE_TYPE_EXT = FILE_TYPE_DTS;
    private static final int LAST_AUDIO_FILE_TYPE_EXT = FILE_TYPE_MHAS;

    // MIDI file types
    public static final int FILE_TYPE_MID     = 11;
    public static final int FILE_TYPE_SMF     = 12;
    public static final int FILE_TYPE_IMY     = 13;
    private static final int FIRST_MIDI_FILE_TYPE = FILE_TYPE_MID;
    private static final int LAST_MIDI_FILE_TYPE = FILE_TYPE_IMY;

    // Video file types
    public static final int FILE_TYPE_MP4     = 21;
    public static final int FILE_TYPE_M4V     = 22;
    public static final int FILE_TYPE_3GPP    = 23;
    public static final int FILE_TYPE_3GPP2   = 24;
    public static final int FILE_TYPE_WMV     = 25;
    public static final int FILE_TYPE_ASF     = 26;
    public static final int FILE_TYPE_MKV     = 27;
    public static final int FILE_TYPE_MP2TS   = 28;
    public static final int FILE_TYPE_AVI     = 29;
    public static final int FILE_TYPE_WEBM    = 30;
    private static final int FIRST_VIDEO_FILE_TYPE = FILE_TYPE_MP4;
    private static final int LAST_VIDEO_FILE_TYPE = FILE_TYPE_WEBM;

    // More video file types
    public static final int FILE_TYPE_MP2PS   = 200;
    public static final int FILE_TYPE_QT      = 201;
    public static final int FILE_TYPE_DIVX    = 202;
    public static final int FILE_TYPE_FLV = 203;
    private static final int FIRST_VIDEO_FILE_TYPE2 = FILE_TYPE_MP2PS;
    private static final int LAST_VIDEO_FILE_TYPE2 = FILE_TYPE_FLV;

    // Image file types
    public static final int FILE_TYPE_JPEG    = 31;
    public static final int FILE_TYPE_GIF     = 32;
    public static final int FILE_TYPE_PNG     = 33;
    public static final int FILE_TYPE_BMP     = 34;
    public static final int FILE_TYPE_WBMP    = 35;
    public static final int FILE_TYPE_WEBP    = 36;
    public static final int FILE_TYPE_HEIF    = 37;
    private static final int FIRST_IMAGE_FILE_TYPE = FILE_TYPE_JPEG;
    private static final int LAST_IMAGE_FILE_TYPE = FILE_TYPE_HEIF;

    // Raw image file types
    public static final int FILE_TYPE_DNG     = 300;
    public static final int FILE_TYPE_CR2     = 301;
    public static final int FILE_TYPE_NEF     = 302;
    public static final int FILE_TYPE_NRW     = 303;
    public static final int FILE_TYPE_ARW     = 304;
    public static final int FILE_TYPE_RW2     = 305;
    public static final int FILE_TYPE_ORF     = 306;
    public static final int FILE_TYPE_RAF     = 307;
    public static final int FILE_TYPE_PEF     = 308;
    public static final int FILE_TYPE_SRW     = 309;
    private static final int FIRST_RAW_IMAGE_FILE_TYPE = FILE_TYPE_DNG;
    private static final int LAST_RAW_IMAGE_FILE_TYPE = FILE_TYPE_SRW;

    // Playlist file types
    public static final int FILE_TYPE_M3U      = 41;
    public static final int FILE_TYPE_PLS      = 42;
    public static final int FILE_TYPE_WPL      = 43;
    public static final int FILE_TYPE_HTTPLIVE = 44;

    private static final int FIRST_PLAYLIST_FILE_TYPE = FILE_TYPE_M3U;
    private static final int LAST_PLAYLIST_FILE_TYPE = FILE_TYPE_HTTPLIVE;

    // Drm file types
    public static final int FILE_TYPE_FL      = 51;
    private static final int FIRST_DRM_FILE_TYPE = FILE_TYPE_FL;
    private static final int LAST_DRM_FILE_TYPE = FILE_TYPE_FL;

    // Other popular file types
    public static final int FILE_TYPE_TEXT          = 100;
    public static final int FILE_TYPE_HTML          = 101;
    public static final int FILE_TYPE_PDF           = 102;
    public static final int FILE_TYPE_XML           = 103;
    public static final int FILE_TYPE_MS_WORD       = 104;
    public static final int FILE_TYPE_MS_EXCEL      = 105;
    public static final int FILE_TYPE_MS_POWERPOINT = 106;
    public static final int FILE_TYPE_ZIP           = 107;
","    private static final int LAST_AUDIO_FILE_TYPE = FILE_TYPE_FLAC;

    // More audio file types
    public static final int FILE_TYPE_DTS   = 210;
    public static final int FILE_TYPE_3GPA  = 211;
    public static final int FILE_TYPE_AC3   = 212;
    public static final int FILE_TYPE_QCP   = 213;
    public static final int FILE_TYPE_PCM   = 214;
    public static final int FILE_TYPE_EC3   = 215;
    public static final int FILE_TYPE_AIFF  = 216;
    public static final int FILE_TYPE_APE   = 217;
    public static final int FILE_TYPE_DSD   = 218;
    public static final int FILE_TYPE_MHAS  = 219;
    private static final int FIRST_AUDIO_FILE_TYPE_EXT = FILE_TYPE_DTS;
    private static final int LAST_AUDIO_FILE_TYPE_EXT = FILE_TYPE_MHAS;

    // MIDI file types
    public static final int FILE_TYPE_MID     = 11;
    public static final int FILE_TYPE_SMF     = 12;
    public static final int FILE_TYPE_IMY     = 13;
    private static final int FIRST_MIDI_FILE_TYPE = FILE_TYPE_MID;
    private static final int LAST_MIDI_FILE_TYPE = FILE_TYPE_IMY;

    // Video file types
    public static final int FILE_TYPE_MP4     = 21;
    public static final int FILE_TYPE_M4V     = 22;
    public static final int FILE_TYPE_3GPP    = 23;
    public static final int FILE_TYPE_3GPP2   = 24;
    public static final int FILE_TYPE_WMV     = 25;
    public static final int FILE_TYPE_ASF     = 26;
    public static final int FILE_TYPE_MKV     = 27;
    public static final int FILE_TYPE_MP2TS   = 28;
    public static final int FILE_TYPE_AVI     = 29;
    public static final int FILE_TYPE_WEBM    = 30;
    private static final int FIRST_VIDEO_FILE_TYPE = FILE_TYPE_MP4;
    private static final int LAST_VIDEO_FILE_TYPE = FILE_TYPE_WEBM;

    // More video file types
    public static final int FILE_TYPE_MP2PS   = 200;
    public static final int FILE_TYPE_QT      = 201;
    public static final int FILE_TYPE_DIVX    = 202;
    public static final int FILE_TYPE_FLV = 203;
    private static final int FIRST_VIDEO_FILE_TYPE2 = FILE_TYPE_MP2PS;
    private static final int LAST_VIDEO_FILE_TYPE2 = FILE_TYPE_FLV;

    // Image file types
    public static final int FILE_TYPE_JPEG    = 31;
    public static final int FILE_TYPE_GIF     = 32;
    public static final int FILE_TYPE_PNG     = 33;
    public static final int FILE_TYPE_BMP     = 34;
    public static final int FILE_TYPE_WBMP    = 35;
    public static final int FILE_TYPE_WEBP    = 36;
    public static final int FILE_TYPE_HEIF    = 37;
    private static final int FIRST_IMAGE_FILE_TYPE = FILE_TYPE_JPEG;
    private static final int LAST_IMAGE_FILE_TYPE = FILE_TYPE_HEIF;

    // Raw image file types
    public static final int FILE_TYPE_DNG     = 300;
    public static final int FILE_TYPE_CR2     = 301;
    public static final int FILE_TYPE_NEF     = 302;
    public static final int FILE_TYPE_NRW     = 303;
    public static final int FILE_TYPE_ARW     = 304;
    public static final int FILE_TYPE_RW2     = 305;
    public static final int FILE_TYPE_ORF     = 306;
    public static final int FILE_TYPE_RAF     = 307;
    public static final int FILE_TYPE_PEF     = 308;
    public static final int FILE_TYPE_SRW     = 309;
    private static final int FIRST_RAW_IMAGE_FILE_TYPE = FILE_TYPE_DNG;
    private static final int LAST_RAW_IMAGE_FILE_TYPE = FILE_TYPE_SRW;

    // Playlist file types
    public static final int FILE_TYPE_M3U      = 41;
    public static final int FILE_TYPE_PLS      = 42;
    public static final int FILE_TYPE_WPL      = 43;
    public static final int FILE_TYPE_HTTPLIVE = 44;

    private static final int FIRST_PLAYLIST_FILE_TYPE = FILE_TYPE_M3U;
    private static final int LAST_PLAYLIST_FILE_TYPE = FILE_TYPE_HTTPLIVE;

    // Drm file types
    public static final int FILE_TYPE_FL      = 51;
    private static final int FIRST_DRM_FILE_TYPE = FILE_TYPE_FL;
    private static final int LAST_DRM_FILE_TYPE = FILE_TYPE_FL;

    // Other popular file types
    public static final int FILE_TYPE_TEXT          = 100;
    public static final int FILE_TYPE_HTML          = 101;
    public static final int FILE_TYPE_PDF           = 102;
    public static final int FILE_TYPE_XML           = 103;
    public static final int FILE_TYPE_MS_WORD       = 104;
    public static final int FILE_TYPE_MS_EXCEL      = 105;
    public static final int FILE_TYPE_MS_POWERPOINT = 106;
    public static final int FILE_TYPE_ZIP           = 107;
","    private static final int LAST_AUDIO_FILE_TYPE = FILE_TYPE_FLAC;

    // More audio file types
    public static final int FILE_TYPE_DTS   = 210;
    public static final int FILE_TYPE_3GPA  = 211;
    public static final int FILE_TYPE_AC3   = 212;
    public static final int FILE_TYPE_QCP   = 213;
    public static final int FILE_TYPE_PCM   = 214;
    public static final int FILE_TYPE_EC3   = 215;
    public static final int FILE_TYPE_AIFF  = 216;
    public static final int FILE_TYPE_APE   = 217;
    public static final int FILE_TYPE_DSD   = 218;
    public static final int FILE_TYPE_MHAS  = 219;
    private static final int FIRST_AUDIO_FILE_TYPE_EXT = FILE_TYPE_DTS;
    private static final int LAST_AUDIO_FILE_TYPE_EXT = FILE_TYPE_MHAS;

    // MIDI file types
    public static final int FILE_TYPE_MID     = 11;
    public static final int FILE_TYPE_SMF     = 12;
    public static final int FILE_TYPE_IMY     = 13;
    private static final int FIRST_MIDI_FILE_TYPE = FILE_TYPE_MID;
    private static final int LAST_MIDI_FILE_TYPE = FILE_TYPE_IMY;

    // Video file types
    public static final int FILE_TYPE_MP4     = 21;
    public static final int FILE_TYPE_M4V     = 22;
    public static final int FILE_TYPE_3GPP    = 23;
    public static final int FILE_TYPE_3GPP2   = 24;
    public static final int FILE_TYPE_WMV     = 25;
    public static final int FILE_TYPE_ASF     = 26;
    public static final int FILE_TYPE_MKV     = 27;
    public static final int FILE_TYPE_MP2TS   = 28;
    public static final int FILE_TYPE_AVI     = 29;
    public static final int FILE_TYPE_WEBM    = 30;
    private static final int FIRST_VIDEO_FILE_TYPE = FILE_TYPE_MP4;
    private static final int LAST_VIDEO_FILE_TYPE = FILE_TYPE_WEBM;

    // More video file types
    public static final int FILE_TYPE_MP2PS   = 200;
    public static final int FILE_TYPE_QT      = 201;
    public static final int FILE_TYPE_DIVX    = 202;
    public static final int FILE_TYPE_FLV = 203;
    private static final int FIRST_VIDEO_FILE_TYPE2 = FILE_TYPE_MP2PS;
    private static final int LAST_VIDEO_FILE_TYPE2 = FILE_TYPE_FLV;

    // Image file types
    public static final int FILE_TYPE_JPEG    = 31;
    public static final int FILE_TYPE_GIF     = 32;
    public static final int FILE_TYPE_PNG     = 33;
    public static final int FILE_TYPE_BMP     = 34;
    public static final int FILE_TYPE_WBMP    = 35;
    public static final int FILE_TYPE_WEBP    = 36;
    public static final int FILE_TYPE_HEIF    = 37;
    private static final int FIRST_IMAGE_FILE_TYPE = FILE_TYPE_JPEG;
    private static final int LAST_IMAGE_FILE_TYPE = FILE_TYPE_HEIF;

    // Raw image file types
    public static final int FILE_TYPE_DNG     = 300;
    public static final int FILE_TYPE_CR2     = 301;
    public static final int FILE_TYPE_NEF     = 302;
    public static final int FILE_TYPE_NRW     = 303;
    public static final int FILE_TYPE_ARW     = 304;
    public static final int FILE_TYPE_RW2     = 305;
    public static final int FILE_TYPE_ORF     = 306;
    public static final int FILE_TYPE_RAF     = 307;
    public static final int FILE_TYPE_PEF     = 308;
    public static final int FILE_TYPE_SRW     = 309;
    private static final int FIRST_RAW_IMAGE_FILE_TYPE = FILE_TYPE_DNG;
    private static final int LAST_RAW_IMAGE_FILE_TYPE = FILE_TYPE_SRW;

    // Playlist file types
    public static final int FILE_TYPE_M3U      = 41;
    public static final int FILE_TYPE_PLS      = 42;
    public static final int FILE_TYPE_WPL      = 43;
    public static final int FILE_TYPE_HTTPLIVE = 44;

    private static final int FIRST_PLAYLIST_FILE_TYPE = FILE_TYPE_M3U;
    private static final int LAST_PLAYLIST_FILE_TYPE = FILE_TYPE_HTTPLIVE;

    // Drm file types
    public static final int FILE_TYPE_FL      = 51;
    private static final int FIRST_DRM_FILE_TYPE = FILE_TYPE_FL;
    private static final int LAST_DRM_FILE_TYPE = FILE_TYPE_FL;

    // Other popular file types
    public static final int FILE_TYPE_TEXT          = 100;
    public static final int FILE_TYPE_HTML          = 101;
    public static final int FILE_TYPE_PDF           = 102;
    public static final int FILE_TYPE_XML           = 103;
    public static final int FILE_TYPE_MS_WORD       = 104;
    public static final int FILE_TYPE_MS_EXCEL      = 105;
    public static final int FILE_TYPE_MS_POWERPOINT = 106;
    public static final int FILE_TYPE_ZIP           = 107;
","[1.0, 1.0]"
146,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",media/java/android/media/MediaFile.java,"[(216, 316, 101), (216, 316, 101)]","        addFileType(""MP3"", FILE_TYPE_MP3, ""audio/mpeg"", MtpConstants.FORMAT_MP3, true);
        addFileType(""MPGA"", FILE_TYPE_MP3, ""audio/mpeg"", MtpConstants.FORMAT_MP3, false);
        addFileType(""M4A"", FILE_TYPE_M4A, ""audio/mp4"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""WAV"", FILE_TYPE_WAV, ""audio/x-wav"", MtpConstants.FORMAT_WAV, true);
        addFileType(""AMR"", FILE_TYPE_AMR, ""audio/amr"");
        addFileType(""AWB"", FILE_TYPE_AWB, ""audio/amr-wb"");
        if (isWMAEnabled()) {
            addFileType(""WMA"", FILE_TYPE_WMA, ""audio/x-ms-wma"", MtpConstants.FORMAT_WMA, true);
        }
        addFileType(""OGG"", FILE_TYPE_OGG, ""audio/ogg"", MtpConstants.FORMAT_OGG, false);
        addFileType(""OGG"", FILE_TYPE_OGG, ""application/ogg"", MtpConstants.FORMAT_OGG, true);
        addFileType(""OGA"", FILE_TYPE_OGG, ""application/ogg"", MtpConstants.FORMAT_OGG, false);
        addFileType(""AAC"", FILE_TYPE_AAC, ""audio/aac"", MtpConstants.FORMAT_AAC, true);
        addFileType(""AAC"", FILE_TYPE_AAC, ""audio/aac-adts"", MtpConstants.FORMAT_AAC, false);
        addFileType(""MKA"", FILE_TYPE_MKA, ""audio/x-matroska"");

        addFileType(""MID"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""MIDI"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""XMF"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""RTTTL"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""SMF"", FILE_TYPE_SMF, ""audio/sp-midi"");
        addFileType(""IMY"", FILE_TYPE_IMY, ""audio/imelody"");
        addFileType(""RTX"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""OTA"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""MXMF"", FILE_TYPE_MID, ""audio/midi"");

        addFileType(""MPEG"", FILE_TYPE_MP4, ""video/mpeg"", MtpConstants.FORMAT_MPEG, true);
        addFileType(""MPG"", FILE_TYPE_MP4, ""video/mpeg"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""MP4"", FILE_TYPE_MP4, ""video/mp4"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""M4V"", FILE_TYPE_M4V, ""video/mp4"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""MOV"", FILE_TYPE_QT, ""video/quicktime"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""MP4"", FILE_TYPE_MP4, ""audio/mhas"", MtpConstants.FORMAT_MPEG, false);

        addFileType(""3GP"", FILE_TYPE_3GPP, ""video/3gpp"",  MtpConstants.FORMAT_3GP_CONTAINER, true);
        addFileType(""3GPP"", FILE_TYPE_3GPP, ""video/3gpp"", MtpConstants.FORMAT_3GP_CONTAINER, false);
        addFileType(""3G2"", FILE_TYPE_3GPP2, ""video/3gpp2"", MtpConstants.FORMAT_3GP_CONTAINER, false);
        addFileType(""3GPP2"", FILE_TYPE_3GPP2, ""video/3gpp2"", MtpConstants.FORMAT_3GP_CONTAINER, false);
        addFileType(""MKV"", FILE_TYPE_MKV, ""video/x-matroska"");
        addFileType(""WEBM"", FILE_TYPE_WEBM, ""video/webm"");
        addFileType(""TS"", FILE_TYPE_MP2TS, ""video/mp2ts"");
        addFileType(""AVI"", FILE_TYPE_AVI, ""video/avi"");

        if (isWMVEnabled()) {
            addFileType(""WMV"", FILE_TYPE_WMV, ""video/x-ms-wmv"", MtpConstants.FORMAT_WMV, true);
            addFileType(""ASF"", FILE_TYPE_ASF, ""video/x-ms-asf"");
        }

        addFileType(""JPG"", FILE_TYPE_JPEG, ""image/jpeg"", MtpConstants.FORMAT_EXIF_JPEG, true);
        addFileType(""JPEG"", FILE_TYPE_JPEG, ""image/jpeg"", MtpConstants.FORMAT_EXIF_JPEG, false);
        addFileType(""GIF"", FILE_TYPE_GIF, ""image/gif"", MtpConstants.FORMAT_GIF, true);
        addFileType(""PNG"", FILE_TYPE_PNG, ""image/png"", MtpConstants.FORMAT_PNG, true);
        addFileType(""BMP"", FILE_TYPE_BMP, ""image/x-ms-bmp"", MtpConstants.FORMAT_BMP, true);
        addFileType(""WBMP"", FILE_TYPE_WBMP, ""image/vnd.wap.wbmp"", MtpConstants.FORMAT_DEFINED, false);
        addFileType(""WEBP"", FILE_TYPE_WEBP, ""image/webp"", MtpConstants.FORMAT_DEFINED, false);
        addFileType(""HEIC"", FILE_TYPE_HEIF, ""image/heif"", MtpConstants.FORMAT_HEIF, true);
        addFileType(""HEIF"", FILE_TYPE_HEIF, ""image/heif"", MtpConstants.FORMAT_HEIF, false);

        addFileType(""DNG"", FILE_TYPE_DNG, ""image/x-adobe-dng"", MtpConstants.FORMAT_DNG, true);
        addFileType(""CR2"", FILE_TYPE_CR2, ""image/x-canon-cr2"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""NEF"", FILE_TYPE_NEF, ""image/x-nikon-nef"", MtpConstants.FORMAT_TIFF_EP, false);
        addFileType(""NRW"", FILE_TYPE_NRW, ""image/x-nikon-nrw"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""ARW"", FILE_TYPE_ARW, ""image/x-sony-arw"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""RW2"", FILE_TYPE_RW2, ""image/x-panasonic-rw2"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""ORF"", FILE_TYPE_ORF, ""image/x-olympus-orf"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""RAF"", FILE_TYPE_RAF, ""image/x-fuji-raf"", MtpConstants.FORMAT_DEFINED, false);
        addFileType(""PEF"", FILE_TYPE_PEF, ""image/x-pentax-pef"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""SRW"", FILE_TYPE_SRW, ""image/x-samsung-srw"", MtpConstants.FORMAT_TIFF, false);

        addFileType(""M3U"", FILE_TYPE_M3U, ""audio/x-mpegurl"", MtpConstants.FORMAT_M3U_PLAYLIST, true);
        addFileType(""M3U"", FILE_TYPE_M3U, ""application/x-mpegurl"", MtpConstants.FORMAT_M3U_PLAYLIST, false);
        addFileType(""PLS"", FILE_TYPE_PLS, ""audio/x-scpls"", MtpConstants.FORMAT_PLS_PLAYLIST, true);
        addFileType(""WPL"", FILE_TYPE_WPL, ""application/vnd.ms-wpl"", MtpConstants.FORMAT_WPL_PLAYLIST, true);
        addFileType(""M3U8"", FILE_TYPE_HTTPLIVE, ""application/vnd.apple.mpegurl"");
        addFileType(""M3U8"", FILE_TYPE_HTTPLIVE, ""audio/mpegurl"");
        addFileType(""M3U8"", FILE_TYPE_HTTPLIVE, ""audio/x-mpegurl"");

        addFileType(""FL"", FILE_TYPE_FL, ""application/x-android-drm-fl"");

        addFileType(""TXT"", FILE_TYPE_TEXT, ""text/plain"", MtpConstants.FORMAT_TEXT, true);
        addFileType(""HTM"", FILE_TYPE_HTML, ""text/html"", MtpConstants.FORMAT_HTML, true);
        addFileType(""HTML"", FILE_TYPE_HTML, ""text/html"", MtpConstants.FORMAT_HTML, false);
        addFileType(""PDF"", FILE_TYPE_PDF, ""application/pdf"");
        addFileType(""DOC"", FILE_TYPE_MS_WORD, ""application/msword"", MtpConstants.FORMAT_MS_WORD_DOCUMENT, true);
        addFileType(""XLS"", FILE_TYPE_MS_EXCEL, ""application/vnd.ms-excel"", MtpConstants.FORMAT_MS_EXCEL_SPREADSHEET, true);
        addFileType(""PPT"", FILE_TYPE_MS_POWERPOINT, ""application/vnd.ms-powerpoint"", MtpConstants.FORMAT_MS_POWERPOINT_PRESENTATION, true);
        addFileType(""FLAC"", FILE_TYPE_FLAC, ""audio/flac"", MtpConstants.FORMAT_FLAC, true);
        addFileType(""ZIP"", FILE_TYPE_ZIP, ""application/zip"");
        addFileType(""MPG"", FILE_TYPE_MP2PS, ""video/mp2p"");
        addFileType(""MPEG"", FILE_TYPE_MP2PS, ""video/mp2p"");
        addFileType(""DIVX"", FILE_TYPE_DIVX, ""video/divx"");
        addFileType(""FLV"", FILE_TYPE_FLV, ""video/flv"");
        addFileType(""QCP"", FILE_TYPE_QCP, ""audio/qcelp"");
        addFileType(""AC3"", FILE_TYPE_AC3, ""audio/ac3"");
        addFileType(""EC3"", FILE_TYPE_EC3, ""audio/eac3"");
        addFileType(""AIF"", FILE_TYPE_AIFF, ""audio/x-aiff"");
        addFileType(""AIFF"", FILE_TYPE_AIFF, ""audio/x-aiff"");
        addFileType(""APE"", FILE_TYPE_APE, ""audio/x-ape"");
        addFileType(""DSF"", FILE_TYPE_DSD, ""audio/x-dsf"");
        addFileType(""DFF"", FILE_TYPE_DSD, ""audio/x-dff"");
        addFileType(""DSD"", FILE_TYPE_DSD, ""audio/dsd"");
        addFileType(""MHAS"", FILE_TYPE_MHAS, ""audio/mhas"");
","        addFileType(""MP3"", FILE_TYPE_MP3, ""audio/mpeg"", MtpConstants.FORMAT_MP3, true);
        addFileType(""MPGA"", FILE_TYPE_MP3, ""audio/mpeg"", MtpConstants.FORMAT_MP3, false);
        addFileType(""M4A"", FILE_TYPE_M4A, ""audio/mp4"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""WAV"", FILE_TYPE_WAV, ""audio/x-wav"", MtpConstants.FORMAT_WAV, true);
        addFileType(""AMR"", FILE_TYPE_AMR, ""audio/amr"");
        addFileType(""AWB"", FILE_TYPE_AWB, ""audio/amr-wb"");
        if (isWMAEnabled()) {
            addFileType(""WMA"", FILE_TYPE_WMA, ""audio/x-ms-wma"", MtpConstants.FORMAT_WMA, true);
        }
        addFileType(""OGG"", FILE_TYPE_OGG, ""audio/ogg"", MtpConstants.FORMAT_OGG, false);
        addFileType(""OGG"", FILE_TYPE_OGG, ""application/ogg"", MtpConstants.FORMAT_OGG, true);
        addFileType(""OGA"", FILE_TYPE_OGG, ""application/ogg"", MtpConstants.FORMAT_OGG, false);
        addFileType(""AAC"", FILE_TYPE_AAC, ""audio/aac"", MtpConstants.FORMAT_AAC, true);
        addFileType(""AAC"", FILE_TYPE_AAC, ""audio/aac-adts"", MtpConstants.FORMAT_AAC, false);
        addFileType(""MKA"", FILE_TYPE_MKA, ""audio/x-matroska"");

        addFileType(""MID"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""MIDI"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""XMF"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""RTTTL"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""SMF"", FILE_TYPE_SMF, ""audio/sp-midi"");
        addFileType(""IMY"", FILE_TYPE_IMY, ""audio/imelody"");
        addFileType(""RTX"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""OTA"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""MXMF"", FILE_TYPE_MID, ""audio/midi"");

        addFileType(""MPEG"", FILE_TYPE_MP4, ""video/mpeg"", MtpConstants.FORMAT_MPEG, true);
        addFileType(""MPG"", FILE_TYPE_MP4, ""video/mpeg"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""MP4"", FILE_TYPE_MP4, ""video/mp4"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""M4V"", FILE_TYPE_M4V, ""video/mp4"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""MOV"", FILE_TYPE_QT, ""video/quicktime"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""MP4"", FILE_TYPE_MP4, ""audio/mhas"", MtpConstants.FORMAT_MPEG, false);

        addFileType(""3GP"", FILE_TYPE_3GPP, ""video/3gpp"",  MtpConstants.FORMAT_3GP_CONTAINER, true);
        addFileType(""3GPP"", FILE_TYPE_3GPP, ""video/3gpp"", MtpConstants.FORMAT_3GP_CONTAINER, false);
        addFileType(""3G2"", FILE_TYPE_3GPP2, ""video/3gpp2"", MtpConstants.FORMAT_3GP_CONTAINER, false);
        addFileType(""3GPP2"", FILE_TYPE_3GPP2, ""video/3gpp2"", MtpConstants.FORMAT_3GP_CONTAINER, false);
        addFileType(""MKV"", FILE_TYPE_MKV, ""video/x-matroska"");
        addFileType(""WEBM"", FILE_TYPE_WEBM, ""video/webm"");
        addFileType(""TS"", FILE_TYPE_MP2TS, ""video/mp2ts"");
        addFileType(""AVI"", FILE_TYPE_AVI, ""video/avi"");

        if (isWMVEnabled()) {
            addFileType(""WMV"", FILE_TYPE_WMV, ""video/x-ms-wmv"", MtpConstants.FORMAT_WMV, true);
            addFileType(""ASF"", FILE_TYPE_ASF, ""video/x-ms-asf"");
        }

        addFileType(""JPG"", FILE_TYPE_JPEG, ""image/jpeg"", MtpConstants.FORMAT_EXIF_JPEG, true);
        addFileType(""JPEG"", FILE_TYPE_JPEG, ""image/jpeg"", MtpConstants.FORMAT_EXIF_JPEG, false);
        addFileType(""GIF"", FILE_TYPE_GIF, ""image/gif"", MtpConstants.FORMAT_GIF, true);
        addFileType(""PNG"", FILE_TYPE_PNG, ""image/png"", MtpConstants.FORMAT_PNG, true);
        addFileType(""BMP"", FILE_TYPE_BMP, ""image/x-ms-bmp"", MtpConstants.FORMAT_BMP, true);
        addFileType(""WBMP"", FILE_TYPE_WBMP, ""image/vnd.wap.wbmp"", MtpConstants.FORMAT_DEFINED, false);
        addFileType(""WEBP"", FILE_TYPE_WEBP, ""image/webp"", MtpConstants.FORMAT_DEFINED, false);
        addFileType(""HEIC"", FILE_TYPE_HEIF, ""image/heif"", MtpConstants.FORMAT_HEIF, true);
        addFileType(""HEIF"", FILE_TYPE_HEIF, ""image/heif"", MtpConstants.FORMAT_HEIF, false);

        addFileType(""DNG"", FILE_TYPE_DNG, ""image/x-adobe-dng"", MtpConstants.FORMAT_DNG, true);
        addFileType(""CR2"", FILE_TYPE_CR2, ""image/x-canon-cr2"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""NEF"", FILE_TYPE_NEF, ""image/x-nikon-nef"", MtpConstants.FORMAT_TIFF_EP, false);
        addFileType(""NRW"", FILE_TYPE_NRW, ""image/x-nikon-nrw"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""ARW"", FILE_TYPE_ARW, ""image/x-sony-arw"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""RW2"", FILE_TYPE_RW2, ""image/x-panasonic-rw2"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""ORF"", FILE_TYPE_ORF, ""image/x-olympus-orf"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""RAF"", FILE_TYPE_RAF, ""image/x-fuji-raf"", MtpConstants.FORMAT_DEFINED, false);
        addFileType(""PEF"", FILE_TYPE_PEF, ""image/x-pentax-pef"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""SRW"", FILE_TYPE_SRW, ""image/x-samsung-srw"", MtpConstants.FORMAT_TIFF, false);

        addFileType(""M3U"", FILE_TYPE_M3U, ""audio/x-mpegurl"", MtpConstants.FORMAT_M3U_PLAYLIST, true);
        addFileType(""M3U"", FILE_TYPE_M3U, ""application/x-mpegurl"", MtpConstants.FORMAT_M3U_PLAYLIST, false);
        addFileType(""PLS"", FILE_TYPE_PLS, ""audio/x-scpls"", MtpConstants.FORMAT_PLS_PLAYLIST, true);
        addFileType(""WPL"", FILE_TYPE_WPL, ""application/vnd.ms-wpl"", MtpConstants.FORMAT_WPL_PLAYLIST, true);
        addFileType(""M3U8"", FILE_TYPE_HTTPLIVE, ""application/vnd.apple.mpegurl"");
        addFileType(""M3U8"", FILE_TYPE_HTTPLIVE, ""audio/mpegurl"");
        addFileType(""M3U8"", FILE_TYPE_HTTPLIVE, ""audio/x-mpegurl"");

        addFileType(""FL"", FILE_TYPE_FL, ""application/x-android-drm-fl"");

        addFileType(""TXT"", FILE_TYPE_TEXT, ""text/plain"", MtpConstants.FORMAT_TEXT, true);
        addFileType(""HTM"", FILE_TYPE_HTML, ""text/html"", MtpConstants.FORMAT_HTML, true);
        addFileType(""HTML"", FILE_TYPE_HTML, ""text/html"", MtpConstants.FORMAT_HTML, false);
        addFileType(""PDF"", FILE_TYPE_PDF, ""application/pdf"");
        addFileType(""DOC"", FILE_TYPE_MS_WORD, ""application/msword"", MtpConstants.FORMAT_MS_WORD_DOCUMENT, true);
        addFileType(""XLS"", FILE_TYPE_MS_EXCEL, ""application/vnd.ms-excel"", MtpConstants.FORMAT_MS_EXCEL_SPREADSHEET, true);
        addFileType(""PPT"", FILE_TYPE_MS_POWERPOINT, ""application/vnd.ms-powerpoint"", MtpConstants.FORMAT_MS_POWERPOINT_PRESENTATION, true);
        addFileType(""FLAC"", FILE_TYPE_FLAC, ""audio/flac"", MtpConstants.FORMAT_FLAC, true);
        addFileType(""ZIP"", FILE_TYPE_ZIP, ""application/zip"");
        addFileType(""MPG"", FILE_TYPE_MP2PS, ""video/mp2p"");
        addFileType(""MPEG"", FILE_TYPE_MP2PS, ""video/mp2p"");
        addFileType(""DIVX"", FILE_TYPE_DIVX, ""video/divx"");
        addFileType(""FLV"", FILE_TYPE_FLV, ""video/flv"");
        addFileType(""QCP"", FILE_TYPE_QCP, ""audio/qcelp"");
        addFileType(""AC3"", FILE_TYPE_AC3, ""audio/ac3"");
        addFileType(""EC3"", FILE_TYPE_EC3, ""audio/eac3"");
        addFileType(""AIF"", FILE_TYPE_AIFF, ""audio/x-aiff"");
        addFileType(""AIFF"", FILE_TYPE_AIFF, ""audio/x-aiff"");
        addFileType(""APE"", FILE_TYPE_APE, ""audio/x-ape"");
        addFileType(""DSF"", FILE_TYPE_DSD, ""audio/x-dsf"");
        addFileType(""DFF"", FILE_TYPE_DSD, ""audio/x-dff"");
        addFileType(""DSD"", FILE_TYPE_DSD, ""audio/dsd"");
        addFileType(""MHAS"", FILE_TYPE_MHAS, ""audio/mhas"");
","        addFileType(""MP3"", FILE_TYPE_MP3, ""audio/mpeg"", MtpConstants.FORMAT_MP3, true);
        addFileType(""MPGA"", FILE_TYPE_MP3, ""audio/mpeg"", MtpConstants.FORMAT_MP3, false);
        addFileType(""M4A"", FILE_TYPE_M4A, ""audio/mp4"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""WAV"", FILE_TYPE_WAV, ""audio/x-wav"", MtpConstants.FORMAT_WAV, true);
        addFileType(""AMR"", FILE_TYPE_AMR, ""audio/amr"");
        addFileType(""AWB"", FILE_TYPE_AWB, ""audio/amr-wb"");
        if (isWMAEnabled()) {
            addFileType(""WMA"", FILE_TYPE_WMA, ""audio/x-ms-wma"", MtpConstants.FORMAT_WMA, true);
        }
        addFileType(""OGG"", FILE_TYPE_OGG, ""audio/ogg"", MtpConstants.FORMAT_OGG, false);
        addFileType(""OGG"", FILE_TYPE_OGG, ""application/ogg"", MtpConstants.FORMAT_OGG, true);
        addFileType(""OGA"", FILE_TYPE_OGG, ""application/ogg"", MtpConstants.FORMAT_OGG, false);
        addFileType(""AAC"", FILE_TYPE_AAC, ""audio/aac"", MtpConstants.FORMAT_AAC, true);
        addFileType(""AAC"", FILE_TYPE_AAC, ""audio/aac-adts"", MtpConstants.FORMAT_AAC, false);
        addFileType(""MKA"", FILE_TYPE_MKA, ""audio/x-matroska"");

        addFileType(""MID"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""MIDI"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""XMF"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""RTTTL"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""SMF"", FILE_TYPE_SMF, ""audio/sp-midi"");
        addFileType(""IMY"", FILE_TYPE_IMY, ""audio/imelody"");
        addFileType(""RTX"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""OTA"", FILE_TYPE_MID, ""audio/midi"");
        addFileType(""MXMF"", FILE_TYPE_MID, ""audio/midi"");

        addFileType(""MPEG"", FILE_TYPE_MP4, ""video/mpeg"", MtpConstants.FORMAT_MPEG, true);
        addFileType(""MPG"", FILE_TYPE_MP4, ""video/mpeg"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""MP4"", FILE_TYPE_MP4, ""video/mp4"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""M4V"", FILE_TYPE_M4V, ""video/mp4"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""MOV"", FILE_TYPE_QT, ""video/quicktime"", MtpConstants.FORMAT_MPEG, false);
        addFileType(""MP4"", FILE_TYPE_MP4, ""audio/mhas"", MtpConstants.FORMAT_MPEG, false);

        addFileType(""3GP"", FILE_TYPE_3GPP, ""video/3gpp"",  MtpConstants.FORMAT_3GP_CONTAINER, true);
        addFileType(""3GPP"", FILE_TYPE_3GPP, ""video/3gpp"", MtpConstants.FORMAT_3GP_CONTAINER, false);
        addFileType(""3G2"", FILE_TYPE_3GPP2, ""video/3gpp2"", MtpConstants.FORMAT_3GP_CONTAINER, false);
        addFileType(""3GPP2"", FILE_TYPE_3GPP2, ""video/3gpp2"", MtpConstants.FORMAT_3GP_CONTAINER, false);
        addFileType(""MKV"", FILE_TYPE_MKV, ""video/x-matroska"");
        addFileType(""WEBM"", FILE_TYPE_WEBM, ""video/webm"");
        addFileType(""TS"", FILE_TYPE_MP2TS, ""video/mp2ts"");
        addFileType(""AVI"", FILE_TYPE_AVI, ""video/avi"");

        if (isWMVEnabled()) {
            addFileType(""WMV"", FILE_TYPE_WMV, ""video/x-ms-wmv"", MtpConstants.FORMAT_WMV, true);
            addFileType(""ASF"", FILE_TYPE_ASF, ""video/x-ms-asf"");
        }

        addFileType(""JPG"", FILE_TYPE_JPEG, ""image/jpeg"", MtpConstants.FORMAT_EXIF_JPEG, true);
        addFileType(""JPEG"", FILE_TYPE_JPEG, ""image/jpeg"", MtpConstants.FORMAT_EXIF_JPEG, false);
        addFileType(""GIF"", FILE_TYPE_GIF, ""image/gif"", MtpConstants.FORMAT_GIF, true);
        addFileType(""PNG"", FILE_TYPE_PNG, ""image/png"", MtpConstants.FORMAT_PNG, true);
        addFileType(""BMP"", FILE_TYPE_BMP, ""image/x-ms-bmp"", MtpConstants.FORMAT_BMP, true);
        addFileType(""WBMP"", FILE_TYPE_WBMP, ""image/vnd.wap.wbmp"", MtpConstants.FORMAT_DEFINED, false);
        addFileType(""WEBP"", FILE_TYPE_WEBP, ""image/webp"", MtpConstants.FORMAT_DEFINED, false);
        addFileType(""HEIC"", FILE_TYPE_HEIF, ""image/heif"", MtpConstants.FORMAT_HEIF, true);
        addFileType(""HEIF"", FILE_TYPE_HEIF, ""image/heif"", MtpConstants.FORMAT_HEIF, false);

        addFileType(""DNG"", FILE_TYPE_DNG, ""image/x-adobe-dng"", MtpConstants.FORMAT_DNG, true);
        addFileType(""CR2"", FILE_TYPE_CR2, ""image/x-canon-cr2"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""NEF"", FILE_TYPE_NEF, ""image/x-nikon-nef"", MtpConstants.FORMAT_TIFF_EP, false);
        addFileType(""NRW"", FILE_TYPE_NRW, ""image/x-nikon-nrw"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""ARW"", FILE_TYPE_ARW, ""image/x-sony-arw"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""RW2"", FILE_TYPE_RW2, ""image/x-panasonic-rw2"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""ORF"", FILE_TYPE_ORF, ""image/x-olympus-orf"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""RAF"", FILE_TYPE_RAF, ""image/x-fuji-raf"", MtpConstants.FORMAT_DEFINED, false);
        addFileType(""PEF"", FILE_TYPE_PEF, ""image/x-pentax-pef"", MtpConstants.FORMAT_TIFF, false);
        addFileType(""SRW"", FILE_TYPE_SRW, ""image/x-samsung-srw"", MtpConstants.FORMAT_TIFF, false);

        addFileType(""M3U"", FILE_TYPE_M3U, ""audio/x-mpegurl"", MtpConstants.FORMAT_M3U_PLAYLIST, true);
        addFileType(""M3U"", FILE_TYPE_M3U, ""application/x-mpegurl"", MtpConstants.FORMAT_M3U_PLAYLIST, false);
        addFileType(""PLS"", FILE_TYPE_PLS, ""audio/x-scpls"", MtpConstants.FORMAT_PLS_PLAYLIST, true);
        addFileType(""WPL"", FILE_TYPE_WPL, ""application/vnd.ms-wpl"", MtpConstants.FORMAT_WPL_PLAYLIST, true);
        addFileType(""M3U8"", FILE_TYPE_HTTPLIVE, ""application/vnd.apple.mpegurl"");
        addFileType(""M3U8"", FILE_TYPE_HTTPLIVE, ""audio/mpegurl"");
        addFileType(""M3U8"", FILE_TYPE_HTTPLIVE, ""audio/x-mpegurl"");

        addFileType(""FL"", FILE_TYPE_FL, ""application/x-android-drm-fl"");

        addFileType(""TXT"", FILE_TYPE_TEXT, ""text/plain"", MtpConstants.FORMAT_TEXT, true);
        addFileType(""HTM"", FILE_TYPE_HTML, ""text/html"", MtpConstants.FORMAT_HTML, true);
        addFileType(""HTML"", FILE_TYPE_HTML, ""text/html"", MtpConstants.FORMAT_HTML, false);
        addFileType(""PDF"", FILE_TYPE_PDF, ""application/pdf"");
        addFileType(""DOC"", FILE_TYPE_MS_WORD, ""application/msword"", MtpConstants.FORMAT_MS_WORD_DOCUMENT, true);
        addFileType(""XLS"", FILE_TYPE_MS_EXCEL, ""application/vnd.ms-excel"", MtpConstants.FORMAT_MS_EXCEL_SPREADSHEET, true);
        addFileType(""PPT"", FILE_TYPE_MS_POWERPOINT, ""application/vnd.ms-powerpoint"", MtpConstants.FORMAT_MS_POWERPOINT_PRESENTATION, true);
        addFileType(""FLAC"", FILE_TYPE_FLAC, ""audio/flac"", MtpConstants.FORMAT_FLAC, true);
        addFileType(""ZIP"", FILE_TYPE_ZIP, ""application/zip"");
        addFileType(""MPG"", FILE_TYPE_MP2PS, ""video/mp2p"");
        addFileType(""MPEG"", FILE_TYPE_MP2PS, ""video/mp2p"");
        addFileType(""DIVX"", FILE_TYPE_DIVX, ""video/divx"");
        addFileType(""FLV"", FILE_TYPE_FLV, ""video/flv"");
        addFileType(""QCP"", FILE_TYPE_QCP, ""audio/qcelp"");
        addFileType(""AC3"", FILE_TYPE_AC3, ""audio/ac3"");
        addFileType(""EC3"", FILE_TYPE_EC3, ""audio/eac3"");
        addFileType(""AIF"", FILE_TYPE_AIFF, ""audio/x-aiff"");
        addFileType(""AIFF"", FILE_TYPE_AIFF, ""audio/x-aiff"");
        addFileType(""APE"", FILE_TYPE_APE, ""audio/x-ape"");
        addFileType(""DSF"", FILE_TYPE_DSD, ""audio/x-dsf"");
        addFileType(""DFF"", FILE_TYPE_DSD, ""audio/x-dff"");
        addFileType(""DSD"", FILE_TYPE_DSD, ""audio/dsd"");
        addFileType(""MHAS"", FILE_TYPE_MHAS, ""audio/mhas"");
","[1.0, 1.0]"
147,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",media/java/android/media/MediaFile.java,"[(321, 326, 6), (321, 326, 6)]","        return ((fileType >= FIRST_AUDIO_FILE_TYPE &&
                fileType <= LAST_AUDIO_FILE_TYPE) ||
                (fileType >= FIRST_MIDI_FILE_TYPE &&
                fileType <= LAST_MIDI_FILE_TYPE) ||
                (fileType >= FIRST_AUDIO_FILE_TYPE_EXT &&
                fileType <= LAST_AUDIO_FILE_TYPE_EXT));
","        return ((fileType >= FIRST_AUDIO_FILE_TYPE &&
                fileType <= LAST_AUDIO_FILE_TYPE) ||
                (fileType >= FIRST_MIDI_FILE_TYPE &&
                fileType <= LAST_MIDI_FILE_TYPE) ||
                (fileType >= FIRST_AUDIO_FILE_TYPE_EXT &&
                fileType <= LAST_AUDIO_FILE_TYPE_EXT));
","        return ((fileType >= FIRST_AUDIO_FILE_TYPE &&
                fileType <= LAST_AUDIO_FILE_TYPE) ||
                (fileType >= FIRST_MIDI_FILE_TYPE &&
                fileType <= LAST_MIDI_FILE_TYPE) ||
                (fileType >= FIRST_AUDIO_FILE_TYPE_EXT &&
                fileType <= LAST_AUDIO_FILE_TYPE_EXT));
","[1.0, 1.0]"
148,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ScreenRotationAnimation.java,"[(32, 33, 2), (32, 33, 2)]","import android.os.IBinder;
import android.util.BoostFramework;
","import android.os.IBinder;
import android.util.BoostFramework;
","import android.os.IBinder;
import android.util.BoostFramework;
","[1.0, 1.0]"
149,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothEventManager.java,"[(285, 285, 1), (285, 285, 1)]","                // callback to UI to create Preference for new device
","                // callback to UI to create Preference for new device
","                // callback to UI to create Preference for new device
","[1.0, 1.0]"
150,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(945, 951, 7), (945, 951, 7)]","            if (getPhonebookPermissionChoice() == CachedBluetoothDevice.ACCESS_UNKNOWN) {
                if ((mDevice.getBluetoothClass() != null) &&
                   (mDevice.getBluetoothClass().getDeviceClass()
                        == BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE ||
                    mDevice.getBluetoothClass().getDeviceClass()
                        == BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET)) {
                    setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
","            if (getPhonebookPermissionChoice() == CachedBluetoothDevice.ACCESS_UNKNOWN) {
                if ((mDevice.getBluetoothClass() != null) &&
                   (mDevice.getBluetoothClass().getDeviceClass()
                        == BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE ||
                    mDevice.getBluetoothClass().getDeviceClass()
                        == BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET)) {
                    setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
","            if (getPhonebookPermissionChoice() == CachedBluetoothDevice.ACCESS_UNKNOWN) {
                if ((mDevice.getBluetoothClass() != null) &&
                   (mDevice.getBluetoothClass().getDeviceClass()
                        == BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE ||
                    mDevice.getBluetoothClass().getDeviceClass()
                        == BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET)) {
                    setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
","[1.0, 1.0]"
151,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8201, 8201, 1), (8201, 8201, 1)]","            WIFI_DISCONNECT_DELAY_DURATION,
","            WIFI_DISCONNECT_DELAY_DURATION,
","            WIFI_DISCONNECT_DELAY_DURATION,
","[1.0, 1.0]"
152,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8355, 8355, 1), (8355, 8355, 1)]","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","[1.0, 1.0]"
153,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/le/ScanFilter.java,"[(263, 263, 1), (263, 263, 1)]","     * @hide
","     * @hide
","     * @hide
","[1.0, 1.0]"
154,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/le/ScanFilter.java,"[(408, 410, 3), (408, 410, 3)]","     * @hide
     */
    public static boolean matchesServiceSolicitationUuids(ParcelUuid solicitationUuid,
","     * @hide
     */
    public static boolean matchesServiceSolicitationUuids(ParcelUuid solicitationUuid,
","     * @hide
     */
    public static boolean matchesServiceSolicitationUuids(ParcelUuid solicitationUuid,
","[1.0, 1.0]"
155,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"[(100, 102, 3), (100, 102, 3)]","    private DunServerProfile mDunProfile;
    private final boolean mUsePbapPce;
    private final boolean mUseMapClient;
","    private DunServerProfile mDunProfile;
    private final boolean mUsePbapPce;
    private final boolean mUseMapClient;
","    private DunServerProfile mDunProfile;
    private final boolean mUsePbapPce;
    private final boolean mUseMapClient;
","[1.0, 1.0]"
156,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(514, 515, 2), (514, 515, 2)]","            Log.d(mTag, ""updateTelephony: hasService="" + hasService()
                    + "" ss="" + mSignalStrength);
","            Log.d(mTag, ""updateTelephony: hasService="" + hasService()
                    + "" ss="" + mSignalStrength);
","            Log.d(mTag, ""updateTelephony: hasService="" + hasService()
                    + "" ss="" + mSignalStrength);
","[1.0, 1.0]"
157,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(3998, 4179, 182), (3998, 4179, 182)]","     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
","     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
","     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
","[1.0, 1.0]"
158,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8355, 8355, 1), (8191, 8191, 1)]","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","[1.0, 1.0]"
159,"['2edeff882ab756e76b3a028a1568d8774ddc0257', '6f47ceafbe6febe54aa5c376baed3415cdf848ad']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ScreenRotationAnimation.java,"[(32, 33, 2), (39, 39, 1)]","import android.os.IBinder;
import android.util.BoostFramework;
","import android.util.BoostFramework;
","import android.util.BoostFramework;
","[0.571, 1.0]"
160,"['2edeff882ab756e76b3a028a1568d8774ddc0257', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(3998, 4179, 182), (4012, 4193, 182)]","     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
","     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
","     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
","[1.0, 1.0]"
161,"['3454c1e1aa1d155fe2246ce2627cf58e934397e9', '3454c1e1aa1d155fe2246ce2627cf58e934397e9']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerConstants.java,"[(35, 37, 3), (35, 37, 3)]","import android.text.TextUtils.SimpleStringSplitter;
import android.util.ArraySet;
import android.util.BoostFramework;
","import android.text.TextUtils.SimpleStringSplitter;
import android.util.ArraySet;
import android.util.BoostFramework;
","import android.text.TextUtils.SimpleStringSplitter;
import android.util.ArraySet;
import android.util.BoostFramework;
","[1.0, 1.0]"
166,"['3a5272699e3e16fbfdc397480898bb27abeb2caa', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1108, 1147, 40), (1122, 1160, 39)]","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

    private void setKeystorePassword(String password, int userHandle) {
","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

","[0.947, 1.0]"
167,"['3a5272699e3e16fbfdc397480898bb27abeb2caa', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1577, 1589, 13), (1684, 1696, 13)]","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(String credential) throws RemoteException {
","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(byte[] credential) throws RemoteException {
","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(","[0.934, 0.934]"
168,"['3a5272699e3e16fbfdc397480898bb27abeb2caa', '3a5272699e3e16fbfdc397480898bb27abeb2caa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java,"[(2612, 2613, 2), (2612, 2613, 2)]","	    loadStringSetting(stmt, Settings.Global.NTP_SERVER_2,
                    R.string.def_ntp_server_2);
","	    loadStringSetting(stmt, Settings.Global.NTP_SERVER_2,
                    R.string.def_ntp_server_2);
","	    loadStringSetting(stmt, Settings.Global.NTP_SERVER_2,
                    R.string.def_ntp_server_2);
","[1.0, 1.0]"
169,"['3a5272699e3e16fbfdc397480898bb27abeb2caa', '3a5272699e3e16fbfdc397480898bb27abeb2caa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(605, 632, 28), (605, 632, 28)]","    public void updateClat(INetworkManagementService netd) {
        if (Nat464Xlat.requiresClat(this) &&
            ( this.networkCapabilities.hasCapability(NET_CAPABILITY_INTERNET) ||
              this.networkCapabilities.hasCapability(NET_CAPABILITY_MMS) )) {
            maybeStartClat();
        } else {
            maybeStopClat();
        }
    }

    /** Ensure clat has started for this network. */
    public void maybeStartClat() {
        if (clatd != null && clatd.isStarted()) {
            return;
        }
        clatd = new Nat464Xlat(this, mNetd, mNMS);
        clatd.start();
    }

    /** Ensure clat has stopped for this network. */
    public void maybeStopClat() {
        if (clatd == null) {
            return;
        }
        clatd.stop();
        clatd = null;
    }

","    public void updateClat(INetworkManagementService netd) {
        if (Nat464Xlat.requiresClat(this) &&
            ( this.networkCapabilities.hasCapability(NET_CAPABILITY_INTERNET) ||
              this.networkCapabilities.hasCapability(NET_CAPABILITY_MMS) )) {
            maybeStartClat();
        } else {
            maybeStopClat();
        }
    }

    /** Ensure clat has started for this network. */
    public void maybeStartClat() {
        if (clatd != null && clatd.isStarted()) {
            return;
        }
        clatd = new Nat464Xlat(this, mNetd, mNMS);
        clatd.start();
    }

    /** Ensure clat has stopped for this network. */
    public void maybeStopClat() {
        if (clatd == null) {
            return;
        }
        clatd.stop();
        clatd = null;
    }

","    public void updateClat(INetworkManagementService netd) {
        if (Nat464Xlat.requiresClat(this) &&
            ( this.networkCapabilities.hasCapability(NET_CAPABILITY_INTERNET) ||
              this.networkCapabilities.hasCapability(NET_CAPABILITY_MMS) )) {
            maybeStartClat();
        } else {
            maybeStopClat();
        }
    }

    /** Ensure clat has started for this network. */
    public void maybeStartClat() {
        if (clatd != null && clatd.isStarted()) {
            return;
        }
        clatd = new Nat464Xlat(this, mNetd, mNMS);
        clatd.start();
    }

    /** Ensure clat has stopped for this network. */
    public void maybeStopClat() {
        if (clatd == null) {
            return;
        }
        clatd.stop();
        clatd = null;
    }

","[1.0, 1.0]"
170,"['3a5272699e3e16fbfdc397480898bb27abeb2caa', '3a5272699e3e16fbfdc397480898bb27abeb2caa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1108, 1147, 40), (1108, 1147, 40)]","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

    private void setKeystorePassword(String password, int userHandle) {
","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

    private void setKeystorePassword(String password, int userHandle) {
","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

    private void setKeystorePassword(String password, int userHandle) {
","[1.0, 1.0]"
171,"['3a5272699e3e16fbfdc397480898bb27abeb2caa', '3a5272699e3e16fbfdc397480898bb27abeb2caa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1577, 1589, 13), (1577, 1589, 13)]","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(String credential) throws RemoteException {
","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(String credential) throws RemoteException {
","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(String credential) throws RemoteException {
","[1.0, 1.0]"
172,"['3a5272699e3e16fbfdc397480898bb27abeb2caa', '3a5272699e3e16fbfdc397480898bb27abeb2caa']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/Nat464Xlat.java,"[(28, 28, 1), (28, 28, 1)]","import android.os.SystemProperties;
","import android.os.SystemProperties;
","import android.os.SystemProperties;
","[1.0, 1.0]"
173,"['3a5272699e3e16fbfdc397480898bb27abeb2caa', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1577, 1589, 13), (1749, 1763, 15)]","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(String credential) throws RemoteException {
","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } catch (RemoteException e) {
            throw new IllegalStateException(""clearUserKeyAuth failed user="" + userId);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(byte[] credential) {
"," {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } ","[0.597, 0.534]"
174,"['4646ace2d5aecc79f895d6273c928602852d7f12', '4646ace2d5aecc79f895d6273c928602852d7f12']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java,"[(2604, 2605, 2), (2604, 2605, 2)]","                         ""ro.telephony.default_network"",
                         Integer.toString(RILConstants.NETWORK_MODE_WCDMA_PREF));
","                         ""ro.telephony.default_network"",
                         Integer.toString(RILConstants.NETWORK_MODE_WCDMA_PREF));
","                         ""ro.telephony.default_network"",
                         Integer.toString(RILConstants.NETWORK_MODE_WCDMA_PREF));
","[1.0, 1.0]"
175,"['4646ace2d5aecc79f895d6273c928602852d7f12', '4646ace2d5aecc79f895d6273c928602852d7f12']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java,"[(921, 924, 4), (921, 924, 4)]","    private void updateEmergencyButton() {
        if (mEmergencyButton != null) {
            mEmergencyButton.updateEmergencyCallButton();
        }
","    private void updateEmergencyButton() {
        if (mEmergencyButton != null) {
            mEmergencyButton.updateEmergencyCallButton();
        }
","    private void updateEmergencyButton() {
        if (mEmergencyButton != null) {
            mEmergencyButton.updateEmergencyCallButton();
        }
","[1.0, 1.0]"
180,"['4a30c150e58ec67edb92a7bec5ea48cebd6b90d4', '4a30c150e58ec67edb92a7bec5ea48cebd6b90d4']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(552, 557, 6), (552, 557, 6)]","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();

    final OomAdjuster mOomAdjuster;
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();

    final OomAdjuster mOomAdjuster;
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();

    final OomAdjuster mOomAdjuster;
","[1.0, 1.0]"
181,"['4a30c150e58ec67edb92a7bec5ea48cebd6b90d4', '4a30c150e58ec67edb92a7bec5ea48cebd6b90d4']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/StatusBarMobileView.java,"[(61, 61, 1), (61, 61, 1)]","    private ImageView mVolte;
","    private ImageView mVolte;
","    private ImageView mVolte;
","[1.0, 1.0]"
182,"['4a30c150e58ec67edb92a7bec5ea48cebd6b90d4', '4a30c150e58ec67edb92a7bec5ea48cebd6b90d4']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(190, 199, 10), (190, 199, 10)]","    private static final int LEGACY_CAPABLE_BSSID = 0;
    private static final int HT_CAPABLE_BSSID = 1;
    private static final int VHT_CAPABLE_BSSID = 2;
    private static final int HE_CAPABLE_BSSID = 3;
    private static final int MAX_CAPABLE_BSSID = Integer.MAX_VALUE;

    private static final int WIFI_GENERATION_LEGACY = 0;
    private static final int WIFI_GENERATION_4 = 4;
    private static final int WIFI_GENERATION_5 = 5;
    private static final int WIFI_GENERATION_6 = 6;
","    private static final int LEGACY_CAPABLE_BSSID = 0;
    private static final int HT_CAPABLE_BSSID = 1;
    private static final int VHT_CAPABLE_BSSID = 2;
    private static final int HE_CAPABLE_BSSID = 3;
    private static final int MAX_CAPABLE_BSSID = Integer.MAX_VALUE;

    private static final int WIFI_GENERATION_LEGACY = 0;
    private static final int WIFI_GENERATION_4 = 4;
    private static final int WIFI_GENERATION_5 = 5;
    private static final int WIFI_GENERATION_6 = 6;
","    private static final int LEGACY_CAPABLE_BSSID = 0;
    private static final int HT_CAPABLE_BSSID = 1;
    private static final int VHT_CAPABLE_BSSID = 2;
    private static final int HE_CAPABLE_BSSID = 3;
    private static final int MAX_CAPABLE_BSSID = Integer.MAX_VALUE;

    private static final int WIFI_GENERATION_LEGACY = 0;
    private static final int WIFI_GENERATION_4 = 4;
    private static final int WIFI_GENERATION_5 = 5;
    private static final int WIFI_GENERATION_6 = 6;
","[1.0, 1.0]"
183,"['4a30c150e58ec67edb92a7bec5ea48cebd6b90d4', '4a30c150e58ec67edb92a7bec5ea48cebd6b90d4']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(2663, 2664, 2), (2663, 2664, 2)]","            // during boot.
            clearUserKeyAuth(userId, null, auth.deriveDiskEncryptionKey());
","            // during boot.
            clearUserKeyAuth(userId, null, auth.deriveDiskEncryptionKey());
","            // during boot.
            clearUserKeyAuth(userId, null, auth.deriveDiskEncryptionKey());
","[1.0, 1.0]"
184,"['4a30c150e58ec67edb92a7bec5ea48cebd6b90d4', '4a30c150e58ec67edb92a7bec5ea48cebd6b90d4']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,"[(120, 121, 2), (120, 121, 2)]","
        updateResources();
","
        updateResources();
","
        updateResources();
","[1.0, 1.0]"
185,"['4a30c150e58ec67edb92a7bec5ea48cebd6b90d4', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(552, 557, 6), (578, 582, 5)]","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();

    final OomAdjuster mOomAdjuster;
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
    public static boolean mForceStopKill = false;
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
","[0.839, 0.794]"
186,"['4a30c150e58ec67edb92a7bec5ea48cebd6b90d4', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(190, 199, 10), (225, 242, 18)]","    private static final int LEGACY_CAPABLE_BSSID = 0;
    private static final int HT_CAPABLE_BSSID = 1;
    private static final int VHT_CAPABLE_BSSID = 2;
    private static final int HE_CAPABLE_BSSID = 3;
    private static final int MAX_CAPABLE_BSSID = Integer.MAX_VALUE;

    private static final int WIFI_GENERATION_LEGACY = 0;
    private static final int WIFI_GENERATION_4 = 4;
    private static final int WIFI_GENERATION_5 = 5;
    private static final int WIFI_GENERATION_6 = 6;
","    private static final int LEGACY_CAPABLE_BSSID = 0;
    private static final int HT_CAPABLE_BSSID = 1;
    private static final int VHT_CAPABLE_BSSID = 2;
    private static final int HE_CAPABLE_BSSID = 3;
    private static final int MAX_CAPABLE_BSSID = Integer.MAX_VALUE;

    private static final int WIFI_GENERATION_LEGACY = 0;
    private static final int WIFI_GENERATION_4 = 4;
    private static final int WIFI_GENERATION_5 = 5;
    private static final int WIFI_GENERATION_6 = 6;

    /**
     * The number of distinct wifi levels.
     *
     * <p>Must keep in sync with {@link R.array.wifi_signal} and {@link WifiManager#RSSI_LEVELS}.
     */
    public static final int SIGNAL_LEVELS = 5;

","    private static final int LEGACY_CAPABLE_BSSID = 0;
    private static final int HT_CAPABLE_BSSID = 1;
    private static final int VHT_CAPABLE_BSSID = 2;
    private static final int HE_CAPABLE_BSSID = 3;
    private static final int MAX_CAPABLE_BSSID = Integer.MAX_VALUE;

    private static final int WIFI_GENERATION_LEGACY = 0;
    private static final int WIFI_GENERATION_4 = 4;
    private static final int WIFI_GENERATION_5 = 5;
    private static final int WIFI_GENERATION_6 = 6;
","[1.0, 0.697]"
187,"['4a30c150e58ec67edb92a7bec5ea48cebd6b90d4', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(2663, 2664, 2), (2806, 2806, 1)]","            // during boot.
            clearUserKeyAuth(userId, null, auth.deriveDiskEncryptionKey());
","            clearUserKeyAuth(userId, null, auth.deriveDiskEncryptionKey());
","            clearUserKeyAuth(userId, null, auth.deriveDiskEncryptionKey());
","[0.731, 1.0]"
188,"['4a30c150e58ec67edb92a7bec5ea48cebd6b90d4', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,"[(120, 121, 2), (137, 138, 2)]","
        updateResources();
","
        updateResources();
","
        updateResources();
","[1.0, 1.0]"
189,"['4a30c150e58ec67edb92a7bec5ea48cebd6b90d4', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(552, 557, 6), (545, 548, 4)]","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();

    final OomAdjuster mOomAdjuster;
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
","[0.839, 1.0]"
201,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(184, 185, 2), (199, 200, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
202,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(144, 144, 1), (144, 144, 1)]","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","[1.0, 1.0]"
203,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(334, 335, 2), (334, 335, 2)]","                case MSG_LOCALE_CHANGED:
                    handleLocaleChanged();
","                case MSG_LOCALE_CHANGED:
                    handleLocaleChanged();
","                case MSG_LOCALE_CHANGED:
                    handleLocaleChanged();
","[1.0, 1.0]"
204,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(802, 803, 2), (802, 803, 2)]","            } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);
","            } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);
","            } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);
","[1.0, 1.0]"
205,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Connection.java,"[(331, 337, 7), (331, 337, 7)]","    /**
     * Add participant in an active or conference call option
     *
     * @hide
     */
    public static final int CAPABILITY_ADD_PARTICIPANT = 0x02000000;

","    /**
     * Add participant in an active or conference call option
     *
     * @hide
     */
    public static final int CAPABILITY_ADD_PARTICIPANT = 0x02000000;

","    /**
     * Add participant in an active or conference call option
     *
     * @hide
     */
    public static final int CAPABILITY_ADD_PARTICIPANT = 0x02000000;

","[1.0, 1.0]"
206,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(184, 185, 2), (184, 185, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
207,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Call.java,"[(355, 359, 5), (355, 359, 5)]","        /**
         * Add participant in an active or conference call option
         * @hide
         */
        public static final int CAPABILITY_ADD_PARTICIPANT = 0x01000000;
","        /**
         * Add participant in an active or conference call option
         * @hide
         */
        public static final int CAPABILITY_ADD_PARTICIPANT = 0x01000000;
","        /**
         * Add participant in an active or conference call option
         * @hide
         */
        public static final int CAPABILITY_ADD_PARTICIPANT = 0x01000000;
","[1.0, 1.0]"
208,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Call.java,"[(537, 538, 2), (537, 538, 2)]","            if (can(capabilities, CAPABILITY_ADD_PARTICIPANT)) {
                builder.append("" CAPABILITY_ADD_PARTICIPANT"");
","            if (can(capabilities, CAPABILITY_ADD_PARTICIPANT)) {
                builder.append("" CAPABILITY_ADD_PARTICIPANT"");
","            if (can(capabilities, CAPABILITY_ADD_PARTICIPANT)) {
                builder.append("" CAPABILITY_ADD_PARTICIPANT"");
","[1.0, 1.0]"
209,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(144, 144, 1), (156, 156, 1)]","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","[1.0, 1.0]"
210,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(144, 144, 1), (151, 151, 1)]","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","[1.0, 1.0]"
211,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(184, 185, 2), (198, 199, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
212,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(184, 185, 2), (191, 192, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
213,"['4f3815fffae8119b8607fe1e7ec8f00b095962ea', '4f3815fffae8119b8607fe1e7ec8f00b095962ea']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(395, 396, 2), (395, 396, 2)]","import android.util.BoostFramework;

","import android.util.BoostFramework;

","import android.util.BoostFramework;

","[1.0, 1.0]"
220,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3433, 3441, 9), (3265, 3274, 10)]","            Log.i(TAG, ""In setBluetoothScoOn(), on: ""+on+"". The calling application Uid: ""
                  + Binder.getCallingUid() + "", is greater than FIRST_APPLICATION_UID""
                  + "" exiting from setBluetoothScoOn()"");
            if (on)
                mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
            else if (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO)
                mForcedUseForCommExt = AudioSystem.FORCE_NONE;
            Log.i(TAG, ""In setbluetoothScoOn(), mForcedUseForCommExt: ""
                        + mForcedUseForCommExt);
","        if (Binder.getCallingUid() >= FIRST_APPLICATION_UID) {
            Log.i(TAG, ""In setBluetoothScoOn(), on: ""+on+"". The calling application Uid: ""
                  + Binder.getCallingUid() + "", is greater than FIRST_APPLICATION_UID""
                  + "" exiting from setBluetoothScoOn()"");
            if (on)
                mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
            else if (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO)
                mForcedUseForCommExt = AudioSystem.FORCE_NONE;
            Log.i(TAG, ""In setbluetoothScoOn(), mForcedUseForCommExt: ""
                        + mForcedUseForCommExt);
","            Log.i(TAG, ""In setBluetoothScoOn(), on: ""+on+"". The calling application Uid: ""
                  + Binder.getCallingUid() + "", is greater than FIRST_APPLICATION_UID""
                  + "" exiting from setBluetoothScoOn()"");
            if (on)
                mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
            else if (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO)
                mForcedUseForCommExt = AudioSystem.FORCE_NONE;
            Log.i(TAG, ""In setbluetoothScoOn(), mForcedUseForCommExt: ""
                        + mForcedUseForCommExt);
","[1.0, 0.901]"
221,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerConstants.java,"[(25, 26, 2), (28, 29, 2)]","import android.os.SystemProperties;
import android.os.Process;
","import android.os.SystemProperties;
import android.os.Process;
","import android.os.SystemProperties;
import android.os.Process;
","[1.0, 1.0]"
222,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(96, 96, 1), (96, 96, 1)]","import android.net.StringNetworkSpecifier;
","import android.net.StringNetworkSpecifier;
","import android.net.StringNetworkSpecifier;
","[1.0, 1.0]"
223,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(3457, 3458, 2), (3457, 3458, 2)]","                case EVENT_UPDATE_TCP_BUFFER_FOR_5G:
                    handleUpdateTCPBuffersfor5G();
","                case EVENT_UPDATE_TCP_BUFFER_FOR_5G:
                    handleUpdateTCPBuffersfor5G();
","                case EVENT_UPDATE_TCP_BUFFER_FOR_5G:
                    handleUpdateTCPBuffersfor5G();
","[1.0, 1.0]"
224,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(6445, 6514, 70), (6445, 6514, 70)]","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId())) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId())) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId())) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","[1.0, 1.0]"
225,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(991, 1008, 18), (991, 1008, 18)]","        mScoConnectionState = AudioManager.SCO_AUDIO_STATE_ERROR;
        Log.i(TAG, ""In onSystemReady(), calling resetBluetoothSco()"");
        resetBluetoothSco();
        getBluetoothHeadset();
        //FIXME: this is to maintain compatibility with deprecated intent
        // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
        Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
        newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,
                AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
        sendStickyBroadcastToAll(newIntent);

        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if (adapter != null) {
            adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
                                    BluetoothProfile.A2DP);
            adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
                                    BluetoothProfile.HEARING_AID);
        }
","        mScoConnectionState = AudioManager.SCO_AUDIO_STATE_ERROR;
        Log.i(TAG, ""In onSystemReady(), calling resetBluetoothSco()"");
        resetBluetoothSco();
        getBluetoothHeadset();
        //FIXME: this is to maintain compatibility with deprecated intent
        // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
        Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
        newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,
                AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
        sendStickyBroadcastToAll(newIntent);

        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if (adapter != null) {
            adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
                                    BluetoothProfile.A2DP);
            adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
                                    BluetoothProfile.HEARING_AID);
        }
","        mScoConnectionState = AudioManager.SCO_AUDIO_STATE_ERROR;
        Log.i(TAG, ""In onSystemReady(), calling resetBluetoothSco()"");
        resetBluetoothSco();
        getBluetoothHeadset();
        //FIXME: this is to maintain compatibility with deprecated intent
        // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
        Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
        newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,
                AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
        sendStickyBroadcastToAll(newIntent);

        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if (adapter != null) {
            adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
                                    BluetoothProfile.A2DP);
            adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
                                    BluetoothProfile.HEARING_AID);
        }
","[1.0, 1.0]"
226,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(1630, 1630, 1), (1630, 1630, 1)]","        mVolumeLogger.log(new VolumeEvent(VolumeEvent.VOL_ADJUST_SUGG_VOL, suggestedStreamType,
","        mVolumeLogger.log(new VolumeEvent(VolumeEvent.VOL_ADJUST_SUGG_VOL, suggestedStreamType,
","        mVolumeLogger.log(new VolumeEvent(VolumeEvent.VOL_ADJUST_SUGG_VOL, suggestedStreamType,
","[1.0, 1.0]"
227,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(2964, 2967, 4), (2964, 2967, 4)]","                final long ident = Binder.clearCallingIdentity();
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                disconnectBluetoothSco(newModeOwnerPid);
                Binder.restoreCallingIdentity(ident);
","                final long ident = Binder.clearCallingIdentity();
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                disconnectBluetoothSco(newModeOwnerPid);
                Binder.restoreCallingIdentity(ident);
","                final long ident = Binder.clearCallingIdentity();
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                disconnectBluetoothSco(newModeOwnerPid);
                Binder.restoreCallingIdentity(ident);
","[1.0, 1.0]"
228,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3024, 3025, 2), (3024, 3025, 2)]","            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
            disconnectBluetoothSco(newModeOwnerPid);
","            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
            disconnectBluetoothSco(newModeOwnerPid);
","            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
            disconnectBluetoothSco(newModeOwnerPid);
","[1.0, 1.0]"
229,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3399, 3416, 18), (3399, 3416, 18)]","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        if (on) {
            if (mForcedUseForComm == AudioSystem.FORCE_BT_SCO) {
                    sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                            AudioSystem.FOR_RECORD, AudioSystem.FORCE_NONE,
                            eventSource, 0);
            }
            mForcedUseForComm = AudioSystem.FORCE_SPEAKER;
        } else if (mForcedUseForComm == AudioSystem.FORCE_SPEAKER){
            mForcedUseForComm = AudioSystem.FORCE_NONE;
        }

        mForcedUseForCommExt = mForcedUseForComm;
        Log.i(TAG, ""In setSpeakerphoneOn(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, eventSource, 0);
","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        if (on) {
            if (mForcedUseForComm == AudioSystem.FORCE_BT_SCO) {
                    sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                            AudioSystem.FOR_RECORD, AudioSystem.FORCE_NONE,
                            eventSource, 0);
            }
            mForcedUseForComm = AudioSystem.FORCE_SPEAKER;
        } else if (mForcedUseForComm == AudioSystem.FORCE_SPEAKER){
            mForcedUseForComm = AudioSystem.FORCE_NONE;
        }

        mForcedUseForCommExt = mForcedUseForComm;
        Log.i(TAG, ""In setSpeakerphoneOn(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, eventSource, 0);
","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        if (on) {
            if (mForcedUseForComm == AudioSystem.FORCE_BT_SCO) {
                    sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                            AudioSystem.FOR_RECORD, AudioSystem.FORCE_NONE,
                            eventSource, 0);
            }
            mForcedUseForComm = AudioSystem.FORCE_SPEAKER;
        } else if (mForcedUseForComm == AudioSystem.FORCE_SPEAKER){
            mForcedUseForComm = AudioSystem.FORCE_NONE;
        }

        mForcedUseForCommExt = mForcedUseForComm;
        Log.i(TAG, ""In setSpeakerphoneOn(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, eventSource, 0);
","[1.0, 1.0]"
230,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3421, 3423, 3), (3421, 3423, 3)]","        Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        return (mForcedUseForCommExt == AudioSystem.FORCE_SPEAKER);
","        Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        return (mForcedUseForCommExt == AudioSystem.FORCE_SPEAKER);
","        Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        return (mForcedUseForCommExt == AudioSystem.FORCE_SPEAKER);
","[1.0, 1.0]"
231,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3421, 3423, 3), (3513, 3515, 3)]","        Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        return (mForcedUseForCommExt == AudioSystem.FORCE_SPEAKER);
","        Log.i(TAG, ""In isBluetoothScoOn(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        return (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO);
","On(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        return (mForcedUseForCommExt == AudioSystem.FORCE_","[0.739, 0.743]"
232,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3433, 3441, 9), (3433, 3441, 9)]","            Log.i(TAG, ""In setBluetoothScoOn(), on: ""+on+"". The calling application Uid: ""
                  + Binder.getCallingUid() + "", is greater than FIRST_APPLICATION_UID""
                  + "" exiting from setBluetoothScoOn()"");
            if (on)
                mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
            else if (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO)
                mForcedUseForCommExt = AudioSystem.FORCE_NONE;
            Log.i(TAG, ""In setbluetoothScoOn(), mForcedUseForCommExt: ""
                        + mForcedUseForCommExt);
","            Log.i(TAG, ""In setBluetoothScoOn(), on: ""+on+"". The calling application Uid: ""
                  + Binder.getCallingUid() + "", is greater than FIRST_APPLICATION_UID""
                  + "" exiting from setBluetoothScoOn()"");
            if (on)
                mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
            else if (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO)
                mForcedUseForCommExt = AudioSystem.FORCE_NONE;
            Log.i(TAG, ""In setbluetoothScoOn(), mForcedUseForCommExt: ""
                        + mForcedUseForCommExt);
","            Log.i(TAG, ""In setBluetoothScoOn(), on: ""+on+"". The calling application Uid: ""
                  + Binder.getCallingUid() + "", is greater than FIRST_APPLICATION_UID""
                  + "" exiting from setBluetoothScoOn()"");
            if (on)
                mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
            else if (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO)
                mForcedUseForCommExt = AudioSystem.FORCE_NONE;
            Log.i(TAG, ""In setbluetoothScoOn(), mForcedUseForCommExt: ""
                        + mForcedUseForCommExt);
","[1.0, 1.0]"
233,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3449, 3508, 60), (3449, 3508, 60)]","        Log.i(TAG, ""In setBluetoothScoOn(), eventSource: "" + eventSource);
        setBluetoothScoOnInt(on, eventSource);
    }

    private boolean isBluetoothAudioNotConnectedToEarbud() {
       //default value as true so that
       //non-twsplus device case returns true
       boolean ret = true;
       if (mBluetoothHeadsetDevice != null
              && mBluetoothHeadsetDevice.isTwsPlusDevice()) {
           //If It is TWSplus Device, check for TWS pair device
           //Sco state
           String pDevAddr = mBluetoothHeadsetDevice.getTwsPlusPeerAddress();
           if (pDevAddr != null) {
               BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
               BluetoothDevice peerDev = adapter.getRemoteDevice(pDevAddr);
               Log.d(TAG, ""peer device audio State: "" + mBluetoothHeadset.getAudioState(peerDev));
               if (mBluetoothHeadset.getAudioState(peerDev)
                     == BluetoothHeadset.STATE_AUDIO_CONNECTED ||
                     mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice)
                       == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                           Log.w(TAG, ""TwsPLus Case: one of eb SCO is connected"");
                   ret = false;
               }
           }
       }
       Log.d(TAG, ""isBluetoothAudioConnectedToEarbud returns: "" + ret);
       return ret;
    }

    public void setBluetoothScoOnInt(boolean on, String eventSource) {
        Log.i(TAG, ""setBluetoothScoOnInt: "" + on + "" "" + eventSource);
        if (on) {
            // do not accept SCO ON if SCO audio is not connected
            synchronized (mScoClients) {
                if ((mBluetoothHeadset != null)
                        && (mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice)
                            != BluetoothHeadset.STATE_AUDIO_CONNECTED)) {
                    if (isBluetoothAudioNotConnectedToEarbud()) {
                        mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
                        Log.w(TAG, ""setBluetoothScoOnInt(true) failed because ""
                                + mBluetoothHeadsetDevice + "" is not in audio connected mode"");
                        return;
                    }
                }
            }
            mForcedUseForComm = AudioSystem.FORCE_BT_SCO;
        } else if (mForcedUseForComm == AudioSystem.FORCE_BT_SCO) {
            mForcedUseForComm = AudioSystem.FORCE_NONE;
        }
        mForcedUseForCommExt = mForcedUseForComm;
        Log.i(TAG, ""In setbluetoothScoOnInt(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        AudioSystem.setParameters(""BT_SCO=""+ (on ? ""on"" : ""off""));
        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, eventSource, 0);
        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                AudioSystem.FOR_RECORD, mForcedUseForComm, eventSource, 0);
        // Un-mute ringtone stream volume
        setRingerModeInt(getRingerModeInternal(), false);
","        Log.i(TAG, ""In setBluetoothScoOn(), eventSource: "" + eventSource);
        setBluetoothScoOnInt(on, eventSource);
    }

    private boolean isBluetoothAudioNotConnectedToEarbud() {
       //default value as true so that
       //non-twsplus device case returns true
       boolean ret = true;
       if (mBluetoothHeadsetDevice != null
              && mBluetoothHeadsetDevice.isTwsPlusDevice()) {
           //If It is TWSplus Device, check for TWS pair device
           //Sco state
           String pDevAddr = mBluetoothHeadsetDevice.getTwsPlusPeerAddress();
           if (pDevAddr != null) {
               BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
               BluetoothDevice peerDev = adapter.getRemoteDevice(pDevAddr);
               Log.d(TAG, ""peer device audio State: "" + mBluetoothHeadset.getAudioState(peerDev));
               if (mBluetoothHeadset.getAudioState(peerDev)
                     == BluetoothHeadset.STATE_AUDIO_CONNECTED ||
                     mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice)
                       == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                           Log.w(TAG, ""TwsPLus Case: one of eb SCO is connected"");
                   ret = false;
               }
           }
       }
       Log.d(TAG, ""isBluetoothAudioConnectedToEarbud returns: "" + ret);
       return ret;
    }

    public void setBluetoothScoOnInt(boolean on, String eventSource) {
        Log.i(TAG, ""setBluetoothScoOnInt: "" + on + "" "" + eventSource);
        if (on) {
            // do not accept SCO ON if SCO audio is not connected
            synchronized (mScoClients) {
                if ((mBluetoothHeadset != null)
                        && (mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice)
                            != BluetoothHeadset.STATE_AUDIO_CONNECTED)) {
                    if (isBluetoothAudioNotConnectedToEarbud()) {
                        mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
                        Log.w(TAG, ""setBluetoothScoOnInt(true) failed because ""
                                + mBluetoothHeadsetDevice + "" is not in audio connected mode"");
                        return;
                    }
                }
            }
            mForcedUseForComm = AudioSystem.FORCE_BT_SCO;
        } else if (mForcedUseForComm == AudioSystem.FORCE_BT_SCO) {
            mForcedUseForComm = AudioSystem.FORCE_NONE;
        }
        mForcedUseForCommExt = mForcedUseForComm;
        Log.i(TAG, ""In setbluetoothScoOnInt(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        AudioSystem.setParameters(""BT_SCO=""+ (on ? ""on"" : ""off""));
        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, eventSource, 0);
        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                AudioSystem.FOR_RECORD, mForcedUseForComm, eventSource, 0);
        // Un-mute ringtone stream volume
        setRingerModeInt(getRingerModeInternal(), false);
","        Log.i(TAG, ""In setBluetoothScoOn(), eventSource: "" + eventSource);
        setBluetoothScoOnInt(on, eventSource);
    }

    private boolean isBluetoothAudioNotConnectedToEarbud() {
       //default value as true so that
       //non-twsplus device case returns true
       boolean ret = true;
       if (mBluetoothHeadsetDevice != null
              && mBluetoothHeadsetDevice.isTwsPlusDevice()) {
           //If It is TWSplus Device, check for TWS pair device
           //Sco state
           String pDevAddr = mBluetoothHeadsetDevice.getTwsPlusPeerAddress();
           if (pDevAddr != null) {
               BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
               BluetoothDevice peerDev = adapter.getRemoteDevice(pDevAddr);
               Log.d(TAG, ""peer device audio State: "" + mBluetoothHeadset.getAudioState(peerDev));
               if (mBluetoothHeadset.getAudioState(peerDev)
                     == BluetoothHeadset.STATE_AUDIO_CONNECTED ||
                     mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice)
                       == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                           Log.w(TAG, ""TwsPLus Case: one of eb SCO is connected"");
                   ret = false;
               }
           }
       }
       Log.d(TAG, ""isBluetoothAudioConnectedToEarbud returns: "" + ret);
       return ret;
    }

    public void setBluetoothScoOnInt(boolean on, String eventSource) {
        Log.i(TAG, ""setBluetoothScoOnInt: "" + on + "" "" + eventSource);
        if (on) {
            // do not accept SCO ON if SCO audio is not connected
            synchronized (mScoClients) {
                if ((mBluetoothHeadset != null)
                        && (mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice)
                            != BluetoothHeadset.STATE_AUDIO_CONNECTED)) {
                    if (isBluetoothAudioNotConnectedToEarbud()) {
                        mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
                        Log.w(TAG, ""setBluetoothScoOnInt(true) failed because ""
                                + mBluetoothHeadsetDevice + "" is not in audio connected mode"");
                        return;
                    }
                }
            }
            mForcedUseForComm = AudioSystem.FORCE_BT_SCO;
        } else if (mForcedUseForComm == AudioSystem.FORCE_BT_SCO) {
            mForcedUseForComm = AudioSystem.FORCE_NONE;
        }
        mForcedUseForCommExt = mForcedUseForComm;
        Log.i(TAG, ""In setbluetoothScoOnInt(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        AudioSystem.setParameters(""BT_SCO=""+ (on ? ""on"" : ""off""));
        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, eventSource, 0);
        sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                AudioSystem.FOR_RECORD, mForcedUseForComm, eventSource, 0);
        // Un-mute ringtone stream volume
        setRingerModeInt(getRingerModeInternal(), false);
","[1.0, 1.0]"
234,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3513, 3515, 3), (3513, 3515, 3)]","        Log.i(TAG, ""In isBluetoothScoOn(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        return (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO);
","        Log.i(TAG, ""In isBluetoothScoOn(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        return (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO);
","        Log.i(TAG, ""In isBluetoothScoOn(), mForcedUseForCommExt: ""
                    + mForcedUseForCommExt);
        return (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO);
","[1.0, 1.0]"
235,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3546, 3547, 2), (3546, 3547, 2)]","        Log.i(TAG, ""In startBluetoothSco()"");
        int scoAudioMode =
","        Log.i(TAG, ""In startBluetoothSco()"");
        int scoAudioMode =
","        Log.i(TAG, ""In startBluetoothSco()"");
        int scoAudioMode =
","[1.0, 1.0]"
236,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3555, 3560, 6), (3555, 3560, 6)]","        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
        startBluetoothScoInt(cb, SCO_MODE_VIRTUAL_CALL);
    }

    void startBluetoothScoInt(IBinder cb, int scoAudioMode){
        Log.i(TAG, ""In startBluetoothScoInt(), scoAudioMode: "" + scoAudioMode);
","        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
        startBluetoothScoInt(cb, SCO_MODE_VIRTUAL_CALL);
    }

    void startBluetoothScoInt(IBinder cb, int scoAudioMode){
        Log.i(TAG, ""In startBluetoothScoInt(), scoAudioMode: "" + scoAudioMode);
","        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
        startBluetoothScoInt(cb, SCO_MODE_VIRTUAL_CALL);
    }

    void startBluetoothScoInt(IBinder cb, int scoAudioMode){
        Log.i(TAG, ""In startBluetoothScoInt(), scoAudioMode: "" + scoAudioMode);
","[1.0, 1.0]"
237,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3619, 3663, 45), (3619, 3663, 45)]","        public void incCount(int scoAudioMode) {
            synchronized(mScoClients) {
                Log.i(TAG, ""In incCount(), mStartcount = "" + mStartcount);
                boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_CONNECTED,
                                                    scoAudioMode);
                if (!ScoState) {
                    Log.e(TAG, ""In incCount(), requestScoState failed returning"");
                    return;
                }
                if (mStartcount == 0) {
                    try {
                        mCb.linkToDeath(this, 0);
                    } catch (RemoteException e) {
                        // client has already died!
                        Log.w(TAG, ""ScoClient incCount() could not link to ""+mCb+"" binder death"");
                    }
                }
                //mStartCount should always be either 0 or 1 only if the startBluetoothSco
                //is called by the same app multiple times by mistake. This will ensure that
                //SCO gets disconnected when app calls stopBluetoothSco only once.
                //Also, if SCO is already there, we just need to select the SCO devices by
                //calling setBluetoothScoOn(true) in system context.
                if (mStartcount == 1) {
                    Log.i(TAG, ""mStartcount is 1, calling setBluetoothScoOn(true)""
                                + ""in system context"");
                    setBluetoothScoOn(true);
                } else if (mStartcount == 0) {
                    mStartcount++;
                    Log.i(TAG, ""mStartcount is 0, incrementing by 1"");
                }
            }
        }

        public void decCount() {
            synchronized(mScoClients) {
                Log.i(TAG, ""In decCount(), mStartcount: "" + mStartcount);
                if (mStartcount == 0) {
                    Log.w(TAG, ""ScoClient.decCount() already 0"");
                } else {
                    mStartcount--;
                    if (mStartcount == 0) {
                        try {
                            mCb.unlinkToDeath(this, 0);
                        } catch (NoSuchElementException e) {
                            Log.w(TAG, ""decCount() going to 0 but not registered to binder"");
","        public void incCount(int scoAudioMode) {
            synchronized(mScoClients) {
                Log.i(TAG, ""In incCount(), mStartcount = "" + mStartcount);
                boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_CONNECTED,
                                                    scoAudioMode);
                if (!ScoState) {
                    Log.e(TAG, ""In incCount(), requestScoState failed returning"");
                    return;
                }
                if (mStartcount == 0) {
                    try {
                        mCb.linkToDeath(this, 0);
                    } catch (RemoteException e) {
                        // client has already died!
                        Log.w(TAG, ""ScoClient incCount() could not link to ""+mCb+"" binder death"");
                    }
                }
                //mStartCount should always be either 0 or 1 only if the startBluetoothSco
                //is called by the same app multiple times by mistake. This will ensure that
                //SCO gets disconnected when app calls stopBluetoothSco only once.
                //Also, if SCO is already there, we just need to select the SCO devices by
                //calling setBluetoothScoOn(true) in system context.
                if (mStartcount == 1) {
                    Log.i(TAG, ""mStartcount is 1, calling setBluetoothScoOn(true)""
                                + ""in system context"");
                    setBluetoothScoOn(true);
                } else if (mStartcount == 0) {
                    mStartcount++;
                    Log.i(TAG, ""mStartcount is 0, incrementing by 1"");
                }
            }
        }

        public void decCount() {
            synchronized(mScoClients) {
                Log.i(TAG, ""In decCount(), mStartcount: "" + mStartcount);
                if (mStartcount == 0) {
                    Log.w(TAG, ""ScoClient.decCount() already 0"");
                } else {
                    mStartcount--;
                    if (mStartcount == 0) {
                        try {
                            mCb.unlinkToDeath(this, 0);
                        } catch (NoSuchElementException e) {
                            Log.w(TAG, ""decCount() going to 0 but not registered to binder"");
","        public void incCount(int scoAudioMode) {
            synchronized(mScoClients) {
                Log.i(TAG, ""In incCount(), mStartcount = "" + mStartcount);
                boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_CONNECTED,
                                                    scoAudioMode);
                if (!ScoState) {
                    Log.e(TAG, ""In incCount(), requestScoState failed returning"");
                    return;
                }
                if (mStartcount == 0) {
                    try {
                        mCb.linkToDeath(this, 0);
                    } catch (RemoteException e) {
                        // client has already died!
                        Log.w(TAG, ""ScoClient incCount() could not link to ""+mCb+"" binder death"");
                    }
                }
                //mStartCount should always be either 0 or 1 only if the startBluetoothSco
                //is called by the same app multiple times by mistake. This will ensure that
                //SCO gets disconnected when app calls stopBluetoothSco only once.
                //Also, if SCO is already there, we just need to select the SCO devices by
                //calling setBluetoothScoOn(true) in system context.
                if (mStartcount == 1) {
                    Log.i(TAG, ""mStartcount is 1, calling setBluetoothScoOn(true)""
                                + ""in system context"");
                    setBluetoothScoOn(true);
                } else if (mStartcount == 0) {
                    mStartcount++;
                    Log.i(TAG, ""mStartcount is 0, incrementing by 1"");
                }
            }
        }

        public void decCount() {
            synchronized(mScoClients) {
                Log.i(TAG, ""In decCount(), mStartcount: "" + mStartcount);
                if (mStartcount == 0) {
                    Log.w(TAG, ""ScoClient.decCount() already 0"");
                } else {
                    mStartcount--;
                    if (mStartcount == 0) {
                        try {
                            mCb.unlinkToDeath(this, 0);
                        } catch (NoSuchElementException e) {
                            Log.w(TAG, ""decCount() going to 0 but not registered to binder"");
","[1.0, 1.0]"
238,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3666, 3686, 21), (3666, 3686, 21)]","                    boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED,
                                                        0);
                }
            }
        }

        public void clearCount(boolean stopSco) {
            synchronized(mScoClients) {
                Log.i(TAG, ""In clearCount(), stopSco: "" + stopSco +
                            "", mStartcount: "" + mStartcount);
                if (mStartcount != 0) {
                    try {
                        mCb.unlinkToDeath(this, 0);
                    } catch (NoSuchElementException e) {
                        Log.w(TAG, ""clearCount() mStartcount: ""+mStartcount+"" != 0 but not registered to binder"");
                    }
                }
                mStartcount = 0;
                if (stopSco) {
                    boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED,
                                                        0);
","                    boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED,
                                                        0);
                }
            }
        }

        public void clearCount(boolean stopSco) {
            synchronized(mScoClients) {
                Log.i(TAG, ""In clearCount(), stopSco: "" + stopSco +
                            "", mStartcount: "" + mStartcount);
                if (mStartcount != 0) {
                    try {
                        mCb.unlinkToDeath(this, 0);
                    } catch (NoSuchElementException e) {
                        Log.w(TAG, ""clearCount() mStartcount: ""+mStartcount+"" != 0 but not registered to binder"");
                    }
                }
                mStartcount = 0;
                if (stopSco) {
                    boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED,
                                                        0);
","                    boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED,
                                                        0);
                }
            }
        }

        public void clearCount(boolean stopSco) {
            synchronized(mScoClients) {
                Log.i(TAG, ""In clearCount(), stopSco: "" + stopSco +
                            "", mStartcount: "" + mStartcount);
                if (mStartcount != 0) {
                    try {
                        mCb.unlinkToDeath(this, 0);
                    } catch (NoSuchElementException e) {
                        Log.w(TAG, ""clearCount() mStartcount: ""+mStartcount+"" != 0 but not registered to binder"");
                    }
                }
                mStartcount = 0;
                if (stopSco) {
                    boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED,
                                                        0);
","[1.0, 1.0]"
239,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3703, 3839, 137), (3703, 3839, 137)]","        public int totalCount() {
            synchronized(mScoClients) {
                int count = 0;
                for (ScoClient mScoClient : mScoClients) {
                    count += mScoClient.getCount();
                }
                Log.i(TAG, ""In totalCount(), count: "" + count);
                return count;
            }
        }

        private boolean requestScoState(int state, int scoAudioMode) {
            Log.i(TAG, ""In requestScoState(), state: "" + state + "", scoAudioMode: ""
                         + scoAudioMode);
            checkScoAudioState();
            int clientCount = totalCount();
            if (clientCount != 0) {
                Log.w(TAG, ""requestScoState: returning with state="" + state + "", scoAudioMode="" +
                             scoAudioMode + "", clientCount="" + clientCount);
                return false;
            }
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                // Make sure that the state transitions to CONNECTING even if we cannot initiate
                // the connection.
                broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_CONNECTING);
                // Accept SCO audio activation only in NORMAL audio mode or if the mode is
                // currently controlled by the same client process.
                synchronized(mSetModeDeathHandlers) {
                    int modeOwnerPid =  mSetModeDeathHandlers.isEmpty()
                            ? 0 : mSetModeDeathHandlers.get(0).getPid();
                    if (modeOwnerPid != 0 && (modeOwnerPid != mCreatorPid)) {
                        Log.w(TAG, ""requestScoState: audio mode is not NORMAL and modeOwnerPid ""
                                + modeOwnerPid + "" != creatorPid "" + mCreatorPid);
                        broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        return false;
                    }
                    switch (mScoAudioState) {
                        case SCO_STATE_INACTIVE:
                            mScoAudioMode = scoAudioMode;
                            if (scoAudioMode == SCO_MODE_UNDEFINED) {
                                mScoAudioMode = SCO_MODE_VIRTUAL_CALL;
                                if (mBluetoothHeadsetDevice != null) {
                                    mScoAudioMode = Settings.Global.getInt(mContentResolver,
                                            ""bluetooth_sco_channel_""
                                                    + mBluetoothHeadsetDevice.getAddress(),
                                            SCO_MODE_VIRTUAL_CALL);
                                    if (mScoAudioMode > SCO_MODE_MAX || mScoAudioMode < 0) {
                                        mScoAudioMode = SCO_MODE_VIRTUAL_CALL;
                                    }
                                }
                            }
                            if (mBluetoothHeadset == null) {
                                if (getBluetoothHeadset()) {
                                    mScoAudioState = SCO_STATE_ACTIVATE_REQ;
                                } else {
                                    Log.w(TAG, ""requestScoState: getBluetoothHeadset failed during""
                                            + "" connection, mScoAudioMode="" + mScoAudioMode);
                                    broadcastScoConnectionState(
                                            AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                    return false;
                                }
                                break;
                            }
                            if (mBluetoothHeadsetDevice == null) {
                                Log.w(TAG, ""requestScoState: no active device while connecting,""
                                        + "" mScoAudioMode="" + mScoAudioMode);
                                broadcastScoConnectionState(
                                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                return false;
                            }
                            if (connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                    mBluetoothHeadsetDevice, mScoAudioMode)) {
                                mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                            } else {
                                Log.w(TAG, ""requestScoState: connect to "" + mBluetoothHeadsetDevice
                                        + "" failed, mScoAudioMode="" + mScoAudioMode);
                                broadcastScoConnectionState(
                                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                return false;
                            }
                            break;
                        case SCO_STATE_DEACTIVATING:
                            mScoAudioState = SCO_STATE_ACTIVATE_REQ;
                            break;
                        case SCO_STATE_DEACTIVATE_REQ:
                            mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_CONNECTED);
                            break;
                        default:
                            Log.w(TAG, ""requestScoState: failed to connect in state ""
                                    + mScoAudioState + "", scoAudioMode="" + scoAudioMode);
                            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                            return false;

                    }
                }
            } else if (state == BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
                switch (mScoAudioState) {
                    case SCO_STATE_ACTIVE_INTERNAL:
                        if (mBluetoothHeadset == null) {
                            if (getBluetoothHeadset()) {
                                mScoAudioState = SCO_STATE_DEACTIVATE_REQ;
                            } else {
                                Log.w(TAG, ""requestScoState: getBluetoothHeadset failed during""
                                        + "" disconnection, mScoAudioMode="" + mScoAudioMode);
                                mScoAudioState = SCO_STATE_INACTIVE;
                                broadcastScoConnectionState(
                                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                return false;
                            }
                            break;
                        }
                        if (mBluetoothHeadsetDevice == null) {
                            mScoAudioState = SCO_STATE_INACTIVE;
                            broadcastScoConnectionState(
                                    AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                            break;
                        }
                        if (disconnectBluetoothScoAudioHelper(mBluetoothHeadset,
                                mBluetoothHeadsetDevice, mScoAudioMode)) {
                            mScoAudioState = SCO_STATE_DEACTIVATING;
                        } else {
                            mScoAudioState = SCO_STATE_INACTIVE;
                            broadcastScoConnectionState(
                                    AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        }
                        break;
                    case SCO_STATE_ACTIVATE_REQ:
                        mScoAudioState = SCO_STATE_INACTIVE;
                        broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        break;
                    default:
                        Log.w(TAG, ""requestScoState: failed to disconnect in state ""
                                + mScoAudioState + "", scoAudioMode="" + scoAudioMode);
                        broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        return false;
                }
","        public int totalCount() {
            synchronized(mScoClients) {
                int count = 0;
                for (ScoClient mScoClient : mScoClients) {
                    count += mScoClient.getCount();
                }
                Log.i(TAG, ""In totalCount(), count: "" + count);
                return count;
            }
        }

        private boolean requestScoState(int state, int scoAudioMode) {
            Log.i(TAG, ""In requestScoState(), state: "" + state + "", scoAudioMode: ""
                         + scoAudioMode);
            checkScoAudioState();
            int clientCount = totalCount();
            if (clientCount != 0) {
                Log.w(TAG, ""requestScoState: returning with state="" + state + "", scoAudioMode="" +
                             scoAudioMode + "", clientCount="" + clientCount);
                return false;
            }
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                // Make sure that the state transitions to CONNECTING even if we cannot initiate
                // the connection.
                broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_CONNECTING);
                // Accept SCO audio activation only in NORMAL audio mode or if the mode is
                // currently controlled by the same client process.
                synchronized(mSetModeDeathHandlers) {
                    int modeOwnerPid =  mSetModeDeathHandlers.isEmpty()
                            ? 0 : mSetModeDeathHandlers.get(0).getPid();
                    if (modeOwnerPid != 0 && (modeOwnerPid != mCreatorPid)) {
                        Log.w(TAG, ""requestScoState: audio mode is not NORMAL and modeOwnerPid ""
                                + modeOwnerPid + "" != creatorPid "" + mCreatorPid);
                        broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        return false;
                    }
                    switch (mScoAudioState) {
                        case SCO_STATE_INACTIVE:
                            mScoAudioMode = scoAudioMode;
                            if (scoAudioMode == SCO_MODE_UNDEFINED) {
                                mScoAudioMode = SCO_MODE_VIRTUAL_CALL;
                                if (mBluetoothHeadsetDevice != null) {
                                    mScoAudioMode = Settings.Global.getInt(mContentResolver,
                                            ""bluetooth_sco_channel_""
                                                    + mBluetoothHeadsetDevice.getAddress(),
                                            SCO_MODE_VIRTUAL_CALL);
                                    if (mScoAudioMode > SCO_MODE_MAX || mScoAudioMode < 0) {
                                        mScoAudioMode = SCO_MODE_VIRTUAL_CALL;
                                    }
                                }
                            }
                            if (mBluetoothHeadset == null) {
                                if (getBluetoothHeadset()) {
                                    mScoAudioState = SCO_STATE_ACTIVATE_REQ;
                                } else {
                                    Log.w(TAG, ""requestScoState: getBluetoothHeadset failed during""
                                            + "" connection, mScoAudioMode="" + mScoAudioMode);
                                    broadcastScoConnectionState(
                                            AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                    return false;
                                }
                                break;
                            }
                            if (mBluetoothHeadsetDevice == null) {
                                Log.w(TAG, ""requestScoState: no active device while connecting,""
                                        + "" mScoAudioMode="" + mScoAudioMode);
                                broadcastScoConnectionState(
                                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                return false;
                            }
                            if (connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                    mBluetoothHeadsetDevice, mScoAudioMode)) {
                                mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                            } else {
                                Log.w(TAG, ""requestScoState: connect to "" + mBluetoothHeadsetDevice
                                        + "" failed, mScoAudioMode="" + mScoAudioMode);
                                broadcastScoConnectionState(
                                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                return false;
                            }
                            break;
                        case SCO_STATE_DEACTIVATING:
                            mScoAudioState = SCO_STATE_ACTIVATE_REQ;
                            break;
                        case SCO_STATE_DEACTIVATE_REQ:
                            mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_CONNECTED);
                            break;
                        default:
                            Log.w(TAG, ""requestScoState: failed to connect in state ""
                                    + mScoAudioState + "", scoAudioMode="" + scoAudioMode);
                            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                            return false;

                    }
                }
            } else if (state == BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
                switch (mScoAudioState) {
                    case SCO_STATE_ACTIVE_INTERNAL:
                        if (mBluetoothHeadset == null) {
                            if (getBluetoothHeadset()) {
                                mScoAudioState = SCO_STATE_DEACTIVATE_REQ;
                            } else {
                                Log.w(TAG, ""requestScoState: getBluetoothHeadset failed during""
                                        + "" disconnection, mScoAudioMode="" + mScoAudioMode);
                                mScoAudioState = SCO_STATE_INACTIVE;
                                broadcastScoConnectionState(
                                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                return false;
                            }
                            break;
                        }
                        if (mBluetoothHeadsetDevice == null) {
                            mScoAudioState = SCO_STATE_INACTIVE;
                            broadcastScoConnectionState(
                                    AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                            break;
                        }
                        if (disconnectBluetoothScoAudioHelper(mBluetoothHeadset,
                                mBluetoothHeadsetDevice, mScoAudioMode)) {
                            mScoAudioState = SCO_STATE_DEACTIVATING;
                        } else {
                            mScoAudioState = SCO_STATE_INACTIVE;
                            broadcastScoConnectionState(
                                    AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        }
                        break;
                    case SCO_STATE_ACTIVATE_REQ:
                        mScoAudioState = SCO_STATE_INACTIVE;
                        broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        break;
                    default:
                        Log.w(TAG, ""requestScoState: failed to disconnect in state ""
                                + mScoAudioState + "", scoAudioMode="" + scoAudioMode);
                        broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        return false;
                }
","        public int totalCount() {
            synchronized(mScoClients) {
                int count = 0;
                for (ScoClient mScoClient : mScoClients) {
                    count += mScoClient.getCount();
                }
                Log.i(TAG, ""In totalCount(), count: "" + count);
                return count;
            }
        }

        private boolean requestScoState(int state, int scoAudioMode) {
            Log.i(TAG, ""In requestScoState(), state: "" + state + "", scoAudioMode: ""
                         + scoAudioMode);
            checkScoAudioState();
            int clientCount = totalCount();
            if (clientCount != 0) {
                Log.w(TAG, ""requestScoState: returning with state="" + state + "", scoAudioMode="" +
                             scoAudioMode + "", clientCount="" + clientCount);
                return false;
            }
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                // Make sure that the state transitions to CONNECTING even if we cannot initiate
                // the connection.
                broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_CONNECTING);
                // Accept SCO audio activation only in NORMAL audio mode or if the mode is
                // currently controlled by the same client process.
                synchronized(mSetModeDeathHandlers) {
                    int modeOwnerPid =  mSetModeDeathHandlers.isEmpty()
                            ? 0 : mSetModeDeathHandlers.get(0).getPid();
                    if (modeOwnerPid != 0 && (modeOwnerPid != mCreatorPid)) {
                        Log.w(TAG, ""requestScoState: audio mode is not NORMAL and modeOwnerPid ""
                                + modeOwnerPid + "" != creatorPid "" + mCreatorPid);
                        broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        return false;
                    }
                    switch (mScoAudioState) {
                        case SCO_STATE_INACTIVE:
                            mScoAudioMode = scoAudioMode;
                            if (scoAudioMode == SCO_MODE_UNDEFINED) {
                                mScoAudioMode = SCO_MODE_VIRTUAL_CALL;
                                if (mBluetoothHeadsetDevice != null) {
                                    mScoAudioMode = Settings.Global.getInt(mContentResolver,
                                            ""bluetooth_sco_channel_""
                                                    + mBluetoothHeadsetDevice.getAddress(),
                                            SCO_MODE_VIRTUAL_CALL);
                                    if (mScoAudioMode > SCO_MODE_MAX || mScoAudioMode < 0) {
                                        mScoAudioMode = SCO_MODE_VIRTUAL_CALL;
                                    }
                                }
                            }
                            if (mBluetoothHeadset == null) {
                                if (getBluetoothHeadset()) {
                                    mScoAudioState = SCO_STATE_ACTIVATE_REQ;
                                } else {
                                    Log.w(TAG, ""requestScoState: getBluetoothHeadset failed during""
                                            + "" connection, mScoAudioMode="" + mScoAudioMode);
                                    broadcastScoConnectionState(
                                            AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                    return false;
                                }
                                break;
                            }
                            if (mBluetoothHeadsetDevice == null) {
                                Log.w(TAG, ""requestScoState: no active device while connecting,""
                                        + "" mScoAudioMode="" + mScoAudioMode);
                                broadcastScoConnectionState(
                                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                return false;
                            }
                            if (connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                    mBluetoothHeadsetDevice, mScoAudioMode)) {
                                mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                            } else {
                                Log.w(TAG, ""requestScoState: connect to "" + mBluetoothHeadsetDevice
                                        + "" failed, mScoAudioMode="" + mScoAudioMode);
                                broadcastScoConnectionState(
                                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                return false;
                            }
                            break;
                        case SCO_STATE_DEACTIVATING:
                            mScoAudioState = SCO_STATE_ACTIVATE_REQ;
                            break;
                        case SCO_STATE_DEACTIVATE_REQ:
                            mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_CONNECTED);
                            break;
                        default:
                            Log.w(TAG, ""requestScoState: failed to connect in state ""
                                    + mScoAudioState + "", scoAudioMode="" + scoAudioMode);
                            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                            return false;

                    }
                }
            } else if (state == BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
                switch (mScoAudioState) {
                    case SCO_STATE_ACTIVE_INTERNAL:
                        if (mBluetoothHeadset == null) {
                            if (getBluetoothHeadset()) {
                                mScoAudioState = SCO_STATE_DEACTIVATE_REQ;
                            } else {
                                Log.w(TAG, ""requestScoState: getBluetoothHeadset failed during""
                                        + "" disconnection, mScoAudioMode="" + mScoAudioMode);
                                mScoAudioState = SCO_STATE_INACTIVE;
                                broadcastScoConnectionState(
                                        AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                                return false;
                            }
                            break;
                        }
                        if (mBluetoothHeadsetDevice == null) {
                            mScoAudioState = SCO_STATE_INACTIVE;
                            broadcastScoConnectionState(
                                    AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                            break;
                        }
                        if (disconnectBluetoothScoAudioHelper(mBluetoothHeadset,
                                mBluetoothHeadsetDevice, mScoAudioMode)) {
                            mScoAudioState = SCO_STATE_DEACTIVATING;
                        } else {
                            mScoAudioState = SCO_STATE_INACTIVE;
                            broadcastScoConnectionState(
                                    AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        }
                        break;
                    case SCO_STATE_ACTIVATE_REQ:
                        mScoAudioState = SCO_STATE_INACTIVE;
                        broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        break;
                    default:
                        Log.w(TAG, ""requestScoState: failed to disconnect in state ""
                                + mScoAudioState + "", scoAudioMode="" + scoAudioMode);
                        broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        return false;
                }
","[1.0, 1.0]"
240,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3845, 3855, 11), (3845, 3855, 11)]","    private void checkScoAudioState() {
        synchronized (mScoClients) {
            if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null &&
                    mScoAudioState == SCO_STATE_INACTIVE &&
                    mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice)
                            != BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
                mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
            }
        }
        Log.i(TAG, ""In checkScoAudioState(), mScoAudioState: "" + mScoAudioState);
    }
","    private void checkScoAudioState() {
        synchronized (mScoClients) {
            if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null &&
                    mScoAudioState == SCO_STATE_INACTIVE &&
                    mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice)
                            != BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
                mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
            }
        }
        Log.i(TAG, ""In checkScoAudioState(), mScoAudioState: "" + mScoAudioState);
    }
","    private void checkScoAudioState() {
        synchronized (mScoClients) {
            if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null &&
                    mScoAudioState == SCO_STATE_INACTIVE &&
                    mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice)
                            != BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
                mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
            }
        }
        Log.i(TAG, ""In checkScoAudioState(), mScoAudioState: "" + mScoAudioState);
    }
","[1.0, 1.0]"
241,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3874, 4385, 512), (3874, 4385, 512)]","    public void clearAllScoClients(int exceptPid, boolean stopSco) {
        synchronized(mScoClients) {
            ScoClient savedClient = null;
            for (ScoClient cl : mScoClients) {
                if (cl.getPid() != exceptPid) {
                    cl.clearCount(stopSco);
                } else {
                    savedClient = cl;
                }
            }
            mScoClients.clear();
            if (savedClient != null) {
                mScoClients.add(savedClient);
            }
        }
    }

    private boolean getBluetoothHeadset() {
        boolean result = false;
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if (adapter != null) {
            result = adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
                                    BluetoothProfile.HEADSET);
        }
        // If we could not get a bluetooth headset proxy, send a failure message
        // without delay to reset the SCO audio state and clear SCO clients.
        // If we could get a proxy, send a delayed failure message that will reset our state
        // in case we don't receive onServiceConnected().
        sendMsg(mAudioHandler, MSG_BT_HEADSET_CNCT_FAILED,
                SENDMSG_REPLACE, 0, 0, null, result ? BT_HEADSET_CNCT_TIMEOUT_MS : 0);
        return result;
    }

    /**
     * Disconnect all SCO connections started by {@link AudioManager} except those started by
     * {@param exceptPid}
     *
     * @param exceptPid pid whose SCO connections through {@link AudioManager} should be kept
     */
    private void disconnectBluetoothSco(int exceptPid) {
        Log.i(TAG, ""In disconnectBluetoothSco(), exceptPid: "" + exceptPid);
        synchronized(mScoClients) {
            checkScoAudioState();
            if (mScoAudioState == SCO_STATE_ACTIVE_EXTERNAL) {
                return;
            }
            clearAllScoClients(exceptPid, true);
        }
    }

    private static boolean disconnectBluetoothScoAudioHelper(BluetoothHeadset bluetoothHeadset,
            BluetoothDevice device, int scoAudioMode) {
        Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), scoAudioMode: "" + scoAudioMode +
               "", bluetoothHeadset: "" + bluetoothHeadset + "", BluetoothDevice: "" + device);
        switch (scoAudioMode) {
            case SCO_MODE_RAW:
                Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), calling disconnectAudio()"");
                return bluetoothHeadset.disconnectAudio();
            case SCO_MODE_VIRTUAL_CALL:
                Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), calling "" +
                           ""stopScoUsingVirtualVoiceCall()"");
                return bluetoothHeadset.stopScoUsingVirtualVoiceCall();
            case SCO_MODE_VR:
                Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), calling "" +
                           ""stopVoiceRecognition()"");
                return bluetoothHeadset.stopVoiceRecognition(device);
            default:
                return false;
        }
    }

    private static boolean connectBluetoothScoAudioHelper(BluetoothHeadset bluetoothHeadset,
            BluetoothDevice device, int scoAudioMode) {
        Log.i(TAG, ""In connectBluetoothScoAudioHelper(), scoAudioMode: "" + scoAudioMode +
               "", bluetoothHeadset: "" + bluetoothHeadset + "", BluetoothDevice: "" + device);
        switch (scoAudioMode) {
            case SCO_MODE_RAW:
                Log.i(TAG, ""In connectBluetoothScoAudioHelper(), calling connectAudio()"");
                return bluetoothHeadset.connectAudio();
            case SCO_MODE_VIRTUAL_CALL:
                Log.i(TAG, ""In connectBluetoothScoAudioHelper(), calling ""
                       + ""startScoUsingVirtualVoiceCall()"");
                return bluetoothHeadset.startScoUsingVirtualVoiceCall();
            case SCO_MODE_VR:
                Log.i(TAG, ""In connectBluetoothScoAudioHelper(), calling ""
                       + ""startVoiceRecognition()"");
                return bluetoothHeadset.startVoiceRecognition(device);
            default:
                return false;
        }
    }

    private void resetBluetoothSco() {
        synchronized(mScoClients) {
            Log.i(TAG, ""In resetBluetoothSco(), calling clearAllScoClients()"");
            clearAllScoClients(0, false);
            mScoAudioState = SCO_STATE_INACTIVE;
            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
        }
        mScoClientDevices.clear();
        AudioSystem.setParameters(""A2dpSuspended=false"");
        setBluetoothScoOnInt(false, ""resetBluetoothSco"");
    }

    private void broadcastScoConnectionState(int state) {
        sendMsg(mAudioHandler, MSG_BROADCAST_BT_CONNECTION_STATE,
                SENDMSG_QUEUE, state, 0, null, 0);
    }

    private void onBroadcastScoConnectionState(int state) {
        if (state != mScoConnectionState) {
            Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_UPDATED);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, state);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_PREVIOUS_STATE,
                    mScoConnectionState);
            sendStickyBroadcastToAll(newIntent);
            mScoConnectionState = state;
        }
    }

    private boolean handleBtScoActiveDeviceChange(BluetoothDevice btDevice, boolean isActive) {
        if (btDevice == null) {
            return true;
        }

        String address = btDevice.getAddress();
        BluetoothClass btClass = btDevice.getBluetoothClass();
        int inDevice = AudioSystem.DEVICE_IN_BLUETOOTH_SCO_HEADSET;
        int[] outDeviceTypes = {
            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,
            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET,
            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT
        };
        if (btClass != null) {
            switch (btClass.getDeviceClass()) {
                case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
                case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                    outDeviceTypes = new int[] { AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET };
                    break;
                case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                    outDeviceTypes = new int[] { AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT };
                    break;
            }
        }
        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
            address = """";
        }
        String btDeviceName =  btDevice.getName();
        if (btDeviceName == null) {
            Slog.i(TAG, ""handleBtScoActiveDeviceChange: btDeviceName is null,"" +
                       "" sending empty string"");
            btDeviceName = """";
        }

        boolean result = false;
        if (isActive) {
            result |= handleDeviceConnection(isActive, outDeviceTypes[0], address, btDeviceName);
        } else {
            for (int outDeviceType : outDeviceTypes) {
                result |= handleDeviceConnection(isActive, outDeviceType, address, btDeviceName);
            }
        }

        // handleDeviceConnection() && result to make sure the method get executed
        result = handleDeviceConnection(isActive, inDevice, address, btDeviceName) && result;
        Slog.i(TAG, ""for inDevice"" + inDevice + "" result is "" + result);
        return result;
    }

    private void setBtScoActiveDevice(BluetoothDevice btDevice) {
        synchronized (mScoClients) {
            Log.i(TAG, ""setBtScoActiveDevice: "" + mBluetoothHeadsetDevice + "" -> "" + btDevice);
            final BluetoothDevice previousActiveDevice = mBluetoothHeadsetDevice;
            if (mBluetoothHeadsetDevice != null && mBluetoothHeadsetDevice.isTwsPlusDevice()
               && btDevice != null
               && Objects.equals(mBluetoothHeadsetDevice.getTwsPlusPeerAddress(), btDevice.getAddress())) {
                Log.i(TAG, ""setBtScoActiveDevice: Active device switch between twsplus devices"");
                //Keep the same mBluetoothHeadsetDevice as current Active so
                //that It tears down when active becomes null
                return;
            }
            if (!Objects.equals(btDevice, previousActiveDevice)) {
                if (!handleBtScoActiveDeviceChange(previousActiveDevice, false)) {
                    Log.w(TAG, ""setBtScoActiveDevice() failed to remove previous device ""
                            + previousActiveDevice);
                }
                if (!handleBtScoActiveDeviceChange(btDevice, true)) {
                    Log.e(TAG, ""setBtScoActiveDevice() failed to add new device "" + btDevice);
                    // set mBluetoothHeadsetDevice to null when failing to add new device
                    btDevice = null;
                }
                mBluetoothHeadsetDevice = btDevice;
                if (mBluetoothHeadsetDevice == null) {
                    Log.i(TAG, ""In setBtScoActiveDevice(), calling resetBluetoothSco()"");
                    resetBluetoothSco();
                }
            }
        }
    }

    private BluetoothProfile.ServiceListener mBluetoothProfileServiceListener =
        new BluetoothProfile.ServiceListener() {
        public void onServiceConnected(int profile, BluetoothProfile proxy) {
            Log.i(TAG, ""In onServiceConnected(), profile: "" + profile +
                  "", proxy: "" + proxy);
            BluetoothDevice btDevice;
            List<BluetoothDevice> deviceList;
            switch(profile) {
            case BluetoothProfile.A2DP:
                synchronized (mConnectedDevices) {
                    synchronized (mA2dpAvrcpLock) {
                        mA2dp = (BluetoothA2dp) proxy;
                        deviceList = mA2dp.getConnectedDevices();
                        if (deviceList.size() > 0) {
                            btDevice = deviceList.get(0);
                            int state = mA2dp.getConnectionState(btDevice);
                            int intState = (state == BluetoothA2dp.STATE_CONNECTED) ? 1 : 0;
                            int delay = checkSendBecomingNoisyIntent(
                                    AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, intState,
                                    AudioSystem.DEVICE_NONE);
                            final String addr = btDevice == null ? ""null"" : btDevice.getAddress();
                            mDeviceLogger.log(new AudioEventLogger.StringEvent(
                                    ""A2DP service connected: device addr="" + addr
                                    + "" state="" + state));
                            queueMsgUnderWakeLock(mAudioHandler,
                                    MSG_SET_A2DP_SINK_CONNECTION_STATE,
                                    state,
                                    0 /* arg2 unused */,
                                    new BluetoothA2dpDeviceInfo(btDevice),
                                    delay);
                        }
                    }
                }
                break;

            case BluetoothProfile.A2DP_SINK:
                deviceList = proxy.getConnectedDevices();
                if (deviceList.size() > 0) {
                    btDevice = deviceList.get(0);
                    synchronized (mConnectedDevices) {
                        int state = proxy.getConnectionState(btDevice);
                        queueMsgUnderWakeLock(mAudioHandler,
                                MSG_SET_A2DP_SRC_CONNECTION_STATE,
                                state,
                                0 /* arg2 unused */,
                                new BluetoothA2dpDeviceInfo(btDevice),
                                0 /* delay */);
                    }
                }
                break;

            case BluetoothProfile.HEADSET:
                synchronized (mScoClients) {
                    // Discard timeout message
                    mAudioHandler.removeMessages(MSG_BT_HEADSET_CNCT_FAILED);
                    mBluetoothHeadset = (BluetoothHeadset) proxy;
                    setBtScoActiveDevice(mBluetoothHeadset.getActiveDevice());
                    // Refresh SCO audio state
                    checkScoAudioState();
                    Log.i(TAG, ""In HEADSET profile, mScoAudioState: "" + mScoAudioState
                          + "", mScoAudioMode: "" + mScoAudioMode);
                    // Continue pending action if any
                    if (mScoAudioState == SCO_STATE_ACTIVATE_REQ ||
                            mScoAudioState == SCO_STATE_DEACTIVATE_REQ) {
                        boolean status = false;
                        if (mBluetoothHeadsetDevice != null) {
                            // Get correct mScoAudioMode
                            mScoAudioMode = new Integer(Settings.Global.getInt(
                                                        mContentResolver,
                                                        ""bluetooth_sco_channel_""+
                                                        mBluetoothHeadsetDevice.getAddress(),
                                                        SCO_MODE_VIRTUAL_CALL));
                            if (mScoAudioMode > SCO_MODE_MAX || mScoAudioMode < 0) {
                                Log.i(TAG, ""Resetting the mScoAudioMode to "" +
                                      ""SCO_MODE_VIRTUAL_CALL"");
                                mScoAudioMode = SCO_MODE_VIRTUAL_CALL;
                            }
                            switch (mScoAudioState) {
                                case SCO_STATE_ACTIVATE_REQ:
                                    Log.i(TAG, ""In HEADSET profile, calling connectBluetoothScoAudioHelper()"");
                                    status = connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                            mBluetoothHeadsetDevice, mScoAudioMode);
                                    if (status) {
                                        mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                                    }
                                    break;
                                case SCO_STATE_DEACTIVATE_REQ:
                                    Log.i(TAG, ""In HEADSET profile, calling disconnectBluetoothScoAudioHelper()"");
                                    status = disconnectBluetoothScoAudioHelper(mBluetoothHeadset,
                                            mBluetoothHeadsetDevice, mScoAudioMode);
                                    if (status) {
                                        mScoAudioState = SCO_STATE_DEACTIVATING;
                                    }
                                    break;
                            }
                        }
                        if (!status) {
                            mScoAudioState = SCO_STATE_INACTIVE;
                            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        }
                    }
                }
                break;

            case BluetoothProfile.HEARING_AID:
                synchronized (mConnectedDevices) {
                    synchronized (mHearingAidLock) {
                        mHearingAid = (BluetoothHearingAid) proxy;
                        deviceList = mHearingAid.getConnectedDevices();
                        if (deviceList.size() > 0) {
                            btDevice = deviceList.get(0);
                            int state = mHearingAid.getConnectionState(btDevice);
                            int intState = (state == BluetoothHearingAid.STATE_CONNECTED) ? 1 : 0;
                            int delay = checkSendBecomingNoisyIntent(
                                    AudioSystem.DEVICE_OUT_HEARING_AID, intState,
                                    AudioSystem.DEVICE_NONE);
                            queueMsgUnderWakeLock(mAudioHandler,
                                    MSG_SET_HEARING_AID_CONNECTION_STATE,
                                    state,
                                    0 /* arg2 unused */,
                                    btDevice,
                                    delay);
                        }
                    }
                }

                break;

            default:
                break;
            }
        }
        public void onServiceDisconnected(int profile) {

            switch (profile) {
            case BluetoothProfile.A2DP:
                disconnectA2dp();
                break;

            case BluetoothProfile.A2DP_SINK:
                disconnectA2dpSink();
                break;

            case BluetoothProfile.HEADSET:
                 Log.i(TAG, ""In onServiceDisconnected(), calling disconnectHeadset()"");
                disconnectHeadset();
                break;

            case BluetoothProfile.HEARING_AID:
                disconnectHearingAid();
                break;

            default:
                break;
            }
        }
    };

    void disconnectAllBluetoothProfiles() {
        disconnectA2dp();
        disconnectA2dpSink();
        disconnectHeadset();
        disconnectHearingAid();
    }

    void disconnectA2dp() {
        synchronized (mConnectedDevices) {
            synchronized (mA2dpAvrcpLock) {
                ArraySet<String> toRemove = null;
                // Disconnect ALL DEVICE_OUT_BLUETOOTH_A2DP devices
                for (int i = 0; i < mConnectedDevices.size(); i++) {
                    DeviceListSpec deviceSpec = mConnectedDevices.valueAt(i);
                    if (deviceSpec.mDeviceType == AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) {
                        toRemove = toRemove != null ? toRemove : new ArraySet<String>();
                        toRemove.add(deviceSpec.mDeviceAddress);
                    }
                }
                if (toRemove != null) {
                    int delay = checkSendBecomingNoisyIntent(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
                            0, AudioSystem.DEVICE_NONE);
                    for (int i = 0; i < toRemove.size(); i++) {
                        makeA2dpDeviceUnavailableLater(toRemove.valueAt(i), delay);
                    }
                }
            }
        }
    }

    void disconnectA2dpSink() {
        synchronized (mConnectedDevices) {
            ArraySet<String> toRemove = null;
            // Disconnect ALL DEVICE_IN_BLUETOOTH_A2DP devices
            for(int i = 0; i < mConnectedDevices.size(); i++) {
                DeviceListSpec deviceSpec = mConnectedDevices.valueAt(i);
                if (deviceSpec.mDeviceType == AudioSystem.DEVICE_IN_BLUETOOTH_A2DP) {
                    toRemove = toRemove != null ? toRemove : new ArraySet<String>();
                    toRemove.add(deviceSpec.mDeviceAddress);
                }
            }
            if (toRemove != null) {
                for (int i = 0; i < toRemove.size(); i++) {
                    makeA2dpSrcUnavailable(toRemove.valueAt(i));
                }
            }
        }
    }

    void disconnectHeadset() {
        synchronized (mScoClients) {
            setBtScoActiveDevice(null);
            mBluetoothHeadset = null;
        }
    }

    void disconnectHearingAid() {
        synchronized (mConnectedDevices) {
            synchronized (mHearingAidLock) {
                ArraySet<String> toRemove = null;
                // Disconnect ALL DEVICE_OUT_HEARING_AID devices
                for (int i = 0; i < mConnectedDevices.size(); i++) {
                    DeviceListSpec deviceSpec = mConnectedDevices.valueAt(i);
                    if (deviceSpec.mDeviceType == AudioSystem.DEVICE_OUT_HEARING_AID) {
                        toRemove = toRemove != null ? toRemove : new ArraySet<String>();
                        toRemove.add(deviceSpec.mDeviceAddress);
                    }
                }
                if (toRemove != null) {
                    int delay = checkSendBecomingNoisyIntent(AudioSystem.DEVICE_OUT_HEARING_AID,
                            0, AudioSystem.DEVICE_NONE);
                    for (int i = 0; i < toRemove.size(); i++) {
                        makeHearingAidDeviceUnavailable(toRemove.valueAt(i) /*, delay*/);
                    }
                }
            }
        }
    }

    private void onCheckMusicActive(String caller) {
        synchronized (mSafeMediaVolumeStateLock) {
            if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_INACTIVE) {
                int device = getDeviceForStream(AudioSystem.STREAM_MUSIC);

                if ((device & mSafeMediaVolumeDevices) != 0) {
                    sendMsg(mAudioHandler,
                            MSG_CHECK_MUSIC_ACTIVE,
                            SENDMSG_REPLACE,
                            0,
                            0,
                            caller,
                            MUSIC_ACTIVE_POLL_PERIOD_MS);
                    int index = mStreamStates[AudioSystem.STREAM_MUSIC].getIndex(device);
                    if (AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC, 0) &&
                            (index > safeMediaVolumeIndex(device))) {
                        // Approximate cumulative active music time
                        mMusicActiveMs += MUSIC_ACTIVE_POLL_PERIOD_MS;
                        if (mMusicActiveMs > UNSAFE_VOLUME_MUSIC_ACTIVE_MS_MAX) {
                            setSafeMediaVolumeEnabled(true, caller);
                            mMusicActiveMs = 0;
                        }
                        saveMusicActiveMs();
                    }
                }
            }
        }
    }

    private void saveMusicActiveMs() {
        mAudioHandler.obtainMessage(MSG_PERSIST_MUSIC_ACTIVE_MS, mMusicActiveMs, 0).sendToTarget();
    }

    private int getSafeUsbMediaVolumeIndex()
    {
        // determine UI volume index corresponding to the wanted safe gain in dBFS
        int min = MIN_STREAM_VOLUME[AudioSystem.STREAM_MUSIC];
        int max = MAX_STREAM_VOLUME[AudioSystem.STREAM_MUSIC];

        mSafeUsbMediaVolumeDbfs = mContext.getResources().getInteger(
                com.android.internal.R.integer.config_safe_media_volume_usb_mB) / 100.0f;

        while (Math.abs(max-min) > 1) {
            int index = (max + min) / 2;
            float gainDB = AudioSystem.getStreamVolumeDB(
                    AudioSystem.STREAM_MUSIC, index, AudioSystem.DEVICE_OUT_USB_HEADSET);
            if (Float.isNaN(gainDB)) {
                //keep last min in case of read error
                break;
            } else if (gainDB == mSafeUsbMediaVolumeDbfs) {
                min = index;
                break;
            } else if (gainDB < mSafeUsbMediaVolumeDbfs) {
                min = index;
            } else {
                max = index;
            }
        }
        return min * 10;
    }

    private void onConfigureSafeVolume(boolean force, String caller) {
        synchronized (mSafeMediaVolumeStateLock) {
            int mcc = mContext.getResources().getConfiguration().mcc;
            if ((mMcc != mcc) || ((mMcc == 0) && force)) {
                mSafeMediaVolumeIndex = mContext.getResources().getInteger(
                        com.android.internal.R.integer.config_safe_media_volume_index) * 10;

                mSafeUsbMediaVolumeIndex = getSafeUsbMediaVolumeIndex();

                boolean safeMediaVolumeEnabled =
                        SystemProperties.getBoolean(""audio.safemedia.force"", false)
                        || mContext.getResources().getBoolean(
                                com.android.internal.R.bool.config_safe_media_volume_enabled);

","    public void clearAllScoClients(int exceptPid, boolean stopSco) {
        synchronized(mScoClients) {
            ScoClient savedClient = null;
            for (ScoClient cl : mScoClients) {
                if (cl.getPid() != exceptPid) {
                    cl.clearCount(stopSco);
                } else {
                    savedClient = cl;
                }
            }
            mScoClients.clear();
            if (savedClient != null) {
                mScoClients.add(savedClient);
            }
        }
    }

    private boolean getBluetoothHeadset() {
        boolean result = false;
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if (adapter != null) {
            result = adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
                                    BluetoothProfile.HEADSET);
        }
        // If we could not get a bluetooth headset proxy, send a failure message
        // without delay to reset the SCO audio state and clear SCO clients.
        // If we could get a proxy, send a delayed failure message that will reset our state
        // in case we don't receive onServiceConnected().
        sendMsg(mAudioHandler, MSG_BT_HEADSET_CNCT_FAILED,
                SENDMSG_REPLACE, 0, 0, null, result ? BT_HEADSET_CNCT_TIMEOUT_MS : 0);
        return result;
    }

    /**
     * Disconnect all SCO connections started by {@link AudioManager} except those started by
     * {@param exceptPid}
     *
     * @param exceptPid pid whose SCO connections through {@link AudioManager} should be kept
     */
    private void disconnectBluetoothSco(int exceptPid) {
        Log.i(TAG, ""In disconnectBluetoothSco(), exceptPid: "" + exceptPid);
        synchronized(mScoClients) {
            checkScoAudioState();
            if (mScoAudioState == SCO_STATE_ACTIVE_EXTERNAL) {
                return;
            }
            clearAllScoClients(exceptPid, true);
        }
    }

    private static boolean disconnectBluetoothScoAudioHelper(BluetoothHeadset bluetoothHeadset,
            BluetoothDevice device, int scoAudioMode) {
        Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), scoAudioMode: "" + scoAudioMode +
               "", bluetoothHeadset: "" + bluetoothHeadset + "", BluetoothDevice: "" + device);
        switch (scoAudioMode) {
            case SCO_MODE_RAW:
                Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), calling disconnectAudio()"");
                return bluetoothHeadset.disconnectAudio();
            case SCO_MODE_VIRTUAL_CALL:
                Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), calling "" +
                           ""stopScoUsingVirtualVoiceCall()"");
                return bluetoothHeadset.stopScoUsingVirtualVoiceCall();
            case SCO_MODE_VR:
                Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), calling "" +
                           ""stopVoiceRecognition()"");
                return bluetoothHeadset.stopVoiceRecognition(device);
            default:
                return false;
        }
    }

    private static boolean connectBluetoothScoAudioHelper(BluetoothHeadset bluetoothHeadset,
            BluetoothDevice device, int scoAudioMode) {
        Log.i(TAG, ""In connectBluetoothScoAudioHelper(), scoAudioMode: "" + scoAudioMode +
               "", bluetoothHeadset: "" + bluetoothHeadset + "", BluetoothDevice: "" + device);
        switch (scoAudioMode) {
            case SCO_MODE_RAW:
                Log.i(TAG, ""In connectBluetoothScoAudioHelper(), calling connectAudio()"");
                return bluetoothHeadset.connectAudio();
            case SCO_MODE_VIRTUAL_CALL:
                Log.i(TAG, ""In connectBluetoothScoAudioHelper(), calling ""
                       + ""startScoUsingVirtualVoiceCall()"");
                return bluetoothHeadset.startScoUsingVirtualVoiceCall();
            case SCO_MODE_VR:
                Log.i(TAG, ""In connectBluetoothScoAudioHelper(), calling ""
                       + ""startVoiceRecognition()"");
                return bluetoothHeadset.startVoiceRecognition(device);
            default:
                return false;
        }
    }

    private void resetBluetoothSco() {
        synchronized(mScoClients) {
            Log.i(TAG, ""In resetBluetoothSco(), calling clearAllScoClients()"");
            clearAllScoClients(0, false);
            mScoAudioState = SCO_STATE_INACTIVE;
            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
        }
        mScoClientDevices.clear();
        AudioSystem.setParameters(""A2dpSuspended=false"");
        setBluetoothScoOnInt(false, ""resetBluetoothSco"");
    }

    private void broadcastScoConnectionState(int state) {
        sendMsg(mAudioHandler, MSG_BROADCAST_BT_CONNECTION_STATE,
                SENDMSG_QUEUE, state, 0, null, 0);
    }

    private void onBroadcastScoConnectionState(int state) {
        if (state != mScoConnectionState) {
            Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_UPDATED);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, state);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_PREVIOUS_STATE,
                    mScoConnectionState);
            sendStickyBroadcastToAll(newIntent);
            mScoConnectionState = state;
        }
    }

    private boolean handleBtScoActiveDeviceChange(BluetoothDevice btDevice, boolean isActive) {
        if (btDevice == null) {
            return true;
        }

        String address = btDevice.getAddress();
        BluetoothClass btClass = btDevice.getBluetoothClass();
        int inDevice = AudioSystem.DEVICE_IN_BLUETOOTH_SCO_HEADSET;
        int[] outDeviceTypes = {
            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,
            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET,
            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT
        };
        if (btClass != null) {
            switch (btClass.getDeviceClass()) {
                case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
                case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                    outDeviceTypes = new int[] { AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET };
                    break;
                case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                    outDeviceTypes = new int[] { AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT };
                    break;
            }
        }
        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
            address = """";
        }
        String btDeviceName =  btDevice.getName();
        if (btDeviceName == null) {
            Slog.i(TAG, ""handleBtScoActiveDeviceChange: btDeviceName is null,"" +
                       "" sending empty string"");
            btDeviceName = """";
        }

        boolean result = false;
        if (isActive) {
            result |= handleDeviceConnection(isActive, outDeviceTypes[0], address, btDeviceName);
        } else {
            for (int outDeviceType : outDeviceTypes) {
                result |= handleDeviceConnection(isActive, outDeviceType, address, btDeviceName);
            }
        }

        // handleDeviceConnection() && result to make sure the method get executed
        result = handleDeviceConnection(isActive, inDevice, address, btDeviceName) && result;
        Slog.i(TAG, ""for inDevice"" + inDevice + "" result is "" + result);
        return result;
    }

    private void setBtScoActiveDevice(BluetoothDevice btDevice) {
        synchronized (mScoClients) {
            Log.i(TAG, ""setBtScoActiveDevice: "" + mBluetoothHeadsetDevice + "" -> "" + btDevice);
            final BluetoothDevice previousActiveDevice = mBluetoothHeadsetDevice;
            if (mBluetoothHeadsetDevice != null && mBluetoothHeadsetDevice.isTwsPlusDevice()
               && btDevice != null
               && Objects.equals(mBluetoothHeadsetDevice.getTwsPlusPeerAddress(), btDevice.getAddress())) {
                Log.i(TAG, ""setBtScoActiveDevice: Active device switch between twsplus devices"");
                //Keep the same mBluetoothHeadsetDevice as current Active so
                //that It tears down when active becomes null
                return;
            }
            if (!Objects.equals(btDevice, previousActiveDevice)) {
                if (!handleBtScoActiveDeviceChange(previousActiveDevice, false)) {
                    Log.w(TAG, ""setBtScoActiveDevice() failed to remove previous device ""
                            + previousActiveDevice);
                }
                if (!handleBtScoActiveDeviceChange(btDevice, true)) {
                    Log.e(TAG, ""setBtScoActiveDevice() failed to add new device "" + btDevice);
                    // set mBluetoothHeadsetDevice to null when failing to add new device
                    btDevice = null;
                }
                mBluetoothHeadsetDevice = btDevice;
                if (mBluetoothHeadsetDevice == null) {
                    Log.i(TAG, ""In setBtScoActiveDevice(), calling resetBluetoothSco()"");
                    resetBluetoothSco();
                }
            }
        }
    }

    private BluetoothProfile.ServiceListener mBluetoothProfileServiceListener =
        new BluetoothProfile.ServiceListener() {
        public void onServiceConnected(int profile, BluetoothProfile proxy) {
            Log.i(TAG, ""In onServiceConnected(), profile: "" + profile +
                  "", proxy: "" + proxy);
            BluetoothDevice btDevice;
            List<BluetoothDevice> deviceList;
            switch(profile) {
            case BluetoothProfile.A2DP:
                synchronized (mConnectedDevices) {
                    synchronized (mA2dpAvrcpLock) {
                        mA2dp = (BluetoothA2dp) proxy;
                        deviceList = mA2dp.getConnectedDevices();
                        if (deviceList.size() > 0) {
                            btDevice = deviceList.get(0);
                            int state = mA2dp.getConnectionState(btDevice);
                            int intState = (state == BluetoothA2dp.STATE_CONNECTED) ? 1 : 0;
                            int delay = checkSendBecomingNoisyIntent(
                                    AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, intState,
                                    AudioSystem.DEVICE_NONE);
                            final String addr = btDevice == null ? ""null"" : btDevice.getAddress();
                            mDeviceLogger.log(new AudioEventLogger.StringEvent(
                                    ""A2DP service connected: device addr="" + addr
                                    + "" state="" + state));
                            queueMsgUnderWakeLock(mAudioHandler,
                                    MSG_SET_A2DP_SINK_CONNECTION_STATE,
                                    state,
                                    0 /* arg2 unused */,
                                    new BluetoothA2dpDeviceInfo(btDevice),
                                    delay);
                        }
                    }
                }
                break;

            case BluetoothProfile.A2DP_SINK:
                deviceList = proxy.getConnectedDevices();
                if (deviceList.size() > 0) {
                    btDevice = deviceList.get(0);
                    synchronized (mConnectedDevices) {
                        int state = proxy.getConnectionState(btDevice);
                        queueMsgUnderWakeLock(mAudioHandler,
                                MSG_SET_A2DP_SRC_CONNECTION_STATE,
                                state,
                                0 /* arg2 unused */,
                                new BluetoothA2dpDeviceInfo(btDevice),
                                0 /* delay */);
                    }
                }
                break;

            case BluetoothProfile.HEADSET:
                synchronized (mScoClients) {
                    // Discard timeout message
                    mAudioHandler.removeMessages(MSG_BT_HEADSET_CNCT_FAILED);
                    mBluetoothHeadset = (BluetoothHeadset) proxy;
                    setBtScoActiveDevice(mBluetoothHeadset.getActiveDevice());
                    // Refresh SCO audio state
                    checkScoAudioState();
                    Log.i(TAG, ""In HEADSET profile, mScoAudioState: "" + mScoAudioState
                          + "", mScoAudioMode: "" + mScoAudioMode);
                    // Continue pending action if any
                    if (mScoAudioState == SCO_STATE_ACTIVATE_REQ ||
                            mScoAudioState == SCO_STATE_DEACTIVATE_REQ) {
                        boolean status = false;
                        if (mBluetoothHeadsetDevice != null) {
                            // Get correct mScoAudioMode
                            mScoAudioMode = new Integer(Settings.Global.getInt(
                                                        mContentResolver,
                                                        ""bluetooth_sco_channel_""+
                                                        mBluetoothHeadsetDevice.getAddress(),
                                                        SCO_MODE_VIRTUAL_CALL));
                            if (mScoAudioMode > SCO_MODE_MAX || mScoAudioMode < 0) {
                                Log.i(TAG, ""Resetting the mScoAudioMode to "" +
                                      ""SCO_MODE_VIRTUAL_CALL"");
                                mScoAudioMode = SCO_MODE_VIRTUAL_CALL;
                            }
                            switch (mScoAudioState) {
                                case SCO_STATE_ACTIVATE_REQ:
                                    Log.i(TAG, ""In HEADSET profile, calling connectBluetoothScoAudioHelper()"");
                                    status = connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                            mBluetoothHeadsetDevice, mScoAudioMode);
                                    if (status) {
                                        mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                                    }
                                    break;
                                case SCO_STATE_DEACTIVATE_REQ:
                                    Log.i(TAG, ""In HEADSET profile, calling disconnectBluetoothScoAudioHelper()"");
                                    status = disconnectBluetoothScoAudioHelper(mBluetoothHeadset,
                                            mBluetoothHeadsetDevice, mScoAudioMode);
                                    if (status) {
                                        mScoAudioState = SCO_STATE_DEACTIVATING;
                                    }
                                    break;
                            }
                        }
                        if (!status) {
                            mScoAudioState = SCO_STATE_INACTIVE;
                            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        }
                    }
                }
                break;

            case BluetoothProfile.HEARING_AID:
                synchronized (mConnectedDevices) {
                    synchronized (mHearingAidLock) {
                        mHearingAid = (BluetoothHearingAid) proxy;
                        deviceList = mHearingAid.getConnectedDevices();
                        if (deviceList.size() > 0) {
                            btDevice = deviceList.get(0);
                            int state = mHearingAid.getConnectionState(btDevice);
                            int intState = (state == BluetoothHearingAid.STATE_CONNECTED) ? 1 : 0;
                            int delay = checkSendBecomingNoisyIntent(
                                    AudioSystem.DEVICE_OUT_HEARING_AID, intState,
                                    AudioSystem.DEVICE_NONE);
                            queueMsgUnderWakeLock(mAudioHandler,
                                    MSG_SET_HEARING_AID_CONNECTION_STATE,
                                    state,
                                    0 /* arg2 unused */,
                                    btDevice,
                                    delay);
                        }
                    }
                }

                break;

            default:
                break;
            }
        }
        public void onServiceDisconnected(int profile) {

            switch (profile) {
            case BluetoothProfile.A2DP:
                disconnectA2dp();
                break;

            case BluetoothProfile.A2DP_SINK:
                disconnectA2dpSink();
                break;

            case BluetoothProfile.HEADSET:
                 Log.i(TAG, ""In onServiceDisconnected(), calling disconnectHeadset()"");
                disconnectHeadset();
                break;

            case BluetoothProfile.HEARING_AID:
                disconnectHearingAid();
                break;

            default:
                break;
            }
        }
    };

    void disconnectAllBluetoothProfiles() {
        disconnectA2dp();
        disconnectA2dpSink();
        disconnectHeadset();
        disconnectHearingAid();
    }

    void disconnectA2dp() {
        synchronized (mConnectedDevices) {
            synchronized (mA2dpAvrcpLock) {
                ArraySet<String> toRemove = null;
                // Disconnect ALL DEVICE_OUT_BLUETOOTH_A2DP devices
                for (int i = 0; i < mConnectedDevices.size(); i++) {
                    DeviceListSpec deviceSpec = mConnectedDevices.valueAt(i);
                    if (deviceSpec.mDeviceType == AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) {
                        toRemove = toRemove != null ? toRemove : new ArraySet<String>();
                        toRemove.add(deviceSpec.mDeviceAddress);
                    }
                }
                if (toRemove != null) {
                    int delay = checkSendBecomingNoisyIntent(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
                            0, AudioSystem.DEVICE_NONE);
                    for (int i = 0; i < toRemove.size(); i++) {
                        makeA2dpDeviceUnavailableLater(toRemove.valueAt(i), delay);
                    }
                }
            }
        }
    }

    void disconnectA2dpSink() {
        synchronized (mConnectedDevices) {
            ArraySet<String> toRemove = null;
            // Disconnect ALL DEVICE_IN_BLUETOOTH_A2DP devices
            for(int i = 0; i < mConnectedDevices.size(); i++) {
                DeviceListSpec deviceSpec = mConnectedDevices.valueAt(i);
                if (deviceSpec.mDeviceType == AudioSystem.DEVICE_IN_BLUETOOTH_A2DP) {
                    toRemove = toRemove != null ? toRemove : new ArraySet<String>();
                    toRemove.add(deviceSpec.mDeviceAddress);
                }
            }
            if (toRemove != null) {
                for (int i = 0; i < toRemove.size(); i++) {
                    makeA2dpSrcUnavailable(toRemove.valueAt(i));
                }
            }
        }
    }

    void disconnectHeadset() {
        synchronized (mScoClients) {
            setBtScoActiveDevice(null);
            mBluetoothHeadset = null;
        }
    }

    void disconnectHearingAid() {
        synchronized (mConnectedDevices) {
            synchronized (mHearingAidLock) {
                ArraySet<String> toRemove = null;
                // Disconnect ALL DEVICE_OUT_HEARING_AID devices
                for (int i = 0; i < mConnectedDevices.size(); i++) {
                    DeviceListSpec deviceSpec = mConnectedDevices.valueAt(i);
                    if (deviceSpec.mDeviceType == AudioSystem.DEVICE_OUT_HEARING_AID) {
                        toRemove = toRemove != null ? toRemove : new ArraySet<String>();
                        toRemove.add(deviceSpec.mDeviceAddress);
                    }
                }
                if (toRemove != null) {
                    int delay = checkSendBecomingNoisyIntent(AudioSystem.DEVICE_OUT_HEARING_AID,
                            0, AudioSystem.DEVICE_NONE);
                    for (int i = 0; i < toRemove.size(); i++) {
                        makeHearingAidDeviceUnavailable(toRemove.valueAt(i) /*, delay*/);
                    }
                }
            }
        }
    }

    private void onCheckMusicActive(String caller) {
        synchronized (mSafeMediaVolumeStateLock) {
            if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_INACTIVE) {
                int device = getDeviceForStream(AudioSystem.STREAM_MUSIC);

                if ((device & mSafeMediaVolumeDevices) != 0) {
                    sendMsg(mAudioHandler,
                            MSG_CHECK_MUSIC_ACTIVE,
                            SENDMSG_REPLACE,
                            0,
                            0,
                            caller,
                            MUSIC_ACTIVE_POLL_PERIOD_MS);
                    int index = mStreamStates[AudioSystem.STREAM_MUSIC].getIndex(device);
                    if (AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC, 0) &&
                            (index > safeMediaVolumeIndex(device))) {
                        // Approximate cumulative active music time
                        mMusicActiveMs += MUSIC_ACTIVE_POLL_PERIOD_MS;
                        if (mMusicActiveMs > UNSAFE_VOLUME_MUSIC_ACTIVE_MS_MAX) {
                            setSafeMediaVolumeEnabled(true, caller);
                            mMusicActiveMs = 0;
                        }
                        saveMusicActiveMs();
                    }
                }
            }
        }
    }

    private void saveMusicActiveMs() {
        mAudioHandler.obtainMessage(MSG_PERSIST_MUSIC_ACTIVE_MS, mMusicActiveMs, 0).sendToTarget();
    }

    private int getSafeUsbMediaVolumeIndex()
    {
        // determine UI volume index corresponding to the wanted safe gain in dBFS
        int min = MIN_STREAM_VOLUME[AudioSystem.STREAM_MUSIC];
        int max = MAX_STREAM_VOLUME[AudioSystem.STREAM_MUSIC];

        mSafeUsbMediaVolumeDbfs = mContext.getResources().getInteger(
                com.android.internal.R.integer.config_safe_media_volume_usb_mB) / 100.0f;

        while (Math.abs(max-min) > 1) {
            int index = (max + min) / 2;
            float gainDB = AudioSystem.getStreamVolumeDB(
                    AudioSystem.STREAM_MUSIC, index, AudioSystem.DEVICE_OUT_USB_HEADSET);
            if (Float.isNaN(gainDB)) {
                //keep last min in case of read error
                break;
            } else if (gainDB == mSafeUsbMediaVolumeDbfs) {
                min = index;
                break;
            } else if (gainDB < mSafeUsbMediaVolumeDbfs) {
                min = index;
            } else {
                max = index;
            }
        }
        return min * 10;
    }

    private void onConfigureSafeVolume(boolean force, String caller) {
        synchronized (mSafeMediaVolumeStateLock) {
            int mcc = mContext.getResources().getConfiguration().mcc;
            if ((mMcc != mcc) || ((mMcc == 0) && force)) {
                mSafeMediaVolumeIndex = mContext.getResources().getInteger(
                        com.android.internal.R.integer.config_safe_media_volume_index) * 10;

                mSafeUsbMediaVolumeIndex = getSafeUsbMediaVolumeIndex();

                boolean safeMediaVolumeEnabled =
                        SystemProperties.getBoolean(""audio.safemedia.force"", false)
                        || mContext.getResources().getBoolean(
                                com.android.internal.R.bool.config_safe_media_volume_enabled);

","    public void clearAllScoClients(int exceptPid, boolean stopSco) {
        synchronized(mScoClients) {
            ScoClient savedClient = null;
            for (ScoClient cl : mScoClients) {
                if (cl.getPid() != exceptPid) {
                    cl.clearCount(stopSco);
                } else {
                    savedClient = cl;
                }
            }
            mScoClients.clear();
            if (savedClient != null) {
                mScoClients.add(savedClient);
            }
        }
    }

    private boolean getBluetoothHeadset() {
        boolean result = false;
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if (adapter != null) {
            result = adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
                                    BluetoothProfile.HEADSET);
        }
        // If we could not get a bluetooth headset proxy, send a failure message
        // without delay to reset the SCO audio state and clear SCO clients.
        // If we could get a proxy, send a delayed failure message that will reset our state
        // in case we don't receive onServiceConnected().
        sendMsg(mAudioHandler, MSG_BT_HEADSET_CNCT_FAILED,
                SENDMSG_REPLACE, 0, 0, null, result ? BT_HEADSET_CNCT_TIMEOUT_MS : 0);
        return result;
    }

    /**
     * Disconnect all SCO connections started by {@link AudioManager} except those started by
     * {@param exceptPid}
     *
     * @param exceptPid pid whose SCO connections through {@link AudioManager} should be kept
     */
    private void disconnectBluetoothSco(int exceptPid) {
        Log.i(TAG, ""In disconnectBluetoothSco(), exceptPid: "" + exceptPid);
        synchronized(mScoClients) {
            checkScoAudioState();
            if (mScoAudioState == SCO_STATE_ACTIVE_EXTERNAL) {
                return;
            }
            clearAllScoClients(exceptPid, true);
        }
    }

    private static boolean disconnectBluetoothScoAudioHelper(BluetoothHeadset bluetoothHeadset,
            BluetoothDevice device, int scoAudioMode) {
        Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), scoAudioMode: "" + scoAudioMode +
               "", bluetoothHeadset: "" + bluetoothHeadset + "", BluetoothDevice: "" + device);
        switch (scoAudioMode) {
            case SCO_MODE_RAW:
                Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), calling disconnectAudio()"");
                return bluetoothHeadset.disconnectAudio();
            case SCO_MODE_VIRTUAL_CALL:
                Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), calling "" +
                           ""stopScoUsingVirtualVoiceCall()"");
                return bluetoothHeadset.stopScoUsingVirtualVoiceCall();
            case SCO_MODE_VR:
                Log.i(TAG, ""In disconnectBluetoothScoAudioHelper(), calling "" +
                           ""stopVoiceRecognition()"");
                return bluetoothHeadset.stopVoiceRecognition(device);
            default:
                return false;
        }
    }

    private static boolean connectBluetoothScoAudioHelper(BluetoothHeadset bluetoothHeadset,
            BluetoothDevice device, int scoAudioMode) {
        Log.i(TAG, ""In connectBluetoothScoAudioHelper(), scoAudioMode: "" + scoAudioMode +
               "", bluetoothHeadset: "" + bluetoothHeadset + "", BluetoothDevice: "" + device);
        switch (scoAudioMode) {
            case SCO_MODE_RAW:
                Log.i(TAG, ""In connectBluetoothScoAudioHelper(), calling connectAudio()"");
                return bluetoothHeadset.connectAudio();
            case SCO_MODE_VIRTUAL_CALL:
                Log.i(TAG, ""In connectBluetoothScoAudioHelper(), calling ""
                       + ""startScoUsingVirtualVoiceCall()"");
                return bluetoothHeadset.startScoUsingVirtualVoiceCall();
            case SCO_MODE_VR:
                Log.i(TAG, ""In connectBluetoothScoAudioHelper(), calling ""
                       + ""startVoiceRecognition()"");
                return bluetoothHeadset.startVoiceRecognition(device);
            default:
                return false;
        }
    }

    private void resetBluetoothSco() {
        synchronized(mScoClients) {
            Log.i(TAG, ""In resetBluetoothSco(), calling clearAllScoClients()"");
            clearAllScoClients(0, false);
            mScoAudioState = SCO_STATE_INACTIVE;
            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
        }
        mScoClientDevices.clear();
        AudioSystem.setParameters(""A2dpSuspended=false"");
        setBluetoothScoOnInt(false, ""resetBluetoothSco"");
    }

    private void broadcastScoConnectionState(int state) {
        sendMsg(mAudioHandler, MSG_BROADCAST_BT_CONNECTION_STATE,
                SENDMSG_QUEUE, state, 0, null, 0);
    }

    private void onBroadcastScoConnectionState(int state) {
        if (state != mScoConnectionState) {
            Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_UPDATED);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, state);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_PREVIOUS_STATE,
                    mScoConnectionState);
            sendStickyBroadcastToAll(newIntent);
            mScoConnectionState = state;
        }
    }

    private boolean handleBtScoActiveDeviceChange(BluetoothDevice btDevice, boolean isActive) {
        if (btDevice == null) {
            return true;
        }

        String address = btDevice.getAddress();
        BluetoothClass btClass = btDevice.getBluetoothClass();
        int inDevice = AudioSystem.DEVICE_IN_BLUETOOTH_SCO_HEADSET;
        int[] outDeviceTypes = {
            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,
            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET,
            AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT
        };
        if (btClass != null) {
            switch (btClass.getDeviceClass()) {
                case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
                case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                    outDeviceTypes = new int[] { AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET };
                    break;
                case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                    outDeviceTypes = new int[] { AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT };
                    break;
            }
        }
        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
            address = """";
        }
        String btDeviceName =  btDevice.getName();
        if (btDeviceName == null) {
            Slog.i(TAG, ""handleBtScoActiveDeviceChange: btDeviceName is null,"" +
                       "" sending empty string"");
            btDeviceName = """";
        }

        boolean result = false;
        if (isActive) {
            result |= handleDeviceConnection(isActive, outDeviceTypes[0], address, btDeviceName);
        } else {
            for (int outDeviceType : outDeviceTypes) {
                result |= handleDeviceConnection(isActive, outDeviceType, address, btDeviceName);
            }
        }

        // handleDeviceConnection() && result to make sure the method get executed
        result = handleDeviceConnection(isActive, inDevice, address, btDeviceName) && result;
        Slog.i(TAG, ""for inDevice"" + inDevice + "" result is "" + result);
        return result;
    }

    private void setBtScoActiveDevice(BluetoothDevice btDevice) {
        synchronized (mScoClients) {
            Log.i(TAG, ""setBtScoActiveDevice: "" + mBluetoothHeadsetDevice + "" -> "" + btDevice);
            final BluetoothDevice previousActiveDevice = mBluetoothHeadsetDevice;
            if (mBluetoothHeadsetDevice != null && mBluetoothHeadsetDevice.isTwsPlusDevice()
               && btDevice != null
               && Objects.equals(mBluetoothHeadsetDevice.getTwsPlusPeerAddress(), btDevice.getAddress())) {
                Log.i(TAG, ""setBtScoActiveDevice: Active device switch between twsplus devices"");
                //Keep the same mBluetoothHeadsetDevice as current Active so
                //that It tears down when active becomes null
                return;
            }
            if (!Objects.equals(btDevice, previousActiveDevice)) {
                if (!handleBtScoActiveDeviceChange(previousActiveDevice, false)) {
                    Log.w(TAG, ""setBtScoActiveDevice() failed to remove previous device ""
                            + previousActiveDevice);
                }
                if (!handleBtScoActiveDeviceChange(btDevice, true)) {
                    Log.e(TAG, ""setBtScoActiveDevice() failed to add new device "" + btDevice);
                    // set mBluetoothHeadsetDevice to null when failing to add new device
                    btDevice = null;
                }
                mBluetoothHeadsetDevice = btDevice;
                if (mBluetoothHeadsetDevice == null) {
                    Log.i(TAG, ""In setBtScoActiveDevice(), calling resetBluetoothSco()"");
                    resetBluetoothSco();
                }
            }
        }
    }

    private BluetoothProfile.ServiceListener mBluetoothProfileServiceListener =
        new BluetoothProfile.ServiceListener() {
        public void onServiceConnected(int profile, BluetoothProfile proxy) {
            Log.i(TAG, ""In onServiceConnected(), profile: "" + profile +
                  "", proxy: "" + proxy);
            BluetoothDevice btDevice;
            List<BluetoothDevice> deviceList;
            switch(profile) {
            case BluetoothProfile.A2DP:
                synchronized (mConnectedDevices) {
                    synchronized (mA2dpAvrcpLock) {
                        mA2dp = (BluetoothA2dp) proxy;
                        deviceList = mA2dp.getConnectedDevices();
                        if (deviceList.size() > 0) {
                            btDevice = deviceList.get(0);
                            int state = mA2dp.getConnectionState(btDevice);
                            int intState = (state == BluetoothA2dp.STATE_CONNECTED) ? 1 : 0;
                            int delay = checkSendBecomingNoisyIntent(
                                    AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, intState,
                                    AudioSystem.DEVICE_NONE);
                            final String addr = btDevice == null ? ""null"" : btDevice.getAddress();
                            mDeviceLogger.log(new AudioEventLogger.StringEvent(
                                    ""A2DP service connected: device addr="" + addr
                                    + "" state="" + state));
                            queueMsgUnderWakeLock(mAudioHandler,
                                    MSG_SET_A2DP_SINK_CONNECTION_STATE,
                                    state,
                                    0 /* arg2 unused */,
                                    new BluetoothA2dpDeviceInfo(btDevice),
                                    delay);
                        }
                    }
                }
                break;

            case BluetoothProfile.A2DP_SINK:
                deviceList = proxy.getConnectedDevices();
                if (deviceList.size() > 0) {
                    btDevice = deviceList.get(0);
                    synchronized (mConnectedDevices) {
                        int state = proxy.getConnectionState(btDevice);
                        queueMsgUnderWakeLock(mAudioHandler,
                                MSG_SET_A2DP_SRC_CONNECTION_STATE,
                                state,
                                0 /* arg2 unused */,
                                new BluetoothA2dpDeviceInfo(btDevice),
                                0 /* delay */);
                    }
                }
                break;

            case BluetoothProfile.HEADSET:
                synchronized (mScoClients) {
                    // Discard timeout message
                    mAudioHandler.removeMessages(MSG_BT_HEADSET_CNCT_FAILED);
                    mBluetoothHeadset = (BluetoothHeadset) proxy;
                    setBtScoActiveDevice(mBluetoothHeadset.getActiveDevice());
                    // Refresh SCO audio state
                    checkScoAudioState();
                    Log.i(TAG, ""In HEADSET profile, mScoAudioState: "" + mScoAudioState
                          + "", mScoAudioMode: "" + mScoAudioMode);
                    // Continue pending action if any
                    if (mScoAudioState == SCO_STATE_ACTIVATE_REQ ||
                            mScoAudioState == SCO_STATE_DEACTIVATE_REQ) {
                        boolean status = false;
                        if (mBluetoothHeadsetDevice != null) {
                            // Get correct mScoAudioMode
                            mScoAudioMode = new Integer(Settings.Global.getInt(
                                                        mContentResolver,
                                                        ""bluetooth_sco_channel_""+
                                                        mBluetoothHeadsetDevice.getAddress(),
                                                        SCO_MODE_VIRTUAL_CALL));
                            if (mScoAudioMode > SCO_MODE_MAX || mScoAudioMode < 0) {
                                Log.i(TAG, ""Resetting the mScoAudioMode to "" +
                                      ""SCO_MODE_VIRTUAL_CALL"");
                                mScoAudioMode = SCO_MODE_VIRTUAL_CALL;
                            }
                            switch (mScoAudioState) {
                                case SCO_STATE_ACTIVATE_REQ:
                                    Log.i(TAG, ""In HEADSET profile, calling connectBluetoothScoAudioHelper()"");
                                    status = connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                            mBluetoothHeadsetDevice, mScoAudioMode);
                                    if (status) {
                                        mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                                    }
                                    break;
                                case SCO_STATE_DEACTIVATE_REQ:
                                    Log.i(TAG, ""In HEADSET profile, calling disconnectBluetoothScoAudioHelper()"");
                                    status = disconnectBluetoothScoAudioHelper(mBluetoothHeadset,
                                            mBluetoothHeadsetDevice, mScoAudioMode);
                                    if (status) {
                                        mScoAudioState = SCO_STATE_DEACTIVATING;
                                    }
                                    break;
                            }
                        }
                        if (!status) {
                            mScoAudioState = SCO_STATE_INACTIVE;
                            broadcastScoConnectionState(AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
                        }
                    }
                }
                break;

            case BluetoothProfile.HEARING_AID:
                synchronized (mConnectedDevices) {
                    synchronized (mHearingAidLock) {
                        mHearingAid = (BluetoothHearingAid) proxy;
                        deviceList = mHearingAid.getConnectedDevices();
                        if (deviceList.size() > 0) {
                            btDevice = deviceList.get(0);
                            int state = mHearingAid.getConnectionState(btDevice);
                            int intState = (state == BluetoothHearingAid.STATE_CONNECTED) ? 1 : 0;
                            int delay = checkSendBecomingNoisyIntent(
                                    AudioSystem.DEVICE_OUT_HEARING_AID, intState,
                                    AudioSystem.DEVICE_NONE);
                            queueMsgUnderWakeLock(mAudioHandler,
                                    MSG_SET_HEARING_AID_CONNECTION_STATE,
                                    state,
                                    0 /* arg2 unused */,
                                    btDevice,
                                    delay);
                        }
                    }
                }

                break;

            default:
                break;
            }
        }
        public void onServiceDisconnected(int profile) {

            switch (profile) {
            case BluetoothProfile.A2DP:
                disconnectA2dp();
                break;

            case BluetoothProfile.A2DP_SINK:
                disconnectA2dpSink();
                break;

            case BluetoothProfile.HEADSET:
                 Log.i(TAG, ""In onServiceDisconnected(), calling disconnectHeadset()"");
                disconnectHeadset();
                break;

            case BluetoothProfile.HEARING_AID:
                disconnectHearingAid();
                break;

            default:
                break;
            }
        }
    };

    void disconnectAllBluetoothProfiles() {
        disconnectA2dp();
        disconnectA2dpSink();
        disconnectHeadset();
        disconnectHearingAid();
    }

    void disconnectA2dp() {
        synchronized (mConnectedDevices) {
            synchronized (mA2dpAvrcpLock) {
                ArraySet<String> toRemove = null;
                // Disconnect ALL DEVICE_OUT_BLUETOOTH_A2DP devices
                for (int i = 0; i < mConnectedDevices.size(); i++) {
                    DeviceListSpec deviceSpec = mConnectedDevices.valueAt(i);
                    if (deviceSpec.mDeviceType == AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) {
                        toRemove = toRemove != null ? toRemove : new ArraySet<String>();
                        toRemove.add(deviceSpec.mDeviceAddress);
                    }
                }
                if (toRemove != null) {
                    int delay = checkSendBecomingNoisyIntent(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
                            0, AudioSystem.DEVICE_NONE);
                    for (int i = 0; i < toRemove.size(); i++) {
                        makeA2dpDeviceUnavailableLater(toRemove.valueAt(i), delay);
                    }
                }
            }
        }
    }

    void disconnectA2dpSink() {
        synchronized (mConnectedDevices) {
            ArraySet<String> toRemove = null;
            // Disconnect ALL DEVICE_IN_BLUETOOTH_A2DP devices
            for(int i = 0; i < mConnectedDevices.size(); i++) {
                DeviceListSpec deviceSpec = mConnectedDevices.valueAt(i);
                if (deviceSpec.mDeviceType == AudioSystem.DEVICE_IN_BLUETOOTH_A2DP) {
                    toRemove = toRemove != null ? toRemove : new ArraySet<String>();
                    toRemove.add(deviceSpec.mDeviceAddress);
                }
            }
            if (toRemove != null) {
                for (int i = 0; i < toRemove.size(); i++) {
                    makeA2dpSrcUnavailable(toRemove.valueAt(i));
                }
            }
        }
    }

    void disconnectHeadset() {
        synchronized (mScoClients) {
            setBtScoActiveDevice(null);
            mBluetoothHeadset = null;
        }
    }

    void disconnectHearingAid() {
        synchronized (mConnectedDevices) {
            synchronized (mHearingAidLock) {
                ArraySet<String> toRemove = null;
                // Disconnect ALL DEVICE_OUT_HEARING_AID devices
                for (int i = 0; i < mConnectedDevices.size(); i++) {
                    DeviceListSpec deviceSpec = mConnectedDevices.valueAt(i);
                    if (deviceSpec.mDeviceType == AudioSystem.DEVICE_OUT_HEARING_AID) {
                        toRemove = toRemove != null ? toRemove : new ArraySet<String>();
                        toRemove.add(deviceSpec.mDeviceAddress);
                    }
                }
                if (toRemove != null) {
                    int delay = checkSendBecomingNoisyIntent(AudioSystem.DEVICE_OUT_HEARING_AID,
                            0, AudioSystem.DEVICE_NONE);
                    for (int i = 0; i < toRemove.size(); i++) {
                        makeHearingAidDeviceUnavailable(toRemove.valueAt(i) /*, delay*/);
                    }
                }
            }
        }
    }

    private void onCheckMusicActive(String caller) {
        synchronized (mSafeMediaVolumeStateLock) {
            if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_INACTIVE) {
                int device = getDeviceForStream(AudioSystem.STREAM_MUSIC);

                if ((device & mSafeMediaVolumeDevices) != 0) {
                    sendMsg(mAudioHandler,
                            MSG_CHECK_MUSIC_ACTIVE,
                            SENDMSG_REPLACE,
                            0,
                            0,
                            caller,
                            MUSIC_ACTIVE_POLL_PERIOD_MS);
                    int index = mStreamStates[AudioSystem.STREAM_MUSIC].getIndex(device);
                    if (AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC, 0) &&
                            (index > safeMediaVolumeIndex(device))) {
                        // Approximate cumulative active music time
                        mMusicActiveMs += MUSIC_ACTIVE_POLL_PERIOD_MS;
                        if (mMusicActiveMs > UNSAFE_VOLUME_MUSIC_ACTIVE_MS_MAX) {
                            setSafeMediaVolumeEnabled(true, caller);
                            mMusicActiveMs = 0;
                        }
                        saveMusicActiveMs();
                    }
                }
            }
        }
    }

    private void saveMusicActiveMs() {
        mAudioHandler.obtainMessage(MSG_PERSIST_MUSIC_ACTIVE_MS, mMusicActiveMs, 0).sendToTarget();
    }

    private int getSafeUsbMediaVolumeIndex()
    {
        // determine UI volume index corresponding to the wanted safe gain in dBFS
        int min = MIN_STREAM_VOLUME[AudioSystem.STREAM_MUSIC];
        int max = MAX_STREAM_VOLUME[AudioSystem.STREAM_MUSIC];

        mSafeUsbMediaVolumeDbfs = mContext.getResources().getInteger(
                com.android.internal.R.integer.config_safe_media_volume_usb_mB) / 100.0f;

        while (Math.abs(max-min) > 1) {
            int index = (max + min) / 2;
            float gainDB = AudioSystem.getStreamVolumeDB(
                    AudioSystem.STREAM_MUSIC, index, AudioSystem.DEVICE_OUT_USB_HEADSET);
            if (Float.isNaN(gainDB)) {
                //keep last min in case of read error
                break;
            } else if (gainDB == mSafeUsbMediaVolumeDbfs) {
                min = index;
                break;
            } else if (gainDB < mSafeUsbMediaVolumeDbfs) {
                min = index;
            } else {
                max = index;
            }
        }
        return min * 10;
    }

    private void onConfigureSafeVolume(boolean force, String caller) {
        synchronized (mSafeMediaVolumeStateLock) {
            int mcc = mContext.getResources().getConfiguration().mcc;
            if ((mMcc != mcc) || ((mMcc == 0) && force)) {
                mSafeMediaVolumeIndex = mContext.getResources().getInteger(
                        com.android.internal.R.integer.config_safe_media_volume_index) * 10;

                mSafeUsbMediaVolumeIndex = getSafeUsbMediaVolumeIndex();

                boolean safeMediaVolumeEnabled =
                        SystemProperties.getBoolean(""audio.safemedia.force"", false)
                        || mContext.getResources().getBoolean(
                                com.android.internal.R.bool.config_safe_media_volume_enabled);

","[1.0, 1.0]"
242,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(5978, 6025, 48), (5978, 6025, 48)]","                    break;

                case MSG_BTA2DP_DOCK_TIMEOUT:
                    // msg.obj  == address of BTA2DP device
                    synchronized (mConnectedDevices) {
                        makeA2dpDeviceUnavailableNow((String) msg.obj, msg.arg1);
                    }
                    mAudioEventWakeLock.release();
                    break;

                case MSG_SET_FORCE_USE:
                case MSG_SET_FORCE_BT_A2DP_USE:
                    setForceUse(msg.arg1, msg.arg2, (String) msg.obj);
                    break;

                case MSG_BT_HEADSET_CNCT_FAILED:
                    Log.i(TAG, ""In handleMessage(), calling resetBluetoothSco()"");
                    resetBluetoothSco();
                    break;

                case MSG_SET_WIRED_DEVICE_CONNECTION_STATE:
                    {   WiredDeviceConnectionState connectState =
                            (WiredDeviceConnectionState)msg.obj;
                        mDeviceLogger.log(new WiredDevConnectEvent(connectState));
                        onSetWiredDeviceConnectionState(connectState.mType, connectState.mState,
                                connectState.mAddress, connectState.mName, connectState.mCaller);
                        mAudioEventWakeLock.release();
                    }
                    break;

                case MSG_SET_A2DP_SRC_CONNECTION_STATE:
                    onSetA2dpSourceConnectionState((BluetoothA2dpDeviceInfo) msg.obj, msg.arg1);
                    mAudioEventWakeLock.release();
                    break;

                case MSG_SET_A2DP_SINK_CONNECTION_STATE:
                    onSetA2dpSinkConnectionState((BluetoothA2dpDeviceInfo) msg.obj, msg.arg1);
                    mAudioEventWakeLock.release();
                    break;

                case MSG_SET_HEARING_AID_CONNECTION_STATE:
                    onSetHearingAidConnectionState((BluetoothDevice)msg.obj, msg.arg1);
                    mAudioEventWakeLock.release();
                    break;

                case MSG_A2DP_DEVICE_CONFIG_CHANGE:
                    onBluetoothA2dpDeviceConfigChange((BluetoothA2dpDeviceInfo) msg.obj);
                    mAudioEventWakeLock.release();
","                    break;

                case MSG_BTA2DP_DOCK_TIMEOUT:
                    // msg.obj  == address of BTA2DP device
                    synchronized (mConnectedDevices) {
                        makeA2dpDeviceUnavailableNow((String) msg.obj, msg.arg1);
                    }
                    mAudioEventWakeLock.release();
                    break;

                case MSG_SET_FORCE_USE:
                case MSG_SET_FORCE_BT_A2DP_USE:
                    setForceUse(msg.arg1, msg.arg2, (String) msg.obj);
                    break;

                case MSG_BT_HEADSET_CNCT_FAILED:
                    Log.i(TAG, ""In handleMessage(), calling resetBluetoothSco()"");
                    resetBluetoothSco();
                    break;

                case MSG_SET_WIRED_DEVICE_CONNECTION_STATE:
                    {   WiredDeviceConnectionState connectState =
                            (WiredDeviceConnectionState)msg.obj;
                        mDeviceLogger.log(new WiredDevConnectEvent(connectState));
                        onSetWiredDeviceConnectionState(connectState.mType, connectState.mState,
                                connectState.mAddress, connectState.mName, connectState.mCaller);
                        mAudioEventWakeLock.release();
                    }
                    break;

                case MSG_SET_A2DP_SRC_CONNECTION_STATE:
                    onSetA2dpSourceConnectionState((BluetoothA2dpDeviceInfo) msg.obj, msg.arg1);
                    mAudioEventWakeLock.release();
                    break;

                case MSG_SET_A2DP_SINK_CONNECTION_STATE:
                    onSetA2dpSinkConnectionState((BluetoothA2dpDeviceInfo) msg.obj, msg.arg1);
                    mAudioEventWakeLock.release();
                    break;

                case MSG_SET_HEARING_AID_CONNECTION_STATE:
                    onSetHearingAidConnectionState((BluetoothDevice)msg.obj, msg.arg1);
                    mAudioEventWakeLock.release();
                    break;

                case MSG_A2DP_DEVICE_CONFIG_CHANGE:
                    onBluetoothA2dpDeviceConfigChange((BluetoothA2dpDeviceInfo) msg.obj);
                    mAudioEventWakeLock.release();
","                    break;

                case MSG_BTA2DP_DOCK_TIMEOUT:
                    // msg.obj  == address of BTA2DP device
                    synchronized (mConnectedDevices) {
                        makeA2dpDeviceUnavailableNow((String) msg.obj, msg.arg1);
                    }
                    mAudioEventWakeLock.release();
                    break;

                case MSG_SET_FORCE_USE:
                case MSG_SET_FORCE_BT_A2DP_USE:
                    setForceUse(msg.arg1, msg.arg2, (String) msg.obj);
                    break;

                case MSG_BT_HEADSET_CNCT_FAILED:
                    Log.i(TAG, ""In handleMessage(), calling resetBluetoothSco()"");
                    resetBluetoothSco();
                    break;

                case MSG_SET_WIRED_DEVICE_CONNECTION_STATE:
                    {   WiredDeviceConnectionState connectState =
                            (WiredDeviceConnectionState)msg.obj;
                        mDeviceLogger.log(new WiredDevConnectEvent(connectState));
                        onSetWiredDeviceConnectionState(connectState.mType, connectState.mState,
                                connectState.mAddress, connectState.mName, connectState.mCaller);
                        mAudioEventWakeLock.release();
                    }
                    break;

                case MSG_SET_A2DP_SRC_CONNECTION_STATE:
                    onSetA2dpSourceConnectionState((BluetoothA2dpDeviceInfo) msg.obj, msg.arg1);
                    mAudioEventWakeLock.release();
                    break;

                case MSG_SET_A2DP_SINK_CONNECTION_STATE:
                    onSetA2dpSinkConnectionState((BluetoothA2dpDeviceInfo) msg.obj, msg.arg1);
                    mAudioEventWakeLock.release();
                    break;

                case MSG_SET_HEARING_AID_CONNECTION_STATE:
                    onSetHearingAidConnectionState((BluetoothDevice)msg.obj, msg.arg1);
                    mAudioEventWakeLock.release();
                    break;

                case MSG_A2DP_DEVICE_CONFIG_CHANGE:
                    onBluetoothA2dpDeviceConfigChange((BluetoothA2dpDeviceInfo) msg.obj);
                    mAudioEventWakeLock.release();
","[1.0, 1.0]"
243,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(6610, 6706, 97), (6610, 6706, 97)]","        }
    }

    private boolean handleDeviceConnection(boolean connect, int device, String address,
            String deviceName) {
        if (DEBUG_DEVICES) {
            Slog.i(TAG, ""handleDeviceConnection("" + connect + "" dev:"" + Integer.toHexString(device)
                    + "" address:"" + address + "" name:"" + deviceName + "")"");
        }
        synchronized (mConnectedDevices) {
            String deviceKey = makeDeviceListKey(device, address);
            if (DEBUG_DEVICES) {
                Slog.i(TAG, ""deviceKey:"" + deviceKey);
            }
            DeviceListSpec deviceSpec = mConnectedDevices.get(deviceKey);
            boolean isConnected = deviceSpec != null;
            if (DEBUG_DEVICES) {
                Slog.i(TAG, ""deviceSpec:"" + deviceSpec + "" is(already)Connected:"" + isConnected);
            }
            if (connect && !isConnected) {
                final int res = AudioSystem.setDeviceConnectionState(device,
                        AudioSystem.DEVICE_STATE_AVAILABLE, address, deviceName,
                        AudioSystem.AUDIO_FORMAT_DEFAULT);
                if (res != AudioSystem.AUDIO_STATUS_OK) {
                    Slog.e(TAG, ""not connecting device 0x"" + Integer.toHexString(device) +
                            "" due to command error "" + res );
                    return false;
                }
                mConnectedDevices.put(deviceKey, new DeviceListSpec(device,
                                deviceName, address, AudioSystem.AUDIO_FORMAT_DEFAULT));
                sendMsg(mAudioHandler, MSG_ACCESSORY_PLUG_MEDIA_UNMUTE, SENDMSG_QUEUE,
                        device, 0, null, 0);
                return true;
            } else if (!connect && isConnected) {
                AudioSystem.setDeviceConnectionState(device,
                        AudioSystem.DEVICE_STATE_UNAVAILABLE, address, deviceName,
                        AudioSystem.AUDIO_FORMAT_DEFAULT);
                // always remove even if disconnection failed
                mConnectedDevices.remove(deviceKey);
                return true;
            }
            Log.w(TAG, ""handleDeviceConnection() failed, deviceKey="" + deviceKey + "", deviceSpec=""
                       + deviceSpec + "", connect="" + connect);
        }

        Slog.e(TAG, ""handleDeviceConnection: returning false"");
        return false;
    }

    // Devices which removal triggers intent ACTION_AUDIO_BECOMING_NOISY. The intent is only
    // sent if:
    // - none of these devices are connected anymore after one is disconnected AND
    // - the device being disconnected is actually used for music.
    // Access synchronized on mConnectedDevices
    int mBecomingNoisyIntentDevices =
            AudioSystem.DEVICE_OUT_WIRED_HEADSET | AudioSystem.DEVICE_OUT_WIRED_HEADPHONE |
            AudioSystem.DEVICE_OUT_ALL_A2DP | AudioSystem.DEVICE_OUT_HDMI |
            AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET | AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET |
            AudioSystem.DEVICE_OUT_ALL_USB | AudioSystem.DEVICE_OUT_LINE |
            AudioSystem.DEVICE_OUT_HEARING_AID;

    // must be called before removing the device from mConnectedDevices
    // Called synchronized on mConnectedDevices
    // musicDevice argument is used when not AudioSystem.DEVICE_NONE instead of querying
    // from AudioSystem
    private int checkSendBecomingNoisyIntent(int device, int state, int musicDevice) {
        int delay = 0;
        if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
            int devices = 0;
            for (int i = 0; i < mConnectedDevices.size(); i++) {
                int dev = mConnectedDevices.valueAt(i).mDeviceType;
                if (((dev & AudioSystem.DEVICE_BIT_IN) == 0)
                        && ((dev & mBecomingNoisyIntentDevices) != 0)) {
                    devices |= dev;
                }
            }
            if (musicDevice == AudioSystem.DEVICE_NONE) {
                musicDevice = getDeviceForStream(AudioSystem.STREAM_MUSIC);
            }
            // ignore condition on device being actually used for music when in communication
            // because music routing is altered in this case.
            // also checks whether media routing if affected by a dynamic policy
            if (((device == musicDevice) || isInCommunication()) && (device == devices)
                    && !hasMediaDynamicPolicy()) {
                mAudioHandler.removeMessages(MSG_BROADCAST_AUDIO_BECOMING_NOISY);
                sendMsg(mAudioHandler,
                        MSG_BROADCAST_AUDIO_BECOMING_NOISY,
                        SENDMSG_REPLACE,
                        0,
                        0,
                        null,
                        0);
                delay = SystemProperties.getInt(""vendor.audio.noisy.broadcast.delay"", 700);
            }
        }

        return delay;
","        }
    }

    private boolean handleDeviceConnection(boolean connect, int device, String address,
            String deviceName) {
        if (DEBUG_DEVICES) {
            Slog.i(TAG, ""handleDeviceConnection("" + connect + "" dev:"" + Integer.toHexString(device)
                    + "" address:"" + address + "" name:"" + deviceName + "")"");
        }
        synchronized (mConnectedDevices) {
            String deviceKey = makeDeviceListKey(device, address);
            if (DEBUG_DEVICES) {
                Slog.i(TAG, ""deviceKey:"" + deviceKey);
            }
            DeviceListSpec deviceSpec = mConnectedDevices.get(deviceKey);
            boolean isConnected = deviceSpec != null;
            if (DEBUG_DEVICES) {
                Slog.i(TAG, ""deviceSpec:"" + deviceSpec + "" is(already)Connected:"" + isConnected);
            }
            if (connect && !isConnected) {
                final int res = AudioSystem.setDeviceConnectionState(device,
                        AudioSystem.DEVICE_STATE_AVAILABLE, address, deviceName,
                        AudioSystem.AUDIO_FORMAT_DEFAULT);
                if (res != AudioSystem.AUDIO_STATUS_OK) {
                    Slog.e(TAG, ""not connecting device 0x"" + Integer.toHexString(device) +
                            "" due to command error "" + res );
                    return false;
                }
                mConnectedDevices.put(deviceKey, new DeviceListSpec(device,
                                deviceName, address, AudioSystem.AUDIO_FORMAT_DEFAULT));
                sendMsg(mAudioHandler, MSG_ACCESSORY_PLUG_MEDIA_UNMUTE, SENDMSG_QUEUE,
                        device, 0, null, 0);
                return true;
            } else if (!connect && isConnected) {
                AudioSystem.setDeviceConnectionState(device,
                        AudioSystem.DEVICE_STATE_UNAVAILABLE, address, deviceName,
                        AudioSystem.AUDIO_FORMAT_DEFAULT);
                // always remove even if disconnection failed
                mConnectedDevices.remove(deviceKey);
                return true;
            }
            Log.w(TAG, ""handleDeviceConnection() failed, deviceKey="" + deviceKey + "", deviceSpec=""
                       + deviceSpec + "", connect="" + connect);
        }

        Slog.e(TAG, ""handleDeviceConnection: returning false"");
        return false;
    }

    // Devices which removal triggers intent ACTION_AUDIO_BECOMING_NOISY. The intent is only
    // sent if:
    // - none of these devices are connected anymore after one is disconnected AND
    // - the device being disconnected is actually used for music.
    // Access synchronized on mConnectedDevices
    int mBecomingNoisyIntentDevices =
            AudioSystem.DEVICE_OUT_WIRED_HEADSET | AudioSystem.DEVICE_OUT_WIRED_HEADPHONE |
            AudioSystem.DEVICE_OUT_ALL_A2DP | AudioSystem.DEVICE_OUT_HDMI |
            AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET | AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET |
            AudioSystem.DEVICE_OUT_ALL_USB | AudioSystem.DEVICE_OUT_LINE |
            AudioSystem.DEVICE_OUT_HEARING_AID;

    // must be called before removing the device from mConnectedDevices
    // Called synchronized on mConnectedDevices
    // musicDevice argument is used when not AudioSystem.DEVICE_NONE instead of querying
    // from AudioSystem
    private int checkSendBecomingNoisyIntent(int device, int state, int musicDevice) {
        int delay = 0;
        if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
            int devices = 0;
            for (int i = 0; i < mConnectedDevices.size(); i++) {
                int dev = mConnectedDevices.valueAt(i).mDeviceType;
                if (((dev & AudioSystem.DEVICE_BIT_IN) == 0)
                        && ((dev & mBecomingNoisyIntentDevices) != 0)) {
                    devices |= dev;
                }
            }
            if (musicDevice == AudioSystem.DEVICE_NONE) {
                musicDevice = getDeviceForStream(AudioSystem.STREAM_MUSIC);
            }
            // ignore condition on device being actually used for music when in communication
            // because music routing is altered in this case.
            // also checks whether media routing if affected by a dynamic policy
            if (((device == musicDevice) || isInCommunication()) && (device == devices)
                    && !hasMediaDynamicPolicy()) {
                mAudioHandler.removeMessages(MSG_BROADCAST_AUDIO_BECOMING_NOISY);
                sendMsg(mAudioHandler,
                        MSG_BROADCAST_AUDIO_BECOMING_NOISY,
                        SENDMSG_REPLACE,
                        0,
                        0,
                        null,
                        0);
                delay = SystemProperties.getInt(""vendor.audio.noisy.broadcast.delay"", 700);
            }
        }

        return delay;
","        }
    }

    private boolean handleDeviceConnection(boolean connect, int device, String address,
            String deviceName) {
        if (DEBUG_DEVICES) {
            Slog.i(TAG, ""handleDeviceConnection("" + connect + "" dev:"" + Integer.toHexString(device)
                    + "" address:"" + address + "" name:"" + deviceName + "")"");
        }
        synchronized (mConnectedDevices) {
            String deviceKey = makeDeviceListKey(device, address);
            if (DEBUG_DEVICES) {
                Slog.i(TAG, ""deviceKey:"" + deviceKey);
            }
            DeviceListSpec deviceSpec = mConnectedDevices.get(deviceKey);
            boolean isConnected = deviceSpec != null;
            if (DEBUG_DEVICES) {
                Slog.i(TAG, ""deviceSpec:"" + deviceSpec + "" is(already)Connected:"" + isConnected);
            }
            if (connect && !isConnected) {
                final int res = AudioSystem.setDeviceConnectionState(device,
                        AudioSystem.DEVICE_STATE_AVAILABLE, address, deviceName,
                        AudioSystem.AUDIO_FORMAT_DEFAULT);
                if (res != AudioSystem.AUDIO_STATUS_OK) {
                    Slog.e(TAG, ""not connecting device 0x"" + Integer.toHexString(device) +
                            "" due to command error "" + res );
                    return false;
                }
                mConnectedDevices.put(deviceKey, new DeviceListSpec(device,
                                deviceName, address, AudioSystem.AUDIO_FORMAT_DEFAULT));
                sendMsg(mAudioHandler, MSG_ACCESSORY_PLUG_MEDIA_UNMUTE, SENDMSG_QUEUE,
                        device, 0, null, 0);
                return true;
            } else if (!connect && isConnected) {
                AudioSystem.setDeviceConnectionState(device,
                        AudioSystem.DEVICE_STATE_UNAVAILABLE, address, deviceName,
                        AudioSystem.AUDIO_FORMAT_DEFAULT);
                // always remove even if disconnection failed
                mConnectedDevices.remove(deviceKey);
                return true;
            }
            Log.w(TAG, ""handleDeviceConnection() failed, deviceKey="" + deviceKey + "", deviceSpec=""
                       + deviceSpec + "", connect="" + connect);
        }

        Slog.e(TAG, ""handleDeviceConnection: returning false"");
        return false;
    }

    // Devices which removal triggers intent ACTION_AUDIO_BECOMING_NOISY. The intent is only
    // sent if:
    // - none of these devices are connected anymore after one is disconnected AND
    // - the device being disconnected is actually used for music.
    // Access synchronized on mConnectedDevices
    int mBecomingNoisyIntentDevices =
            AudioSystem.DEVICE_OUT_WIRED_HEADSET | AudioSystem.DEVICE_OUT_WIRED_HEADPHONE |
            AudioSystem.DEVICE_OUT_ALL_A2DP | AudioSystem.DEVICE_OUT_HDMI |
            AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET | AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET |
            AudioSystem.DEVICE_OUT_ALL_USB | AudioSystem.DEVICE_OUT_LINE |
            AudioSystem.DEVICE_OUT_HEARING_AID;

    // must be called before removing the device from mConnectedDevices
    // Called synchronized on mConnectedDevices
    // musicDevice argument is used when not AudioSystem.DEVICE_NONE instead of querying
    // from AudioSystem
    private int checkSendBecomingNoisyIntent(int device, int state, int musicDevice) {
        int delay = 0;
        if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
            int devices = 0;
            for (int i = 0; i < mConnectedDevices.size(); i++) {
                int dev = mConnectedDevices.valueAt(i).mDeviceType;
                if (((dev & AudioSystem.DEVICE_BIT_IN) == 0)
                        && ((dev & mBecomingNoisyIntentDevices) != 0)) {
                    devices |= dev;
                }
            }
            if (musicDevice == AudioSystem.DEVICE_NONE) {
                musicDevice = getDeviceForStream(AudioSystem.STREAM_MUSIC);
            }
            // ignore condition on device being actually used for music when in communication
            // because music routing is altered in this case.
            // also checks whether media routing if affected by a dynamic policy
            if (((device == musicDevice) || isInCommunication()) && (device == devices)
                    && !hasMediaDynamicPolicy()) {
                mAudioHandler.removeMessages(MSG_BROADCAST_AUDIO_BECOMING_NOISY);
                sendMsg(mAudioHandler,
                        MSG_BROADCAST_AUDIO_BECOMING_NOISY,
                        SENDMSG_REPLACE,
                        0,
                        0,
                        null,
                        0);
                delay = SystemProperties.getInt(""vendor.audio.noisy.broadcast.delay"", 700);
            }
        }

        return delay;
","[1.0, 1.0]"
244,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(7038, 7110, 73), (7038, 7110, 73)]","            } else if (action.equals(BluetoothHeadset.ACTION_ACTIVE_DEVICE_CHANGED)) {
                BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                Log.i(TAG, ""In onReceive(), calling setBtScoActiveDevice() with ""
                      + ""btDevice: "" + btDevice);
                setBtScoActiveDevice(btDevice);
            } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
                boolean broadcast = false;
                int scoAudioState = AudioManager.SCO_AUDIO_STATE_ERROR;
                synchronized (mScoClients) {
                    int btState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
                    // broadcast intent if the connection was initated by AudioService
                    if (!mScoClients.isEmpty() &&
                            (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL ||
                             mScoAudioState == SCO_STATE_ACTIVATE_REQ ||
                             mScoAudioState == SCO_STATE_DEACTIVATE_REQ ||
                             mScoAudioState == SCO_STATE_DEACTIVATING)) {
                        broadcast = true;
                    }
                    switch (btState) {
                        case BluetoothHeadset.STATE_AUDIO_CONNECTED:
                            if (checkAndUpdatTwsPlusScoState(intent,
                                    BluetoothHeadset.STATE_AUDIO_CONNECTED)) {
                                scoAudioState = AudioManager.SCO_AUDIO_STATE_CONNECTED;
                                if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL &&
                                    mScoAudioState != SCO_STATE_DEACTIVATE_REQ) {
                                    mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                                }
                                setBluetoothScoOn(true);
                                Log.i(TAG, ""Audio-path brought-up"");
                            }
                            break;
                        case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
                            if (checkAndUpdatTwsPlusScoState(intent,
                                   BluetoothHeadset.STATE_AUDIO_DISCONNECTED)) {
                                setBluetoothScoOn(false);
                                scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                                // startBluetoothSco called after stopBluetoothSco
                                if (mScoAudioState == SCO_STATE_ACTIVATE_REQ) {
                                    if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null
                                            && connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                            mBluetoothHeadsetDevice, mScoAudioMode)) {
                                        mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                                        broadcast = false;
                                        break;
                                    }
                                }
                                // Tear down SCO if disconnected from external
                                clearAllScoClients(0, mScoAudioState == SCO_STATE_ACTIVE_INTERNAL);
                                mScoAudioState = SCO_STATE_INACTIVE;
                                Log.i(TAG, ""Audio-path brought-down"");
                            }
                            break;
                        case BluetoothHeadset.STATE_AUDIO_CONNECTING:
                            if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL &&
                                mScoAudioState != SCO_STATE_DEACTIVATE_REQ) {
                                mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                            }
                        default:
                            // do not broadcast CONNECTING or invalid state
                            broadcast = false;
                            break;
                    }
                }
                Log.i(TAG, ""In onReceive(), mScoAudioState: "" + mScoAudioState
                      + "", broadcast: "" + broadcast);
                if (broadcast) {
                    broadcastScoConnectionState(scoAudioState);
                    //FIXME: this is to maintain compatibility with deprecated intent
                    // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
                    Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
                    newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, scoAudioState);
                    sendStickyBroadcastToAll(newIntent);
                }
","            } else if (action.equals(BluetoothHeadset.ACTION_ACTIVE_DEVICE_CHANGED)) {
                BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                Log.i(TAG, ""In onReceive(), calling setBtScoActiveDevice() with ""
                      + ""btDevice: "" + btDevice);
                setBtScoActiveDevice(btDevice);
            } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
                boolean broadcast = false;
                int scoAudioState = AudioManager.SCO_AUDIO_STATE_ERROR;
                synchronized (mScoClients) {
                    int btState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
                    // broadcast intent if the connection was initated by AudioService
                    if (!mScoClients.isEmpty() &&
                            (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL ||
                             mScoAudioState == SCO_STATE_ACTIVATE_REQ ||
                             mScoAudioState == SCO_STATE_DEACTIVATE_REQ ||
                             mScoAudioState == SCO_STATE_DEACTIVATING)) {
                        broadcast = true;
                    }
                    switch (btState) {
                        case BluetoothHeadset.STATE_AUDIO_CONNECTED:
                            if (checkAndUpdatTwsPlusScoState(intent,
                                    BluetoothHeadset.STATE_AUDIO_CONNECTED)) {
                                scoAudioState = AudioManager.SCO_AUDIO_STATE_CONNECTED;
                                if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL &&
                                    mScoAudioState != SCO_STATE_DEACTIVATE_REQ) {
                                    mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                                }
                                setBluetoothScoOn(true);
                                Log.i(TAG, ""Audio-path brought-up"");
                            }
                            break;
                        case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
                            if (checkAndUpdatTwsPlusScoState(intent,
                                   BluetoothHeadset.STATE_AUDIO_DISCONNECTED)) {
                                setBluetoothScoOn(false);
                                scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                                // startBluetoothSco called after stopBluetoothSco
                                if (mScoAudioState == SCO_STATE_ACTIVATE_REQ) {
                                    if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null
                                            && connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                            mBluetoothHeadsetDevice, mScoAudioMode)) {
                                        mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                                        broadcast = false;
                                        break;
                                    }
                                }
                                // Tear down SCO if disconnected from external
                                clearAllScoClients(0, mScoAudioState == SCO_STATE_ACTIVE_INTERNAL);
                                mScoAudioState = SCO_STATE_INACTIVE;
                                Log.i(TAG, ""Audio-path brought-down"");
                            }
                            break;
                        case BluetoothHeadset.STATE_AUDIO_CONNECTING:
                            if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL &&
                                mScoAudioState != SCO_STATE_DEACTIVATE_REQ) {
                                mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                            }
                        default:
                            // do not broadcast CONNECTING or invalid state
                            broadcast = false;
                            break;
                    }
                }
                Log.i(TAG, ""In onReceive(), mScoAudioState: "" + mScoAudioState
                      + "", broadcast: "" + broadcast);
                if (broadcast) {
                    broadcastScoConnectionState(scoAudioState);
                    //FIXME: this is to maintain compatibility with deprecated intent
                    // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
                    Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
                    newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, scoAudioState);
                    sendStickyBroadcastToAll(newIntent);
                }
","            } else if (action.equals(BluetoothHeadset.ACTION_ACTIVE_DEVICE_CHANGED)) {
                BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                Log.i(TAG, ""In onReceive(), calling setBtScoActiveDevice() with ""
                      + ""btDevice: "" + btDevice);
                setBtScoActiveDevice(btDevice);
            } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
                boolean broadcast = false;
                int scoAudioState = AudioManager.SCO_AUDIO_STATE_ERROR;
                synchronized (mScoClients) {
                    int btState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
                    // broadcast intent if the connection was initated by AudioService
                    if (!mScoClients.isEmpty() &&
                            (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL ||
                             mScoAudioState == SCO_STATE_ACTIVATE_REQ ||
                             mScoAudioState == SCO_STATE_DEACTIVATE_REQ ||
                             mScoAudioState == SCO_STATE_DEACTIVATING)) {
                        broadcast = true;
                    }
                    switch (btState) {
                        case BluetoothHeadset.STATE_AUDIO_CONNECTED:
                            if (checkAndUpdatTwsPlusScoState(intent,
                                    BluetoothHeadset.STATE_AUDIO_CONNECTED)) {
                                scoAudioState = AudioManager.SCO_AUDIO_STATE_CONNECTED;
                                if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL &&
                                    mScoAudioState != SCO_STATE_DEACTIVATE_REQ) {
                                    mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                                }
                                setBluetoothScoOn(true);
                                Log.i(TAG, ""Audio-path brought-up"");
                            }
                            break;
                        case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
                            if (checkAndUpdatTwsPlusScoState(intent,
                                   BluetoothHeadset.STATE_AUDIO_DISCONNECTED)) {
                                setBluetoothScoOn(false);
                                scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                                // startBluetoothSco called after stopBluetoothSco
                                if (mScoAudioState == SCO_STATE_ACTIVATE_REQ) {
                                    if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null
                                            && connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                            mBluetoothHeadsetDevice, mScoAudioMode)) {
                                        mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                                        broadcast = false;
                                        break;
                                    }
                                }
                                // Tear down SCO if disconnected from external
                                clearAllScoClients(0, mScoAudioState == SCO_STATE_ACTIVE_INTERNAL);
                                mScoAudioState = SCO_STATE_INACTIVE;
                                Log.i(TAG, ""Audio-path brought-down"");
                            }
                            break;
                        case BluetoothHeadset.STATE_AUDIO_CONNECTING:
                            if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL &&
                                mScoAudioState != SCO_STATE_DEACTIVATE_REQ) {
                                mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                            }
                        default:
                            // do not broadcast CONNECTING or invalid state
                            broadcast = false;
                            break;
                    }
                }
                Log.i(TAG, ""In onReceive(), mScoAudioState: "" + mScoAudioState
                      + "", broadcast: "" + broadcast);
                if (broadcast) {
                    broadcastScoConnectionState(scoAudioState);
                    //FIXME: this is to maintain compatibility with deprecated intent
                    // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
                    Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
                    newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, scoAudioState);
                    sendStickyBroadcastToAll(newIntent);
                }
","[1.0, 1.0]"
245,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/BluetoothAdapter.java,"[(2514, 2518, 5), (2514, 2518, 5)]","            BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
            return true;
        } else if (profile == BluetoothProfile.BA_TRANSMITTER) {
            BluetoothBATransmitter baTransmitter = new BluetoothBATransmitter(context, listener);
            return true;
","            BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
            return true;
        } else if (profile == BluetoothProfile.BA_TRANSMITTER) {
            BluetoothBATransmitter baTransmitter = new BluetoothBATransmitter(context, listener);
            return true;
","            BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
            return true;
        } else if (profile == BluetoothProfile.BA_TRANSMITTER) {
            BluetoothBATransmitter baTransmitter = new BluetoothBATransmitter(context, listener);
            return true;
","[1.0, 1.0]"
246,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(5870, 5880, 11), (5870, 5880, 11)]","         * Setting to configure Wifi disconnect delay duration in seconds.
         * @hide
         **/
        public static final String WIFI_DISCONNECT_DELAY_DURATION =
                ""wifi_disconnect_delay_duration"";

        private static final Validator WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR =
                NON_NEGATIVE_INTEGER_VALIDATOR;

        /**
         * Location access disabled.
","         * Setting to configure Wifi disconnect delay duration in seconds.
         * @hide
         **/
        public static final String WIFI_DISCONNECT_DELAY_DURATION =
                ""wifi_disconnect_delay_duration"";

        private static final Validator WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR =
                NON_NEGATIVE_INTEGER_VALIDATOR;

        /**
         * Location access disabled.
","         * Setting to configure Wifi disconnect delay duration in seconds.
         * @hide
         **/
        public static final String WIFI_DISCONNECT_DELAY_DURATION =
                ""wifi_disconnect_delay_duration"";

        private static final Validator WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR =
                NON_NEGATIVE_INTEGER_VALIDATOR;

        /**
         * Location access disabled.
","[1.0, 1.0]"
247,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerConstants.java,"[(25, 26, 2), (25, 26, 2)]","import android.os.SystemProperties;
import android.os.Process;
","import android.os.SystemProperties;
import android.os.Process;
","import android.os.SystemProperties;
import android.os.Process;
","[1.0, 1.0]"
248,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3546, 3547, 2), (4056, 4056, 1)]","        Log.i(TAG, ""In startBluetoothSco()"");
        int scoAudioMode =
","        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
","        Log.i(TAG, ""In startBluetoothSco","[0.548, 0.702]"
249,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3546, 3547, 2), (4064, 4064, 1)]","        Log.i(TAG, ""In startBluetoothSco()"");
        int scoAudioMode =
","        Log.i(TAG, ""In startBluetoothScoInt(), scoAudioMode: "" + scoAudioMode);
","        Log.i(TAG, ""In startBluetoothSco","[0.548, 0.5]"
250,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3024, 3025, 2), (3272, 3272, 1)]","            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
            disconnectBluetoothSco(newModeOwnerPid);
","            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
","            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
","[0.583, 1.0]"
251,"['567b4cf7b54062947b5eabe6ecef7b70fbb7301b', 'ba167de93776a7e5d1b347d1ee646e161cf24ce5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(3457, 3458, 2), (3206, 3207, 2)]","                case EVENT_UPDATE_TCP_BUFFER_FOR_5G:
                    handleUpdateTCPBuffersfor5G();
","                case EVENT_UPDATE_TCP_BUFFER_FOR_5G:
                    handleUpdateTCPBuffersfor5G();
","                case EVENT_UPDATE_TCP_BUFFER_FOR_5G:
                    handleUpdateTCPBuffersfor5G();
","[1.0, 1.0]"
253,"['587cb520382d349c91bd59ada23fbefcdb44314f', '587cb520382d349c91bd59ada23fbefcdb44314f']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,"[(288, 291, 4), (288, 291, 4)]","        for (TileRecord r : mRecords) {
            r.tile.clearState();
        }
        refreshAllTiles();
","        for (TileRecord r : mRecords) {
            r.tile.clearState();
        }
        refreshAllTiles();
","        for (TileRecord r : mRecords) {
            r.tile.clearState();
        }
        refreshAllTiles();
","[1.0, 1.0]"
254,"['587cb520382d349c91bd59ada23fbefcdb44314f', '587cb520382d349c91bd59ada23fbefcdb44314f']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(5998, 5998, 1), (5998, 5998, 1)]","        // TODO (b/67683350)
","        // TODO (b/67683350)
","        // TODO (b/67683350)
","[1.0, 1.0]"
309,"['595572aed3270fda20949d9c19381969d40ecfd4', '595572aed3270fda20949d9c19381969d40ecfd4']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(271, 276, 6), (271, 276, 6)]","            if (mConfig.readIconsFromXml) {
                return getIcons().mSingleSignalIcon;
            }else {
                return SignalDrawable.getState(level, getNumLevels(),
                        mCurrentState.inetCondition == 0);
            }
","            if (mConfig.readIconsFromXml) {
                return getIcons().mSingleSignalIcon;
            }else {
                return SignalDrawable.getState(level, getNumLevels(),
                        mCurrentState.inetCondition == 0);
            }
","            if (mConfig.readIconsFromXml) {
                return getIcons().mSingleSignalIcon;
            }else {
                return SignalDrawable.getState(level, getNumLevels(),
                        mCurrentState.inetCondition == 0);
            }
","[1.0, 1.0]"
310,"['595572aed3270fda20949d9c19381969d40ecfd4', '595572aed3270fda20949d9c19381969d40ecfd4']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(836, 847, 12), (836, 847, 12)]","                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
                int qsDataType) {
                this(name, sbIcons, qsIcons, contentDesc, sbNullState, qsNullState, sbDiscState,
                        qsDiscState, discContentDesc, dataContentDesc, dataType, isWide,
                        qsDataType, 0, 0, 0, 0);
        }

        public MobileIconGroup(String name, int[][] sbIcons, int[][] qsIcons, int[] contentDesc,
                int sbNullState, int qsNullState, int sbDiscState, int qsDiscState,
                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
                int qsDataType, int singleSignalIcon, int stackedDataIcon,
                int stackedVoicelIcon, int activityId) {
","                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
                int qsDataType) {
                this(name, sbIcons, qsIcons, contentDesc, sbNullState, qsNullState, sbDiscState,
                        qsDiscState, discContentDesc, dataContentDesc, dataType, isWide,
                        qsDataType, 0, 0, 0, 0);
        }

        public MobileIconGroup(String name, int[][] sbIcons, int[][] qsIcons, int[] contentDesc,
                int sbNullState, int qsNullState, int sbDiscState, int qsDiscState,
                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
                int qsDataType, int singleSignalIcon, int stackedDataIcon,
                int stackedVoicelIcon, int activityId) {
","                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
                int qsDataType) {
                this(name, sbIcons, qsIcons, contentDesc, sbNullState, qsNullState, sbDiscState,
                        qsDiscState, discContentDesc, dataContentDesc, dataType, isWide,
                        qsDataType, 0, 0, 0, 0);
        }

        public MobileIconGroup(String name, int[][] sbIcons, int[][] qsIcons, int[] contentDesc,
                int sbNullState, int qsNullState, int sbDiscState, int qsDiscState,
                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
                int qsDataType, int singleSignalIcon, int stackedDataIcon,
                int stackedVoicelIcon, int activityId) {
","[1.0, 1.0]"
311,"['595572aed3270fda20949d9c19381969d40ecfd4', '595572aed3270fda20949d9c19381969d40ecfd4']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(853, 857, 5), (853, 857, 5)]","            mQsDataType = qsDataType;
            mSingleSignalIcon = singleSignalIcon;
            mStackedDataIcon = stackedDataIcon;
            mStackedVoiceIcon = stackedVoicelIcon;
            mActivityId = activityId;
","            mQsDataType = qsDataType;
            mSingleSignalIcon = singleSignalIcon;
            mStackedDataIcon = stackedDataIcon;
            mStackedVoiceIcon = stackedVoicelIcon;
            mActivityId = activityId;
","            mQsDataType = qsDataType;
            mSingleSignalIcon = singleSignalIcon;
            mStackedDataIcon = stackedDataIcon;
            mStackedVoiceIcon = stackedVoicelIcon;
            mActivityId = activityId;
","[1.0, 1.0]"
312,"['59a28bc92ad55fd0c19ce28047f205978aed52ca', '59a28bc92ad55fd0c19ce28047f205978aed52ca']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(3512, 3513, 2), (3512, 3513, 2)]","    public final void networkOptsCheck(int flag, String packageName) {
        mHandler.sendMessage(mHandler.obtainMessage(NETWORK_OPTS_CHECK_MSG, flag, 0, packageName));
","    public final void networkOptsCheck(int flag, String packageName) {
        mHandler.sendMessage(mHandler.obtainMessage(NETWORK_OPTS_CHECK_MSG, flag, 0, packageName));
","    public final void networkOptsCheck(int flag, String packageName) {
        mHandler.sendMessage(mHandler.obtainMessage(NETWORK_OPTS_CHECK_MSG, flag, 0, packageName));
","[1.0, 1.0]"
313,"['59a28bc92ad55fd0c19ce28047f205978aed52ca', '59a28bc92ad55fd0c19ce28047f205978aed52ca']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(25070, 25072, 3), (25070, 25072, 3)]","        ProcessRecord selectedAppRecord = null;
        long serviceLastActivity = 0;
        int numBServices = 0;
","        ProcessRecord selectedAppRecord = null;
        long serviceLastActivity = 0;
        int numBServices = 0;
","        ProcessRecord selectedAppRecord = null;
        long serviceLastActivity = 0;
        int numBServices = 0;
","[1.0, 1.0]"
314,"['645ae5df5346c679626d708a62c0a24d6b294f1a', '645ae5df5346c679626d708a62c0a24d6b294f1a']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/view/Choreographer.java,"[(276, 282, 7), (276, 282, 7)]","     * {@hide}
     */
    public void setMotionEventInfo(int motionEventType, int touchMoveNum) {
        synchronized(this) {
            mTouchMoveNum = touchMoveNum;
            mMotionEventType = motionEventType;
        }
","     * {@hide}
     */
    public void setMotionEventInfo(int motionEventType, int touchMoveNum) {
        synchronized(this) {
            mTouchMoveNum = touchMoveNum;
            mMotionEventType = motionEventType;
        }
","     * {@hide}
     */
    public void setMotionEventInfo(int motionEventType, int touchMoveNum) {
        synchronized(this) {
            mTouchMoveNum = touchMoveNum;
            mMotionEventType = motionEventType;
        }
","[1.0, 1.0]"
319,"['657230bb5e95ec8560c534360cac5a25fd743129', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(156, 156, 1), (156, 156, 1)]","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","[1.0, 1.0]"
320,"['657230bb5e95ec8560c534360cac5a25fd743129', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardSimPinView.java,"[(70, 81, 12), (70, 81, 12)]","                // If the SIM is removed, then we must remove the keyguard. It will be put up
                // again when the PUK locked SIM is re-entered.
                case ABSENT: {
                    KeyguardUpdateMonitor.getInstance(getContext()).reportSimUnlocked(subId);
                    // onSimStateChanged callback can fire when the SIM PIN lock is not currently
                    // active and mCallback is null.
                    if (mCallback != null) {
                        mCallback.dismiss(true, KeyguardUpdateMonitor.getCurrentUser());
                    }
                    mSubId = subId;
                    break;
                }
","                // If the SIM is removed, then we must remove the keyguard. It will be put up
                // again when the PUK locked SIM is re-entered.
                case ABSENT: {
                    KeyguardUpdateMonitor.getInstance(getContext()).reportSimUnlocked(subId);
                    // onSimStateChanged callback can fire when the SIM PIN lock is not currently
                    // active and mCallback is null.
                    if (mCallback != null) {
                        mCallback.dismiss(true, KeyguardUpdateMonitor.getCurrentUser());
                    }
                    mSubId = subId;
                    break;
                }
","                // If the SIM is removed, then we must remove the keyguard. It will be put up
                // again when the PUK locked SIM is re-entered.
                case ABSENT: {
                    KeyguardUpdateMonitor.getInstance(getContext()).reportSimUnlocked(subId);
                    // onSimStateChanged callback can fire when the SIM PIN lock is not currently
                    // active and mCallback is null.
                    if (mCallback != null) {
                        mCallback.dismiss(true, KeyguardUpdateMonitor.getCurrentUser());
                    }
                    mSubId = subId;
                    break;
                }
","[1.0, 1.0]"
321,"['657230bb5e95ec8560c534360cac5a25fd743129', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/pm/PackageVerificationState.java,"[(146, 151, 6), (146, 151, 6)]","    public boolean isVerificationComplete() {
        if (mRequiredVerifierUid != -1 && !mRequiredVerificationComplete) {
            return false;
        }

        if (mHasOptionalVerifier && !mOptionalVerificationComplete) {
","    public boolean isVerificationComplete() {
        if (mRequiredVerifierUid != -1 && !mRequiredVerificationComplete) {
            return false;
        }

        if (mHasOptionalVerifier && !mOptionalVerificationComplete) {
","    public boolean isVerificationComplete() {
        if (mRequiredVerifierUid != -1 && !mRequiredVerificationComplete) {
            return false;
        }

        if (mHasOptionalVerifier && !mOptionalVerificationComplete) {
","[1.0, 1.0]"
322,"['657230bb5e95ec8560c534360cac5a25fd743129', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/pm/PackageVerificationState.java,"[(168, 173, 6), (168, 173, 6)]","    public boolean isInstallAllowed() {
        if (mRequiredVerifierUid != -1 && !mRequiredVerificationPassed) {
            return false;
        }

        if (mHasOptionalVerifier && !mOptionalVerificationPassed) {
","    public boolean isInstallAllowed() {
        if (mRequiredVerifierUid != -1 && !mRequiredVerificationPassed) {
            return false;
        }

        if (mHasOptionalVerifier && !mOptionalVerificationPassed) {
","    public boolean isInstallAllowed() {
        if (mRequiredVerifierUid != -1 && !mRequiredVerificationPassed) {
            return false;
        }

        if (mHasOptionalVerifier && !mOptionalVerificationPassed) {
","[1.0, 1.0]"
323,"['657230bb5e95ec8560c534360cac5a25fd743129', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,"[(56, 57, 2), (56, 57, 2)]","        if(wifiManager != null){
            wifiManager.registerTrafficStateCallback(new WifiTrafficStateCallback(),  null);
","        if(wifiManager != null){
            wifiManager.registerTrafficStateCallback(new WifiTrafficStateCallback(),  null);
","        if(wifiManager != null){
            wifiManager.registerTrafficStateCallback(new WifiTrafficStateCallback(),  null);
","[1.0, 1.0]"
324,"['657230bb5e95ec8560c534360cac5a25fd743129', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java,"[(116, 118, 3), (116, 118, 3)]","                    Dependency.get(Dependency.MAIN_HANDLER));
            } else {
                mWifiManager.unregisterSoftApCallback(this);
","                    Dependency.get(Dependency.MAIN_HANDLER));
            } else {
                mWifiManager.unregisterSoftApCallback(this);
","                    Dependency.get(Dependency.MAIN_HANDLER));
            } else {
                mWifiManager.unregisterSoftApCallback(this);
","[1.0, 1.0]"
325,"['657230bb5e95ec8560c534360cac5a25fd743129', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Connection.java,"[(640, 645, 6), (640, 645, 6)]","     * Connection event used to inform an {@link InCallService} that the call session property
     * has changed
     * @hide
     */
    public static final String EVENT_CALL_PROPERTY_CHANGED =
            ""android.telecom.event.EVENT_CALL_PROPERTY_CHANGED"";
","     * Connection event used to inform an {@link InCallService} that the call session property
     * has changed
     * @hide
     */
    public static final String EVENT_CALL_PROPERTY_CHANGED =
            ""android.telecom.event.EVENT_CALL_PROPERTY_CHANGED"";
","     * Connection event used to inform an {@link InCallService} that the call session property
     * has changed
     * @hide
     */
    public static final String EVENT_CALL_PROPERTY_CHANGED =
            ""android.telecom.event.EVENT_CALL_PROPERTY_CHANGED"";
","[1.0, 1.0]"
326,"['657230bb5e95ec8560c534360cac5a25fd743129', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(16, 16, 1), (16, 16, 1)]","
","
","
","[1.0, 1.0]"
327,"['657230bb5e95ec8560c534360cac5a25fd743129', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(28, 30, 3), (28, 30, 3)]","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.stub.ImsRegistrationImplBase;
","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.stub.ImsRegistrationImplBase;
","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.stub.ImsRegistrationImplBase;
","[1.0, 1.0]"
328,"['657230bb5e95ec8560c534360cac5a25fd743129', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(591, 609, 19), (591, 609, 19)]","        if ( mAlwasyShowTypeIcon ) {
            int iconType = TelephonyManager.NETWORK_TYPE_UNKNOWN;
            if ( isDataNetworkTypeAvailable() ) {
                iconType = mDataNetType;
            }else {
                iconType = getVoiceNetworkType();
            }

            if (mNetworkToIconLookup.indexOfKey(iconType) >= 0) {
                mCurrentState.iconGroup = mNetworkToIconLookup.get(iconType);
            } else {
                mCurrentState.iconGroup = mDefaultIcons;
            }
        }else {
            if (mNetworkToIconLookup.indexOfKey(mDataNetType) >= 0) {
                mCurrentState.iconGroup = mNetworkToIconLookup.get(mDataNetType);
            } else {
                mCurrentState.iconGroup = mDefaultIcons;
            }
","        if ( mAlwasyShowTypeIcon ) {
            int iconType = TelephonyManager.NETWORK_TYPE_UNKNOWN;
            if ( isDataNetworkTypeAvailable() ) {
                iconType = mDataNetType;
            }else {
                iconType = getVoiceNetworkType();
            }

            if (mNetworkToIconLookup.indexOfKey(iconType) >= 0) {
                mCurrentState.iconGroup = mNetworkToIconLookup.get(iconType);
            } else {
                mCurrentState.iconGroup = mDefaultIcons;
            }
        }else {
            if (mNetworkToIconLookup.indexOfKey(mDataNetType) >= 0) {
                mCurrentState.iconGroup = mNetworkToIconLookup.get(mDataNetType);
            } else {
                mCurrentState.iconGroup = mDefaultIcons;
            }
","        if ( mAlwasyShowTypeIcon ) {
            int iconType = TelephonyManager.NETWORK_TYPE_UNKNOWN;
            if ( isDataNetworkTypeAvailable() ) {
                iconType = mDataNetType;
            }else {
                iconType = getVoiceNetworkType();
            }

            if (mNetworkToIconLookup.indexOfKey(iconType) >= 0) {
                mCurrentState.iconGroup = mNetworkToIconLookup.get(iconType);
            } else {
                mCurrentState.iconGroup = mDefaultIcons;
            }
        }else {
            if (mNetworkToIconLookup.indexOfKey(mDataNetType) >= 0) {
                mCurrentState.iconGroup = mNetworkToIconLookup.get(mDataNetType);
            } else {
                mCurrentState.iconGroup = mDefaultIcons;
            }
","[1.0, 1.0]"
329,"['657230bb5e95ec8560c534360cac5a25fd743129', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java,"[(1073, 1075, 3), (1073, 1075, 3)]","            config.showRsrpSignalLevelforLTE =
                    res.getBoolean(R.bool.config_showRsrpSignalLevelforLTE);
            config.showVolteIcon = res.getBoolean(R.bool.config_display_volte);
","            config.showRsrpSignalLevelforLTE =
                    res.getBoolean(R.bool.config_showRsrpSignalLevelforLTE);
            config.showVolteIcon = res.getBoolean(R.bool.config_display_volte);
","            config.showRsrpSignalLevelforLTE =
                    res.getBoolean(R.bool.config_showRsrpSignalLevelforLTE);
            config.showVolteIcon = res.getBoolean(R.bool.config_display_volte);
","[1.0, 1.0]"
330,"['657230bb5e95ec8560c534360cac5a25fd743129', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(156, 156, 1), (151, 151, 1)]","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","[1.0, 1.0]"
331,"['657230bb5e95ec8560c534360cac5a25fd743129', '6f47ceafbe6febe54aa5c376baed3415cdf848ad']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(28, 30, 3), (32, 36, 5)]","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.stub.ImsRegistrationImplBase;
","import android.telephony.CellSignalStrengthNr;
import android.telephony.DisplayInfo;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.","[0.799, 0.527]"
332,"['657230bb5e95ec8560c534360cac5a25fd743129', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Connection.java,"[(640, 645, 6), (645, 650, 6)]","     * Connection event used to inform an {@link InCallService} that the call session property
     * has changed
     * @hide
     */
    public static final String EVENT_CALL_PROPERTY_CHANGED =
            ""android.telecom.event.EVENT_CALL_PROPERTY_CHANGED"";
","     * Connection event used to inform an {@link InCallService} that the call session property
     * has changed
     * @hide
     */
    public static final String EVENT_CALL_PROPERTY_CHANGED =
            ""android.telecom.event.EVENT_CALL_PROPERTY_CHANGED"";
","     * Connection event used to inform an {@link InCallService} that the call session property
     * has changed
     * @hide
     */
    public static final String EVENT_CALL_PROPERTY_CHANGED =
            ""android.telecom.event.EVENT_CALL_PROPERTY_CHANGED"";
","[1.0, 1.0]"
333,"['657230bb5e95ec8560c534360cac5a25fd743129', '89cad5d93a5083474840e90d08d6e4aec5833932']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardSimPinView.java,"[(70, 81, 12), (71, 81, 11)]","                // If the SIM is removed, then we must remove the keyguard. It will be put up
                // again when the PUK locked SIM is re-entered.
                case ABSENT: {
                    KeyguardUpdateMonitor.getInstance(getContext()).reportSimUnlocked(subId);
                    // onSimStateChanged callback can fire when the SIM PIN lock is not currently
                    // active and mCallback is null.
                    if (mCallback != null) {
                        mCallback.dismiss(true, KeyguardUpdateMonitor.getCurrentUser());
                    }
                    mSubId = subId;
                    break;
                }
","                // If the SIM is removed, then we must remove the keyguard. It will be put up
                // again when the PUK locked SIM is re-entered.
                case ABSENT: {
                    KeyguardUpdateMonitor.getInstance(getContext()).reportSimUnlocked(subId);
                    // onSimStateChanged callback can fire when the SIM PIN lock is not currently
                    // active and mCallback is null.
                    if (mCallback != null) {
                        mCallback.dismiss(true, KeyguardUpdateMonitor.getCurrentUser());
                    }
                    break;
                }
","                // If the SIM is removed, then we must remove the keyguard. It will be put up
                // again when the PUK locked SIM is re-entered.
                case ABSENT: {
                    KeyguardUpdateMonitor.getInstance(getContext()).reportSimUnlocked(subId);
                    // onSimStateChanged callback can fire when the SIM PIN lock is not currently
                    // active and mCallback is null.
                    if (mCallback != null) {
                        mCallback.dismiss(true, KeyguardUpdateMonitor.getCurrentUser());
                    }
                    ","[0.909, 0.961]"
334,"['657230bb5e95ec8560c534360cac5a25fd743129', '89cad5d93a5083474840e90d08d6e4aec5833932']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(16, 16, 1), (16, 16, 1)]","
","
","
","[1.0, 1.0]"
335,"['657230bb5e95ec8560c534360cac5a25fd743129', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(28, 30, 3), (36, 39, 4)]","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.stub.ImsRegistrationImplBase;
","import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.","[0.799, 0.633]"
336,"['657230bb5e95ec8560c534360cac5a25fd743129', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(28, 30, 3), (29, 32, 4)]","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.stub.ImsRegistrationImplBase;
","import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.","[0.799, 0.633]"
338,"['6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6', '12930acc5076e1acff0744b8d225bb2d2173f1b5']","['aospa-quartz-SAP-block_text', 'lineage-16.0-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(6000, 6011, 12), (6014, 6025, 12)]","        // TODO (b/67683350)
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
","        // Hack for pi
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
","
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
","[0.96, 0.968]"
339,"['6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(151, 151, 1), (151, 151, 1)]","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","[1.0, 1.0]"
340,"['6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java,"[(190, 204, 15), (190, 204, 15)]","    @Override
    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
","    @Override
    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
","    @Override
    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
","[1.0, 1.0]"
341,"['6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(1229, 1232, 4), (1229, 1232, 4)]","        A2dpSinkProfile a2dpSinkProfile = mProfileManager.getA2dpSinkProfile();
        Log.i(TAG, ""a2dpProfile :"" + a2dpProfile + "" a2dpSinkProfile :"" + a2dpSinkProfile);
        if (a2dpProfile != null) {
            return a2dpProfile.getConnectionStatus(mDevice) ==
","        A2dpSinkProfile a2dpSinkProfile = mProfileManager.getA2dpSinkProfile();
        Log.i(TAG, ""a2dpProfile :"" + a2dpProfile + "" a2dpSinkProfile :"" + a2dpSinkProfile);
        if (a2dpProfile != null) {
            return a2dpProfile.getConnectionStatus(mDevice) ==
","        A2dpSinkProfile a2dpSinkProfile = mProfileManager.getA2dpSinkProfile();
        Log.i(TAG, ""a2dpProfile :"" + a2dpProfile + "" a2dpSinkProfile :"" + a2dpSinkProfile);
        if (a2dpProfile != null) {
            return a2dpProfile.getConnectionStatus(mDevice) ==
","[1.0, 1.0]"
342,"['6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8191, 8191, 1), (8191, 8191, 1)]","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","[1.0, 1.0]"
343,"['6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(6000, 6011, 12), (6000, 6011, 12)]","        // TODO (b/67683350)
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
","        // TODO (b/67683350)
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
","        // TODO (b/67683350)
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
","[1.0, 1.0]"
344,"['6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"[(165, 176, 12), (165, 176, 12)]","        List<Integer> supportedList = mLocalAdapter.getSupportedProfiles();
        if (supportedList.contains(BluetoothProfile.HEARING_AID)) {
            mHearingAidProfile = new HearingAidProfile(mContext, mLocalAdapter, mDeviceManager,
                                                       this);
            addProfile(mHearingAidProfile, HearingAidProfile.NAME,
                       BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);
        }

        mDunProfile = new DunServerProfile(context);
        addProfile(mDunProfile, DunServerProfile.NAME,
                BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);

","        List<Integer> supportedList = mLocalAdapter.getSupportedProfiles();
        if (supportedList.contains(BluetoothProfile.HEARING_AID)) {
            mHearingAidProfile = new HearingAidProfile(mContext, mLocalAdapter, mDeviceManager,
                                                       this);
            addProfile(mHearingAidProfile, HearingAidProfile.NAME,
                       BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);
        }

        mDunProfile = new DunServerProfile(context);
        addProfile(mDunProfile, DunServerProfile.NAME,
                BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);

","        List<Integer> supportedList = mLocalAdapter.getSupportedProfiles();
        if (supportedList.contains(BluetoothProfile.HEARING_AID)) {
            mHearingAidProfile = new HearingAidProfile(mContext, mLocalAdapter, mDeviceManager,
                                                       this);
            addProfile(mHearingAidProfile, HearingAidProfile.NAME,
                       BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);
        }

        mDunProfile = new DunServerProfile(context);
        addProfile(mDunProfile, DunServerProfile.NAME,
                BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);

","[1.0, 1.0]"
345,"['6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java,"[(190, 204, 15), (190, 204, 15)]","    @Override
    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
","    @Override
    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
","    @Override
    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
","[1.0, 1.0]"
346,"['6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6', '7100a7fa7244d86adf9e33b9079ce2a355e2a525']","['aospa-quartz-SAP-block_text', 'omnirom-9.0-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(6000, 6011, 12), (5944, 5955, 12)]","        // TODO (b/67683350)
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
","        // Hack for pi
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
","
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
","[0.96, 0.968]"
349,"['6e44ad255823e1b7f2b23386d61af655c19adb49', '6e44ad255823e1b7f2b23386d61af655c19adb49']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(599, 599, 1), (599, 599, 1)]","                                subject, null, finalStack, null);
","                                subject, null, finalStack, null);
","                                subject, null, finalStack, null);
","[1.0, 1.0]"
350,"['6e44ad255823e1b7f2b23386d61af655c19adb49', '6e44ad255823e1b7f2b23386d61af655c19adb49']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/net/NetworkPolicyManagerService.java,"[(1340, 1340, 1), (1340, 1340, 1)]","                        String.format(""%s %s"", bres.value, bres.units));
","                        String.format(""%s %s"", bres.value, bres.units));
","                        String.format(""%s %s"", bres.value, bres.units));
","[1.0, 1.0]"
351,"['6e44ad255823e1b7f2b23386d61af655c19adb49', '6e44ad255823e1b7f2b23386d61af655c19adb49']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/TaskTapPointerEventListener.java,"[(54, 56, 3), (54, 56, 3)]","    private int mLastDownX;
    private int mLastDownY;
    public BoostFramework mPerfObj = null;
","    private int mLastDownX;
    private int mLastDownY;
    public BoostFramework mPerfObj = null;
","    private int mLastDownX;
    private int mLastDownY;
    public BoostFramework mPerfObj = null;
","[1.0, 1.0]"
352,"['6e44ad255823e1b7f2b23386d61af655c19adb49', '6e44ad255823e1b7f2b23386d61af655c19adb49']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/TaskTapPointerEventListener.java,"[(62, 111, 50), (62, 111, 50)]","        mHandler = new Handler(mService.mH.getLooper());
        mMoveDisplayToTop = () -> {
            int x;
            int y;
            synchronized (this) {
                x = mLastDownX;
                y = mLastDownY;
            }
            synchronized (mService.mGlobalLock) {
                if (!mService.mPerDisplayFocusEnabled
                        && mService.mRoot.getTopFocusedDisplayContent() != mDisplayContent
                        && inputMethodWindowContains(x, y)) {
                    // In a single focus system, if the input method window and the input method
                    // target window are on the different displays, when the user is tapping on the
                    // input method window, we don't move its display to top. Otherwise, the input
                    // method target window will lose the focus.
                    return;
                }
                final Region windowTapExcludeRegion = Region.obtain();
                mDisplayContent.amendWindowTapExcludeRegion(windowTapExcludeRegion);
                if (windowTapExcludeRegion.contains(x, y)) {
                    windowTapExcludeRegion.recycle();
                    // The user is tapping on the window tap exclude region. We don't move this
                    // display to top. A window tap exclude region, for example, may be set by an
                    // ActivityView, and the region would match the bounds of both the ActivityView
                    // and the virtual display in it. In this case, we would take the tap that is on
                    // the embedded virtual display instead of this display.
                    return;
                }
                windowTapExcludeRegion.recycle();
                WindowContainer parent = mDisplayContent.getParent();
                if (parent != null && parent.getTopChild() != mDisplayContent) {
                    parent.positionChildAt(WindowContainer.POSITION_TOP, mDisplayContent,
                            true /* includingParents */);
                    // For compatibility, only the topmost activity is allowed to be resumed for
                    // pre-Q app. Ensure the topmost activities are resumed whenever a display is
                    // moved to top.
                    // TODO(b/123761773): Investigate whether we can move this into
                    // RootActivityContainer#updateTopResumedActivityIfNeeded(). Currently, it is
                    // risky to do so because it seems possible to resume activities as part of a
                    // larger transaction and it's too early to resume based on current order
                    // when performing updateTopResumedActivityIfNeeded().
                    mDisplayContent.mAcitvityDisplay.ensureActivitiesVisible(null /* starting */,
                            0 /* configChanges */, !PRESERVE_WINDOWS, true /* notifyClients */);
                }
            }
        };
        if (mPerfObj == null) {
            mPerfObj = new BoostFramework();
        }
","        mHandler = new Handler(mService.mH.getLooper());
        mMoveDisplayToTop = () -> {
            int x;
            int y;
            synchronized (this) {
                x = mLastDownX;
                y = mLastDownY;
            }
            synchronized (mService.mGlobalLock) {
                if (!mService.mPerDisplayFocusEnabled
                        && mService.mRoot.getTopFocusedDisplayContent() != mDisplayContent
                        && inputMethodWindowContains(x, y)) {
                    // In a single focus system, if the input method window and the input method
                    // target window are on the different displays, when the user is tapping on the
                    // input method window, we don't move its display to top. Otherwise, the input
                    // method target window will lose the focus.
                    return;
                }
                final Region windowTapExcludeRegion = Region.obtain();
                mDisplayContent.amendWindowTapExcludeRegion(windowTapExcludeRegion);
                if (windowTapExcludeRegion.contains(x, y)) {
                    windowTapExcludeRegion.recycle();
                    // The user is tapping on the window tap exclude region. We don't move this
                    // display to top. A window tap exclude region, for example, may be set by an
                    // ActivityView, and the region would match the bounds of both the ActivityView
                    // and the virtual display in it. In this case, we would take the tap that is on
                    // the embedded virtual display instead of this display.
                    return;
                }
                windowTapExcludeRegion.recycle();
                WindowContainer parent = mDisplayContent.getParent();
                if (parent != null && parent.getTopChild() != mDisplayContent) {
                    parent.positionChildAt(WindowContainer.POSITION_TOP, mDisplayContent,
                            true /* includingParents */);
                    // For compatibility, only the topmost activity is allowed to be resumed for
                    // pre-Q app. Ensure the topmost activities are resumed whenever a display is
                    // moved to top.
                    // TODO(b/123761773): Investigate whether we can move this into
                    // RootActivityContainer#updateTopResumedActivityIfNeeded(). Currently, it is
                    // risky to do so because it seems possible to resume activities as part of a
                    // larger transaction and it's too early to resume based on current order
                    // when performing updateTopResumedActivityIfNeeded().
                    mDisplayContent.mAcitvityDisplay.ensureActivitiesVisible(null /* starting */,
                            0 /* configChanges */, !PRESERVE_WINDOWS, true /* notifyClients */);
                }
            }
        };
        if (mPerfObj == null) {
            mPerfObj = new BoostFramework();
        }
","        mHandler = new Handler(mService.mH.getLooper());
        mMoveDisplayToTop = () -> {
            int x;
            int y;
            synchronized (this) {
                x = mLastDownX;
                y = mLastDownY;
            }
            synchronized (mService.mGlobalLock) {
                if (!mService.mPerDisplayFocusEnabled
                        && mService.mRoot.getTopFocusedDisplayContent() != mDisplayContent
                        && inputMethodWindowContains(x, y)) {
                    // In a single focus system, if the input method window and the input method
                    // target window are on the different displays, when the user is tapping on the
                    // input method window, we don't move its display to top. Otherwise, the input
                    // method target window will lose the focus.
                    return;
                }
                final Region windowTapExcludeRegion = Region.obtain();
                mDisplayContent.amendWindowTapExcludeRegion(windowTapExcludeRegion);
                if (windowTapExcludeRegion.contains(x, y)) {
                    windowTapExcludeRegion.recycle();
                    // The user is tapping on the window tap exclude region. We don't move this
                    // display to top. A window tap exclude region, for example, may be set by an
                    // ActivityView, and the region would match the bounds of both the ActivityView
                    // and the virtual display in it. In this case, we would take the tap that is on
                    // the embedded virtual display instead of this display.
                    return;
                }
                windowTapExcludeRegion.recycle();
                WindowContainer parent = mDisplayContent.getParent();
                if (parent != null && parent.getTopChild() != mDisplayContent) {
                    parent.positionChildAt(WindowContainer.POSITION_TOP, mDisplayContent,
                            true /* includingParents */);
                    // For compatibility, only the topmost activity is allowed to be resumed for
                    // pre-Q app. Ensure the topmost activities are resumed whenever a display is
                    // moved to top.
                    // TODO(b/123761773): Investigate whether we can move this into
                    // RootActivityContainer#updateTopResumedActivityIfNeeded(). Currently, it is
                    // risky to do so because it seems possible to resume activities as part of a
                    // larger transaction and it's too early to resume based on current order
                    // when performing updateTopResumedActivityIfNeeded().
                    mDisplayContent.mAcitvityDisplay.ensureActivitiesVisible(null /* starting */,
                            0 /* configChanges */, !PRESERVE_WINDOWS, true /* notifyClients */);
                }
            }
        };
        if (mPerfObj == null) {
            mPerfObj = new BoostFramework();
        }
","[1.0, 1.0]"
353,"['6e44ad255823e1b7f2b23386d61af655c19adb49', '6e44ad255823e1b7f2b23386d61af655c19adb49']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2281, 2298, 18), (2281, 2298, 18)]","            if (allowedKeyManagement.get(KeyMgmt.WPA_PSK)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.WPA_PSK];
            } else if (allowedKeyManagement.get(KeyMgmt.WPA_EAP) ||
                    allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.WPA_EAP];
            } else if (wepKeys[0] != null) {
                key = SSID + ""WEP"";
            } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
            } else if (allowedKeyManagement.get(KeyMgmt.OWE)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.OWE];
            } else if (allowedKeyManagement.get(KeyMgmt.SAE)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.SAE];
            } else if (allowedKeyManagement.get(KeyMgmt.SUITE_B_192)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.SUITE_B_192];
            } else {
                key = SSID + KeyMgmt.strings[KeyMgmt.NONE];
            }
","            if (allowedKeyManagement.get(KeyMgmt.WPA_PSK)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.WPA_PSK];
            } else if (allowedKeyManagement.get(KeyMgmt.WPA_EAP) ||
                    allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.WPA_EAP];
            } else if (wepKeys[0] != null) {
                key = SSID + ""WEP"";
            } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
            } else if (allowedKeyManagement.get(KeyMgmt.OWE)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.OWE];
            } else if (allowedKeyManagement.get(KeyMgmt.SAE)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.SAE];
            } else if (allowedKeyManagement.get(KeyMgmt.SUITE_B_192)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.SUITE_B_192];
            } else {
                key = SSID + KeyMgmt.strings[KeyMgmt.NONE];
            }
","            if (allowedKeyManagement.get(KeyMgmt.WPA_PSK)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.WPA_PSK];
            } else if (allowedKeyManagement.get(KeyMgmt.WPA_EAP) ||
                    allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.WPA_EAP];
            } else if (wepKeys[0] != null) {
                key = SSID + ""WEP"";
            } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
            } else if (allowedKeyManagement.get(KeyMgmt.OWE)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.OWE];
            } else if (allowedKeyManagement.get(KeyMgmt.SAE)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.SAE];
            } else if (allowedKeyManagement.get(KeyMgmt.SUITE_B_192)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.SUITE_B_192];
            } else {
                key = SSID + KeyMgmt.strings[KeyMgmt.NONE];
            }
","[1.0, 1.0]"
354,"['6e44ad255823e1b7f2b23386d61af655c19adb49', '6e44ad255823e1b7f2b23386d61af655c19adb49']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardSimPinView.java,"[(115, 122, 8), (115, 122, 8)]","    private void showDefaultMessage() {
        if (mRemainingAttempts >= 0) {
            mSecurityMessageDisplay.setMessage(getPinPasswordErrorMessage(
                    mRemainingAttempts, true));
            return;
        }

        mSlotId = SubscriptionManager.getSlotIndex(mSubId) + 1;
","    private void showDefaultMessage() {
        if (mRemainingAttempts >= 0) {
            mSecurityMessageDisplay.setMessage(getPinPasswordErrorMessage(
                    mRemainingAttempts, true));
            return;
        }

        mSlotId = SubscriptionManager.getSlotIndex(mSubId) + 1;
","    private void showDefaultMessage() {
        if (mRemainingAttempts >= 0) {
            mSecurityMessageDisplay.setMessage(getPinPasswordErrorMessage(
                    mRemainingAttempts, true));
            return;
        }

        mSlotId = SubscriptionManager.getSlotIndex(mSubId) + 1;
","[1.0, 1.0]"
355,"['6e44ad255823e1b7f2b23386d61af655c19adb49', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(599, 599, 1), (688, 688, 1)]","                                subject, null, finalStack, null);
","                                    subject, null, finalStack, null);
","                                subject, null, finalStack, null);
","[1.0, 0.943]"
356,"['6e44ad255823e1b7f2b23386d61af655c19adb49', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(599, 599, 1), (695, 695, 1)]","                                subject, null, finalStack, null);
","                                    subject, cpuInfo, finalStack, null);
","                                subject, ","[0.621, 0.562]"
358,"['81b587a542e8381268a9ba8e7461712ef23cd11f', '81b587a542e8381268a9ba8e7461712ef23cd11f']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/LocalDisplayAdapter.java,"[(184, 187, 4), (184, 187, 4)]","                int[] colorModes, int activeColorMode) {
            super(LocalDisplayAdapter.this, displayToken, UNIQUE_ID_PREFIX + builtInDisplayId,
                  builtInDisplayId);
            mBuiltInDisplayId = builtInDisplayId;
","                int[] colorModes, int activeColorMode) {
            super(LocalDisplayAdapter.this, displayToken, UNIQUE_ID_PREFIX + builtInDisplayId,
                  builtInDisplayId);
            mBuiltInDisplayId = builtInDisplayId;
","                int[] colorModes, int activeColorMode) {
            super(LocalDisplayAdapter.this, displayToken, UNIQUE_ID_PREFIX + builtInDisplayId,
                  builtInDisplayId);
            mBuiltInDisplayId = builtInDisplayId;
","[1.0, 1.0]"
359,"['81b587a542e8381268a9ba8e7461712ef23cd11f', '81b587a542e8381268a9ba8e7461712ef23cd11f']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActiveServices.java,"[(2459, 2487, 29), (2459, 2487, 29)]","            if(SERVICE_RESCHEDULE) {
                boolean shouldDelay = false;
                ActivityRecord top_rc = null;
                ActivityStack stack = mAm.mStackSupervisor.mRootActivityContainer.getTopDisplayFocusedStack();
                if(stack != null) {
                    top_rc = stack.topRunningActivityLocked();
                }

                boolean isPersistent
                        = !((r.serviceInfo.applicationInfo.flags&ApplicationInfo.FLAG_PERSISTENT) == 0);
                if(top_rc != null) {
                    if(top_rc.launching && !r.shortInstanceName.contains(top_rc.packageName)
                            && !isPersistent) {
                        shouldDelay = true;
                    }
                }
                if(!shouldDelay) {
                    bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
                } else {
                    if (DEBUG_DELAYED_SERVICE) {
                        Slog.v(TAG, ""Reschedule service restart due to app launch""
                              +"" r.shortInstanceName ""+r.shortInstanceName+"" r.app = ""+r.app);
                    }
                    r.resetRestartCounter();
                    scheduleServiceRestartLocked(r, true);
                }
            } else {
                bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
            }
","            if(SERVICE_RESCHEDULE) {
                boolean shouldDelay = false;
                ActivityRecord top_rc = null;
                ActivityStack stack = mAm.mStackSupervisor.mRootActivityContainer.getTopDisplayFocusedStack();
                if(stack != null) {
                    top_rc = stack.topRunningActivityLocked();
                }

                boolean isPersistent
                        = !((r.serviceInfo.applicationInfo.flags&ApplicationInfo.FLAG_PERSISTENT) == 0);
                if(top_rc != null) {
                    if(top_rc.launching && !r.shortInstanceName.contains(top_rc.packageName)
                            && !isPersistent) {
                        shouldDelay = true;
                    }
                }
                if(!shouldDelay) {
                    bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
                } else {
                    if (DEBUG_DELAYED_SERVICE) {
                        Slog.v(TAG, ""Reschedule service restart due to app launch""
                              +"" r.shortInstanceName ""+r.shortInstanceName+"" r.app = ""+r.app);
                    }
                    r.resetRestartCounter();
                    scheduleServiceRestartLocked(r, true);
                }
            } else {
                bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
            }
","            if(SERVICE_RESCHEDULE) {
                boolean shouldDelay = false;
                ActivityRecord top_rc = null;
                ActivityStack stack = mAm.mStackSupervisor.mRootActivityContainer.getTopDisplayFocusedStack();
                if(stack != null) {
                    top_rc = stack.topRunningActivityLocked();
                }

                boolean isPersistent
                        = !((r.serviceInfo.applicationInfo.flags&ApplicationInfo.FLAG_PERSISTENT) == 0);
                if(top_rc != null) {
                    if(top_rc.launching && !r.shortInstanceName.contains(top_rc.packageName)
                            && !isPersistent) {
                        shouldDelay = true;
                    }
                }
                if(!shouldDelay) {
                    bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
                } else {
                    if (DEBUG_DELAYED_SERVICE) {
                        Slog.v(TAG, ""Reschedule service restart due to app launch""
                              +"" r.shortInstanceName ""+r.shortInstanceName+"" r.app = ""+r.app);
                    }
                    r.resetRestartCounter();
                    scheduleServiceRestartLocked(r, true);
                }
            } else {
                bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
            }
","[1.0, 1.0]"
366,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 22, 4), (19, 22, 4)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","[1.0, 1.0]"
367,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '24f36fd2514856aaafe6a32a99050e272a6bd361']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 22, 4), (19, 20, 2)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","[0.652, 1.0]"
368,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 22, 4), (19, 20, 2)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","[0.652, 1.0]"
369,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(545, 548, 4), (578, 582, 5)]","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
    public static boolean mForceStopKill = false;
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
","[1.0, 0.794]"
370,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(449, 449, 1), (449, 449, 1)]","    private static final int EVENT_UPDATE_TCP_BUFFER_FOR_5G = 160;
","    private static final int EVENT_UPDATE_TCP_BUFFER_FOR_5G = 160;
","    private static final int EVENT_UPDATE_TCP_BUFFER_FOR_5G = 160;
","[1.0, 1.0]"
371,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/ims/ImsCallSession.java,"[(448, 453, 6), (448, 453, 6)]","         * While in call, there has been a change in the call session
         * property.
         * @param property - an integer containing masks for different properties
         * {e.g. @see Connection#PROPERTY_RTT_AUDIO_SPEECH}
         */
        public void callSessionPropertyChanged(int property) {
","         * While in call, there has been a change in the call session
         * property.
         * @param property - an integer containing masks for different properties
         * {e.g. @see Connection#PROPERTY_RTT_AUDIO_SPEECH}
         */
        public void callSessionPropertyChanged(int property) {
","         * While in call, there has been a change in the call session
         * property.
         * @param property - an integer containing masks for different properties
         * {e.g. @see Connection#PROPERTY_RTT_AUDIO_SPEECH}
         */
        public void callSessionPropertyChanged(int property) {
","[1.0, 1.0]"
372,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/ims/ImsCallSession.java,"[(448, 453, 6), (1412, 1420, 9)]","         * While in call, there has been a change in the call session
         * property.
         * @param property - an integer containing masks for different properties
         * {e.g. @see Connection#PROPERTY_RTT_AUDIO_SPEECH}
         */
        public void callSessionPropertyChanged(int property) {
","         * While in call, there has been a change in the call session
         * property.
         * @param property - an integer containing masks for different properties
         * {e.g. @see Connection#PROPERTY_RTT_AUDIO_SPEECH}
         */
        @Override
        public void callSessionPropertyChanged(int property) {
            if (mListener != null) {
                mListener.callSessionPropertyChanged(property);
","         * While in call, there has been a change in the call session
         * property.
         * @param property - an integer containing masks for different properties
         * {e.g. @see Connection#PROPERTY_RTT_AUDIO_SPEECH}
         */
        ","[0.821, 0.593]"
373,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/ims/ImsCallSession.java,"[(1412, 1420, 9), (1412, 1420, 9)]","         * While in call, there has been a change in the call session
         * property.
         * @param property - an integer containing masks for different properties
         * {e.g. @see Connection#PROPERTY_RTT_AUDIO_SPEECH}
         */
        @Override
        public void callSessionPropertyChanged(int property) {
            if (mListener != null) {
                mListener.callSessionPropertyChanged(property);
","         * While in call, there has been a change in the call session
         * property.
         * @param property - an integer containing masks for different properties
         * {e.g. @see Connection#PROPERTY_RTT_AUDIO_SPEECH}
         */
        @Override
        public void callSessionPropertyChanged(int property) {
            if (mListener != null) {
                mListener.callSessionPropertyChanged(property);
","         * While in call, there has been a change in the call session
         * property.
         * @param property - an integer containing masks for different properties
         * {e.g. @see Connection#PROPERTY_RTT_AUDIO_SPEECH}
         */
        @Override
        public void callSessionPropertyChanged(int property) {
            if (mListener != null) {
                mListener.callSessionPropertyChanged(property);
","[1.0, 1.0]"
374,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Connection.java,"[(522, 527, 6), (522, 527, 6)]","     * Integer connection extra key on a {@link Connection} to indicate that there is an updated
     * call property
     * @hide
     */
    public static final String EXTRA_CALL_PROPERTY =
            ""android.telecom.extra.EXTRA_CALL_PROPERTY"";
","     * Integer connection extra key on a {@link Connection} to indicate that there is an updated
     * call property
     * @hide
     */
    public static final String EXTRA_CALL_PROPERTY =
            ""android.telecom.extra.EXTRA_CALL_PROPERTY"";
","     * Integer connection extra key on a {@link Connection} to indicate that there is an updated
     * call property
     * @hide
     */
    public static final String EXTRA_CALL_PROPERTY =
            ""android.telecom.extra.EXTRA_CALL_PROPERTY"";
","[1.0, 1.0]"
375,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Connection.java,"[(645, 650, 6), (645, 650, 6)]","     * Connection event used to inform an {@link InCallService} that the call session property
     * has changed
     * @hide
     */
    public static final String EVENT_CALL_PROPERTY_CHANGED =
            ""android.telecom.event.EVENT_CALL_PROPERTY_CHANGED"";
","     * Connection event used to inform an {@link InCallService} that the call session property
     * has changed
     * @hide
     */
    public static final String EVENT_CALL_PROPERTY_CHANGED =
            ""android.telecom.event.EVENT_CALL_PROPERTY_CHANGED"";
","     * Connection event used to inform an {@link InCallService} that the call session property
     * has changed
     * @hide
     */
    public static final String EVENT_CALL_PROPERTY_CHANGED =
            ""android.telecom.event.EVENT_CALL_PROPERTY_CHANGED"";
","[1.0, 1.0]"
376,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(81, 82, 2), (81, 82, 2)]","import static android.os.Process.setProcessGroup;
import static android.os.Process.setCgroupProcsProcessGroup;
","import static android.os.Process.setProcessGroup;
import static android.os.Process.setCgroupProcsProcessGroup;
","import static android.os.Process.setProcessGroup;
import static android.os.Process.setCgroupProcsProcessGroup;
","[1.0, 1.0]"
377,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(545, 548, 4), (545, 548, 4)]","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
","[1.0, 1.0]"
378,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(17066, 17350, 285), (17066, 17350, 285)]","    private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now,
            long nowElapsed) {
        boolean success = true;

        if (app.getCurRawAdj() != app.setRawAdj) {
            app.setRawAdj = app.getCurRawAdj();
        }

        int changes = 0;

        if (app.curAdj != app.setAdj) {
            // don't compact during bootup
            if (mConstants.USE_COMPACTION && mBooted) {
                // Perform a minor compaction when a perceptible app becomes the prev/home app
                // Perform a major compaction when any app enters cached
                // reminder: here, setAdj is previous state, curAdj is upcoming state
                if (app.setAdj <= ProcessList.PERCEPTIBLE_APP_ADJ &&
                    (app.curAdj == ProcessList.PREVIOUS_APP_ADJ ||
                     app.curAdj == ProcessList.HOME_APP_ADJ)) {
                    mAppCompact.compactAppSome(app);
                } else if (app.setAdj < ProcessList.CACHED_APP_MIN_ADJ &&
                           app.curAdj >= ProcessList.CACHED_APP_MIN_ADJ) {
                    mAppCompact.compactAppFull(app);
                }
            }
            ProcessList.setOomAdj(app.pid, app.uid, app.curAdj);
            if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.info.uid) {
                String msg = ""Set "" + app.pid + "" "" + app.processName + "" adj ""
                        + app.curAdj + "": "" + app.adjType;
                reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
            }
            app.setAdj = app.curAdj;
            app.verifiedAdj = ProcessList.INVALID_ADJ;
        }

        final int curSchedGroup = app.getCurrentSchedulingGroup();
        if (app.setSchedGroup != curSchedGroup) {
            int oldSchedGroup = app.setSchedGroup;
            app.setSchedGroup = curSchedGroup;
            if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.uid) {
                String msg = ""Setting sched group of "" + app.processName
                        + "" to "" + curSchedGroup + "": "" + app.adjType;
                reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
            }
            if (app.waitingToKill != null && app.curReceivers.isEmpty()
                    && app.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND) {
                app.kill(app.waitingToKill, true);
                success = false;
            } else {
                int processGroup;
                switch (curSchedGroup) {
                    case ProcessList.SCHED_GROUP_BACKGROUND:
                        processGroup = THREAD_GROUP_BG_NONINTERACTIVE;
                        break;
                    case ProcessList.SCHED_GROUP_TOP_APP:
                    case ProcessList.SCHED_GROUP_TOP_APP_BOUND:
                        processGroup = THREAD_GROUP_TOP_APP;
                        break;
                    case ProcessList.SCHED_GROUP_RESTRICTED:
                        processGroup = THREAD_GROUP_RESTRICTED;
                        break;
                    default:
                        processGroup = THREAD_GROUP_DEFAULT;
                        break;
                }
                long oldId = Binder.clearCallingIdentity();
                try {
                    if (mEnableProcessGroupCgroupFollow) {
                        setCgroupProcsProcessGroup(app.info.uid, app.pid, processGroup);
                    } else {
                        setProcessGroup(app.pid, processGroup);
                    }
                    if (curSchedGroup == ProcessList.SCHED_GROUP_TOP_APP) {
                        // do nothing if we already switched to RT
                        if (oldSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) {
                            app.getWindowProcessController().onTopProcChanged();
                            if (mUseFifoUiScheduling) {
                                // Switch UI pipeline for app to SCHED_FIFO
                                app.savedPriority = Process.getThreadPriority(app.pid);
                                scheduleAsFifoPriority(app.pid, /* suppressLogs */true);
                                if (app.renderThreadTid != 0) {
                                    scheduleAsFifoPriority(app.renderThreadTid,
                                        /* suppressLogs */true);
                                    if (DEBUG_OOM_ADJ) {
                                        Slog.d(""UI_FIFO"", ""Set RenderThread (TID "" +
                                            app.renderThreadTid + "") to FIFO"");
                                    }
                                } else {
                                    if (DEBUG_OOM_ADJ) {
                                        Slog.d(""UI_FIFO"", ""Not setting RenderThread TID"");
                                    }
                                }
                            } else {
                                // Boost priority for top app UI and render threads
                                setThreadPriority(app.pid, TOP_APP_PRIORITY_BOOST);
                                if (app.renderThreadTid != 0) {
                                    try {
                                        setThreadPriority(app.renderThreadTid,
                                                TOP_APP_PRIORITY_BOOST);
                                    } catch (IllegalArgumentException e) {
                                        // thread died, ignore
                                    }
                                }
                            }
                        }
                    } else if (oldSchedGroup == ProcessList.SCHED_GROUP_TOP_APP &&
                            curSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) {
                        app.getWindowProcessController().onTopProcChanged();
                        if (mUseFifoUiScheduling) {
                            try {
                                // Reset UI pipeline to SCHED_OTHER
                                setThreadScheduler(app.pid, SCHED_OTHER, 0);
                                setThreadPriority(app.pid, app.savedPriority);
                                if (app.renderThreadTid != 0) {
                                    setThreadScheduler(app.renderThreadTid,
                                        SCHED_OTHER, 0);
                                    setThreadPriority(app.renderThreadTid, -4);
                                }
                            } catch (IllegalArgumentException e) {
                                Slog.w(TAG,
                                        ""Failed to set scheduling policy, thread does not exist:\n""
                                                + e);
                            } catch (SecurityException e) {
                                Slog.w(TAG, ""Failed to set scheduling policy, not allowed:\n"" + e);
                            }
                        } else {
                            // Reset priority for top app UI and render threads
                            setThreadPriority(app.pid, 0);
                            if (app.renderThreadTid != 0) {
                                setThreadPriority(app.renderThreadTid, 0);
                            }
                        }
                    }
                } catch (Exception e) {
                    if (false) {
                        Slog.w(TAG, ""Failed setting process group of "" + app.pid
                                + "" to "" + app.getCurrentSchedulingGroup());
                        Slog.w(TAG, ""at location"", e);
                    }
                } finally {
                    Binder.restoreCallingIdentity(oldId);
                }
            }
        }
        if (app.repForegroundActivities != app.hasForegroundActivities()) {
            app.repForegroundActivities = app.hasForegroundActivities();
            changes |= ProcessChangeItem.CHANGE_ACTIVITIES;
        }
        if (app.getReportedProcState() != app.getCurProcState()) {
            app.setReportedProcState(app.getCurProcState());
            if (app.thread != null) {
                try {
                    if (false) {
                        //RuntimeException h = new RuntimeException(""here"");
                        Slog.i(TAG, ""Sending new process state "" + app.getReportedProcState()
                                + "" to "" + app /*, h*/);
                    }
                    app.thread.setProcessState(app.getReportedProcState());
                } catch (RemoteException e) {
                }
            }
        }
        if (app.setProcState == PROCESS_STATE_NONEXISTENT
                || ProcessList.procStatesDifferForMem(app.getCurProcState(), app.setProcState)) {
            if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now-200)) {
                // Experimental code to more aggressively collect pss while
                // running test...  the problem is that this tends to collect
                // the data right when a process is transitioning between process
                // states, which will tend to give noisy data.
                long start = SystemClock.uptimeMillis();
                long startTime = SystemClock.currentThreadTimeMillis();
                long pss = Debug.getPss(app.pid, mTmpLong, null);
                long endTime = SystemClock.currentThreadTimeMillis();
                recordPssSampleLocked(app, app.getCurProcState(), pss, mTmpLong[0], mTmpLong[1],
                        mTmpLong[2], ProcessStats.ADD_PSS_INTERNAL_SINGLE, endTime-startTime, now);
                mPendingPssProcesses.remove(app);
                Slog.i(TAG, ""Recorded pss for "" + app + "" state "" + app.setProcState
                        + "" to "" + app.getCurProcState() + "": ""
                        + (SystemClock.uptimeMillis()-start) + ""ms"");
            }
            app.lastStateTime = now;
            app.nextPssTime = ProcessList.computeNextPssTime(app.getCurProcState(),
                    app.procStateMemTracker, mTestPssMode, mAtmInternal.isSleeping(), now);
            if (DEBUG_PSS) Slog.d(TAG_PSS, ""Process state change from ""
                    + ProcessList.makeProcStateString(app.setProcState) + "" to ""
                    + ProcessList.makeProcStateString(app.getCurProcState()) + "" next pss in ""
                    + (app.nextPssTime-now) + "": "" + app);
        } else {
            if (now > app.nextPssTime || (now > (app.lastPssTime+ProcessList.PSS_MAX_INTERVAL)
                    && now > (app.lastStateTime+ProcessList.minTimeFromStateChange(
                    mTestPssMode)))) {
                if (requestPssLocked(app, app.setProcState)) {
                    app.nextPssTime = ProcessList.computeNextPssTime(app.getCurProcState(),
                            app.procStateMemTracker, mTestPssMode, mAtmInternal.isSleeping(), now);
                }
            } else if (false && DEBUG_PSS) Slog.d(TAG_PSS,
                    ""Not requesting pss of "" + app + "": next="" + (app.nextPssTime-now));
        }
        if (app.setProcState != app.getCurProcState()) {
            if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.uid) {
                String msg = ""Proc state change of "" + app.processName
                        + "" to "" + ProcessList.makeProcStateString(app.getCurProcState())
                        + "" ("" + app.getCurProcState() + "")"" + "": "" + app.adjType;
                reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
            }
            boolean setImportant = app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
            boolean curImportant = app.getCurProcState() < ActivityManager.PROCESS_STATE_SERVICE;
            if (setImportant && !curImportant) {
                // This app is no longer something we consider important enough to allow to use
                // arbitrary amounts of battery power. Note its current CPU time to later know to
                // kill it if it is not behaving well.
                app.setWhenUnimportant(now);
                app.lastCpuTime = 0;
            }
            // Inform UsageStats of important process state change
            // Must be called before updating setProcState
            maybeUpdateUsageStatsLocked(app, nowElapsed);

            maybeUpdateLastTopTime(app, now);

            app.setProcState = app.getCurProcState();
            if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
                app.notCachedSinceIdle = false;
            }
            if (!doingAll) {
                setProcessTrackerStateLocked(app, mProcessStats.getMemFactorLocked(), now);
            } else {
                app.procStateChanged = true;
            }
        } else if (app.reportedInteraction && (nowElapsed - app.getInteractionEventTime())
                > mConstants.USAGE_STATS_INTERACTION_INTERVAL) {
            // For apps that sit around for a long time in the interactive state, we need
            // to report this at least once a day so they don't go idle.
            maybeUpdateUsageStatsLocked(app, nowElapsed);
        }

        if (changes != 0) {
            if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                    ""Changes in "" + app + "": "" + changes);
            int i = mPendingProcessChanges.size()-1;
            ProcessChangeItem item = null;
            while (i >= 0) {
                item = mPendingProcessChanges.get(i);
                if (item.pid == app.pid) {
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""Re-using existing item: "" + item);
                    break;
                }
                i--;
            }
            if (i < 0) {
                // No existing item in pending changes; need a new one.
                final int NA = mAvailProcessChanges.size();
                if (NA > 0) {
                    item = mAvailProcessChanges.remove(NA-1);
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""Retrieving available item: "" + item);
                } else {
                    item = new ProcessChangeItem();
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""Allocating new item: "" + item);
                }
                item.changes = 0;
                item.pid = app.pid;
                item.uid = app.info.uid;
                if (mPendingProcessChanges.size() == 0) {
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""*** Enqueueing dispatch processes changed!"");
                    mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED_UI_MSG).sendToTarget();
                }
                mPendingProcessChanges.add(item);
            }
            item.changes |= changes;
            item.foregroundActivities = app.repForegroundActivities;
            if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                    ""Item "" + Integer.toHexString(System.identityHashCode(item))
                    + "" "" + app.toShortString() + "": changes="" + item.changes
                    + "" foreground="" + item.foregroundActivities
                    + "" type="" + app.adjType + "" source="" + app.adjSource
                    + "" target="" + app.adjTarget);
        }

        return success;
    }

","    private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now,
            long nowElapsed) {
        boolean success = true;

        if (app.getCurRawAdj() != app.setRawAdj) {
            app.setRawAdj = app.getCurRawAdj();
        }

        int changes = 0;

        if (app.curAdj != app.setAdj) {
            // don't compact during bootup
            if (mConstants.USE_COMPACTION && mBooted) {
                // Perform a minor compaction when a perceptible app becomes the prev/home app
                // Perform a major compaction when any app enters cached
                // reminder: here, setAdj is previous state, curAdj is upcoming state
                if (app.setAdj <= ProcessList.PERCEPTIBLE_APP_ADJ &&
                    (app.curAdj == ProcessList.PREVIOUS_APP_ADJ ||
                     app.curAdj == ProcessList.HOME_APP_ADJ)) {
                    mAppCompact.compactAppSome(app);
                } else if (app.setAdj < ProcessList.CACHED_APP_MIN_ADJ &&
                           app.curAdj >= ProcessList.CACHED_APP_MIN_ADJ) {
                    mAppCompact.compactAppFull(app);
                }
            }
            ProcessList.setOomAdj(app.pid, app.uid, app.curAdj);
            if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.info.uid) {
                String msg = ""Set "" + app.pid + "" "" + app.processName + "" adj ""
                        + app.curAdj + "": "" + app.adjType;
                reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
            }
            app.setAdj = app.curAdj;
            app.verifiedAdj = ProcessList.INVALID_ADJ;
        }

        final int curSchedGroup = app.getCurrentSchedulingGroup();
        if (app.setSchedGroup != curSchedGroup) {
            int oldSchedGroup = app.setSchedGroup;
            app.setSchedGroup = curSchedGroup;
            if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.uid) {
                String msg = ""Setting sched group of "" + app.processName
                        + "" to "" + curSchedGroup + "": "" + app.adjType;
                reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
            }
            if (app.waitingToKill != null && app.curReceivers.isEmpty()
                    && app.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND) {
                app.kill(app.waitingToKill, true);
                success = false;
            } else {
                int processGroup;
                switch (curSchedGroup) {
                    case ProcessList.SCHED_GROUP_BACKGROUND:
                        processGroup = THREAD_GROUP_BG_NONINTERACTIVE;
                        break;
                    case ProcessList.SCHED_GROUP_TOP_APP:
                    case ProcessList.SCHED_GROUP_TOP_APP_BOUND:
                        processGroup = THREAD_GROUP_TOP_APP;
                        break;
                    case ProcessList.SCHED_GROUP_RESTRICTED:
                        processGroup = THREAD_GROUP_RESTRICTED;
                        break;
                    default:
                        processGroup = THREAD_GROUP_DEFAULT;
                        break;
                }
                long oldId = Binder.clearCallingIdentity();
                try {
                    if (mEnableProcessGroupCgroupFollow) {
                        setCgroupProcsProcessGroup(app.info.uid, app.pid, processGroup);
                    } else {
                        setProcessGroup(app.pid, processGroup);
                    }
                    if (curSchedGroup == ProcessList.SCHED_GROUP_TOP_APP) {
                        // do nothing if we already switched to RT
                        if (oldSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) {
                            app.getWindowProcessController().onTopProcChanged();
                            if (mUseFifoUiScheduling) {
                                // Switch UI pipeline for app to SCHED_FIFO
                                app.savedPriority = Process.getThreadPriority(app.pid);
                                scheduleAsFifoPriority(app.pid, /* suppressLogs */true);
                                if (app.renderThreadTid != 0) {
                                    scheduleAsFifoPriority(app.renderThreadTid,
                                        /* suppressLogs */true);
                                    if (DEBUG_OOM_ADJ) {
                                        Slog.d(""UI_FIFO"", ""Set RenderThread (TID "" +
                                            app.renderThreadTid + "") to FIFO"");
                                    }
                                } else {
                                    if (DEBUG_OOM_ADJ) {
                                        Slog.d(""UI_FIFO"", ""Not setting RenderThread TID"");
                                    }
                                }
                            } else {
                                // Boost priority for top app UI and render threads
                                setThreadPriority(app.pid, TOP_APP_PRIORITY_BOOST);
                                if (app.renderThreadTid != 0) {
                                    try {
                                        setThreadPriority(app.renderThreadTid,
                                                TOP_APP_PRIORITY_BOOST);
                                    } catch (IllegalArgumentException e) {
                                        // thread died, ignore
                                    }
                                }
                            }
                        }
                    } else if (oldSchedGroup == ProcessList.SCHED_GROUP_TOP_APP &&
                            curSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) {
                        app.getWindowProcessController().onTopProcChanged();
                        if (mUseFifoUiScheduling) {
                            try {
                                // Reset UI pipeline to SCHED_OTHER
                                setThreadScheduler(app.pid, SCHED_OTHER, 0);
                                setThreadPriority(app.pid, app.savedPriority);
                                if (app.renderThreadTid != 0) {
                                    setThreadScheduler(app.renderThreadTid,
                                        SCHED_OTHER, 0);
                                    setThreadPriority(app.renderThreadTid, -4);
                                }
                            } catch (IllegalArgumentException e) {
                                Slog.w(TAG,
                                        ""Failed to set scheduling policy, thread does not exist:\n""
                                                + e);
                            } catch (SecurityException e) {
                                Slog.w(TAG, ""Failed to set scheduling policy, not allowed:\n"" + e);
                            }
                        } else {
                            // Reset priority for top app UI and render threads
                            setThreadPriority(app.pid, 0);
                            if (app.renderThreadTid != 0) {
                                setThreadPriority(app.renderThreadTid, 0);
                            }
                        }
                    }
                } catch (Exception e) {
                    if (false) {
                        Slog.w(TAG, ""Failed setting process group of "" + app.pid
                                + "" to "" + app.getCurrentSchedulingGroup());
                        Slog.w(TAG, ""at location"", e);
                    }
                } finally {
                    Binder.restoreCallingIdentity(oldId);
                }
            }
        }
        if (app.repForegroundActivities != app.hasForegroundActivities()) {
            app.repForegroundActivities = app.hasForegroundActivities();
            changes |= ProcessChangeItem.CHANGE_ACTIVITIES;
        }
        if (app.getReportedProcState() != app.getCurProcState()) {
            app.setReportedProcState(app.getCurProcState());
            if (app.thread != null) {
                try {
                    if (false) {
                        //RuntimeException h = new RuntimeException(""here"");
                        Slog.i(TAG, ""Sending new process state "" + app.getReportedProcState()
                                + "" to "" + app /*, h*/);
                    }
                    app.thread.setProcessState(app.getReportedProcState());
                } catch (RemoteException e) {
                }
            }
        }
        if (app.setProcState == PROCESS_STATE_NONEXISTENT
                || ProcessList.procStatesDifferForMem(app.getCurProcState(), app.setProcState)) {
            if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now-200)) {
                // Experimental code to more aggressively collect pss while
                // running test...  the problem is that this tends to collect
                // the data right when a process is transitioning between process
                // states, which will tend to give noisy data.
                long start = SystemClock.uptimeMillis();
                long startTime = SystemClock.currentThreadTimeMillis();
                long pss = Debug.getPss(app.pid, mTmpLong, null);
                long endTime = SystemClock.currentThreadTimeMillis();
                recordPssSampleLocked(app, app.getCurProcState(), pss, mTmpLong[0], mTmpLong[1],
                        mTmpLong[2], ProcessStats.ADD_PSS_INTERNAL_SINGLE, endTime-startTime, now);
                mPendingPssProcesses.remove(app);
                Slog.i(TAG, ""Recorded pss for "" + app + "" state "" + app.setProcState
                        + "" to "" + app.getCurProcState() + "": ""
                        + (SystemClock.uptimeMillis()-start) + ""ms"");
            }
            app.lastStateTime = now;
            app.nextPssTime = ProcessList.computeNextPssTime(app.getCurProcState(),
                    app.procStateMemTracker, mTestPssMode, mAtmInternal.isSleeping(), now);
            if (DEBUG_PSS) Slog.d(TAG_PSS, ""Process state change from ""
                    + ProcessList.makeProcStateString(app.setProcState) + "" to ""
                    + ProcessList.makeProcStateString(app.getCurProcState()) + "" next pss in ""
                    + (app.nextPssTime-now) + "": "" + app);
        } else {
            if (now > app.nextPssTime || (now > (app.lastPssTime+ProcessList.PSS_MAX_INTERVAL)
                    && now > (app.lastStateTime+ProcessList.minTimeFromStateChange(
                    mTestPssMode)))) {
                if (requestPssLocked(app, app.setProcState)) {
                    app.nextPssTime = ProcessList.computeNextPssTime(app.getCurProcState(),
                            app.procStateMemTracker, mTestPssMode, mAtmInternal.isSleeping(), now);
                }
            } else if (false && DEBUG_PSS) Slog.d(TAG_PSS,
                    ""Not requesting pss of "" + app + "": next="" + (app.nextPssTime-now));
        }
        if (app.setProcState != app.getCurProcState()) {
            if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.uid) {
                String msg = ""Proc state change of "" + app.processName
                        + "" to "" + ProcessList.makeProcStateString(app.getCurProcState())
                        + "" ("" + app.getCurProcState() + "")"" + "": "" + app.adjType;
                reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
            }
            boolean setImportant = app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
            boolean curImportant = app.getCurProcState() < ActivityManager.PROCESS_STATE_SERVICE;
            if (setImportant && !curImportant) {
                // This app is no longer something we consider important enough to allow to use
                // arbitrary amounts of battery power. Note its current CPU time to later know to
                // kill it if it is not behaving well.
                app.setWhenUnimportant(now);
                app.lastCpuTime = 0;
            }
            // Inform UsageStats of important process state change
            // Must be called before updating setProcState
            maybeUpdateUsageStatsLocked(app, nowElapsed);

            maybeUpdateLastTopTime(app, now);

            app.setProcState = app.getCurProcState();
            if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
                app.notCachedSinceIdle = false;
            }
            if (!doingAll) {
                setProcessTrackerStateLocked(app, mProcessStats.getMemFactorLocked(), now);
            } else {
                app.procStateChanged = true;
            }
        } else if (app.reportedInteraction && (nowElapsed - app.getInteractionEventTime())
                > mConstants.USAGE_STATS_INTERACTION_INTERVAL) {
            // For apps that sit around for a long time in the interactive state, we need
            // to report this at least once a day so they don't go idle.
            maybeUpdateUsageStatsLocked(app, nowElapsed);
        }

        if (changes != 0) {
            if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                    ""Changes in "" + app + "": "" + changes);
            int i = mPendingProcessChanges.size()-1;
            ProcessChangeItem item = null;
            while (i >= 0) {
                item = mPendingProcessChanges.get(i);
                if (item.pid == app.pid) {
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""Re-using existing item: "" + item);
                    break;
                }
                i--;
            }
            if (i < 0) {
                // No existing item in pending changes; need a new one.
                final int NA = mAvailProcessChanges.size();
                if (NA > 0) {
                    item = mAvailProcessChanges.remove(NA-1);
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""Retrieving available item: "" + item);
                } else {
                    item = new ProcessChangeItem();
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""Allocating new item: "" + item);
                }
                item.changes = 0;
                item.pid = app.pid;
                item.uid = app.info.uid;
                if (mPendingProcessChanges.size() == 0) {
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""*** Enqueueing dispatch processes changed!"");
                    mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED_UI_MSG).sendToTarget();
                }
                mPendingProcessChanges.add(item);
            }
            item.changes |= changes;
            item.foregroundActivities = app.repForegroundActivities;
            if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                    ""Item "" + Integer.toHexString(System.identityHashCode(item))
                    + "" "" + app.toShortString() + "": changes="" + item.changes
                    + "" foreground="" + item.foregroundActivities
                    + "" type="" + app.adjType + "" source="" + app.adjSource
                    + "" target="" + app.adjTarget);
        }

        return success;
    }

","    private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now,
            long nowElapsed) {
        boolean success = true;

        if (app.getCurRawAdj() != app.setRawAdj) {
            app.setRawAdj = app.getCurRawAdj();
        }

        int changes = 0;

        if (app.curAdj != app.setAdj) {
            // don't compact during bootup
            if (mConstants.USE_COMPACTION && mBooted) {
                // Perform a minor compaction when a perceptible app becomes the prev/home app
                // Perform a major compaction when any app enters cached
                // reminder: here, setAdj is previous state, curAdj is upcoming state
                if (app.setAdj <= ProcessList.PERCEPTIBLE_APP_ADJ &&
                    (app.curAdj == ProcessList.PREVIOUS_APP_ADJ ||
                     app.curAdj == ProcessList.HOME_APP_ADJ)) {
                    mAppCompact.compactAppSome(app);
                } else if (app.setAdj < ProcessList.CACHED_APP_MIN_ADJ &&
                           app.curAdj >= ProcessList.CACHED_APP_MIN_ADJ) {
                    mAppCompact.compactAppFull(app);
                }
            }
            ProcessList.setOomAdj(app.pid, app.uid, app.curAdj);
            if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.info.uid) {
                String msg = ""Set "" + app.pid + "" "" + app.processName + "" adj ""
                        + app.curAdj + "": "" + app.adjType;
                reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
            }
            app.setAdj = app.curAdj;
            app.verifiedAdj = ProcessList.INVALID_ADJ;
        }

        final int curSchedGroup = app.getCurrentSchedulingGroup();
        if (app.setSchedGroup != curSchedGroup) {
            int oldSchedGroup = app.setSchedGroup;
            app.setSchedGroup = curSchedGroup;
            if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.uid) {
                String msg = ""Setting sched group of "" + app.processName
                        + "" to "" + curSchedGroup + "": "" + app.adjType;
                reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
            }
            if (app.waitingToKill != null && app.curReceivers.isEmpty()
                    && app.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND) {
                app.kill(app.waitingToKill, true);
                success = false;
            } else {
                int processGroup;
                switch (curSchedGroup) {
                    case ProcessList.SCHED_GROUP_BACKGROUND:
                        processGroup = THREAD_GROUP_BG_NONINTERACTIVE;
                        break;
                    case ProcessList.SCHED_GROUP_TOP_APP:
                    case ProcessList.SCHED_GROUP_TOP_APP_BOUND:
                        processGroup = THREAD_GROUP_TOP_APP;
                        break;
                    case ProcessList.SCHED_GROUP_RESTRICTED:
                        processGroup = THREAD_GROUP_RESTRICTED;
                        break;
                    default:
                        processGroup = THREAD_GROUP_DEFAULT;
                        break;
                }
                long oldId = Binder.clearCallingIdentity();
                try {
                    if (mEnableProcessGroupCgroupFollow) {
                        setCgroupProcsProcessGroup(app.info.uid, app.pid, processGroup);
                    } else {
                        setProcessGroup(app.pid, processGroup);
                    }
                    if (curSchedGroup == ProcessList.SCHED_GROUP_TOP_APP) {
                        // do nothing if we already switched to RT
                        if (oldSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) {
                            app.getWindowProcessController().onTopProcChanged();
                            if (mUseFifoUiScheduling) {
                                // Switch UI pipeline for app to SCHED_FIFO
                                app.savedPriority = Process.getThreadPriority(app.pid);
                                scheduleAsFifoPriority(app.pid, /* suppressLogs */true);
                                if (app.renderThreadTid != 0) {
                                    scheduleAsFifoPriority(app.renderThreadTid,
                                        /* suppressLogs */true);
                                    if (DEBUG_OOM_ADJ) {
                                        Slog.d(""UI_FIFO"", ""Set RenderThread (TID "" +
                                            app.renderThreadTid + "") to FIFO"");
                                    }
                                } else {
                                    if (DEBUG_OOM_ADJ) {
                                        Slog.d(""UI_FIFO"", ""Not setting RenderThread TID"");
                                    }
                                }
                            } else {
                                // Boost priority for top app UI and render threads
                                setThreadPriority(app.pid, TOP_APP_PRIORITY_BOOST);
                                if (app.renderThreadTid != 0) {
                                    try {
                                        setThreadPriority(app.renderThreadTid,
                                                TOP_APP_PRIORITY_BOOST);
                                    } catch (IllegalArgumentException e) {
                                        // thread died, ignore
                                    }
                                }
                            }
                        }
                    } else if (oldSchedGroup == ProcessList.SCHED_GROUP_TOP_APP &&
                            curSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) {
                        app.getWindowProcessController().onTopProcChanged();
                        if (mUseFifoUiScheduling) {
                            try {
                                // Reset UI pipeline to SCHED_OTHER
                                setThreadScheduler(app.pid, SCHED_OTHER, 0);
                                setThreadPriority(app.pid, app.savedPriority);
                                if (app.renderThreadTid != 0) {
                                    setThreadScheduler(app.renderThreadTid,
                                        SCHED_OTHER, 0);
                                    setThreadPriority(app.renderThreadTid, -4);
                                }
                            } catch (IllegalArgumentException e) {
                                Slog.w(TAG,
                                        ""Failed to set scheduling policy, thread does not exist:\n""
                                                + e);
                            } catch (SecurityException e) {
                                Slog.w(TAG, ""Failed to set scheduling policy, not allowed:\n"" + e);
                            }
                        } else {
                            // Reset priority for top app UI and render threads
                            setThreadPriority(app.pid, 0);
                            if (app.renderThreadTid != 0) {
                                setThreadPriority(app.renderThreadTid, 0);
                            }
                        }
                    }
                } catch (Exception e) {
                    if (false) {
                        Slog.w(TAG, ""Failed setting process group of "" + app.pid
                                + "" to "" + app.getCurrentSchedulingGroup());
                        Slog.w(TAG, ""at location"", e);
                    }
                } finally {
                    Binder.restoreCallingIdentity(oldId);
                }
            }
        }
        if (app.repForegroundActivities != app.hasForegroundActivities()) {
            app.repForegroundActivities = app.hasForegroundActivities();
            changes |= ProcessChangeItem.CHANGE_ACTIVITIES;
        }
        if (app.getReportedProcState() != app.getCurProcState()) {
            app.setReportedProcState(app.getCurProcState());
            if (app.thread != null) {
                try {
                    if (false) {
                        //RuntimeException h = new RuntimeException(""here"");
                        Slog.i(TAG, ""Sending new process state "" + app.getReportedProcState()
                                + "" to "" + app /*, h*/);
                    }
                    app.thread.setProcessState(app.getReportedProcState());
                } catch (RemoteException e) {
                }
            }
        }
        if (app.setProcState == PROCESS_STATE_NONEXISTENT
                || ProcessList.procStatesDifferForMem(app.getCurProcState(), app.setProcState)) {
            if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now-200)) {
                // Experimental code to more aggressively collect pss while
                // running test...  the problem is that this tends to collect
                // the data right when a process is transitioning between process
                // states, which will tend to give noisy data.
                long start = SystemClock.uptimeMillis();
                long startTime = SystemClock.currentThreadTimeMillis();
                long pss = Debug.getPss(app.pid, mTmpLong, null);
                long endTime = SystemClock.currentThreadTimeMillis();
                recordPssSampleLocked(app, app.getCurProcState(), pss, mTmpLong[0], mTmpLong[1],
                        mTmpLong[2], ProcessStats.ADD_PSS_INTERNAL_SINGLE, endTime-startTime, now);
                mPendingPssProcesses.remove(app);
                Slog.i(TAG, ""Recorded pss for "" + app + "" state "" + app.setProcState
                        + "" to "" + app.getCurProcState() + "": ""
                        + (SystemClock.uptimeMillis()-start) + ""ms"");
            }
            app.lastStateTime = now;
            app.nextPssTime = ProcessList.computeNextPssTime(app.getCurProcState(),
                    app.procStateMemTracker, mTestPssMode, mAtmInternal.isSleeping(), now);
            if (DEBUG_PSS) Slog.d(TAG_PSS, ""Process state change from ""
                    + ProcessList.makeProcStateString(app.setProcState) + "" to ""
                    + ProcessList.makeProcStateString(app.getCurProcState()) + "" next pss in ""
                    + (app.nextPssTime-now) + "": "" + app);
        } else {
            if (now > app.nextPssTime || (now > (app.lastPssTime+ProcessList.PSS_MAX_INTERVAL)
                    && now > (app.lastStateTime+ProcessList.minTimeFromStateChange(
                    mTestPssMode)))) {
                if (requestPssLocked(app, app.setProcState)) {
                    app.nextPssTime = ProcessList.computeNextPssTime(app.getCurProcState(),
                            app.procStateMemTracker, mTestPssMode, mAtmInternal.isSleeping(), now);
                }
            } else if (false && DEBUG_PSS) Slog.d(TAG_PSS,
                    ""Not requesting pss of "" + app + "": next="" + (app.nextPssTime-now));
        }
        if (app.setProcState != app.getCurProcState()) {
            if (DEBUG_SWITCH || DEBUG_OOM_ADJ || mCurOomAdjUid == app.uid) {
                String msg = ""Proc state change of "" + app.processName
                        + "" to "" + ProcessList.makeProcStateString(app.getCurProcState())
                        + "" ("" + app.getCurProcState() + "")"" + "": "" + app.adjType;
                reportOomAdjMessageLocked(TAG_OOM_ADJ, msg);
            }
            boolean setImportant = app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
            boolean curImportant = app.getCurProcState() < ActivityManager.PROCESS_STATE_SERVICE;
            if (setImportant && !curImportant) {
                // This app is no longer something we consider important enough to allow to use
                // arbitrary amounts of battery power. Note its current CPU time to later know to
                // kill it if it is not behaving well.
                app.setWhenUnimportant(now);
                app.lastCpuTime = 0;
            }
            // Inform UsageStats of important process state change
            // Must be called before updating setProcState
            maybeUpdateUsageStatsLocked(app, nowElapsed);

            maybeUpdateLastTopTime(app, now);

            app.setProcState = app.getCurProcState();
            if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
                app.notCachedSinceIdle = false;
            }
            if (!doingAll) {
                setProcessTrackerStateLocked(app, mProcessStats.getMemFactorLocked(), now);
            } else {
                app.procStateChanged = true;
            }
        } else if (app.reportedInteraction && (nowElapsed - app.getInteractionEventTime())
                > mConstants.USAGE_STATS_INTERACTION_INTERVAL) {
            // For apps that sit around for a long time in the interactive state, we need
            // to report this at least once a day so they don't go idle.
            maybeUpdateUsageStatsLocked(app, nowElapsed);
        }

        if (changes != 0) {
            if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                    ""Changes in "" + app + "": "" + changes);
            int i = mPendingProcessChanges.size()-1;
            ProcessChangeItem item = null;
            while (i >= 0) {
                item = mPendingProcessChanges.get(i);
                if (item.pid == app.pid) {
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""Re-using existing item: "" + item);
                    break;
                }
                i--;
            }
            if (i < 0) {
                // No existing item in pending changes; need a new one.
                final int NA = mAvailProcessChanges.size();
                if (NA > 0) {
                    item = mAvailProcessChanges.remove(NA-1);
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""Retrieving available item: "" + item);
                } else {
                    item = new ProcessChangeItem();
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""Allocating new item: "" + item);
                }
                item.changes = 0;
                item.pid = app.pid;
                item.uid = app.info.uid;
                if (mPendingProcessChanges.size() == 0) {
                    if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                            ""*** Enqueueing dispatch processes changed!"");
                    mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED_UI_MSG).sendToTarget();
                }
                mPendingProcessChanges.add(item);
            }
            item.changes |= changes;
            item.foregroundActivities = app.repForegroundActivities;
            if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,
                    ""Item "" + Integer.toHexString(System.identityHashCode(item))
                    + "" "" + app.toShortString() + "": changes="" + item.changes
                    + "" foreground="" + item.foregroundActivities
                    + "" type="" + app.adjType + "" source="" + app.adjSource
                    + "" target="" + app.adjTarget);
        }

        return success;
    }

","[1.0, 1.0]"
379,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(17831, 18250, 420), (17831, 18250, 420)]","        mOomAdjProfiler.oomAdjStarted();
        final ProcessRecord TOP_APP = getTopAppLocked();
        final long now = SystemClock.uptimeMillis();
        final long nowElapsed = SystemClock.elapsedRealtime();
        final long oldTime = now - ProcessList.MAX_EMPTY_TIME;
        final int N = mProcessList.getLruSizeLocked();

        // Reset state in all uid records.
        for (int i=mActiveUids.size()-1; i>=0; i--) {
            final UidRecord uidRec = mActiveUids.valueAt(i);
            if (false && DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,
                    ""Starting update of "" + uidRec);
            uidRec.reset();
        }

        if (mAtmInternal != null) {
            mAtmInternal.rankTaskLayersIfNeeded();
        }

        mAdjSeq++;
        mNewNumServiceProcs = 0;
        mNewNumAServiceProcs = 0;

        final int emptyProcessLimit = mConstants.CUR_MAX_EMPTY_PROCESSES;
        final int cachedProcessLimit = mConstants.CUR_MAX_CACHED_PROCESSES - emptyProcessLimit;

        // Let's determine how many processes we have running vs.
        // how many slots we have for background processes; we may want
        // to put multiple processes in a slot of there are enough of
        // them.
        final int numSlots = (ProcessList.CACHED_APP_MAX_ADJ
                - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2
                / ProcessList.CACHED_APP_IMPORTANCE_LEVELS;
        int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;
        if (numEmptyProcs > cachedProcessLimit) {
            // If there are more empty processes than our limit on cached
            // processes, then use the cached process limit for the factor.
            // This ensures that the really old empty processes get pushed
            // down to the bottom, so if we are running low on memory we will
            // have a better chance at keeping around more cached processes
            // instead of a gazillion empty processes.
            numEmptyProcs = cachedProcessLimit;
        }
        int emptyFactor = (numEmptyProcs + numSlots - 1) / numSlots;
        if (emptyFactor < 1) emptyFactor = 1;
        int cachedFactor = (mNumCachedHiddenProcs > 0 ? (mNumCachedHiddenProcs + numSlots - 1) : 1)
                / numSlots;
        if (cachedFactor < 1) cachedFactor = 1;
        int stepCached = -1;
        int stepEmpty = -1;
        int numCached = 0;
        int numCachedExtraGroup = 0;
        int numEmpty = 0;
        int numTrimming = 0;
        int lastCachedGroup = 0;
        int lastCachedGroupImportance = 0;
        int lastCachedGroupUid = 0;

        mNumNonCachedProcs = 0;
        mNumCachedHiddenProcs = 0;

        // First update the OOM adjustment for each of the
        // application processes based on their current state.
        int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;
        int nextCachedAdj = curCachedAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        int curCachedImpAdj = 0;
        int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ + ProcessList.CACHED_APP_IMPORTANCE_LEVELS;
        int nextEmptyAdj = curEmptyAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        ProcessRecord selectedAppRecord = null;
        long serviceLastActivity = 0;
        int numBServices = 0;

        boolean retryCycles = false;

        // need to reset cycle state before calling computeOomAdjLocked because of service connections
        for (int i=N-1; i>=0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            app.containsCycle = false;
            app.setCurRawProcState(PROCESS_STATE_CACHED_EMPTY);
            app.setCurRawAdj(ProcessList.UNKNOWN_ADJ);
        }
        for (int i=N-1; i>=0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            if (mEnableBServicePropagation && app.serviceb
                    && (app.curAdj == ProcessList.SERVICE_B_ADJ)) {
                numBServices++;
                for (int s = app.services.size() - 1; s >= 0; s--) {
                    ServiceRecord sr = app.services.valueAt(s);
                    if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + app.processName
                            + "" serviceb = "" + app.serviceb + "" s = "" + s + "" sr.lastActivity = ""
                            + sr.lastActivity + "" packageName = "" + sr.packageName
                            + "" processName = "" + sr.processName);
                    if (SystemClock.uptimeMillis() - sr.lastActivity
                            < mMinBServiceAgingTime) {
                        if (DEBUG_OOM_ADJ) {
                            Slog.d(TAG,""Not aged enough!!!"");
                        }
                        continue;
                    }
                    if (serviceLastActivity == 0) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    } else if (sr.lastActivity < serviceLastActivity) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    }
                }
            }
            if (DEBUG_OOM_ADJ && selectedAppRecord != null) Slog.d(TAG,
                    ""Identified app.processName = "" + selectedAppRecord.processName
                    + "" app.pid = "" + selectedAppRecord.pid);
            if (!app.killedByAm && app.thread != null) {
                app.procStateChanged = false;
                computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now, false);

                // if any app encountered a cycle, we need to perform an additional loop later
                retryCycles |= app.containsCycle;

                // If we haven't yet assigned the final cached adj
                // to the process, do that now.
                if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
                    switch (app.getCurProcState()) {
                        case PROCESS_STATE_CACHED_ACTIVITY:
                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                        case ActivityManager.PROCESS_STATE_CACHED_RECENT:
                            // Figure out the next cached level, taking into account groups.
                            boolean inGroup = false;
                            if (app.connectionGroup != 0) {
                                if (lastCachedGroupUid == app.uid
                                        && lastCachedGroup == app.connectionGroup) {
                                    // This is in the same group as the last process, just tweak
                                    // adjustment by importance.
                                    if (app.connectionImportance > lastCachedGroupImportance) {
                                        lastCachedGroupImportance = app.connectionImportance;
                                        if (curCachedAdj < nextCachedAdj
                                                && curCachedAdj < ProcessList.CACHED_APP_MAX_ADJ) {
                                            curCachedImpAdj++;
                                        }
                                    }
                                    inGroup = true;
                                } else {
                                    lastCachedGroupUid = app.uid;
                                    lastCachedGroup = app.connectionGroup;
                                    lastCachedGroupImportance = app.connectionImportance;
                                }
                            }
                            if (!inGroup && curCachedAdj != nextCachedAdj) {
                                stepCached++;
                                curCachedImpAdj = 0;
                                if (stepCached >= cachedFactor) {
                                    stepCached = 0;
                                    curCachedAdj = nextCachedAdj;
                                    nextCachedAdj += ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2;
                                    if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
                                        nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;
                                    }
                                }
                            }
                            // This process is a cached process holding activities...
                            // assign it the next cached value for that type, and then
                            // step that cached level.
                            app.setCurRawAdj(curCachedAdj + curCachedImpAdj);
                            app.curAdj = app.modifyRawOomAdj(curCachedAdj + curCachedImpAdj);
                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, ""Assigning activity LRU #"" + i
                                    + "" adj: "" + app.curAdj + "" (curCachedAdj="" + curCachedAdj
                                    + "" curCachedImpAdj="" + curCachedImpAdj + "")"");
                            break;
                        default:
                            // Figure out the next cached level.
                            if (curEmptyAdj != nextEmptyAdj) {
                                stepEmpty++;
                                if (stepEmpty >= emptyFactor) {
                                    stepEmpty = 0;
                                    curEmptyAdj = nextEmptyAdj;
                                    nextEmptyAdj += ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2;
                                    if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
                                        nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;
                                    }
                                }
                            }
                            // For everything else, assign next empty cached process
                            // level and bump that up.  Note that this means that
                            // long-running services that have dropped down to the
                            // cached level will be treated as empty (since their process
                            // state is still as a service), which is what we want.
                            app.setCurRawAdj(curEmptyAdj);
                            app.curAdj = app.modifyRawOomAdj(curEmptyAdj);
                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, ""Assigning empty LRU #"" + i
                                    + "" adj: "" + app.curAdj + "" (curEmptyAdj="" + curEmptyAdj
                                    + "")"");
                            break;
                    }
                }
            }
        }

        // Cycle strategy:
        // - Retry computing any process that has encountered a cycle.
        // - Continue retrying until no process was promoted.
        // - Iterate from least important to most important.
        int cycleCount = 0;
        while (retryCycles && cycleCount < 10) {
            cycleCount++;
            retryCycles = false;

            for (int i=0; i<N; i++) {
                ProcessRecord app = mProcessList.mLruProcesses.get(i);
                if (!app.killedByAm && app.thread != null && app.containsCycle == true) {
                    app.adjSeq--;
                    app.completedAdjSeq--;
                }
            }

            for (int i=0; i<N; i++) {
                ProcessRecord app = mProcessList.mLruProcesses.get(i);
                if (!app.killedByAm && app.thread != null && app.containsCycle == true) {
                    if (computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now,
                            true)) {
                        retryCycles = true;
                    }
                }
            }
        }

        lastCachedGroup = lastCachedGroupUid = 0;

        for (int i=N-1; i>=0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            if (!app.killedByAm && app.thread != null) {
                applyOomAdjLocked(app, true, now, nowElapsed);

                // Count the number of process types.
                switch (app.getCurProcState()) {
                    case PROCESS_STATE_CACHED_ACTIVITY:
                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                        mNumCachedHiddenProcs++;
                        numCached++;
                        if (app.connectionGroup != 0) {
                            if (lastCachedGroupUid == app.uid
                                    && lastCachedGroup == app.connectionGroup) {
                                // If this process is the next in the same group, we don't
                                // want it to count against our limit of the number of cached
                                // processes, so bump up the group count to account for it.
                                numCachedExtraGroup++;
                            } else {
                                lastCachedGroupUid = app.uid;
                                lastCachedGroup = app.connectionGroup;
                            }
                        } else {
                            lastCachedGroupUid = lastCachedGroup = 0;
                        }
                        if ((numCached - numCachedExtraGroup) > cachedProcessLimit) {
                            app.kill(""cached #"" + numCached, true);
                        }
                        break;
                    case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
                        if (numEmpty > mConstants.CUR_TRIM_EMPTY_PROCESSES
                                && app.lastActivityTime < oldTime) {
                            app.kill(""empty for ""
                                    + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)
                                    / 1000) + ""s"", true);
                        } else {
                            numEmpty++;
                            if (numEmpty > emptyProcessLimit) {
                                app.kill(""empty #"" + numEmpty, true);
                            }
                        }
                        break;
                    default:
                        mNumNonCachedProcs++;
                        break;
                }

                if (app.isolated && app.services.size() <= 0 && app.isolatedEntryPoint == null) {
                    // If this is an isolated process, there are no services
                    // running in it, and it's not a special process with a
                    // custom entry point, then the process is no longer
                    // needed.  We agressively kill these because we can by
                    // definition not re-use the same process again, and it is
                    // good to avoid having whatever code was running in them
                    // left sitting around after no longer needed.
                    app.kill(""isolated not needed"", true);
                } else {
                    // Keeping this process, update its uid.
                    final UidRecord uidRec = app.uidRecord;
                    if (uidRec != null) {
                        uidRec.ephemeral = app.info.isInstantApp();
                        if (uidRec.getCurProcState() > app.getCurProcState()) {
                            uidRec.setCurProcState(app.getCurProcState());
                        }
                        if (app.hasForegroundServices()) {
                            uidRec.foregroundServices = true;
                        }
                    }
                }

                if (app.getCurProcState() >= ActivityManager.PROCESS_STATE_HOME
                        && !app.killedByAm) {
                    numTrimming++;
                }
            }
        }
        if ((numBServices > mBServiceAppThreshold) && (true == mAllowLowerMemLevel)
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }

        incrementProcStateSeqAndNotifyAppsLocked();

        mNumServiceProcs = mNewNumServiceProcs;

        boolean allChanged = updateLowMemStateLocked(numCached, numEmpty, numTrimming);

        if (mAlwaysFinishActivities) {
            // Need to do this on its own message because the stack may not
            // be in a consistent state at this point.
            mAtmInternal.scheduleDestroyAllActivities(""always-finish"");
        }

        if (allChanged) {
            requestPssAllProcsLocked(now, false, mProcessStats.isMemFactorLowered());
        }

        ArrayList<UidRecord> becameIdle = null;

        // Update from any uid changes.
        if (mLocalPowerManager != null) {
            mLocalPowerManager.startUidChanges();
        }
        for (int i=mActiveUids.size()-1; i>=0; i--) {
            final UidRecord uidRec = mActiveUids.valueAt(i);
            int uidChange = UidRecord.CHANGE_PROCSTATE;
            if (uidRec.getCurProcState() != PROCESS_STATE_NONEXISTENT
                    && (uidRec.setProcState != uidRec.getCurProcState()
                           || uidRec.setWhitelist != uidRec.curWhitelist)) {
                if (DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS, ""Changes in "" + uidRec
                        + "": proc state from "" + uidRec.setProcState + "" to ""
                        + uidRec.getCurProcState() + "", whitelist from "" + uidRec.setWhitelist
                        + "" to "" + uidRec.curWhitelist);
                if (ActivityManager.isProcStateBackground(uidRec.getCurProcState())
                        && !uidRec.curWhitelist) {
                    // UID is now in the background (and not on the temp whitelist).  Was it
                    // previously in the foreground (or on the temp whitelist)?
                    if (!ActivityManager.isProcStateBackground(uidRec.setProcState)
                            || uidRec.setWhitelist) {
                        uidRec.lastBackgroundTime = nowElapsed;
                        if (!mHandler.hasMessages(IDLE_UIDS_MSG)) {
                            // Note: the background settle time is in elapsed realtime, while
                            // the handler time base is uptime.  All this means is that we may
                            // stop background uids later than we had intended, but that only
                            // happens because the device was sleeping so we are okay anyway.
                            mHandler.sendEmptyMessageDelayed(IDLE_UIDS_MSG,
                                    mConstants.BACKGROUND_SETTLE_TIME);
                        }
                    }
                    if (uidRec.idle && !uidRec.setIdle) {
                        uidChange = UidRecord.CHANGE_IDLE;
                        if (becameIdle == null) {
                            becameIdle = new ArrayList<>();
                        }
                        becameIdle.add(uidRec);
                    }
                } else {
                    if (uidRec.idle) {
                        uidChange = UidRecord.CHANGE_ACTIVE;
                        EventLogTags.writeAmUidActive(uidRec.uid);
                        uidRec.idle = false;
                    }
                    uidRec.lastBackgroundTime = 0;
                }
                final boolean wasCached = uidRec.setProcState
                        > ActivityManager.PROCESS_STATE_RECEIVER;
                final boolean isCached = uidRec.getCurProcState()
                        > ActivityManager.PROCESS_STATE_RECEIVER;
                if (wasCached != isCached || uidRec.setProcState == PROCESS_STATE_NONEXISTENT) {
                    uidChange |= isCached ? UidRecord.CHANGE_CACHED : UidRecord.CHANGE_UNCACHED;
                }
                uidRec.setProcState = uidRec.getCurProcState();
                uidRec.setWhitelist = uidRec.curWhitelist;
                uidRec.setIdle = uidRec.idle;
                enqueueUidChangeLocked(uidRec, -1, uidChange);
                noteUidProcessState(uidRec.uid, uidRec.getCurProcState());
                if (uidRec.foregroundServices) {
                    mServices.foregroundServiceProcStateChangedLocked(uidRec);
                }
            }
        }
        if (mLocalPowerManager != null) {
            mLocalPowerManager.finishUidChanges();
        }

        if (becameIdle != null) {
            // If we have any new uids that became idle this time, we need to make sure
            // they aren't left with running services.
            for (int i = becameIdle.size() - 1; i >= 0; i--) {
                mServices.stopInBackgroundLocked(becameIdle.get(i).uid);
            }
        }

        if (mProcessStats.shouldWriteNowLocked(now)) {
            mHandler.post(new ProcStatsRunnable(ActivityManagerService.this, mProcessStats));
        }

        // Run this after making sure all procstates are updated.
        mProcessStats.updateTrackingAssociationsLocked(mAdjSeq, now);

        if (DEBUG_OOM_ADJ) {
            final long duration = SystemClock.uptimeMillis() - now;
            if (false) {
                Slog.d(TAG_OOM_ADJ, ""Did OOM ADJ in "" + duration + ""ms"",
                        new RuntimeException(""here"").fillInStackTrace());
            } else {
                Slog.d(TAG_OOM_ADJ, ""Did OOM ADJ in "" + duration + ""ms"");
            }
        }
        mOomAdjProfiler.oomAdjEnded();
","        mOomAdjProfiler.oomAdjStarted();
        final ProcessRecord TOP_APP = getTopAppLocked();
        final long now = SystemClock.uptimeMillis();
        final long nowElapsed = SystemClock.elapsedRealtime();
        final long oldTime = now - ProcessList.MAX_EMPTY_TIME;
        final int N = mProcessList.getLruSizeLocked();

        // Reset state in all uid records.
        for (int i=mActiveUids.size()-1; i>=0; i--) {
            final UidRecord uidRec = mActiveUids.valueAt(i);
            if (false && DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,
                    ""Starting update of "" + uidRec);
            uidRec.reset();
        }

        if (mAtmInternal != null) {
            mAtmInternal.rankTaskLayersIfNeeded();
        }

        mAdjSeq++;
        mNewNumServiceProcs = 0;
        mNewNumAServiceProcs = 0;

        final int emptyProcessLimit = mConstants.CUR_MAX_EMPTY_PROCESSES;
        final int cachedProcessLimit = mConstants.CUR_MAX_CACHED_PROCESSES - emptyProcessLimit;

        // Let's determine how many processes we have running vs.
        // how many slots we have for background processes; we may want
        // to put multiple processes in a slot of there are enough of
        // them.
        final int numSlots = (ProcessList.CACHED_APP_MAX_ADJ
                - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2
                / ProcessList.CACHED_APP_IMPORTANCE_LEVELS;
        int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;
        if (numEmptyProcs > cachedProcessLimit) {
            // If there are more empty processes than our limit on cached
            // processes, then use the cached process limit for the factor.
            // This ensures that the really old empty processes get pushed
            // down to the bottom, so if we are running low on memory we will
            // have a better chance at keeping around more cached processes
            // instead of a gazillion empty processes.
            numEmptyProcs = cachedProcessLimit;
        }
        int emptyFactor = (numEmptyProcs + numSlots - 1) / numSlots;
        if (emptyFactor < 1) emptyFactor = 1;
        int cachedFactor = (mNumCachedHiddenProcs > 0 ? (mNumCachedHiddenProcs + numSlots - 1) : 1)
                / numSlots;
        if (cachedFactor < 1) cachedFactor = 1;
        int stepCached = -1;
        int stepEmpty = -1;
        int numCached = 0;
        int numCachedExtraGroup = 0;
        int numEmpty = 0;
        int numTrimming = 0;
        int lastCachedGroup = 0;
        int lastCachedGroupImportance = 0;
        int lastCachedGroupUid = 0;

        mNumNonCachedProcs = 0;
        mNumCachedHiddenProcs = 0;

        // First update the OOM adjustment for each of the
        // application processes based on their current state.
        int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;
        int nextCachedAdj = curCachedAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        int curCachedImpAdj = 0;
        int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ + ProcessList.CACHED_APP_IMPORTANCE_LEVELS;
        int nextEmptyAdj = curEmptyAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        ProcessRecord selectedAppRecord = null;
        long serviceLastActivity = 0;
        int numBServices = 0;

        boolean retryCycles = false;

        // need to reset cycle state before calling computeOomAdjLocked because of service connections
        for (int i=N-1; i>=0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            app.containsCycle = false;
            app.setCurRawProcState(PROCESS_STATE_CACHED_EMPTY);
            app.setCurRawAdj(ProcessList.UNKNOWN_ADJ);
        }
        for (int i=N-1; i>=0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            if (mEnableBServicePropagation && app.serviceb
                    && (app.curAdj == ProcessList.SERVICE_B_ADJ)) {
                numBServices++;
                for (int s = app.services.size() - 1; s >= 0; s--) {
                    ServiceRecord sr = app.services.valueAt(s);
                    if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + app.processName
                            + "" serviceb = "" + app.serviceb + "" s = "" + s + "" sr.lastActivity = ""
                            + sr.lastActivity + "" packageName = "" + sr.packageName
                            + "" processName = "" + sr.processName);
                    if (SystemClock.uptimeMillis() - sr.lastActivity
                            < mMinBServiceAgingTime) {
                        if (DEBUG_OOM_ADJ) {
                            Slog.d(TAG,""Not aged enough!!!"");
                        }
                        continue;
                    }
                    if (serviceLastActivity == 0) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    } else if (sr.lastActivity < serviceLastActivity) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    }
                }
            }
            if (DEBUG_OOM_ADJ && selectedAppRecord != null) Slog.d(TAG,
                    ""Identified app.processName = "" + selectedAppRecord.processName
                    + "" app.pid = "" + selectedAppRecord.pid);
            if (!app.killedByAm && app.thread != null) {
                app.procStateChanged = false;
                computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now, false);

                // if any app encountered a cycle, we need to perform an additional loop later
                retryCycles |= app.containsCycle;

                // If we haven't yet assigned the final cached adj
                // to the process, do that now.
                if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
                    switch (app.getCurProcState()) {
                        case PROCESS_STATE_CACHED_ACTIVITY:
                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                        case ActivityManager.PROCESS_STATE_CACHED_RECENT:
                            // Figure out the next cached level, taking into account groups.
                            boolean inGroup = false;
                            if (app.connectionGroup != 0) {
                                if (lastCachedGroupUid == app.uid
                                        && lastCachedGroup == app.connectionGroup) {
                                    // This is in the same group as the last process, just tweak
                                    // adjustment by importance.
                                    if (app.connectionImportance > lastCachedGroupImportance) {
                                        lastCachedGroupImportance = app.connectionImportance;
                                        if (curCachedAdj < nextCachedAdj
                                                && curCachedAdj < ProcessList.CACHED_APP_MAX_ADJ) {
                                            curCachedImpAdj++;
                                        }
                                    }
                                    inGroup = true;
                                } else {
                                    lastCachedGroupUid = app.uid;
                                    lastCachedGroup = app.connectionGroup;
                                    lastCachedGroupImportance = app.connectionImportance;
                                }
                            }
                            if (!inGroup && curCachedAdj != nextCachedAdj) {
                                stepCached++;
                                curCachedImpAdj = 0;
                                if (stepCached >= cachedFactor) {
                                    stepCached = 0;
                                    curCachedAdj = nextCachedAdj;
                                    nextCachedAdj += ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2;
                                    if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
                                        nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;
                                    }
                                }
                            }
                            // This process is a cached process holding activities...
                            // assign it the next cached value for that type, and then
                            // step that cached level.
                            app.setCurRawAdj(curCachedAdj + curCachedImpAdj);
                            app.curAdj = app.modifyRawOomAdj(curCachedAdj + curCachedImpAdj);
                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, ""Assigning activity LRU #"" + i
                                    + "" adj: "" + app.curAdj + "" (curCachedAdj="" + curCachedAdj
                                    + "" curCachedImpAdj="" + curCachedImpAdj + "")"");
                            break;
                        default:
                            // Figure out the next cached level.
                            if (curEmptyAdj != nextEmptyAdj) {
                                stepEmpty++;
                                if (stepEmpty >= emptyFactor) {
                                    stepEmpty = 0;
                                    curEmptyAdj = nextEmptyAdj;
                                    nextEmptyAdj += ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2;
                                    if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
                                        nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;
                                    }
                                }
                            }
                            // For everything else, assign next empty cached process
                            // level and bump that up.  Note that this means that
                            // long-running services that have dropped down to the
                            // cached level will be treated as empty (since their process
                            // state is still as a service), which is what we want.
                            app.setCurRawAdj(curEmptyAdj);
                            app.curAdj = app.modifyRawOomAdj(curEmptyAdj);
                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, ""Assigning empty LRU #"" + i
                                    + "" adj: "" + app.curAdj + "" (curEmptyAdj="" + curEmptyAdj
                                    + "")"");
                            break;
                    }
                }
            }
        }

        // Cycle strategy:
        // - Retry computing any process that has encountered a cycle.
        // - Continue retrying until no process was promoted.
        // - Iterate from least important to most important.
        int cycleCount = 0;
        while (retryCycles && cycleCount < 10) {
            cycleCount++;
            retryCycles = false;

            for (int i=0; i<N; i++) {
                ProcessRecord app = mProcessList.mLruProcesses.get(i);
                if (!app.killedByAm && app.thread != null && app.containsCycle == true) {
                    app.adjSeq--;
                    app.completedAdjSeq--;
                }
            }

            for (int i=0; i<N; i++) {
                ProcessRecord app = mProcessList.mLruProcesses.get(i);
                if (!app.killedByAm && app.thread != null && app.containsCycle == true) {
                    if (computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now,
                            true)) {
                        retryCycles = true;
                    }
                }
            }
        }

        lastCachedGroup = lastCachedGroupUid = 0;

        for (int i=N-1; i>=0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            if (!app.killedByAm && app.thread != null) {
                applyOomAdjLocked(app, true, now, nowElapsed);

                // Count the number of process types.
                switch (app.getCurProcState()) {
                    case PROCESS_STATE_CACHED_ACTIVITY:
                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                        mNumCachedHiddenProcs++;
                        numCached++;
                        if (app.connectionGroup != 0) {
                            if (lastCachedGroupUid == app.uid
                                    && lastCachedGroup == app.connectionGroup) {
                                // If this process is the next in the same group, we don't
                                // want it to count against our limit of the number of cached
                                // processes, so bump up the group count to account for it.
                                numCachedExtraGroup++;
                            } else {
                                lastCachedGroupUid = app.uid;
                                lastCachedGroup = app.connectionGroup;
                            }
                        } else {
                            lastCachedGroupUid = lastCachedGroup = 0;
                        }
                        if ((numCached - numCachedExtraGroup) > cachedProcessLimit) {
                            app.kill(""cached #"" + numCached, true);
                        }
                        break;
                    case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
                        if (numEmpty > mConstants.CUR_TRIM_EMPTY_PROCESSES
                                && app.lastActivityTime < oldTime) {
                            app.kill(""empty for ""
                                    + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)
                                    / 1000) + ""s"", true);
                        } else {
                            numEmpty++;
                            if (numEmpty > emptyProcessLimit) {
                                app.kill(""empty #"" + numEmpty, true);
                            }
                        }
                        break;
                    default:
                        mNumNonCachedProcs++;
                        break;
                }

                if (app.isolated && app.services.size() <= 0 && app.isolatedEntryPoint == null) {
                    // If this is an isolated process, there are no services
                    // running in it, and it's not a special process with a
                    // custom entry point, then the process is no longer
                    // needed.  We agressively kill these because we can by
                    // definition not re-use the same process again, and it is
                    // good to avoid having whatever code was running in them
                    // left sitting around after no longer needed.
                    app.kill(""isolated not needed"", true);
                } else {
                    // Keeping this process, update its uid.
                    final UidRecord uidRec = app.uidRecord;
                    if (uidRec != null) {
                        uidRec.ephemeral = app.info.isInstantApp();
                        if (uidRec.getCurProcState() > app.getCurProcState()) {
                            uidRec.setCurProcState(app.getCurProcState());
                        }
                        if (app.hasForegroundServices()) {
                            uidRec.foregroundServices = true;
                        }
                    }
                }

                if (app.getCurProcState() >= ActivityManager.PROCESS_STATE_HOME
                        && !app.killedByAm) {
                    numTrimming++;
                }
            }
        }
        if ((numBServices > mBServiceAppThreshold) && (true == mAllowLowerMemLevel)
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }

        incrementProcStateSeqAndNotifyAppsLocked();

        mNumServiceProcs = mNewNumServiceProcs;

        boolean allChanged = updateLowMemStateLocked(numCached, numEmpty, numTrimming);

        if (mAlwaysFinishActivities) {
            // Need to do this on its own message because the stack may not
            // be in a consistent state at this point.
            mAtmInternal.scheduleDestroyAllActivities(""always-finish"");
        }

        if (allChanged) {
            requestPssAllProcsLocked(now, false, mProcessStats.isMemFactorLowered());
        }

        ArrayList<UidRecord> becameIdle = null;

        // Update from any uid changes.
        if (mLocalPowerManager != null) {
            mLocalPowerManager.startUidChanges();
        }
        for (int i=mActiveUids.size()-1; i>=0; i--) {
            final UidRecord uidRec = mActiveUids.valueAt(i);
            int uidChange = UidRecord.CHANGE_PROCSTATE;
            if (uidRec.getCurProcState() != PROCESS_STATE_NONEXISTENT
                    && (uidRec.setProcState != uidRec.getCurProcState()
                           || uidRec.setWhitelist != uidRec.curWhitelist)) {
                if (DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS, ""Changes in "" + uidRec
                        + "": proc state from "" + uidRec.setProcState + "" to ""
                        + uidRec.getCurProcState() + "", whitelist from "" + uidRec.setWhitelist
                        + "" to "" + uidRec.curWhitelist);
                if (ActivityManager.isProcStateBackground(uidRec.getCurProcState())
                        && !uidRec.curWhitelist) {
                    // UID is now in the background (and not on the temp whitelist).  Was it
                    // previously in the foreground (or on the temp whitelist)?
                    if (!ActivityManager.isProcStateBackground(uidRec.setProcState)
                            || uidRec.setWhitelist) {
                        uidRec.lastBackgroundTime = nowElapsed;
                        if (!mHandler.hasMessages(IDLE_UIDS_MSG)) {
                            // Note: the background settle time is in elapsed realtime, while
                            // the handler time base is uptime.  All this means is that we may
                            // stop background uids later than we had intended, but that only
                            // happens because the device was sleeping so we are okay anyway.
                            mHandler.sendEmptyMessageDelayed(IDLE_UIDS_MSG,
                                    mConstants.BACKGROUND_SETTLE_TIME);
                        }
                    }
                    if (uidRec.idle && !uidRec.setIdle) {
                        uidChange = UidRecord.CHANGE_IDLE;
                        if (becameIdle == null) {
                            becameIdle = new ArrayList<>();
                        }
                        becameIdle.add(uidRec);
                    }
                } else {
                    if (uidRec.idle) {
                        uidChange = UidRecord.CHANGE_ACTIVE;
                        EventLogTags.writeAmUidActive(uidRec.uid);
                        uidRec.idle = false;
                    }
                    uidRec.lastBackgroundTime = 0;
                }
                final boolean wasCached = uidRec.setProcState
                        > ActivityManager.PROCESS_STATE_RECEIVER;
                final boolean isCached = uidRec.getCurProcState()
                        > ActivityManager.PROCESS_STATE_RECEIVER;
                if (wasCached != isCached || uidRec.setProcState == PROCESS_STATE_NONEXISTENT) {
                    uidChange |= isCached ? UidRecord.CHANGE_CACHED : UidRecord.CHANGE_UNCACHED;
                }
                uidRec.setProcState = uidRec.getCurProcState();
                uidRec.setWhitelist = uidRec.curWhitelist;
                uidRec.setIdle = uidRec.idle;
                enqueueUidChangeLocked(uidRec, -1, uidChange);
                noteUidProcessState(uidRec.uid, uidRec.getCurProcState());
                if (uidRec.foregroundServices) {
                    mServices.foregroundServiceProcStateChangedLocked(uidRec);
                }
            }
        }
        if (mLocalPowerManager != null) {
            mLocalPowerManager.finishUidChanges();
        }

        if (becameIdle != null) {
            // If we have any new uids that became idle this time, we need to make sure
            // they aren't left with running services.
            for (int i = becameIdle.size() - 1; i >= 0; i--) {
                mServices.stopInBackgroundLocked(becameIdle.get(i).uid);
            }
        }

        if (mProcessStats.shouldWriteNowLocked(now)) {
            mHandler.post(new ProcStatsRunnable(ActivityManagerService.this, mProcessStats));
        }

        // Run this after making sure all procstates are updated.
        mProcessStats.updateTrackingAssociationsLocked(mAdjSeq, now);

        if (DEBUG_OOM_ADJ) {
            final long duration = SystemClock.uptimeMillis() - now;
            if (false) {
                Slog.d(TAG_OOM_ADJ, ""Did OOM ADJ in "" + duration + ""ms"",
                        new RuntimeException(""here"").fillInStackTrace());
            } else {
                Slog.d(TAG_OOM_ADJ, ""Did OOM ADJ in "" + duration + ""ms"");
            }
        }
        mOomAdjProfiler.oomAdjEnded();
","        mOomAdjProfiler.oomAdjStarted();
        final ProcessRecord TOP_APP = getTopAppLocked();
        final long now = SystemClock.uptimeMillis();
        final long nowElapsed = SystemClock.elapsedRealtime();
        final long oldTime = now - ProcessList.MAX_EMPTY_TIME;
        final int N = mProcessList.getLruSizeLocked();

        // Reset state in all uid records.
        for (int i=mActiveUids.size()-1; i>=0; i--) {
            final UidRecord uidRec = mActiveUids.valueAt(i);
            if (false && DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,
                    ""Starting update of "" + uidRec);
            uidRec.reset();
        }

        if (mAtmInternal != null) {
            mAtmInternal.rankTaskLayersIfNeeded();
        }

        mAdjSeq++;
        mNewNumServiceProcs = 0;
        mNewNumAServiceProcs = 0;

        final int emptyProcessLimit = mConstants.CUR_MAX_EMPTY_PROCESSES;
        final int cachedProcessLimit = mConstants.CUR_MAX_CACHED_PROCESSES - emptyProcessLimit;

        // Let's determine how many processes we have running vs.
        // how many slots we have for background processes; we may want
        // to put multiple processes in a slot of there are enough of
        // them.
        final int numSlots = (ProcessList.CACHED_APP_MAX_ADJ
                - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2
                / ProcessList.CACHED_APP_IMPORTANCE_LEVELS;
        int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;
        if (numEmptyProcs > cachedProcessLimit) {
            // If there are more empty processes than our limit on cached
            // processes, then use the cached process limit for the factor.
            // This ensures that the really old empty processes get pushed
            // down to the bottom, so if we are running low on memory we will
            // have a better chance at keeping around more cached processes
            // instead of a gazillion empty processes.
            numEmptyProcs = cachedProcessLimit;
        }
        int emptyFactor = (numEmptyProcs + numSlots - 1) / numSlots;
        if (emptyFactor < 1) emptyFactor = 1;
        int cachedFactor = (mNumCachedHiddenProcs > 0 ? (mNumCachedHiddenProcs + numSlots - 1) : 1)
                / numSlots;
        if (cachedFactor < 1) cachedFactor = 1;
        int stepCached = -1;
        int stepEmpty = -1;
        int numCached = 0;
        int numCachedExtraGroup = 0;
        int numEmpty = 0;
        int numTrimming = 0;
        int lastCachedGroup = 0;
        int lastCachedGroupImportance = 0;
        int lastCachedGroupUid = 0;

        mNumNonCachedProcs = 0;
        mNumCachedHiddenProcs = 0;

        // First update the OOM adjustment for each of the
        // application processes based on their current state.
        int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;
        int nextCachedAdj = curCachedAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        int curCachedImpAdj = 0;
        int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ + ProcessList.CACHED_APP_IMPORTANCE_LEVELS;
        int nextEmptyAdj = curEmptyAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        ProcessRecord selectedAppRecord = null;
        long serviceLastActivity = 0;
        int numBServices = 0;

        boolean retryCycles = false;

        // need to reset cycle state before calling computeOomAdjLocked because of service connections
        for (int i=N-1; i>=0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            app.containsCycle = false;
            app.setCurRawProcState(PROCESS_STATE_CACHED_EMPTY);
            app.setCurRawAdj(ProcessList.UNKNOWN_ADJ);
        }
        for (int i=N-1; i>=0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            if (mEnableBServicePropagation && app.serviceb
                    && (app.curAdj == ProcessList.SERVICE_B_ADJ)) {
                numBServices++;
                for (int s = app.services.size() - 1; s >= 0; s--) {
                    ServiceRecord sr = app.services.valueAt(s);
                    if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + app.processName
                            + "" serviceb = "" + app.serviceb + "" s = "" + s + "" sr.lastActivity = ""
                            + sr.lastActivity + "" packageName = "" + sr.packageName
                            + "" processName = "" + sr.processName);
                    if (SystemClock.uptimeMillis() - sr.lastActivity
                            < mMinBServiceAgingTime) {
                        if (DEBUG_OOM_ADJ) {
                            Slog.d(TAG,""Not aged enough!!!"");
                        }
                        continue;
                    }
                    if (serviceLastActivity == 0) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    } else if (sr.lastActivity < serviceLastActivity) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    }
                }
            }
            if (DEBUG_OOM_ADJ && selectedAppRecord != null) Slog.d(TAG,
                    ""Identified app.processName = "" + selectedAppRecord.processName
                    + "" app.pid = "" + selectedAppRecord.pid);
            if (!app.killedByAm && app.thread != null) {
                app.procStateChanged = false;
                computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now, false);

                // if any app encountered a cycle, we need to perform an additional loop later
                retryCycles |= app.containsCycle;

                // If we haven't yet assigned the final cached adj
                // to the process, do that now.
                if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
                    switch (app.getCurProcState()) {
                        case PROCESS_STATE_CACHED_ACTIVITY:
                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                        case ActivityManager.PROCESS_STATE_CACHED_RECENT:
                            // Figure out the next cached level, taking into account groups.
                            boolean inGroup = false;
                            if (app.connectionGroup != 0) {
                                if (lastCachedGroupUid == app.uid
                                        && lastCachedGroup == app.connectionGroup) {
                                    // This is in the same group as the last process, just tweak
                                    // adjustment by importance.
                                    if (app.connectionImportance > lastCachedGroupImportance) {
                                        lastCachedGroupImportance = app.connectionImportance;
                                        if (curCachedAdj < nextCachedAdj
                                                && curCachedAdj < ProcessList.CACHED_APP_MAX_ADJ) {
                                            curCachedImpAdj++;
                                        }
                                    }
                                    inGroup = true;
                                } else {
                                    lastCachedGroupUid = app.uid;
                                    lastCachedGroup = app.connectionGroup;
                                    lastCachedGroupImportance = app.connectionImportance;
                                }
                            }
                            if (!inGroup && curCachedAdj != nextCachedAdj) {
                                stepCached++;
                                curCachedImpAdj = 0;
                                if (stepCached >= cachedFactor) {
                                    stepCached = 0;
                                    curCachedAdj = nextCachedAdj;
                                    nextCachedAdj += ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2;
                                    if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
                                        nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;
                                    }
                                }
                            }
                            // This process is a cached process holding activities...
                            // assign it the next cached value for that type, and then
                            // step that cached level.
                            app.setCurRawAdj(curCachedAdj + curCachedImpAdj);
                            app.curAdj = app.modifyRawOomAdj(curCachedAdj + curCachedImpAdj);
                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, ""Assigning activity LRU #"" + i
                                    + "" adj: "" + app.curAdj + "" (curCachedAdj="" + curCachedAdj
                                    + "" curCachedImpAdj="" + curCachedImpAdj + "")"");
                            break;
                        default:
                            // Figure out the next cached level.
                            if (curEmptyAdj != nextEmptyAdj) {
                                stepEmpty++;
                                if (stepEmpty >= emptyFactor) {
                                    stepEmpty = 0;
                                    curEmptyAdj = nextEmptyAdj;
                                    nextEmptyAdj += ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2;
                                    if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
                                        nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;
                                    }
                                }
                            }
                            // For everything else, assign next empty cached process
                            // level and bump that up.  Note that this means that
                            // long-running services that have dropped down to the
                            // cached level will be treated as empty (since their process
                            // state is still as a service), which is what we want.
                            app.setCurRawAdj(curEmptyAdj);
                            app.curAdj = app.modifyRawOomAdj(curEmptyAdj);
                            if (DEBUG_LRU && false) Slog.d(TAG_LRU, ""Assigning empty LRU #"" + i
                                    + "" adj: "" + app.curAdj + "" (curEmptyAdj="" + curEmptyAdj
                                    + "")"");
                            break;
                    }
                }
            }
        }

        // Cycle strategy:
        // - Retry computing any process that has encountered a cycle.
        // - Continue retrying until no process was promoted.
        // - Iterate from least important to most important.
        int cycleCount = 0;
        while (retryCycles && cycleCount < 10) {
            cycleCount++;
            retryCycles = false;

            for (int i=0; i<N; i++) {
                ProcessRecord app = mProcessList.mLruProcesses.get(i);
                if (!app.killedByAm && app.thread != null && app.containsCycle == true) {
                    app.adjSeq--;
                    app.completedAdjSeq--;
                }
            }

            for (int i=0; i<N; i++) {
                ProcessRecord app = mProcessList.mLruProcesses.get(i);
                if (!app.killedByAm && app.thread != null && app.containsCycle == true) {
                    if (computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now,
                            true)) {
                        retryCycles = true;
                    }
                }
            }
        }

        lastCachedGroup = lastCachedGroupUid = 0;

        for (int i=N-1; i>=0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            if (!app.killedByAm && app.thread != null) {
                applyOomAdjLocked(app, true, now, nowElapsed);

                // Count the number of process types.
                switch (app.getCurProcState()) {
                    case PROCESS_STATE_CACHED_ACTIVITY:
                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                        mNumCachedHiddenProcs++;
                        numCached++;
                        if (app.connectionGroup != 0) {
                            if (lastCachedGroupUid == app.uid
                                    && lastCachedGroup == app.connectionGroup) {
                                // If this process is the next in the same group, we don't
                                // want it to count against our limit of the number of cached
                                // processes, so bump up the group count to account for it.
                                numCachedExtraGroup++;
                            } else {
                                lastCachedGroupUid = app.uid;
                                lastCachedGroup = app.connectionGroup;
                            }
                        } else {
                            lastCachedGroupUid = lastCachedGroup = 0;
                        }
                        if ((numCached - numCachedExtraGroup) > cachedProcessLimit) {
                            app.kill(""cached #"" + numCached, true);
                        }
                        break;
                    case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
                        if (numEmpty > mConstants.CUR_TRIM_EMPTY_PROCESSES
                                && app.lastActivityTime < oldTime) {
                            app.kill(""empty for ""
                                    + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)
                                    / 1000) + ""s"", true);
                        } else {
                            numEmpty++;
                            if (numEmpty > emptyProcessLimit) {
                                app.kill(""empty #"" + numEmpty, true);
                            }
                        }
                        break;
                    default:
                        mNumNonCachedProcs++;
                        break;
                }

                if (app.isolated && app.services.size() <= 0 && app.isolatedEntryPoint == null) {
                    // If this is an isolated process, there are no services
                    // running in it, and it's not a special process with a
                    // custom entry point, then the process is no longer
                    // needed.  We agressively kill these because we can by
                    // definition not re-use the same process again, and it is
                    // good to avoid having whatever code was running in them
                    // left sitting around after no longer needed.
                    app.kill(""isolated not needed"", true);
                } else {
                    // Keeping this process, update its uid.
                    final UidRecord uidRec = app.uidRecord;
                    if (uidRec != null) {
                        uidRec.ephemeral = app.info.isInstantApp();
                        if (uidRec.getCurProcState() > app.getCurProcState()) {
                            uidRec.setCurProcState(app.getCurProcState());
                        }
                        if (app.hasForegroundServices()) {
                            uidRec.foregroundServices = true;
                        }
                    }
                }

                if (app.getCurProcState() >= ActivityManager.PROCESS_STATE_HOME
                        && !app.killedByAm) {
                    numTrimming++;
                }
            }
        }
        if ((numBServices > mBServiceAppThreshold) && (true == mAllowLowerMemLevel)
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }

        incrementProcStateSeqAndNotifyAppsLocked();

        mNumServiceProcs = mNewNumServiceProcs;

        boolean allChanged = updateLowMemStateLocked(numCached, numEmpty, numTrimming);

        if (mAlwaysFinishActivities) {
            // Need to do this on its own message because the stack may not
            // be in a consistent state at this point.
            mAtmInternal.scheduleDestroyAllActivities(""always-finish"");
        }

        if (allChanged) {
            requestPssAllProcsLocked(now, false, mProcessStats.isMemFactorLowered());
        }

        ArrayList<UidRecord> becameIdle = null;

        // Update from any uid changes.
        if (mLocalPowerManager != null) {
            mLocalPowerManager.startUidChanges();
        }
        for (int i=mActiveUids.size()-1; i>=0; i--) {
            final UidRecord uidRec = mActiveUids.valueAt(i);
            int uidChange = UidRecord.CHANGE_PROCSTATE;
            if (uidRec.getCurProcState() != PROCESS_STATE_NONEXISTENT
                    && (uidRec.setProcState != uidRec.getCurProcState()
                           || uidRec.setWhitelist != uidRec.curWhitelist)) {
                if (DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS, ""Changes in "" + uidRec
                        + "": proc state from "" + uidRec.setProcState + "" to ""
                        + uidRec.getCurProcState() + "", whitelist from "" + uidRec.setWhitelist
                        + "" to "" + uidRec.curWhitelist);
                if (ActivityManager.isProcStateBackground(uidRec.getCurProcState())
                        && !uidRec.curWhitelist) {
                    // UID is now in the background (and not on the temp whitelist).  Was it
                    // previously in the foreground (or on the temp whitelist)?
                    if (!ActivityManager.isProcStateBackground(uidRec.setProcState)
                            || uidRec.setWhitelist) {
                        uidRec.lastBackgroundTime = nowElapsed;
                        if (!mHandler.hasMessages(IDLE_UIDS_MSG)) {
                            // Note: the background settle time is in elapsed realtime, while
                            // the handler time base is uptime.  All this means is that we may
                            // stop background uids later than we had intended, but that only
                            // happens because the device was sleeping so we are okay anyway.
                            mHandler.sendEmptyMessageDelayed(IDLE_UIDS_MSG,
                                    mConstants.BACKGROUND_SETTLE_TIME);
                        }
                    }
                    if (uidRec.idle && !uidRec.setIdle) {
                        uidChange = UidRecord.CHANGE_IDLE;
                        if (becameIdle == null) {
                            becameIdle = new ArrayList<>();
                        }
                        becameIdle.add(uidRec);
                    }
                } else {
                    if (uidRec.idle) {
                        uidChange = UidRecord.CHANGE_ACTIVE;
                        EventLogTags.writeAmUidActive(uidRec.uid);
                        uidRec.idle = false;
                    }
                    uidRec.lastBackgroundTime = 0;
                }
                final boolean wasCached = uidRec.setProcState
                        > ActivityManager.PROCESS_STATE_RECEIVER;
                final boolean isCached = uidRec.getCurProcState()
                        > ActivityManager.PROCESS_STATE_RECEIVER;
                if (wasCached != isCached || uidRec.setProcState == PROCESS_STATE_NONEXISTENT) {
                    uidChange |= isCached ? UidRecord.CHANGE_CACHED : UidRecord.CHANGE_UNCACHED;
                }
                uidRec.setProcState = uidRec.getCurProcState();
                uidRec.setWhitelist = uidRec.curWhitelist;
                uidRec.setIdle = uidRec.idle;
                enqueueUidChangeLocked(uidRec, -1, uidChange);
                noteUidProcessState(uidRec.uid, uidRec.getCurProcState());
                if (uidRec.foregroundServices) {
                    mServices.foregroundServiceProcStateChangedLocked(uidRec);
                }
            }
        }
        if (mLocalPowerManager != null) {
            mLocalPowerManager.finishUidChanges();
        }

        if (becameIdle != null) {
            // If we have any new uids that became idle this time, we need to make sure
            // they aren't left with running services.
            for (int i = becameIdle.size() - 1; i >= 0; i--) {
                mServices.stopInBackgroundLocked(becameIdle.get(i).uid);
            }
        }

        if (mProcessStats.shouldWriteNowLocked(now)) {
            mHandler.post(new ProcStatsRunnable(ActivityManagerService.this, mProcessStats));
        }

        // Run this after making sure all procstates are updated.
        mProcessStats.updateTrackingAssociationsLocked(mAdjSeq, now);

        if (DEBUG_OOM_ADJ) {
            final long duration = SystemClock.uptimeMillis() - now;
            if (false) {
                Slog.d(TAG_OOM_ADJ, ""Did OOM ADJ in "" + duration + ""ms"",
                        new RuntimeException(""here"").fillInStackTrace());
            } else {
                Slog.d(TAG_OOM_ADJ, ""Did OOM ADJ in "" + duration + ""ms"");
            }
        }
        mOomAdjProfiler.oomAdjEnded();
","[1.0, 1.0]"
380,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/BluetoothAdapter.java,"[(2567, 2574, 8), (2567, 2574, 8)]","            case BluetoothProfile.DUN:
                BluetoothDun dun = (BluetoothDun)proxy;
                dun.close();
                break;
            case BluetoothProfile.HEALTH:
                BluetoothHealth health = (BluetoothHealth) proxy;
                health.close();
                break;
","            case BluetoothProfile.DUN:
                BluetoothDun dun = (BluetoothDun)proxy;
                dun.close();
                break;
            case BluetoothProfile.HEALTH:
                BluetoothHealth health = (BluetoothHealth) proxy;
                health.close();
                break;
","            case BluetoothProfile.DUN:
                BluetoothDun dun = (BluetoothDun)proxy;
                dun.close();
                break;
            case BluetoothProfile.HEALTH:
                BluetoothHealth health = (BluetoothHealth) proxy;
                health.close();
                break;
","[1.0, 1.0]"
381,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 22, 4), (19, 22, 4)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","[1.0, 1.0]"
382,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(579, 582, 4), (579, 582, 4)]","        if (Nat464Xlat.requiresClat(this) &&
            ( this.networkCapabilities.hasCapability(NET_CAPABILITY_INTERNET) ||
              this.networkCapabilities.hasCapability(NET_CAPABILITY_MMS) )) {
            maybeStartClat(netd);
","        if (Nat464Xlat.requiresClat(this) &&
            ( this.networkCapabilities.hasCapability(NET_CAPABILITY_INTERNET) ||
              this.networkCapabilities.hasCapability(NET_CAPABILITY_MMS) )) {
            maybeStartClat(netd);
","        if (Nat464Xlat.requiresClat(this) &&
            ( this.networkCapabilities.hasCapability(NET_CAPABILITY_INTERNET) ||
              this.networkCapabilities.hasCapability(NET_CAPABILITY_MMS) )) {
            maybeStartClat(netd);
","[1.0, 1.0]"
383,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(153, 166, 14), (153, 166, 14)]","        * IEEE 802.11ai FILS SK with SHA256
         * @hide
        */
        public static final int FILS_SHA256 = 11;
        /**
         * IEEE 802.11ai FILS SK with SHA384:
         * @hide
         */
        public static final int FILS_SHA384 = 12;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        public static final int DPP = 13;
","        * IEEE 802.11ai FILS SK with SHA256
         * @hide
        */
        public static final int FILS_SHA256 = 11;
        /**
         * IEEE 802.11ai FILS SK with SHA384:
         * @hide
         */
        public static final int FILS_SHA384 = 12;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        public static final int DPP = 13;
","        * IEEE 802.11ai FILS SK with SHA256
         * @hide
        */
        public static final int FILS_SHA256 = 11;
        /**
         * IEEE 802.11ai FILS SK with SHA384:
         * @hide
         */
        public static final int FILS_SHA384 = 12;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        public static final int DPP = 13;
","[1.0, 1.0]"
384,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(172, 172, 1), (172, 172, 1)]","                ""SAE"", ""OWE"", ""SUITE_B_192"", ""FILS_SHA256"", ""FILS_SHA384"", ""DPP""};
","                ""SAE"", ""OWE"", ""SUITE_B_192"", ""FILS_SHA256"", ""FILS_SHA384"", ""DPP""};
","                ""SAE"", ""OWE"", ""SUITE_B_192"", ""FILS_SHA256"", ""FILS_SHA384"", ""DPP""};
","[1.0, 1.0]"
385,"['88b45c586d461df38b866d529bc98d1dfa3e8838', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 22, 4), (19, 22, 4)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_","[0.943, 0.7]"
386,"['88b45c586d461df38b866d529bc98d1dfa3e8838', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 22, 4), (19, 21, 3)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","[0.995, 1.0]"
387,"['88b45c586d461df38b866d529bc98d1dfa3e8838', 'ba167de93776a7e5d1b347d1ee646e161cf24ce5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(449, 449, 1), (426, 426, 1)]","    private static final int EVENT_UPDATE_TCP_BUFFER_FOR_5G = 160;
","    private static final int EVENT_UPDATE_TCP_BUFFER_FOR_5G = 160;
","    private static final int EVENT_UPDATE_TCP_BUFFER_FOR_5G = 160;
","[1.0, 1.0]"
388,"['89cad5d93a5083474840e90d08d6e4aec5833932', '89cad5d93a5083474840e90d08d6e4aec5833932']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(16, 16, 1), (16, 16, 1)]","
","
","
","[1.0, 1.0]"
389,"['89cad5d93a5083474840e90d08d6e4aec5833932', '89cad5d93a5083474840e90d08d6e4aec5833932']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardSimPinView.java,"[(71, 81, 11), (71, 81, 11)]","                // If the SIM is removed, then we must remove the keyguard. It will be put up
                // again when the PUK locked SIM is re-entered.
                case ABSENT: {
                    KeyguardUpdateMonitor.getInstance(getContext()).reportSimUnlocked(subId);
                    // onSimStateChanged callback can fire when the SIM PIN lock is not currently
                    // active and mCallback is null.
                    if (mCallback != null) {
                        mCallback.dismiss(true, KeyguardUpdateMonitor.getCurrentUser());
                    }
                    break;
                }
","                // If the SIM is removed, then we must remove the keyguard. It will be put up
                // again when the PUK locked SIM is re-entered.
                case ABSENT: {
                    KeyguardUpdateMonitor.getInstance(getContext()).reportSimUnlocked(subId);
                    // onSimStateChanged callback can fire when the SIM PIN lock is not currently
                    // active and mCallback is null.
                    if (mCallback != null) {
                        mCallback.dismiss(true, KeyguardUpdateMonitor.getCurrentUser());
                    }
                    break;
                }
","                // If the SIM is removed, then we must remove the keyguard. It will be put up
                // again when the PUK locked SIM is re-entered.
                case ABSENT: {
                    KeyguardUpdateMonitor.getInstance(getContext()).reportSimUnlocked(subId);
                    // onSimStateChanged callback can fire when the SIM PIN lock is not currently
                    // active and mCallback is null.
                    if (mCallback != null) {
                        mCallback.dismiss(true, KeyguardUpdateMonitor.getCurrentUser());
                    }
                    break;
                }
","[1.0, 1.0]"
392,"['8d21ad0d966c1e9f96e5a65144efad2582391957', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(2083, 2092, 10), (2270, 2288, 19)]","    private void updateTcpBufferSizes(NetworkAgentInfo nai) {
        if (isDefaultNetwork(nai) == false) {
            return;
        }

        String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
        if(nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)){
            tcpBufferSizes = NetPluginDelegate.get5GTcpBuffers(tcpBufferSizes,
                nai.networkCapabilities.getNetworkSpecifier());
        }
","    // Overridden for testing purposes to avoid writing to SystemProperties.
    @VisibleForTesting
    protected MockableSystemProperties getSystemProperties() {
        return new MockableSystemProperties();
    }

    private void updateTcpBufferSizes(NetworkAgentInfo nai) {
        if (isDefaultNetwork(nai) == false) {
            return;
        }

        String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
        if(nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)){
            tcpBufferSizes = NetPluginDelegate.get5GTcpBuffers(tcpBufferSizes,
                nai.networkCapabilities.getNetworkSpecifier());
        }
        updateTcpBufferSizes(tcpBufferSizes);
    }

","    private void updateTcpBufferSizes(NetworkAgentInfo nai) {
        if (isDefaultNetwork(nai) == false) {
            return;
        }

        String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
        if(nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)){
            tcpBufferSizes = NetPluginDelegate.get5GTcpBuffers(tcpBufferSizes,
                nai.networkCapabilities.getNetworkSpecifier());
        }
","[1.0, 0.627]"
393,"['8d21ad0d966c1e9f96e5a65144efad2582391957', '8d21ad0d966c1e9f96e5a65144efad2582391957']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/p2p/WifiP2pManager.java,"[(506, 510, 5), (506, 510, 5)]","    public static final int SET_WFDR2_INFO                          = BASE + 90;
    /** @hide */
    public static final int SET_WFDR2_INFO_FAILED                   = BASE + 91;
    /** @hide */
    public static final int SET_WFDR2_INFO_SUCCEEDED                = BASE + 92;
","    public static final int SET_WFDR2_INFO                          = BASE + 90;
    /** @hide */
    public static final int SET_WFDR2_INFO_FAILED                   = BASE + 91;
    /** @hide */
    public static final int SET_WFDR2_INFO_SUCCEEDED                = BASE + 92;
","    public static final int SET_WFDR2_INFO                          = BASE + 90;
    /** @hide */
    public static final int SET_WFDR2_INFO_FAILED                   = BASE + 91;
    /** @hide */
    public static final int SET_WFDR2_INFO_SUCCEEDED                = BASE + 92;
","[1.0, 1.0]"
394,"['8d21ad0d966c1e9f96e5a65144efad2582391957', '8d21ad0d966c1e9f96e5a65144efad2582391957']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(2083, 2092, 10), (2083, 2092, 10)]","    private void updateTcpBufferSizes(NetworkAgentInfo nai) {
        if (isDefaultNetwork(nai) == false) {
            return;
        }

        String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
        if(nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)){
            tcpBufferSizes = NetPluginDelegate.get5GTcpBuffers(tcpBufferSizes,
                nai.networkCapabilities.getNetworkSpecifier());
        }
","    private void updateTcpBufferSizes(NetworkAgentInfo nai) {
        if (isDefaultNetwork(nai) == false) {
            return;
        }

        String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
        if(nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)){
            tcpBufferSizes = NetPluginDelegate.get5GTcpBuffers(tcpBufferSizes,
                nai.networkCapabilities.getNetworkSpecifier());
        }
","    private void updateTcpBufferSizes(NetworkAgentInfo nai) {
        if (isDefaultNetwork(nai) == false) {
            return;
        }

        String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
        if(nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)){
            tcpBufferSizes = NetPluginDelegate.get5GTcpBuffers(tcpBufferSizes,
                nai.networkCapabilities.getNetworkSpecifier());
        }
","[1.0, 1.0]"
395,"['8d21ad0d966c1e9f96e5a65144efad2582391957', '8d21ad0d966c1e9f96e5a65144efad2582391957']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/policy/PhoneWindowManager.java,"[(23, 27, 5), (23, 27, 5)]","import static android.app.WindowConfiguration.ACTIVITY_TYPE_HOME;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_STANDARD;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_RECENTS;
import static android.app.WindowConfiguration.WINDOWING_MODE_FREEFORM;
import static android.app.WindowConfiguration.WINDOWING_MODE_FULLSCREEN;
","import static android.app.WindowConfiguration.ACTIVITY_TYPE_HOME;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_STANDARD;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_RECENTS;
import static android.app.WindowConfiguration.WINDOWING_MODE_FREEFORM;
import static android.app.WindowConfiguration.WINDOWING_MODE_FULLSCREEN;
","import static android.app.WindowConfiguration.ACTIVITY_TYPE_HOME;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_STANDARD;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_RECENTS;
import static android.app.WindowConfiguration.WINDOWING_MODE_FREEFORM;
import static android.app.WindowConfiguration.WINDOWING_MODE_FULLSCREEN;
","[1.0, 1.0]"
396,"['8d21ad0d966c1e9f96e5a65144efad2582391957', '8d21ad0d966c1e9f96e5a65144efad2582391957']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/policy/PhoneWindowManager.java,"[(228, 229, 2), (228, 229, 2)]","import android.util.BoostFramework;
import android.util.ArraySet;
","import android.util.BoostFramework;
import android.util.ArraySet;
","import android.util.BoostFramework;
import android.util.ArraySet;
","[1.0, 1.0]"
397,"['8d21ad0d966c1e9f96e5a65144efad2582391957', '8d21ad0d966c1e9f96e5a65144efad2582391957']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/policy/PhoneWindowManager.java,"[(405, 427, 23), (405, 427, 23)]","    /**
     * Broadcast Action: WiFi Display video is enabled or disabled
     *
     * <p>The intent will have the following extra values:</p>
     * <ul>
     *    <li><em>state</em> - 0 for disabled, 1 for enabled. </li>
     * </ul>
     */

    private static final String ACTION_WIFI_DISPLAY_VIDEO =
                                        ""org.codeaurora.intent.action.WIFI_DISPLAY_VIDEO"";


    // The panic gesture may become active only after the keyguard is dismissed and the immersive
    // app shows again. If that doesn't happen for 30s we drop the gesture.
    private static final long PANIC_GESTURE_EXPIRATION = 30000;

    private static final String SYSUI_PACKAGE = ""com.android.systemui"";
    private static final String SYSUI_SCREENSHOT_SERVICE =
            ""com.android.systemui.screenshot.TakeScreenshotService"";
    private static final String SYSUI_SCREENSHOT_ERROR_RECEIVER =
            ""com.android.systemui.screenshot.ScreenshotServiceErrorReceiver"";

","    /**
     * Broadcast Action: WiFi Display video is enabled or disabled
     *
     * <p>The intent will have the following extra values:</p>
     * <ul>
     *    <li><em>state</em> - 0 for disabled, 1 for enabled. </li>
     * </ul>
     */

    private static final String ACTION_WIFI_DISPLAY_VIDEO =
                                        ""org.codeaurora.intent.action.WIFI_DISPLAY_VIDEO"";


    // The panic gesture may become active only after the keyguard is dismissed and the immersive
    // app shows again. If that doesn't happen for 30s we drop the gesture.
    private static final long PANIC_GESTURE_EXPIRATION = 30000;

    private static final String SYSUI_PACKAGE = ""com.android.systemui"";
    private static final String SYSUI_SCREENSHOT_SERVICE =
            ""com.android.systemui.screenshot.TakeScreenshotService"";
    private static final String SYSUI_SCREENSHOT_ERROR_RECEIVER =
            ""com.android.systemui.screenshot.ScreenshotServiceErrorReceiver"";

","    /**
     * Broadcast Action: WiFi Display video is enabled or disabled
     *
     * <p>The intent will have the following extra values:</p>
     * <ul>
     *    <li><em>state</em> - 0 for disabled, 1 for enabled. </li>
     * </ul>
     */

    private static final String ACTION_WIFI_DISPLAY_VIDEO =
                                        ""org.codeaurora.intent.action.WIFI_DISPLAY_VIDEO"";


    // The panic gesture may become active only after the keyguard is dismissed and the immersive
    // app shows again. If that doesn't happen for 30s we drop the gesture.
    private static final long PANIC_GESTURE_EXPIRATION = 30000;

    private static final String SYSUI_PACKAGE = ""com.android.systemui"";
    private static final String SYSUI_SCREENSHOT_SERVICE =
            ""com.android.systemui.screenshot.TakeScreenshotService"";
    private static final String SYSUI_SCREENSHOT_ERROR_RECEIVER =
            ""com.android.systemui.screenshot.ScreenshotServiceErrorReceiver"";

","[1.0, 1.0]"
398,"['8d21ad0d966c1e9f96e5a65144efad2582391957', '8d21ad0d966c1e9f96e5a65144efad2582391957']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/policy/PhoneWindowManager.java,"[(823, 843, 21), (823, 843, 21)]","    private static final int MSG_UPDATE_DREAMING_SLEEP_TOKEN = 15;
    private static final int MSG_REQUEST_TRANSIENT_BARS = 16;
    private static final int MSG_SHOW_PICTURE_IN_PICTURE_MENU = 17;
    private static final int MSG_BACK_LONG_PRESS = 18;
    private static final int MSG_DISPOSE_INPUT_CONSUMER = 19;
    private static final int MSG_ACCESSIBILITY_SHORTCUT = 20;
    private static final int MSG_BUGREPORT_TV = 21;
    private static final int MSG_ACCESSIBILITY_TV = 22;
    private static final int MSG_DISPATCH_BACK_KEY_TO_AUTOFILL = 23;
    private static final int MSG_SYSTEM_KEY_PRESS = 24;
    private static final int MSG_HANDLE_ALL_APPS = 25;
    private static final int MSG_LAUNCH_ASSIST = 26;
    private static final int MSG_LAUNCH_ASSIST_LONG_PRESS = 27;
    private static final int MSG_POWER_VERY_LONG_PRESS = 28;
    private static final int MSG_NOTIFY_USER_ACTIVITY = 29;
    private static final int MSG_RINGER_TOGGLE_CHORD = 30;

    private static final int MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS = 0;
    private static final int MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION = 1;
    private boolean mWifiDisplayConnected = false;
    private int mWifiDisplayCustomRotation = -1;
","    private static final int MSG_UPDATE_DREAMING_SLEEP_TOKEN = 15;
    private static final int MSG_REQUEST_TRANSIENT_BARS = 16;
    private static final int MSG_SHOW_PICTURE_IN_PICTURE_MENU = 17;
    private static final int MSG_BACK_LONG_PRESS = 18;
    private static final int MSG_DISPOSE_INPUT_CONSUMER = 19;
    private static final int MSG_ACCESSIBILITY_SHORTCUT = 20;
    private static final int MSG_BUGREPORT_TV = 21;
    private static final int MSG_ACCESSIBILITY_TV = 22;
    private static final int MSG_DISPATCH_BACK_KEY_TO_AUTOFILL = 23;
    private static final int MSG_SYSTEM_KEY_PRESS = 24;
    private static final int MSG_HANDLE_ALL_APPS = 25;
    private static final int MSG_LAUNCH_ASSIST = 26;
    private static final int MSG_LAUNCH_ASSIST_LONG_PRESS = 27;
    private static final int MSG_POWER_VERY_LONG_PRESS = 28;
    private static final int MSG_NOTIFY_USER_ACTIVITY = 29;
    private static final int MSG_RINGER_TOGGLE_CHORD = 30;

    private static final int MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS = 0;
    private static final int MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION = 1;
    private boolean mWifiDisplayConnected = false;
    private int mWifiDisplayCustomRotation = -1;
","    private static final int MSG_UPDATE_DREAMING_SLEEP_TOKEN = 15;
    private static final int MSG_REQUEST_TRANSIENT_BARS = 16;
    private static final int MSG_SHOW_PICTURE_IN_PICTURE_MENU = 17;
    private static final int MSG_BACK_LONG_PRESS = 18;
    private static final int MSG_DISPOSE_INPUT_CONSUMER = 19;
    private static final int MSG_ACCESSIBILITY_SHORTCUT = 20;
    private static final int MSG_BUGREPORT_TV = 21;
    private static final int MSG_ACCESSIBILITY_TV = 22;
    private static final int MSG_DISPATCH_BACK_KEY_TO_AUTOFILL = 23;
    private static final int MSG_SYSTEM_KEY_PRESS = 24;
    private static final int MSG_HANDLE_ALL_APPS = 25;
    private static final int MSG_LAUNCH_ASSIST = 26;
    private static final int MSG_LAUNCH_ASSIST_LONG_PRESS = 27;
    private static final int MSG_POWER_VERY_LONG_PRESS = 28;
    private static final int MSG_NOTIFY_USER_ACTIVITY = 29;
    private static final int MSG_RINGER_TOGGLE_CHORD = 30;

    private static final int MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS = 0;
    private static final int MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION = 1;
    private boolean mWifiDisplayConnected = false;
    private int mWifiDisplayCustomRotation = -1;
","[1.0, 1.0]"
399,"['8d21ad0d966c1e9f96e5a65144efad2582391957', '8d21ad0d966c1e9f96e5a65144efad2582391957']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/policy/PhoneWindowManager.java,"[(2152, 2275, 124), (2152, 2275, 124)]","        // monitor for system gestures
        // TODO(multi-display): Needs to be display specific.
        mSystemGestures = new SystemGesturesPointerEventListener(context,
                new SystemGesturesPointerEventListener.Callbacks() {
                    @Override
                    public void onSwipeFromTop() {
                        if (mStatusBar != null) {
                            requestTransientBars(mStatusBar);
                        }
                    }
                    @Override
                    public void onSwipeFromBottom() {
                        if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                            requestTransientBars(mNavigationBar);
                        }
                    }
                    @Override
                    public void onSwipeFromRight() {
                        if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                            requestTransientBars(mNavigationBar);
                        }
                    }
                    @Override
                    public void onSwipeFromLeft() {
                        if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                            requestTransientBars(mNavigationBar);
                        }
                    }
                    @Override
                    public void onFling(int duration) {
                        if (mPowerManagerInternal != null) {
                            mPowerManagerInternal.powerHint(
                                    PowerHint.INTERACTION, duration);
                        }
                    }
                    @Override
                    public void onVerticalFling(int duration) {
                        String currentPackage = mContext.getPackageName();
                        boolean isGame = isTopAppGame();
                        if (SCROLL_BOOST_SS_ENABLE && !isGame) {
                            if (mPerfBoostFling == null) {
                                mPerfBoostFling = new BoostFramework();
                                mIsPerfBoostFlingAcquired = false;
                            }
                            if (mPerfBoostFling == null) {
                                Slog.e(TAG, ""Error: boost object null"");
                                return;
                            }

                            mPerfBoostFling.perfHint(BoostFramework.VENDOR_HINT_SCROLL_BOOST,
                                currentPackage, duration + 160, BoostFramework.Scroll.VERTICAL);
                            mIsPerfBoostFlingAcquired = true;
                        }
                    }
                    @Override
                    public void onScroll(boolean started) {
                        String currentPackage = mContext.getPackageName();
                        boolean isGame = isTopAppGame();
                        if (mPerfBoostDrag == null) {
                            mPerfBoostDrag = new BoostFramework();
                        }
                        if (mPerfBoostDrag == null) {
                            Slog.e(TAG, ""Error: boost object null"");
                            return;
                        }
                        if (SCROLL_BOOST_SS_ENABLE && !isGame) {
                            if (mPerfBoostPrefling == null) {
                                mPerfBoostPrefling = new BoostFramework();
                            }
                            if (mPerfBoostPrefling == null) {
                                Slog.e(TAG, ""Error: boost object null"");
                                return;
                            }
                            mPerfBoostPrefling.perfHint(BoostFramework.VENDOR_HINT_SCROLL_BOOST,
                                    currentPackage, -1, BoostFramework.Scroll.PREFILING);
                        }
                        if (!isGame && started) {
                            mPerfBoostDrag.perfHint(BoostFramework.VENDOR_HINT_DRAG_BOOST,
                                            currentPackage, -1, 1);
                        } else {
                            mPerfBoostDrag.perfLockRelease();
                        }
                    }

                    @Override
                    public void onDebug() {
                        // no-op
                    }
                    @Override
                    public void onDown() {
                        mDefaultOrientationListener.onTouchStart();
                        if(SCROLL_BOOST_SS_ENABLE && mPerfBoostFling!= null
                                            && mIsPerfBoostFlingAcquired) {
                            mPerfBoostFling.perfLockRelease();
                            mIsPerfBoostFlingAcquired = false;
                        }
                    }
                    @Override
                    public void onUpOrCancel() {
                        mDefaultOrientationListener.onTouchEnd();
                    }
                    @Override
                    public void onMouseHoverAtTop() {
                        mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
                        Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
                        msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
                        mHandler.sendMessageDelayed(msg, 500);
                    }
                    @Override
                    public void onMouseHoverAtBottom() {
                        mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
                        Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
                        msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
                        mHandler.sendMessageDelayed(msg, 500);
                    }
                    @Override
                    public void onMouseLeaveFromEdge() {
                        mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
                    }
                });
        mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
        //TODO (b/111365687) : make system context per display.
        mWindowManagerFuncs.registerPointerEventListener(mSystemGestures, DEFAULT_DISPLAY);

","        // monitor for system gestures
        // TODO(multi-display): Needs to be display specific.
        mSystemGestures = new SystemGesturesPointerEventListener(context,
                new SystemGesturesPointerEventListener.Callbacks() {
                    @Override
                    public void onSwipeFromTop() {
                        if (mStatusBar != null) {
                            requestTransientBars(mStatusBar);
                        }
                    }
                    @Override
                    public void onSwipeFromBottom() {
                        if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                            requestTransientBars(mNavigationBar);
                        }
                    }
                    @Override
                    public void onSwipeFromRight() {
                        if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                            requestTransientBars(mNavigationBar);
                        }
                    }
                    @Override
                    public void onSwipeFromLeft() {
                        if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                            requestTransientBars(mNavigationBar);
                        }
                    }
                    @Override
                    public void onFling(int duration) {
                        if (mPowerManagerInternal != null) {
                            mPowerManagerInternal.powerHint(
                                    PowerHint.INTERACTION, duration);
                        }
                    }
                    @Override
                    public void onVerticalFling(int duration) {
                        String currentPackage = mContext.getPackageName();
                        boolean isGame = isTopAppGame();
                        if (SCROLL_BOOST_SS_ENABLE && !isGame) {
                            if (mPerfBoostFling == null) {
                                mPerfBoostFling = new BoostFramework();
                                mIsPerfBoostFlingAcquired = false;
                            }
                            if (mPerfBoostFling == null) {
                                Slog.e(TAG, ""Error: boost object null"");
                                return;
                            }

                            mPerfBoostFling.perfHint(BoostFramework.VENDOR_HINT_SCROLL_BOOST,
                                currentPackage, duration + 160, BoostFramework.Scroll.VERTICAL);
                            mIsPerfBoostFlingAcquired = true;
                        }
                    }
                    @Override
                    public void onScroll(boolean started) {
                        String currentPackage = mContext.getPackageName();
                        boolean isGame = isTopAppGame();
                        if (mPerfBoostDrag == null) {
                            mPerfBoostDrag = new BoostFramework();
                        }
                        if (mPerfBoostDrag == null) {
                            Slog.e(TAG, ""Error: boost object null"");
                            return;
                        }
                        if (SCROLL_BOOST_SS_ENABLE && !isGame) {
                            if (mPerfBoostPrefling == null) {
                                mPerfBoostPrefling = new BoostFramework();
                            }
                            if (mPerfBoostPrefling == null) {
                                Slog.e(TAG, ""Error: boost object null"");
                                return;
                            }
                            mPerfBoostPrefling.perfHint(BoostFramework.VENDOR_HINT_SCROLL_BOOST,
                                    currentPackage, -1, BoostFramework.Scroll.PREFILING);
                        }
                        if (!isGame && started) {
                            mPerfBoostDrag.perfHint(BoostFramework.VENDOR_HINT_DRAG_BOOST,
                                            currentPackage, -1, 1);
                        } else {
                            mPerfBoostDrag.perfLockRelease();
                        }
                    }

                    @Override
                    public void onDebug() {
                        // no-op
                    }
                    @Override
                    public void onDown() {
                        mDefaultOrientationListener.onTouchStart();
                        if(SCROLL_BOOST_SS_ENABLE && mPerfBoostFling!= null
                                            && mIsPerfBoostFlingAcquired) {
                            mPerfBoostFling.perfLockRelease();
                            mIsPerfBoostFlingAcquired = false;
                        }
                    }
                    @Override
                    public void onUpOrCancel() {
                        mDefaultOrientationListener.onTouchEnd();
                    }
                    @Override
                    public void onMouseHoverAtTop() {
                        mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
                        Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
                        msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
                        mHandler.sendMessageDelayed(msg, 500);
                    }
                    @Override
                    public void onMouseHoverAtBottom() {
                        mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
                        Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
                        msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
                        mHandler.sendMessageDelayed(msg, 500);
                    }
                    @Override
                    public void onMouseLeaveFromEdge() {
                        mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
                    }
                });
        mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
        //TODO (b/111365687) : make system context per display.
        mWindowManagerFuncs.registerPointerEventListener(mSystemGestures, DEFAULT_DISPLAY);

","        // monitor for system gestures
        // TODO(multi-display): Needs to be display specific.
        mSystemGestures = new SystemGesturesPointerEventListener(context,
                new SystemGesturesPointerEventListener.Callbacks() {
                    @Override
                    public void onSwipeFromTop() {
                        if (mStatusBar != null) {
                            requestTransientBars(mStatusBar);
                        }
                    }
                    @Override
                    public void onSwipeFromBottom() {
                        if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                            requestTransientBars(mNavigationBar);
                        }
                    }
                    @Override
                    public void onSwipeFromRight() {
                        if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                            requestTransientBars(mNavigationBar);
                        }
                    }
                    @Override
                    public void onSwipeFromLeft() {
                        if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                            requestTransientBars(mNavigationBar);
                        }
                    }
                    @Override
                    public void onFling(int duration) {
                        if (mPowerManagerInternal != null) {
                            mPowerManagerInternal.powerHint(
                                    PowerHint.INTERACTION, duration);
                        }
                    }
                    @Override
                    public void onVerticalFling(int duration) {
                        String currentPackage = mContext.getPackageName();
                        boolean isGame = isTopAppGame();
                        if (SCROLL_BOOST_SS_ENABLE && !isGame) {
                            if (mPerfBoostFling == null) {
                                mPerfBoostFling = new BoostFramework();
                                mIsPerfBoostFlingAcquired = false;
                            }
                            if (mPerfBoostFling == null) {
                                Slog.e(TAG, ""Error: boost object null"");
                                return;
                            }

                            mPerfBoostFling.perfHint(BoostFramework.VENDOR_HINT_SCROLL_BOOST,
                                currentPackage, duration + 160, BoostFramework.Scroll.VERTICAL);
                            mIsPerfBoostFlingAcquired = true;
                        }
                    }
                    @Override
                    public void onScroll(boolean started) {
                        String currentPackage = mContext.getPackageName();
                        boolean isGame = isTopAppGame();
                        if (mPerfBoostDrag == null) {
                            mPerfBoostDrag = new BoostFramework();
                        }
                        if (mPerfBoostDrag == null) {
                            Slog.e(TAG, ""Error: boost object null"");
                            return;
                        }
                        if (SCROLL_BOOST_SS_ENABLE && !isGame) {
                            if (mPerfBoostPrefling == null) {
                                mPerfBoostPrefling = new BoostFramework();
                            }
                            if (mPerfBoostPrefling == null) {
                                Slog.e(TAG, ""Error: boost object null"");
                                return;
                            }
                            mPerfBoostPrefling.perfHint(BoostFramework.VENDOR_HINT_SCROLL_BOOST,
                                    currentPackage, -1, BoostFramework.Scroll.PREFILING);
                        }
                        if (!isGame && started) {
                            mPerfBoostDrag.perfHint(BoostFramework.VENDOR_HINT_DRAG_BOOST,
                                            currentPackage, -1, 1);
                        } else {
                            mPerfBoostDrag.perfLockRelease();
                        }
                    }

                    @Override
                    public void onDebug() {
                        // no-op
                    }
                    @Override
                    public void onDown() {
                        mDefaultOrientationListener.onTouchStart();
                        if(SCROLL_BOOST_SS_ENABLE && mPerfBoostFling!= null
                                            && mIsPerfBoostFlingAcquired) {
                            mPerfBoostFling.perfLockRelease();
                            mIsPerfBoostFlingAcquired = false;
                        }
                    }
                    @Override
                    public void onUpOrCancel() {
                        mDefaultOrientationListener.onTouchEnd();
                    }
                    @Override
                    public void onMouseHoverAtTop() {
                        mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
                        Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
                        msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
                        mHandler.sendMessageDelayed(msg, 500);
                    }
                    @Override
                    public void onMouseHoverAtBottom() {
                        mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
                        Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
                        msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
                        mHandler.sendMessageDelayed(msg, 500);
                    }
                    @Override
                    public void onMouseLeaveFromEdge() {
                        mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
                    }
                });
        mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
        //TODO (b/111365687) : make system context per display.
        mWindowManagerFuncs.registerPointerEventListener(mSystemGestures, DEFAULT_DISPLAY);

","[1.0, 1.0]"
400,"['8d21ad0d966c1e9f96e5a65144efad2582391957', '8d21ad0d966c1e9f96e5a65144efad2582391957']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/policy/PhoneWindowManager.java,"[(6585, 6641, 57), (6585, 6641, 57)]","    private final Runnable mHiddenNavPanic = new Runnable() {
        @Override
        public void run() {
            synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
                if (!isUserSetupComplete()) {
                    // Swipe-up for navigation bar is disabled during setup
                    return;
                }
                mPendingPanicGestureUptime = SystemClock.uptimeMillis();
                if (!isNavBarEmpty(mLastSystemUiFlags)) {
                    mNavigationBarController.showTransient();
                }
            }
        }
    };

    private void requestTransientBars(WindowState swipeTarget) {
        synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
            if (!isUserSetupComplete()) {
                // Swipe-up for navigation bar is disabled during setup
                return;
            }
            boolean sb = mStatusBarController.checkShowTransientBarLw();
            boolean nb = mNavigationBarController.checkShowTransientBarLw()
                    && !isNavBarEmpty(mLastSystemUiFlags);
            if (sb || nb) {
                // Don't show status bar when swiping on already visible navigation bar
                if (!nb && swipeTarget == mNavigationBar) {
                    if (DEBUG) Slog.d(TAG, ""Not showing transient bar, wrong swipe target"");
                    return;
                }
                if (sb) mStatusBarController.showTransient();
                if (nb) mNavigationBarController.showTransient();
                mImmersiveModeConfirmation.confirmCurrentPrompt();
                updateSystemUiVisibilityLw();
            }
        }
    }


    BroadcastReceiver mWifiDisplayReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (action.equals(ACTION_WIFI_DISPLAY_VIDEO)) {
                int state = intent.getIntExtra(""state"", 0);
                if(state == 1) {
                    mWifiDisplayConnected = true;
                } else {
                    mWifiDisplayConnected = false;
                }
                mWifiDisplayCustomRotation =
                    intent.getIntExtra(""wfd_UIBC_rot"", -1);
                updateRotation(true);
            }
        }
    };

","    private final Runnable mHiddenNavPanic = new Runnable() {
        @Override
        public void run() {
            synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
                if (!isUserSetupComplete()) {
                    // Swipe-up for navigation bar is disabled during setup
                    return;
                }
                mPendingPanicGestureUptime = SystemClock.uptimeMillis();
                if (!isNavBarEmpty(mLastSystemUiFlags)) {
                    mNavigationBarController.showTransient();
                }
            }
        }
    };

    private void requestTransientBars(WindowState swipeTarget) {
        synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
            if (!isUserSetupComplete()) {
                // Swipe-up for navigation bar is disabled during setup
                return;
            }
            boolean sb = mStatusBarController.checkShowTransientBarLw();
            boolean nb = mNavigationBarController.checkShowTransientBarLw()
                    && !isNavBarEmpty(mLastSystemUiFlags);
            if (sb || nb) {
                // Don't show status bar when swiping on already visible navigation bar
                if (!nb && swipeTarget == mNavigationBar) {
                    if (DEBUG) Slog.d(TAG, ""Not showing transient bar, wrong swipe target"");
                    return;
                }
                if (sb) mStatusBarController.showTransient();
                if (nb) mNavigationBarController.showTransient();
                mImmersiveModeConfirmation.confirmCurrentPrompt();
                updateSystemUiVisibilityLw();
            }
        }
    }


    BroadcastReceiver mWifiDisplayReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (action.equals(ACTION_WIFI_DISPLAY_VIDEO)) {
                int state = intent.getIntExtra(""state"", 0);
                if(state == 1) {
                    mWifiDisplayConnected = true;
                } else {
                    mWifiDisplayConnected = false;
                }
                mWifiDisplayCustomRotation =
                    intent.getIntExtra(""wfd_UIBC_rot"", -1);
                updateRotation(true);
            }
        }
    };

","    private final Runnable mHiddenNavPanic = new Runnable() {
        @Override
        public void run() {
            synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
                if (!isUserSetupComplete()) {
                    // Swipe-up for navigation bar is disabled during setup
                    return;
                }
                mPendingPanicGestureUptime = SystemClock.uptimeMillis();
                if (!isNavBarEmpty(mLastSystemUiFlags)) {
                    mNavigationBarController.showTransient();
                }
            }
        }
    };

    private void requestTransientBars(WindowState swipeTarget) {
        synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
            if (!isUserSetupComplete()) {
                // Swipe-up for navigation bar is disabled during setup
                return;
            }
            boolean sb = mStatusBarController.checkShowTransientBarLw();
            boolean nb = mNavigationBarController.checkShowTransientBarLw()
                    && !isNavBarEmpty(mLastSystemUiFlags);
            if (sb || nb) {
                // Don't show status bar when swiping on already visible navigation bar
                if (!nb && swipeTarget == mNavigationBar) {
                    if (DEBUG) Slog.d(TAG, ""Not showing transient bar, wrong swipe target"");
                    return;
                }
                if (sb) mStatusBarController.showTransient();
                if (nb) mNavigationBarController.showTransient();
                mImmersiveModeConfirmation.confirmCurrentPrompt();
                updateSystemUiVisibilityLw();
            }
        }
    }


    BroadcastReceiver mWifiDisplayReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (action.equals(ACTION_WIFI_DISPLAY_VIDEO)) {
                int state = intent.getIntExtra(""state"", 0);
                if(state == 1) {
                    mWifiDisplayConnected = true;
                } else {
                    mWifiDisplayConnected = false;
                }
                mWifiDisplayCustomRotation =
                    intent.getIntExtra(""wfd_UIBC_rot"", -1);
                updateRotation(true);
            }
        }
    };

","[1.0, 1.0]"
401,"['8d21ad0d966c1e9f96e5a65144efad2582391957', '8d21ad0d966c1e9f96e5a65144efad2582391957']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(167, 167, 1), (167, 167, 1)]","    public static final int SECURITY_DPP = 7;
","    public static final int SECURITY_DPP = 7;
","    public static final int SECURITY_DPP = 7;
","[1.0, 1.0]"
402,"['8d21ad0d966c1e9f96e5a65144efad2582391957', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(167, 167, 1), (166, 166, 1)]","    public static final int SECURITY_DPP = 7;
","    public static final int SECURITY_DPP = 6;
",    public static final int SECURITY_DPP = ,"[0.935, 0.935]"
403,"['9caf34febf01086c96266e38d024f7a0315b892d', '9caf34febf01086c96266e38d024f7a0315b892d']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(609, 611, 3), (609, 611, 3)]","                        mActivity.addErrorToDropBox(
                                ""watchdog"", null, ""system_server"", null, null, null,
                                subject, null, finalStack, null);
","                        mActivity.addErrorToDropBox(
                                ""watchdog"", null, ""system_server"", null, null, null,
                                subject, null, finalStack, null);
","                        mActivity.addErrorToDropBox(
                                ""watchdog"", null, ""system_server"", null, null, null,
                                subject, null, finalStack, null);
","[1.0, 1.0]"
404,"['9caf34febf01086c96266e38d024f7a0315b892d', '9caf34febf01086c96266e38d024f7a0315b892d']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(182, 183, 2), (182, 183, 2)]","    public static final int SECURITY_DPP = 7;
    public static final int SECURITY_MAX_VAL = 8; // Has to be the last
","    public static final int SECURITY_DPP = 7;
    public static final int SECURITY_MAX_VAL = 8; // Has to be the last
","    public static final int SECURITY_DPP = 7;
    public static final int SECURITY_MAX_VAL = 8; // Has to be the last
","[1.0, 1.0]"
405,"['9caf34febf01086c96266e38d024f7a0315b892d', '9caf34febf01086c96266e38d024f7a0315b892d']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPointPreference.java,"[(206, 207, 2), (206, 207, 2)]","        if (mAccessPoint.getSecurity() != AccessPoint.SECURITY_NONE &&
            mAccessPoint.getSecurity() != AccessPoint.SECURITY_OWE) {
","        if (mAccessPoint.getSecurity() != AccessPoint.SECURITY_NONE &&
            mAccessPoint.getSecurity() != AccessPoint.SECURITY_OWE) {
","        if (mAccessPoint.getSecurity() != AccessPoint.SECURITY_NONE &&
            mAccessPoint.getSecurity() != AccessPoint.SECURITY_OWE) {
","[1.0, 1.0]"
406,"['9caf34febf01086c96266e38d024f7a0315b892d', '9caf34febf01086c96266e38d024f7a0315b892d']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/SmsManager.java,"[(985, 992, 8), (985, 992, 8)]","        if (isSmsSimPickActivityNeeded) {
            Log.d(TAG, ""getSubscriptionId isSmsSimPickActivityNeeded is true"");
            // ask the user for a default SMS SIM.
            Intent intent = new Intent();
            intent.setClassName(""com.qualcomm.qti.simsettings"",
                    ""com.qualcomm.qti.simsettings.SimDialogActivity"");
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            intent.putExtra(DIALOG_TYPE_KEY, SMS_PICK);
","        if (isSmsSimPickActivityNeeded) {
            Log.d(TAG, ""getSubscriptionId isSmsSimPickActivityNeeded is true"");
            // ask the user for a default SMS SIM.
            Intent intent = new Intent();
            intent.setClassName(""com.qualcomm.qti.simsettings"",
                    ""com.qualcomm.qti.simsettings.SimDialogActivity"");
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            intent.putExtra(DIALOG_TYPE_KEY, SMS_PICK);
","        if (isSmsSimPickActivityNeeded) {
            Log.d(TAG, ""getSubscriptionId isSmsSimPickActivityNeeded is true"");
            // ask the user for a default SMS SIM.
            Intent intent = new Intent();
            intent.setClassName(""com.qualcomm.qti.simsettings"",
                    ""com.qualcomm.qti.simsettings.SimDialogActivity"");
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            intent.putExtra(DIALOG_TYPE_KEY, SMS_PICK);
","[1.0, 1.0]"
410,"['a97ca47ee3713a075711c311c49e3951264007ef', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1780, 1781, 2), (2329, 2329, 1)]","        android.util.SeempLog.record(43);
        return false;
","        android.util.SeempLog.record(48);
",        android.util.SeempLog.record(4,"[0.594, 0.905]"
411,"['a97ca47ee3713a075711c311c49e3951264007ef', 'a97ca47ee3713a075711c311c49e3951264007ef']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1780, 1781, 2), (1780, 1781, 2)]","        android.util.SeempLog.record(43);
        return false;
","        android.util.SeempLog.record(43);
        return false;
","        android.util.SeempLog.record(43);
        return false;
","[1.0, 1.0]"
412,"['a9808279aa66eb64ea573100d13cf753bf293a4c', 'a9808279aa66eb64ea573100d13cf753bf293a4c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"[(164, 171, 8), (164, 171, 8)]","        mHearingAidProfile = new HearingAidProfile(mContext, mLocalAdapter, mDeviceManager, this);
        addProfile(mHearingAidProfile, HearingAidProfile.NAME,
                   BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);

        mDunProfile = new DunServerProfile(context);
        addProfile(mDunProfile, DunServerProfile.NAME,
                BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);

","        mHearingAidProfile = new HearingAidProfile(mContext, mLocalAdapter, mDeviceManager, this);
        addProfile(mHearingAidProfile, HearingAidProfile.NAME,
                   BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);

        mDunProfile = new DunServerProfile(context);
        addProfile(mDunProfile, DunServerProfile.NAME,
                BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);

","        mHearingAidProfile = new HearingAidProfile(mContext, mLocalAdapter, mDeviceManager, this);
        addProfile(mHearingAidProfile, HearingAidProfile.NAME,
                   BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);

        mDunProfile = new DunServerProfile(context);
        addProfile(mDunProfile, DunServerProfile.NAME,
                BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);

","[1.0, 1.0]"
414,"['af01b38e0a0664bc87b649248b0c13fbe0925193', 'af01b38e0a0664bc87b649248b0c13fbe0925193']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/usb/java/com/android/server/usb/UsbDeviceManager.java,"[(1346, 1350, 5), (1346, 1350, 5)]","        private String getChargingFunctions() {
            String func = SystemProperties.get(getPersistProp(true),
                    UsbManager.USB_FUNCTION_NONE);
            if (UsbManager.USB_FUNCTION_NONE.equals(func)) {
                func = UsbManager.USB_FUNCTION_MTP;
","        private String getChargingFunctions() {
            String func = SystemProperties.get(getPersistProp(true),
                    UsbManager.USB_FUNCTION_NONE);
            if (UsbManager.USB_FUNCTION_NONE.equals(func)) {
                func = UsbManager.USB_FUNCTION_MTP;
","        private String getChargingFunctions() {
            String func = SystemProperties.get(getPersistProp(true),
                    UsbManager.USB_FUNCTION_NONE);
            if (UsbManager.USB_FUNCTION_NONE.equals(func)) {
                func = UsbManager.USB_FUNCTION_MTP;
","[1.0, 1.0]"
415,"['b0fb644c3eaa60930300e3689e6652de7c21d4f7', 'b0fb644c3eaa60930300e3689e6652de7c21d4f7']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3679, 3709, 31), (3679, 3709, 31)]","
        Slog.i(TAG, ""handleBtScoActiveDeviceChange: isActive "" + isActive +
             "" outDevice "" + outDevice + "" address "" + address + "" btDevicename "" + btDeviceName);

        boolean result = handleDeviceConnection(isActive, outDevice, address, btDeviceName);
        Slog.i(TAG, ""for outDevice "" + outDevice + "" result is "" + result);

        /* When BT process is killed, getting device class may fail during cleanup.
         * This results in outDevice assigned to DEVICE_OUT_BLUETOOTH_SCO. If
         * outDevice was added as different device than DEVICE_OUT_BLUETOOTH_SCO
         * during connection, removal will fail during disconnection. Attempt to
         * remove outDevice with other possible SCO devices.
         */
        if (isActive == false && result == false) {
           outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
           Slog.w(TAG, ""handleBtScoActiveDeviceChange: retrying with outDevice "" + outDevice);

           result = handleDeviceConnection(isActive, outDevice, address, btDeviceName);

           Slog.w(TAG, ""for outDevice ""+ outDevice + "" result is "" + result);
        }

        if (isActive == false && result == false) {
           outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
           Slog.w(TAG, ""handleBtScoActiveDeviceChange: retrying with outDevice "" + outDevice);

           result = handleDeviceConnection(isActive, outDevice, address, btDeviceName);

           Slog.w(TAG, ""for outDevice ""+ outDevice + "" result is "" + result);
        }

","
        Slog.i(TAG, ""handleBtScoActiveDeviceChange: isActive "" + isActive +
             "" outDevice "" + outDevice + "" address "" + address + "" btDevicename "" + btDeviceName);

        boolean result = handleDeviceConnection(isActive, outDevice, address, btDeviceName);
        Slog.i(TAG, ""for outDevice "" + outDevice + "" result is "" + result);

        /* When BT process is killed, getting device class may fail during cleanup.
         * This results in outDevice assigned to DEVICE_OUT_BLUETOOTH_SCO. If
         * outDevice was added as different device than DEVICE_OUT_BLUETOOTH_SCO
         * during connection, removal will fail during disconnection. Attempt to
         * remove outDevice with other possible SCO devices.
         */
        if (isActive == false && result == false) {
           outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
           Slog.w(TAG, ""handleBtScoActiveDeviceChange: retrying with outDevice "" + outDevice);

           result = handleDeviceConnection(isActive, outDevice, address, btDeviceName);

           Slog.w(TAG, ""for outDevice ""+ outDevice + "" result is "" + result);
        }

        if (isActive == false && result == false) {
           outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
           Slog.w(TAG, ""handleBtScoActiveDeviceChange: retrying with outDevice "" + outDevice);

           result = handleDeviceConnection(isActive, outDevice, address, btDeviceName);

           Slog.w(TAG, ""for outDevice ""+ outDevice + "" result is "" + result);
        }

","
        Slog.i(TAG, ""handleBtScoActiveDeviceChange: isActive "" + isActive +
             "" outDevice "" + outDevice + "" address "" + address + "" btDevicename "" + btDeviceName);

        boolean result = handleDeviceConnection(isActive, outDevice, address, btDeviceName);
        Slog.i(TAG, ""for outDevice "" + outDevice + "" result is "" + result);

        /* When BT process is killed, getting device class may fail during cleanup.
         * This results in outDevice assigned to DEVICE_OUT_BLUETOOTH_SCO. If
         * outDevice was added as different device than DEVICE_OUT_BLUETOOTH_SCO
         * during connection, removal will fail during disconnection. Attempt to
         * remove outDevice with other possible SCO devices.
         */
        if (isActive == false && result == false) {
           outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
           Slog.w(TAG, ""handleBtScoActiveDeviceChange: retrying with outDevice "" + outDevice);

           result = handleDeviceConnection(isActive, outDevice, address, btDeviceName);

           Slog.w(TAG, ""for outDevice ""+ outDevice + "" result is "" + result);
        }

        if (isActive == false && result == false) {
           outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
           Slog.w(TAG, ""handleBtScoActiveDeviceChange: retrying with outDevice "" + outDevice);

           result = handleDeviceConnection(isActive, outDevice, address, btDeviceName);

           Slog.w(TAG, ""for outDevice ""+ outDevice + "" result is "" + result);
        }

","[1.0, 1.0]"
416,"['b576b28ececdf87e488eaf196c28e48371784746', 'b576b28ececdf87e488eaf196c28e48371784746']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(1531, 1533, 3), (1531, 1533, 3)]","        sVolumeLogger.log(new VolumeEvent(VolumeEvent.VOL_ADJUST_SUGG_VOL, suggestedStreamType,
                direction/*val1*/, flags/*val2*/, new StringBuilder(callingPackage)
                        .append(""/"").append(caller).append("" uid:"").append(uid).toString()));
","        sVolumeLogger.log(new VolumeEvent(VolumeEvent.VOL_ADJUST_SUGG_VOL, suggestedStreamType,
                direction/*val1*/, flags/*val2*/, new StringBuilder(callingPackage)
                        .append(""/"").append(caller).append("" uid:"").append(uid).toString()));
","        sVolumeLogger.log(new VolumeEvent(VolumeEvent.VOL_ADJUST_SUGG_VOL, suggestedStreamType,
                direction/*val1*/, flags/*val2*/, new StringBuilder(callingPackage)
                        .append(""/"").append(caller).append("" uid:"").append(uid).toString()));
","[1.0, 1.0]"
429,"['b76115be4efabffaa6febc57cec47acc2f933c79', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']","['aospa-quartz-SAP-block_text', 'omnirom-10-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(593, 656, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
430,"['b76115be4efabffaa6febc57cec47acc2f933c79', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(593, 656, 64), (651, 714, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
431,"['b76115be4efabffaa6febc57cec47acc2f933c79', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2059, 2060, 2), (2486, 2487, 2)]","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            return KeyMgmt.DPP;
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            ","[0.783, 0.626]"
432,"['b76115be4efabffaa6febc57cec47acc2f933c79', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2098, 2099, 2), (2486, 2487, 2)]","            } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            ","[0.585, 0.626]"
433,"['b76115be4efabffaa6febc57cec47acc2f933c79', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(593, 656, 64), (669, 732, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
434,"['b76115be4efabffaa6febc57cec47acc2f933c79', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(593, 656, 64), (677, 740, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
435,"['b76115be4efabffaa6febc57cec47acc2f933c79', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(46, 48, 3), (51, 53, 3)]","import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
import com.android.settingslib.graph.SignalDrawable;
","import com.android.internal.telephony.cdma.EriInfo;
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","[0.69, 0.694]"
436,"['b76115be4efabffaa6febc57cec47acc2f933c79', '7fe8671fd7b5388dd9be6295dbea6d31209468f9']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(593, 656, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
437,"['b76115be4efabffaa6febc57cec47acc2f933c79', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2059, 2060, 2), (2637, 2638, 2)]","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            return KeyMgmt.DPP;
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            ","[0.783, 0.626]"
438,"['b76115be4efabffaa6febc57cec47acc2f933c79', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2098, 2099, 2), (2637, 2638, 2)]","            } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            ","[0.585, 0.626]"
439,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",media/java/android/media/AudioFormat.java,"[(560, 584, 25), (560, 584, 25)]","        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_AMRNB:
        case ENCODING_AMRWB:
        case ENCODING_EVRC:
        case ENCODING_EVRCB:
        case ENCODING_EVRCWB:
        case ENCODING_EVRCNW:
            return true;
        default:
            return false;
","        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_AMRNB:
        case ENCODING_AMRWB:
        case ENCODING_EVRC:
        case ENCODING_EVRCB:
        case ENCODING_EVRCWB:
        case ENCODING_EVRCNW:
            return true;
        default:
            return false;
","        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_AMRNB:
        case ENCODING_AMRWB:
        case ENCODING_EVRC:
        case ENCODING_EVRCB:
        case ENCODING_EVRCWB:
        case ENCODING_EVRCNW:
            return true;
        default:
            return false;
","[1.0, 1.0]"
440,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",media/java/android/media/AudioFormat.java,"[(619, 646, 28), (619, 646, 28)]","        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937: // wrapped in PCM but compressed
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_AMRNB:
        case ENCODING_AMRWB:
        case ENCODING_EVRC:
        case ENCODING_EVRCB:
        case ENCODING_EVRCWB:
        case ENCODING_EVRCNW:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException(""Bad audio format "" + audioFormat);
","        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937: // wrapped in PCM but compressed
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_AMRNB:
        case ENCODING_AMRWB:
        case ENCODING_EVRC:
        case ENCODING_EVRCB:
        case ENCODING_EVRCWB:
        case ENCODING_EVRCNW:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException(""Bad audio format "" + audioFormat);
","        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937: // wrapped in PCM but compressed
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_AMRNB:
        case ENCODING_AMRWB:
        case ENCODING_EVRC:
        case ENCODING_EVRCB:
        case ENCODING_EVRCWB:
        case ENCODING_EVRCNW:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException(""Bad audio format "" + audioFormat);
","[1.0, 1.0]"
441,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",media/java/android/media/AudioFormat.java,"[(576, 581, 6), (576, 581, 6)]","        case ENCODING_AMRNB:
        case ENCODING_AMRWB:
        case ENCODING_EVRC:
        case ENCODING_EVRCB:
        case ENCODING_EVRCWB:
        case ENCODING_EVRCNW:
","        case ENCODING_AMRNB:
        case ENCODING_AMRWB:
        case ENCODING_EVRC:
        case ENCODING_EVRCB:
        case ENCODING_EVRCWB:
        case ENCODING_EVRCNW:
","        case ENCODING_AMRNB:
        case ENCODING_AMRWB:
        case ENCODING_EVRC:
        case ENCODING_EVRCB:
        case ENCODING_EVRCWB:
        case ENCODING_EVRCNW:
","[1.0, 1.0]"
442,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",media/java/android/media/AudioFormat.java,"[(1135, 1140, 6), (1135, 1140, 6)]","        ENCODING_AMRNB,
        ENCODING_AMRWB,
        ENCODING_EVRC,
        ENCODING_EVRCB,
        ENCODING_EVRCWB,
        ENCODING_EVRCNW }
","        ENCODING_AMRNB,
        ENCODING_AMRWB,
        ENCODING_EVRC,
        ENCODING_EVRCB,
        ENCODING_EVRCWB,
        ENCODING_EVRCNW }
","        ENCODING_AMRNB,
        ENCODING_AMRWB,
        ENCODING_EVRC,
        ENCODING_EVRCB,
        ENCODING_EVRCWB,
        ENCODING_EVRCNW }
","[1.0, 1.0]"
443,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(32, 32, 1), (32, 32, 1)]","import android.os.SystemProperties;
","import android.os.SystemProperties;
","import android.os.SystemProperties;
","[1.0, 1.0]"
444,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPointPreference.java,"[(211, 215, 5), (211, 215, 5)]","        if (mAccessPoint.getSecurity() == AccessPoint.SECURITY_SAE) {
            mFrictionSld.setState(STATE_SECURED_SAE);
        } else if (mAccessPoint.getSecurity() == AccessPoint.SECURITY_OWE) {
            mFrictionSld.setState(STATE_SECURED_OWE);
        } else if (mAccessPoint.getSecurity() != AccessPoint.SECURITY_NONE) {
","        if (mAccessPoint.getSecurity() == AccessPoint.SECURITY_SAE) {
            mFrictionSld.setState(STATE_SECURED_SAE);
        } else if (mAccessPoint.getSecurity() == AccessPoint.SECURITY_OWE) {
            mFrictionSld.setState(STATE_SECURED_OWE);
        } else if (mAccessPoint.getSecurity() != AccessPoint.SECURITY_NONE) {
","        if (mAccessPoint.getSecurity() == AccessPoint.SECURITY_SAE) {
            mFrictionSld.setState(STATE_SECURED_SAE);
        } else if (mAccessPoint.getSecurity() == AccessPoint.SECURITY_OWE) {
            mFrictionSld.setState(STATE_SECURED_OWE);
        } else if (mAccessPoint.getSecurity() != AccessPoint.SECURITY_NONE) {
","[1.0, 1.0]"
445,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(345, 391, 47), (345, 391, 47)]","    public static final int QOS_UNAVAILABLE = 76;
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 77;
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 78;
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 79;
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 80;
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 81;
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 82;
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 83;
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 84;
    public static final int INVALID_TRANSACTION_IDENTIFIER = 85;
    public static final int USER_NOT_MEMBER_OF_CUG = 86;
    public static final int INCOMPATIBLE_DESTINATION = 87;
    public static final int INVALID_TRANSIT_NW_SELECTION = 88;
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 89;
    public static final int INVALID_MANDATORY_INFORMATION = 90;
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 91;
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 92;
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 93;
    public static final int CONDITIONAL_IE_ERROR = 94;
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 95;
    public static final int RECOVERY_ON_TIMER_EXPIRED = 96;
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 97;
    public static final int INTERWORKING_UNSPECIFIED = 98;
    public static final int LOCAL_LOW_BATTERY = 99;
    public static final int NO_CIRCUIT_AVAIL = 100;
    public static final int NO_ROUTE_TO_DESTINATION = 101;
    public static final int OPERATOR_DETERMINED_BARRING = 102;
    public static final int CALL_FAIL_NO_USER_RESPONDING = 103;
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 104;
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 105;
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 106;
    public static final int CHANNEL_UNACCEPTABLE = 107;
    public static final int CALL_REJECTED = 108;
    public static final int NUMBER_CHANGED = 109;
    public static final int PREEMPTION = 110;
    public static final int FACILITY_REJECTED = 111;
    public static final int RESP_TO_STATUS_ENQUIRY = 112;
    public static final int NETWORK_OUT_OF_ORDER = 113;
    public static final int TEMPORARY_FAILURE = 114;
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 115;
    public static final int ACCESS_INFORMATION_DISCARDED = 116;
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 117;
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 118;

    /** call failed due to LTE to 3G/2G handover not feasible */
    public static final int HO_NOT_FEASIBLE = 119;
    public static final int NON_SELECTED_USER_CLEARING = 120;
","    public static final int QOS_UNAVAILABLE = 76;
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 77;
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 78;
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 79;
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 80;
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 81;
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 82;
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 83;
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 84;
    public static final int INVALID_TRANSACTION_IDENTIFIER = 85;
    public static final int USER_NOT_MEMBER_OF_CUG = 86;
    public static final int INCOMPATIBLE_DESTINATION = 87;
    public static final int INVALID_TRANSIT_NW_SELECTION = 88;
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 89;
    public static final int INVALID_MANDATORY_INFORMATION = 90;
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 91;
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 92;
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 93;
    public static final int CONDITIONAL_IE_ERROR = 94;
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 95;
    public static final int RECOVERY_ON_TIMER_EXPIRED = 96;
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 97;
    public static final int INTERWORKING_UNSPECIFIED = 98;
    public static final int LOCAL_LOW_BATTERY = 99;
    public static final int NO_CIRCUIT_AVAIL = 100;
    public static final int NO_ROUTE_TO_DESTINATION = 101;
    public static final int OPERATOR_DETERMINED_BARRING = 102;
    public static final int CALL_FAIL_NO_USER_RESPONDING = 103;
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 104;
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 105;
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 106;
    public static final int CHANNEL_UNACCEPTABLE = 107;
    public static final int CALL_REJECTED = 108;
    public static final int NUMBER_CHANGED = 109;
    public static final int PREEMPTION = 110;
    public static final int FACILITY_REJECTED = 111;
    public static final int RESP_TO_STATUS_ENQUIRY = 112;
    public static final int NETWORK_OUT_OF_ORDER = 113;
    public static final int TEMPORARY_FAILURE = 114;
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 115;
    public static final int ACCESS_INFORMATION_DISCARDED = 116;
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 117;
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 118;

    /** call failed due to LTE to 3G/2G handover not feasible */
    public static final int HO_NOT_FEASIBLE = 119;
    public static final int NON_SELECTED_USER_CLEARING = 120;
","    public static final int QOS_UNAVAILABLE = 76;
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 77;
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 78;
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 79;
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 80;
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 81;
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 82;
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 83;
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 84;
    public static final int INVALID_TRANSACTION_IDENTIFIER = 85;
    public static final int USER_NOT_MEMBER_OF_CUG = 86;
    public static final int INCOMPATIBLE_DESTINATION = 87;
    public static final int INVALID_TRANSIT_NW_SELECTION = 88;
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 89;
    public static final int INVALID_MANDATORY_INFORMATION = 90;
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 91;
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 92;
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 93;
    public static final int CONDITIONAL_IE_ERROR = 94;
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 95;
    public static final int RECOVERY_ON_TIMER_EXPIRED = 96;
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 97;
    public static final int INTERWORKING_UNSPECIFIED = 98;
    public static final int LOCAL_LOW_BATTERY = 99;
    public static final int NO_CIRCUIT_AVAIL = 100;
    public static final int NO_ROUTE_TO_DESTINATION = 101;
    public static final int OPERATOR_DETERMINED_BARRING = 102;
    public static final int CALL_FAIL_NO_USER_RESPONDING = 103;
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 104;
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 105;
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 106;
    public static final int CHANNEL_UNACCEPTABLE = 107;
    public static final int CALL_REJECTED = 108;
    public static final int NUMBER_CHANGED = 109;
    public static final int PREEMPTION = 110;
    public static final int FACILITY_REJECTED = 111;
    public static final int RESP_TO_STATUS_ENQUIRY = 112;
    public static final int NETWORK_OUT_OF_ORDER = 113;
    public static final int TEMPORARY_FAILURE = 114;
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 115;
    public static final int ACCESS_INFORMATION_DISCARDED = 116;
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 117;
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 118;

    /** call failed due to LTE to 3G/2G handover not feasible */
    public static final int HO_NOT_FEASIBLE = 119;
    public static final int NON_SELECTED_USER_CLEARING = 120;
","[1.0, 1.0]"
446,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(593, 656, 64), (593, 656, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
447,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/Instrumentation.java,"[(1910, 1912, 3), (1910, 1912, 3)]","            Intent intent, int requestCode, Bundle options, boolean ignoreTargetSecurity,
            int userId) {
        android.util.SeempLog.record_str(379, intent.toString());
","            Intent intent, int requestCode, Bundle options, boolean ignoreTargetSecurity,
            int userId) {
        android.util.SeempLog.record_str(379, intent.toString());
","            Intent intent, int requestCode, Bundle options, boolean ignoreTargetSecurity,
            int userId) {
        android.util.SeempLog.record_str(379, intent.toString());
","[1.0, 1.0]"
448,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/p2p/WifiP2pManager.java,"[(484, 489, 6), (484, 489, 6)]","    public static final int SET_WFDR2_INFO                          = BASE + 82;
    /** @hide */
    public static final int SET_WFDR2_INFO_FAILED                   = BASE + 83;
    /** @hide */
    public static final int SET_WFDR2_INFO_SUCCEEDED                = BASE + 84;

","    public static final int SET_WFDR2_INFO                          = BASE + 82;
    /** @hide */
    public static final int SET_WFDR2_INFO_FAILED                   = BASE + 83;
    /** @hide */
    public static final int SET_WFDR2_INFO_SUCCEEDED                = BASE + 84;

","    public static final int SET_WFDR2_INFO                          = BASE + 82;
    /** @hide */
    public static final int SET_WFDR2_INFO_FAILED                   = BASE + 83;
    /** @hide */
    public static final int SET_WFDR2_INFO_SUCCEEDED                = BASE + 84;

","[1.0, 1.0]"
449,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8272, 8274, 3), (8272, 8274, 3)]","            ACCESSIBILITY_MINIMUM_UI_TIMEOUT_ENABLED,
            ACCESSIBILITY_MINIMUM_UI_TIMEOUT_MS,
            WIFI_DISCONNECT_DELAY_DURATION,
","            ACCESSIBILITY_MINIMUM_UI_TIMEOUT_ENABLED,
            ACCESSIBILITY_MINIMUM_UI_TIMEOUT_MS,
            WIFI_DISCONNECT_DELAY_DURATION,
","            ACCESSIBILITY_MINIMUM_UI_TIMEOUT_ENABLED,
            ACCESSIBILITY_MINIMUM_UI_TIMEOUT_MS,
            WIFI_DISCONNECT_DELAY_DURATION,
","[1.0, 1.0]"
450,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8430, 8432, 3), (8430, 8432, 3)]","            VALIDATORS.put(ACCESSIBILITY_MINIMUM_UI_TIMEOUT_ENABLED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_MINIMUM_UI_TIMEOUT_MS, NON_NEGATIVE_INTEGER_VALIDATOR);
            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(ACCESSIBILITY_MINIMUM_UI_TIMEOUT_ENABLED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_MINIMUM_UI_TIMEOUT_MS, NON_NEGATIVE_INTEGER_VALIDATOR);
            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","            VALIDATORS.put(ACCESSIBILITY_MINIMUM_UI_TIMEOUT_ENABLED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_MINIMUM_UI_TIMEOUT_MS, NON_NEGATIVE_INTEGER_VALIDATOR);
            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
","[1.0, 1.0]"
451,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(17342, 17349, 8), (17342, 17349, 8)]","        if ((numBServices > mBServiceAppThreshold) && (true == mAllowLowerMemLevel)
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }
","        if ((numBServices > mBServiceAppThreshold) && (true == mAllowLowerMemLevel)
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }
","        if ((numBServices > mBServiceAppThreshold) && (true == mAllowLowerMemLevel)
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }
","[1.0, 1.0]"
452,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActiveServices.java,"[(2273, 2282, 10), (2273, 2282, 10)]","                + r.shortName + "" in "" + r.restartDelay + ""ms"");

        if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
            for (int i=mRestartingServices.size()-1; i>=0; i--) {
                ServiceRecord r2 = mRestartingServices.get(i);
                Slog.w(TAG,""Restarting list - i ""+i+"" r2.nextRestartTime ""
                           +r2.nextRestartTime+"" r2.name ""+r2.name);
            }
        }

","                + r.shortName + "" in "" + r.restartDelay + ""ms"");

        if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
            for (int i=mRestartingServices.size()-1; i>=0; i--) {
                ServiceRecord r2 = mRestartingServices.get(i);
                Slog.w(TAG,""Restarting list - i ""+i+"" r2.nextRestartTime ""
                           +r2.nextRestartTime+"" r2.name ""+r2.name);
            }
        }

","                + r.shortName + "" in "" + r.restartDelay + ""ms"");

        if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
            for (int i=mRestartingServices.size()-1; i>=0; i--) {
                ServiceRecord r2 = mRestartingServices.get(i);
                Slog.w(TAG,""Restarting list - i ""+i+"" r2.nextRestartTime ""
                           +r2.nextRestartTime+"" r2.name ""+r2.name);
            }
        }

","[1.0, 1.0]"
453,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(46, 48, 3), (46, 48, 3)]","import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
import com.android.settingslib.graph.SignalDrawable;
","import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
import com.android.settingslib.graph.SignalDrawable;
","import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
import com.android.settingslib.graph.SignalDrawable;
","[1.0, 1.0]"
454,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/WindowManagerService.java,"[(1124, 1126, 3), (1124, 1126, 3)]","        mFocusingActivity = attrs.getTitle().toString();

        synchronized(mWindowMap) {
","        mFocusingActivity = attrs.getTitle().toString();

        synchronized(mWindowMap) {
","        mFocusingActivity = attrs.getTitle().toString();

        synchronized(mWindowMap) {
","[1.0, 1.0]"
455,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/WindowManagerService.java,"[(3135, 3136, 2), (3135, 3136, 2)]","        synchronized(mWindowMap) {
            return animationScalesCheck(ANIMATION_DURATION_SCALE);
","        synchronized(mWindowMap) {
            return animationScalesCheck(ANIMATION_DURATION_SCALE);
","        synchronized(mWindowMap) {
            return animationScalesCheck(ANIMATION_DURATION_SCALE);
","[1.0, 1.0]"
456,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(910, 935, 26), (910, 935, 26)]","     * Broadcast intent action indicating that WifiCountryCode was updated with new
     * country code.
     *
     * @see #EXTRA_COUNTRY_CODE
     *
     * @hide
     */
    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
    public static final String WIFI_COUNTRY_CODE_CHANGED_ACTION =
            ""android.net.wifi.COUNTRY_CODE_CHANGED"";

    /**
     * The lookup key for a string that indicates the 2 char new country code
     *
     * @hide
     */
    public static final String EXTRA_COUNTRY_CODE = ""country_code"";

    /**
     * Broadcast intent action indicating that the user initiated Wifi OFF
     * or APM ON and Wifi disconnection is in progress
     * Actual Wifi disconnection happens after mDisconnectDelayDuration seconds.
     * @hide
     */
    public static final String  ACTION_WIFI_DISCONNECT_IN_PROGRESS =
            ""com.qualcomm.qti.net.wifi.WIFI_DISCONNECT_IN_PROGRESS"";
","     * Broadcast intent action indicating that WifiCountryCode was updated with new
     * country code.
     *
     * @see #EXTRA_COUNTRY_CODE
     *
     * @hide
     */
    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
    public static final String WIFI_COUNTRY_CODE_CHANGED_ACTION =
            ""android.net.wifi.COUNTRY_CODE_CHANGED"";

    /**
     * The lookup key for a string that indicates the 2 char new country code
     *
     * @hide
     */
    public static final String EXTRA_COUNTRY_CODE = ""country_code"";

    /**
     * Broadcast intent action indicating that the user initiated Wifi OFF
     * or APM ON and Wifi disconnection is in progress
     * Actual Wifi disconnection happens after mDisconnectDelayDuration seconds.
     * @hide
     */
    public static final String  ACTION_WIFI_DISCONNECT_IN_PROGRESS =
            ""com.qualcomm.qti.net.wifi.WIFI_DISCONNECT_IN_PROGRESS"";
","     * Broadcast intent action indicating that WifiCountryCode was updated with new
     * country code.
     *
     * @see #EXTRA_COUNTRY_CODE
     *
     * @hide
     */
    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
    public static final String WIFI_COUNTRY_CODE_CHANGED_ACTION =
            ""android.net.wifi.COUNTRY_CODE_CHANGED"";

    /**
     * The lookup key for a string that indicates the 2 char new country code
     *
     * @hide
     */
    public static final String EXTRA_COUNTRY_CODE = ""country_code"";

    /**
     * Broadcast intent action indicating that the user initiated Wifi OFF
     * or APM ON and Wifi disconnection is in progress
     * Actual Wifi disconnection happens after mDisconnectDelayDuration seconds.
     * @hide
     */
    public static final String  ACTION_WIFI_DISCONNECT_IN_PROGRESS =
            ""com.qualcomm.qti.net.wifi.WIFI_DISCONNECT_IN_PROGRESS"";
","[1.0, 1.0]"
457,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(4012, 4193, 182), (4012, 4193, 182)]","     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
","     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
","     * Get driver Capabilities.
     *
     * @param capaType ASCII string, capability type ex: key_mgmt.
     * @return String of capabilities from driver for type capaParameter.
     * {@hide}
     */
    public String getCapabilities(String capaType) {
        try {
            return mService.getCapabilities(capaType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Add the DPP bootstrap info obtained from QR code.
     *
     * @param uri:The URI obtained from the QR code reader.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppAddBootstrapQrCode(String uri) {
        try {
            return mService.dppAddBootstrapQrCode(uri);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }


    /**
     * Generate bootstrap URI based on the passed arguments
     *
     * @param config 每 bootstrap generate config, mandatory parameters
     *                 are: type, frequency, mac_addr, curve, key.
     *
     * @return: Handle to strored URI info else -1 on failure
     * @hide
     */
    public int dppBootstrapGenerate(WifiDppConfig config) {
        try {
            return mService.dppBootstrapGenerate(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Get bootstrap URI based on bootstrap ID
     *
     * @param bootstrap_id: Stored bootstrap ID
     *
     * @return: URI string else -1 on failure
     * @hide
     */
    public String dppGetUri(int bootstrap_id) {
        try {
            return mService.dppGetUri(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove bootstrap URI based on bootstrap ID.
     *
     * @param bootstrap_id: Stored bootstrap ID. 0 to remove all.
     *
     * @return: 0 每 Success or -1 on failure
     * @hide
     */
    public int dppBootstrapRemove(int bootstrap_id) {
        try {
            return mService.dppBootstrapRemove(bootstrap_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * start listen on the channel specified waiting to receive
     * the DPP Authentication request.
     *
     * @param frequency: DPP listen frequency
     * @param dpp_role: Configurator/Enrollee role
     * @param qr_mutual: Mutual authentication required
     * @param netrole_ap: network role
     *
     * @return: Returns 0 if a DPP-listen work is successfully
     *  queued and -1 on failure.
     * @hide
     */
    public int dppListen(String frequency, int dpp_role, boolean qr_mutual,
                         boolean netrole_ap) {
        try {
            return mService.dppListen(frequency, dpp_role, qr_mutual, netrole_ap);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * stop ongoing dpp listen.
     *
     * @hide
     */
    public void dppStopListen() {
        try {
            mService.dppStopListen();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Adds the DPP configurator
     *
     * @param curve curve used for dpp encryption
     * @param key private key
     * @param expiry timeout in seconds
     *
     * @return: Identifier of the added configurator or -1 on failure
     * @hide
     */
    public int dppConfiguratorAdd(String curve, String key, int expiry) {
        try {
            return mService.dppConfiguratorAdd(curve, key, expiry);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Remove the added configurator through dppConfiguratorAdd.
     *
     * @param config_id: DPP Configurator ID. 0 to remove all.
     *
     * @return: Handle to strored info else -1 on failure
     * @hide
     */
    public int dppConfiguratorRemove(int config_id) {
        try {
            return mService.dppConfiguratorRemove(config_id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Start DPP authentication and provisioning with the specified peer
     *
     * @param config 每 dpp auth init config mandatory parameters
     *                 are: peer_bootstrap_id,  own_bootstrap_id,  dpp_role,
     *                 ssid, passphrase, isDpp, conf_id, expiry.
     *
     * @return: 0 if DPP auth request was transmitted and -1 on failure
     * @hide
     */
    public int  dppStartAuth(WifiDppConfig config) {
        try {
            return mService.dppStartAuth(config);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Retrieve Private key to be used for configurator
     *
     * @param id: id of configurator
     *
     * @return: KEY string else -1 on failure
     * @hide
     */
    public String dppConfiguratorGetKey(int id) {
        try {
            return mService.dppConfiguratorGetKey(id);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
","[1.0, 1.0]"
458,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(166, 166, 1), (166, 166, 1)]","    public static final int SECURITY_DPP = 6;
","    public static final int SECURITY_DPP = 6;
","    public static final int SECURITY_DPP = 6;
","[1.0, 1.0]"
459,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(813, 815, 3), (813, 815, 3)]","            case SECURITY_DPP:
                return concise ? context.getString(R.string.wifi_security_short_dpp) :
                    context.getString(R.string.wifi_security_dpp);
","            case SECURITY_DPP:
                return concise ? context.getString(R.string.wifi_security_short_dpp) :
                    context.getString(R.string.wifi_security_dpp);
","            case SECURITY_DPP:
                return concise ? context.getString(R.string.wifi_security_short_dpp) :
                    context.getString(R.string.wifi_security_dpp);
","[1.0, 1.0]"
460,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(1393, 1398, 6), (1393, 1398, 6)]","        if (config.allowedKeyManagement.get(KeyMgmt.DPP)) {
            return SECURITY_DPP;
        }
        if (config.allowedKeyManagement.get(KeyMgmt.SAE)) {
            return SECURITY_SAE;
        }
","        if (config.allowedKeyManagement.get(KeyMgmt.DPP)) {
            return SECURITY_DPP;
        }
        if (config.allowedKeyManagement.get(KeyMgmt.SAE)) {
            return SECURITY_SAE;
        }
","        if (config.allowedKeyManagement.get(KeyMgmt.DPP)) {
            return SECURITY_DPP;
        }
        if (config.allowedKeyManagement.get(KeyMgmt.SAE)) {
            return SECURITY_SAE;
        }
","[1.0, 1.0]"
461,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(1419, 1422, 4), (1419, 1422, 4)]","        } else if (security == SECURITY_DPP) {
            return ""DPP"";
        } else if (security == SECURITY_SAE) {
            return ""SAE"";
","        } else if (security == SECURITY_DPP) {
            return ""DPP"";
        } else if (security == SECURITY_SAE) {
            return ""SAE"";
","        } else if (security == SECURITY_DPP) {
            return ""DPP"";
        } else if (security == SECURITY_SAE) {
            return ""SAE"";
","[1.0, 1.0]"
462,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(132, 162, 31), (132, 162, 31)]","        * IEEE 802.11ai FILS SK with SHA256
         * @hide
        */
        public static final int FILS_SHA256 = 8;
        /**
         * IEEE 802.11ai FILS SK with SHA384:
         * @hide
         */
        public static final int FILS_SHA384 = 9;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        public static final int DPP = 10;

        /**
         * Simultaneous Authentication of Equals
         * @hide
         */
        public static final int SAE = 11;
        /**
         * Opportunististic Wireless Encryption
         * @hide
         */
        public static final int OWE = 12;

        /**
         * SUITE_B_192 192 bit level
         * @hide
         */
        public static final int SUITE_B_192 = 13;
","        * IEEE 802.11ai FILS SK with SHA256
         * @hide
        */
        public static final int FILS_SHA256 = 8;
        /**
         * IEEE 802.11ai FILS SK with SHA384:
         * @hide
         */
        public static final int FILS_SHA384 = 9;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        public static final int DPP = 10;

        /**
         * Simultaneous Authentication of Equals
         * @hide
         */
        public static final int SAE = 11;
        /**
         * Opportunististic Wireless Encryption
         * @hide
         */
        public static final int OWE = 12;

        /**
         * SUITE_B_192 192 bit level
         * @hide
         */
        public static final int SUITE_B_192 = 13;
","        * IEEE 802.11ai FILS SK with SHA256
         * @hide
        */
        public static final int FILS_SHA256 = 8;
        /**
         * IEEE 802.11ai FILS SK with SHA384:
         * @hide
         */
        public static final int FILS_SHA384 = 9;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        public static final int DPP = 10;

        /**
         * Simultaneous Authentication of Equals
         * @hide
         */
        public static final int SAE = 11;
        /**
         * Opportunististic Wireless Encryption
         * @hide
         */
        public static final int OWE = 12;

        /**
         * SUITE_B_192 192 bit level
         * @hide
         */
        public static final int SUITE_B_192 = 13;
","[1.0, 1.0]"
463,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(167, 168, 2), (167, 168, 2)]","                ""IEEE8021X"", ""WPA2_PSK"", ""OSEN"", ""FT_PSK"", ""FT_EAP"", ""FILS_SHA256"",
                ""FILS_SHA384"", ""DPP"", ""SAE"", ""OWE"", ""SUITE_B_192""};
","                ""IEEE8021X"", ""WPA2_PSK"", ""OSEN"", ""FT_PSK"", ""FT_EAP"", ""FILS_SHA256"",
                ""FILS_SHA384"", ""DPP"", ""SAE"", ""OWE"", ""SUITE_B_192""};
","                ""IEEE8021X"", ""WPA2_PSK"", ""OSEN"", ""FT_PSK"", ""FT_EAP"", ""FILS_SHA256"",
                ""FILS_SHA384"", ""DPP"", ""SAE"", ""OWE"", ""SUITE_B_192""};
","[1.0, 1.0]"
464,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(232, 238, 7), (232, 238, 7)]","         * @hide
         */
        public static final int GCMP = 3;

        public static final String varName = ""pairwise"";

        public static final String[] strings = { ""NONE"", ""TKIP"", ""CCMP"", ""GCMP"" };
","         * @hide
         */
        public static final int GCMP = 3;

        public static final String varName = ""pairwise"";

        public static final String[] strings = { ""NONE"", ""TKIP"", ""CCMP"", ""GCMP"" };
","         * @hide
         */
        public static final int GCMP = 3;

        public static final String varName = ""pairwise"";

        public static final String[] strings = { ""NONE"", ""TKIP"", ""CCMP"", ""GCMP"" };
","[1.0, 1.0]"
465,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(248, 248, 1), (248, 248, 1)]","     * GCMP = AES in Galois/Counter Mode
","     * GCMP = AES in Galois/Counter Mode
","     * GCMP = AES in Galois/Counter Mode
","[1.0, 1.0]"
466,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(274, 276, 3), (274, 276, 3)]","         * @hide
         */
        public static final int GCMP = 5;
","         * @hide
         */
        public static final int GCMP = 5;
","         * @hide
         */
        public static final int GCMP = 5;
","[1.0, 1.0]"
467,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(282, 282, 1), (282, 282, 1)]","                        ""TKIP"", ""CCMP"", ""GTK_NOT_USED"", ""GCMP"" };
","                        ""TKIP"", ""CCMP"", ""GTK_NOT_USED"", ""GCMP"" };
","                        ""TKIP"", ""CCMP"", ""GTK_NOT_USED"", ""GCMP"" };
","[1.0, 1.0]"
468,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(288, 291, 4), (288, 291, 4)]","     * CMAC = Cipher-based Message Authentication Code
     * GMAC = Galois Message Authentication Code
     * </pre>
     * @hide
","     * CMAC = Cipher-based Message Authentication Code
     * GMAC = Galois Message Authentication Code
     * </pre>
     * @hide
","     * CMAC = Cipher-based Message Authentication Code
     * GMAC = Galois Message Authentication Code
     * </pre>
     * @hide
","[1.0, 1.0]"
469,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(296, 306, 11), (296, 306, 11)]","        /** CMAC = Cipher-based Message Authentication Code */
        public static final int CMAC = 0;

        /** GMAC = Galois Message Authentication Code */
        public static final int GMAC = 1;

        public static final String varName = ""groupMgmt"";

        public static final String[] strings =
                { ""CMAC"", ""GMAC"" };
    }
","        /** CMAC = Cipher-based Message Authentication Code */
        public static final int CMAC = 0;

        /** GMAC = Galois Message Authentication Code */
        public static final int GMAC = 1;

        public static final String varName = ""groupMgmt"";

        public static final String[] strings =
                { ""CMAC"", ""GMAC"" };
    }
","        /** CMAC = Cipher-based Message Authentication Code */
        public static final int CMAC = 0;

        /** GMAC = Galois Message Authentication Code */
        public static final int GMAC = 1;

        public static final String varName = ""groupMgmt"";

        public static final String[] strings =
                { ""CMAC"", ""GMAC"" };
    }
","[1.0, 1.0]"
470,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(318, 327, 10), (318, 327, 10)]","        /** ECDHE_ECDSA */
        public static final int ECDHE_ECDSA = 0;

        /** ECDHE_RSA */
        public static final int ECDHE_RSA = 1;

        public static final String varName = ""SuiteB"";

        public static final String[] strings =
                { ""ECDHE_ECDSA"", ""ECDHE_RSA"" };
","        /** ECDHE_ECDSA */
        public static final int ECDHE_ECDSA = 0;

        /** ECDHE_RSA */
        public static final int ECDHE_RSA = 1;

        public static final String varName = ""SuiteB"";

        public static final String[] strings =
                { ""ECDHE_ECDSA"", ""ECDHE_RSA"" };
","        /** ECDHE_ECDSA */
        public static final int ECDHE_ECDSA = 0;

        /** ECDHE_RSA */
        public static final int ECDHE_RSA = 1;

        public static final String varName = ""SuiteB"";

        public static final String[] strings =
                { ""ECDHE_ECDSA"", ""ECDHE_RSA"" };
","[1.0, 1.0]"
471,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(109, 109, 1), (109, 109, 1)]","          * @hide
","          * @hide
","          * @hide
","[1.0, 1.0]"
472,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(524, 529, 6), (524, 529, 6)]","     * See {@link SuiteBCipher} for descriptions of the values.
     * @hide
     */
    public BitSet allowedSuiteBCiphers;
     /** {@hide} */
    public static final String erpVarName = ""erp"";
","     * See {@link SuiteBCipher} for descriptions of the values.
     * @hide
     */
    public BitSet allowedSuiteBCiphers;
     /** {@hide} */
    public static final String erpVarName = ""erp"";
","     * See {@link SuiteBCipher} for descriptions of the values.
     * @hide
     */
    public BitSet allowedSuiteBCiphers;
     /** {@hide} */
    public static final String erpVarName = ""erp"";
","[1.0, 1.0]"
473,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(1879, 1879, 1), (1879, 1879, 1)]","        sbuf.append('\n').append("" PSK: "");
","        sbuf.append('\n').append("" PSK: "");
","        sbuf.append('\n').append("" PSK: "");
","[1.0, 1.0]"
474,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2059, 2060, 2), (2059, 2060, 2)]","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            return KeyMgmt.DPP;
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            return KeyMgmt.DPP;
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            return KeyMgmt.DPP;
","[1.0, 1.0]"
475,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2059, 2060, 2), (2098, 2099, 2)]","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            return KeyMgmt.DPP;
","            } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            ","[0.783, 0.585]"
476,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2098, 2099, 2), (2098, 2099, 2)]","            } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","            } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","            } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","[1.0, 1.0]"
477,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2318, 2322, 5), (2318, 2322, 5)]","            dppConnector = source.dppConnector;
            dppNetAccessKey = source.dppNetAccessKey;
            dppNetAccessKeyExpiry = source.dppNetAccessKeyExpiry;
            dppCsign = source.dppCsign;

","            dppConnector = source.dppConnector;
            dppNetAccessKey = source.dppNetAccessKey;
            dppNetAccessKeyExpiry = source.dppNetAccessKeyExpiry;
            dppCsign = source.dppCsign;

","            dppConnector = source.dppConnector;
            dppNetAccessKey = source.dppNetAccessKey;
            dppNetAccessKeyExpiry = source.dppNetAccessKeyExpiry;
            dppCsign = source.dppCsign;

","[1.0, 1.0]"
478,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2391, 2394, 4), (2391, 2394, 4)]","        dest.writeString(dppConnector);
        dest.writeString(dppNetAccessKey);
        dest.writeInt(dppNetAccessKeyExpiry);
        dest.writeString(dppCsign);
","        dest.writeString(dppConnector);
        dest.writeString(dppNetAccessKey);
        dest.writeInt(dppNetAccessKeyExpiry);
        dest.writeString(dppCsign);
","        dest.writeString(dppConnector);
        dest.writeString(dppNetAccessKey);
        dest.writeInt(dppNetAccessKeyExpiry);
        dest.writeString(dppCsign);
","[1.0, 1.0]"
479,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2434, 2435, 2), (2434, 2435, 2)]","                config.allowedGroupMgmtCiphers    = readBitSet(in);
                config.allowedSuiteBCiphers    = readBitSet(in);
","                config.allowedGroupMgmtCiphers    = readBitSet(in);
                config.allowedSuiteBCiphers    = readBitSet(in);
","                config.allowedGroupMgmtCiphers    = readBitSet(in);
                config.allowedSuiteBCiphers    = readBitSet(in);
","[1.0, 1.0]"
480,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2464, 2467, 4), (2464, 2467, 4)]","                config.dppConnector = in.readString();
                config.dppNetAccessKey = in.readString();
                config.dppNetAccessKeyExpiry = in.readInt();
                config.dppCsign = in.readString();
","                config.dppConnector = in.readString();
                config.dppNetAccessKey = in.readString();
                config.dppNetAccessKeyExpiry = in.readInt();
                config.dppCsign = in.readString();
","                config.dppConnector = in.readString();
                config.dppNetAccessKey = in.readString();
                config.dppNetAccessKeyExpiry = in.readInt();
                config.dppCsign = in.readString();
","[1.0, 1.0]"
481,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/Nat464Xlat.java,"[(98, 106, 9), (98, 106, 9)]","        // Only support clat on mobile and wifi for now, because these are the only IPv6-only
        // networks we can connect to.
        boolean doXlat = SystemProperties.getBoolean(""persist.vendor.net.doxlat"", true);
        if(!doXlat) {
            Slog.i(TAG, ""Android Xlat is disabled"");
        }
        return supported && connected && !hasIPv4Address
               && ArrayUtils.contains(NETWORK_TYPES, netType)
               && ((netType == ConnectivityManager.TYPE_MOBILE) ? doXlat : true);
","        // Only support clat on mobile and wifi for now, because these are the only IPv6-only
        // networks we can connect to.
        boolean doXlat = SystemProperties.getBoolean(""persist.vendor.net.doxlat"", true);
        if(!doXlat) {
            Slog.i(TAG, ""Android Xlat is disabled"");
        }
        return supported && connected && !hasIPv4Address
               && ArrayUtils.contains(NETWORK_TYPES, netType)
               && ((netType == ConnectivityManager.TYPE_MOBILE) ? doXlat : true);
","        // Only support clat on mobile and wifi for now, because these are the only IPv6-only
        // networks we can connect to.
        boolean doXlat = SystemProperties.getBoolean(""persist.vendor.net.doxlat"", true);
        if(!doXlat) {
            Slog.i(TAG, ""Android Xlat is disabled"");
        }
        return supported && connected && !hasIPv4Address
               && ArrayUtils.contains(NETWORK_TYPES, netType)
               && ((netType == ConnectivityManager.TYPE_MOBILE) ? doXlat : true);
","[1.0, 1.0]"
482,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(46, 48, 3), (54, 56, 3)]","import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
import com.android.settingslib.graph.SignalDrawable;
","import com.android.internal.telephony.TelephonyIntents;
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","[0.69, 0.678]"
483,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(593, 656, 64), (570, 633, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
484,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(593, 656, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
485,"['b76115be4efabffaa6febc57cec47acc2f933c79', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActiveServices.java,"[(2273, 2282, 10), (2541, 2550, 10)]","                + r.shortName + "" in "" + r.restartDelay + ""ms"");

        if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
            for (int i=mRestartingServices.size()-1; i>=0; i--) {
                ServiceRecord r2 = mRestartingServices.get(i);
                Slog.w(TAG,""Restarting list - i ""+i+"" r2.nextRestartTime ""
                           +r2.nextRestartTime+"" r2.name ""+r2.name);
            }
        }

","                + r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");

        if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
            for (int i=mRestartingServices.size()-1; i>=0; i--) {
                ServiceRecord r2 = mRestartingServices.get(i);
                Slog.w(TAG,""Restarting list - i ""+i+"" r2.nextRestartTime ""
                           +r2.nextRestartTime+"" r2.name ""+r2.name);
            }
        }

","Name + "" in "" + r.restartDelay + ""ms"");

        if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
            for (int i=mRestartingServices.size()-1; i>=0; i--) {
                ServiceRecord r2 = mRestartingServices.get(i);
                Slog.w(TAG,""Restarting list - i ""+i+"" r2.nextRestartTime ""
                           +r2.nextRestartTime+"" r2.name ""+r2.name);
            }
        }

","[0.941, 0.923]"
486,"['ba167de93776a7e5d1b347d1ee646e161cf24ce5', 'ba167de93776a7e5d1b347d1ee646e161cf24ce5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(426, 426, 1), (426, 426, 1)]","    private static final int EVENT_UPDATE_TCP_BUFFER_FOR_5G = 160;
","    private static final int EVENT_UPDATE_TCP_BUFFER_FOR_5G = 160;
","    private static final int EVENT_UPDATE_TCP_BUFFER_FOR_5G = 160;
","[1.0, 1.0]"
487,"['ba167de93776a7e5d1b347d1ee646e161cf24ce5', 'ba167de93776a7e5d1b347d1ee646e161cf24ce5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(3206, 3207, 2), (3206, 3207, 2)]","                case EVENT_UPDATE_TCP_BUFFER_FOR_5G:
                    handleUpdateTCPBuffersfor5G();
","                case EVENT_UPDATE_TCP_BUFFER_FOR_5G:
                    handleUpdateTCPBuffersfor5G();
","                case EVENT_UPDATE_TCP_BUFFER_FOR_5G:
                    handleUpdateTCPBuffersfor5G();
","[1.0, 1.0]"
488,"['ba167de93776a7e5d1b347d1ee646e161cf24ce5', 'ba167de93776a7e5d1b347d1ee646e161cf24ce5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(602, 603, 2), (602, 603, 2)]","                                ""watchdog"", null, ""system_server"", null, null,
                                subject, null, finalStack, null);
","                                ""watchdog"", null, ""system_server"", null, null,
                                subject, null, finalStack, null);
","                                ""watchdog"", null, ""system_server"", null, null,
                                subject, null, finalStack, null);
","[1.0, 1.0]"
489,"['ba167de93776a7e5d1b347d1ee646e161cf24ce5', 'ba167de93776a7e5d1b347d1ee646e161cf24ce5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(1461, 1464, 4), (1461, 1464, 4)]","    static ServiceThread sKillThread = null;
    static KillHandler sKillHandler = null;
    static final ActivityTrigger mActivityTrigger = new ActivityTrigger();

","    static ServiceThread sKillThread = null;
    static KillHandler sKillHandler = null;
    static final ActivityTrigger mActivityTrigger = new ActivityTrigger();

","    static ServiceThread sKillThread = null;
    static KillHandler sKillHandler = null;
    static final ActivityTrigger mActivityTrigger = new ActivityTrigger();

","[1.0, 1.0]"
490,"['ba167de93776a7e5d1b347d1ee646e161cf24ce5', 'ba167de93776a7e5d1b347d1ee646e161cf24ce5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(3302, 3729, 428), (3302, 3729, 428)]","    @GuardedBy(""this"")
    private final void startProcessLocked(ProcessRecord app,
            String hostingType, String hostingNameStr) {
        startProcessLocked(app, hostingType, hostingNameStr, null /* abiOverride */);
    }

    @GuardedBy(""this"")
    private final boolean startProcessLocked(ProcessRecord app,
            String hostingType, String hostingNameStr, String abiOverride) {
        return startProcessLocked(app, hostingType, hostingNameStr,
                false /* disableHiddenApiChecks */, abiOverride);
    }

    /**
     * @return {@code true} if process start is successful, false otherwise.
     */
    @GuardedBy(""this"")
    private final boolean startProcessLocked(ProcessRecord app, String hostingType,
            String hostingNameStr, boolean disableHiddenApiChecks, String abiOverride) {
        if (app.pendingStart) {
            return true;
        }
        long startTime = SystemClock.elapsedRealtime();
        if (app.pid > 0 && app.pid != MY_PID) {
            checkTime(startTime, ""startProcess: removing from pids map"");
            synchronized (mPidsSelfLocked) {
                mPidsSelfLocked.remove(app.pid);
                mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
            }
            checkTime(startTime, ""startProcess: done removing from pids map"");
            app.setPid(0);
        }

        if (DEBUG_PROCESSES && mProcessesOnHold.contains(app)) Slog.v(TAG_PROCESSES,
                ""startProcessLocked removing on hold: "" + app);
        mProcessesOnHold.remove(app);

        checkTime(startTime, ""startProcess: starting to update cpu stats"");
        updateCpuStats();
        checkTime(startTime, ""startProcess: done updating cpu stats"");

        try {
            try {
                final int userId = UserHandle.getUserId(app.uid);
                AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }

            int uid = app.uid;
            int[] gids = null;
            int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
            if (!app.isolated) {
                int[] permGids = null;
                try {
                    checkTime(startTime, ""startProcess: getting gids from package manager"");
                    final IPackageManager pm = AppGlobals.getPackageManager();
                    permGids = pm.getPackageGids(app.info.packageName,
                            MATCH_DEBUG_TRIAGED_MISSING, app.userId);
                    StorageManagerInternal storageManagerInternal = LocalServices.getService(
                            StorageManagerInternal.class);
                    mountExternal = storageManagerInternal.getExternalStorageMountMode(uid,
                            app.info.packageName);
                } catch (RemoteException e) {
                    throw e.rethrowAsRuntimeException();
                }

                /*
                 * Add shared application and profile GIDs so applications can share some
                 * resources like shared libraries and access user-wide resources
                 */
                if (ArrayUtils.isEmpty(permGids)) {
                    gids = new int[3];
                } else {
                    gids = new int[permGids.length + 3];
                    System.arraycopy(permGids, 0, gids, 3, permGids.length);
                }
                gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
                gids[1] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid));
                gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid));

                // Replace any invalid GIDs
                if (gids[0] == UserHandle.ERR_GID) gids[0] = gids[2];
                if (gids[1] == UserHandle.ERR_GID) gids[1] = gids[2];
            }
            checkTime(startTime, ""startProcess: building args"");
            if (mAtmInternal.isFactoryTestProcess(app.getWindowProcessController())) {
                uid = 0;
            }
            int runtimeFlags = 0;
            if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_JDWP;
                runtimeFlags |= Zygote.DEBUG_JAVA_DEBUGGABLE;
                // Also turn on CheckJNI for debuggable apps. It's quite
                // awkward to turn on otherwise.
                runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
            }
            // Run the app in safe mode if its manifest requests so or the
            // system is booted in safe mode.
            if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 ||
                mSafeMode == true) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
            }
            if (""1"".equals(SystemProperties.get(""debug.checkjni""))) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
            }
            String genDebugInfoProperty = SystemProperties.get(""debug.generate-debug-info"");
            if (""1"".equals(genDebugInfoProperty) || ""true"".equals(genDebugInfoProperty)) {
                runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
            }
            String genMiniDebugInfoProperty = SystemProperties.get(""dalvik.vm.minidebuginfo"");
            if (""1"".equals(genMiniDebugInfoProperty) || ""true"".equals(genMiniDebugInfoProperty)) {
                runtimeFlags |= Zygote.DEBUG_GENERATE_MINI_DEBUG_INFO;
            }
            if (""1"".equals(SystemProperties.get(""debug.jni.logging""))) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
            }
            if (""1"".equals(SystemProperties.get(""debug.assert""))) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_ASSERT;
            }
            if (mNativeDebuggingApp != null && mNativeDebuggingApp.equals(app.processName)) {
                // Enable all debug flags required by the native debugger.
                runtimeFlags |= Zygote.DEBUG_ALWAYS_JIT;          // Don't interpret anything
                runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO; // Generate debug info
                runtimeFlags |= Zygote.DEBUG_NATIVE_DEBUGGABLE;   // Disbale optimizations
                mNativeDebuggingApp = null;
            }

            if (app.info.isPrivilegedApp() &&
                    DexManager.isPackageSelectedToRunOob(app.pkgList.mPkgList.keySet())) {
                runtimeFlags |= Zygote.ONLY_USE_SYSTEM_OAT_FILES;
            }

            if (!disableHiddenApiChecks && !mHiddenApiBlacklist.isDisabled()) {
                app.info.maybeUpdateHiddenApiEnforcementPolicy(
                        mHiddenApiBlacklist.getPolicyForPrePApps(),
                        mHiddenApiBlacklist.getPolicyForPApps());
                @HiddenApiEnforcementPolicy int policy =
                        app.info.getHiddenApiEnforcementPolicy();
                int policyBits = (policy << Zygote.API_ENFORCEMENT_POLICY_SHIFT);
                if ((policyBits & Zygote.API_ENFORCEMENT_POLICY_MASK) != policyBits) {
                    throw new IllegalStateException(""Invalid API policy: "" + policy);
                }
                runtimeFlags |= policyBits;
            }

            String invokeWith = null;
            if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
                // Debuggable apps may include a wrapper script with their library directory.
                String wrapperFileName = app.info.nativeLibraryDir + ""/wrap.sh"";
                StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
                try {
                    if (new File(wrapperFileName).exists()) {
                        invokeWith = ""/system/bin/logwrapper "" + wrapperFileName;
                    }
                } finally {
                    StrictMode.setThreadPolicy(oldPolicy);
                }
            }

            String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi;
            if (requiredAbi == null) {
                requiredAbi = Build.SUPPORTED_ABIS[0];
            }

            String instructionSet = null;
            if (app.info.primaryCpuAbi != null) {
                instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
            }

            app.gids = gids;
            app.setRequiredAbi(requiredAbi);
            app.instructionSet = instructionSet;

            // the per-user SELinux context must be set
            if (TextUtils.isEmpty(app.info.seInfoUser)) {
                Slog.wtf(TAG, ""SELinux tag not defined"",
                        new IllegalStateException(""SELinux tag not defined for ""
                        + app.info.packageName + "" (uid "" + app.uid + "")""));
            }
            final String seInfo = app.info.seInfo
                    + (TextUtils.isEmpty(app.info.seInfoUser) ? """" : app.info.seInfoUser);
            // Start the process.  It will either succeed and return a result containing
            // the PID of the new process, or else throw a RuntimeException.
            final String entryPoint = ""android.app.ActivityThread"";

            return startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids,
                    runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,
                    startTime);
        } catch (RuntimeException e) {
            Slog.e(TAG, ""Failure starting process "" + app.processName, e);

            // Something went very wrong while trying to start this process; one
            // common case is when the package is frozen due to an active
            // upgrade. To recover, clean up any active bookkeeping related to
            // starting this process. (We already invoked this method once when
            // the package was initially frozen through KILL_APPLICATION_MSG, so
            // it doesn't hurt to use it again.)
            forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false,
                    false, true, false, false, app.userId, ""start failure"");
            return false;
        }
    }

    @GuardedBy(""this"")
    private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint,
            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,
            String seInfo, String requiredAbi, String instructionSet, String invokeWith,
            long startTime) {
        app.pendingStart = true;
        app.killedByAm = false;
        app.removed = false;
        app.killed = false;
        final long startSeq = app.startSeq = ++mProcStartSeqCounter;
        app.setStartParams(uid, hostingType, hostingNameStr, seInfo, startTime);
        if (mConstants.FLAG_PROCESS_START_ASYNC) {
            if (DEBUG_PROCESSES) Slog.i(TAG_PROCESSES,
                    ""Posting procStart msg for "" + app.toShortString());
            mProcStartHandler.post(() -> {
                try {
                    synchronized (ActivityManagerService.this) {
                        final String reason = isProcStartValidLocked(app, startSeq);
                        if (reason != null) {
                            Slog.w(TAG_PROCESSES, app + "" not valid anymore,""
                                    + "" don't start process, "" + reason);
                            app.pendingStart = false;
                            return;
                        }
                        app.setUsingWrapper(invokeWith != null
                                || SystemProperties.get(""wrap."" + app.processName) != null);
                        mPendingStarts.put(startSeq, app);
                    }
                    final ProcessStartResult startResult = startProcess(app.hostingType, entryPoint,
                            app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo,
                            requiredAbi, instructionSet, invokeWith, app.startTime);
                    synchronized (ActivityManagerService.this) {
                        handleProcessStartedLocked(app, startResult, startSeq);
                    }
                } catch (RuntimeException e) {
                    synchronized (ActivityManagerService.this) {
                        Slog.e(TAG, ""Failure starting process "" + app.processName, e);
                        mPendingStarts.remove(startSeq);
                        app.pendingStart = false;
                        forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),
                                false, false, true, false, false, app.userId, ""start failure"");
                    }
                }
            });
            return true;
        } else {
            try {
                final ProcessStartResult startResult = startProcess(hostingType, entryPoint, app,
                        uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,
                        invokeWith, startTime);
                handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,
                        startSeq, false);
            } catch (RuntimeException e) {
                Slog.e(TAG, ""Failure starting process "" + app.processName, e);
                app.pendingStart = false;
                forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),
                        false, false, true, false, false, app.userId, ""start failure"");
            }
            return app.pid > 0;
        }
    }

    private ProcessStartResult startProcess(String hostingType, String entryPoint,
            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,
            String seInfo, String requiredAbi, String instructionSet, String invokeWith,
            long startTime) {
        try {
            final String[] packageNames = mContext.getPackageManager().getPackagesForUid(uid);
            final String[] visibleVolIds = LocalServices.getService(StorageManagerInternal.class)
                    .getVisibleVolumesForUser(UserHandle.getUserId(uid));
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""Start proc: "" +
                    app.processName);
            checkTime(startTime, ""startProcess: asking zygote to start proc"");
            final ProcessStartResult startResult;
            if (hostingType.equals(""webview_service"")) {
                startResult = startWebView(entryPoint,
                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, null, app.info.packageName,
                        packageNames, visibleVolIds,
                        new String[] {PROC_START_SEQ_IDENT + app.startSeq});
            }
            else {
                startResult = Process.start(entryPoint,
                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, invokeWith, app.info.packageName,
                        packageNames, visibleVolIds,
                        new String[] {PROC_START_SEQ_IDENT + app.startSeq});
            }

            if (mPerfServiceStartHint == null) {
                mPerfServiceStartHint = new BoostFramework();
            }
            if (mPerfServiceStartHint != null) {
                mPerfServiceStartHint.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST, app.processName, -1, BoostFramework.Launch.TYPE_SERVICE_START);
            }

            checkTime(startTime, ""startProcess: returned from zygote!"");
            return startResult;
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        }
    }

    @GuardedBy(""this"")
    private String isProcStartValidLocked(ProcessRecord app, long expectedStartSeq) {
        StringBuilder sb = null;
        if (app.killedByAm) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""killedByAm=true;"");
        }
        if (mProcessNames.get(app.processName, app.uid) != app) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""No entry in mProcessNames;"");
        }
        if (!app.pendingStart) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""pendingStart=false;"");
        }
        if (app.startSeq > expectedStartSeq) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""seq="" + app.startSeq + "",expected="" + expectedStartSeq + "";"");
        }
        return sb == null ? null : sb.toString();
    }

    @GuardedBy(""this"")
    private boolean handleProcessStartedLocked(ProcessRecord pending,
            ProcessStartResult startResult, long expectedStartSeq) {
        // Indicates that this process start has been taken care of.
        if (mPendingStarts.get(expectedStartSeq) == null) {
            if (pending.pid == startResult.pid) {
                pending.setUsingWrapper(startResult.usingWrapper);
                // TODO: Update already existing clients of usingWrapper
            }
            return false;
        }
        return handleProcessStartedLocked(pending, startResult.pid, startResult.usingWrapper,
                expectedStartSeq, false);
    }

    @GuardedBy(""this"")
    private boolean handleProcessStartedLocked(ProcessRecord app, int pid, boolean usingWrapper,
            long expectedStartSeq, boolean procAttached) {
        mPendingStarts.remove(expectedStartSeq);
        final String reason = isProcStartValidLocked(app, expectedStartSeq);
        if (reason != null) {
            Slog.w(TAG_PROCESSES, app + "" start not valid, killing pid="" + pid
                    + "", "" + reason);
            app.pendingStart = false;
            Process.killProcessQuiet(pid);
            Process.killProcessGroup(app.uid, app.pid);
            return false;
        }
        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        checkTime(app.startTime, ""startProcess: done updating battery stats"");

        EventLog.writeEvent(EventLogTags.AM_PROC_START,
                UserHandle.getUserId(app.startUid), pid, app.startUid,
                app.processName, app.hostingType,
                app.hostingNameStr != null ? app.hostingNameStr : """");

        try {
            AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid,
                    app.seInfo, app.info.sourceDir, pid);
        } catch (RemoteException ex) {
            // Ignore
        }

        if (app.isPersistent()) {
            Watchdog.getInstance().processStarted(app.processName, pid);
        }

        checkTime(app.startTime, ""startProcess: building log message"");
        StringBuilder buf = mStringBuilder;
        buf.setLength(0);
        buf.append(""Start proc "");
        buf.append(pid);
        buf.append(':');
        buf.append(app.processName);
        buf.append('/');
        UserHandle.formatUid(buf, app.startUid);
        if (app.isolatedEntryPoint != null) {
            buf.append("" ["");
            buf.append(app.isolatedEntryPoint);
            buf.append(""]"");
        }
        buf.append("" for "");
        buf.append(app.hostingType);
        if (app.hostingNameStr != null) {
            buf.append("" "");
            buf.append(app.hostingNameStr);
        }
        reportUidInfoMessageLocked(TAG, buf.toString(), app.startUid);
        app.setPid(pid);
        app.setUsingWrapper(usingWrapper);
        app.pendingStart = false;
        checkTime(app.startTime, ""startProcess: starting to update pids map"");
        ProcessRecord oldApp;
        synchronized (mPidsSelfLocked) {
            oldApp = mPidsSelfLocked.get(pid);
        }
        // If there is already an app occupying that pid that hasn't been cleaned up
        if (oldApp != null && !app.isolated) {
            // Clean up anything relating to this pid first
            Slog.w(TAG, ""Reusing pid "" + pid
                    + "" while app is still mapped to it"");
            cleanUpApplicationRecordLocked(oldApp, false, false, -1,
                    true /*replacingPid*/);
        }
        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(pid, app);
            if (!procAttached) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, usingWrapper
                        ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
        checkTime(app.startTime, ""startProcess: done updating pids map"");
        return true;
    }

","    @GuardedBy(""this"")
    private final void startProcessLocked(ProcessRecord app,
            String hostingType, String hostingNameStr) {
        startProcessLocked(app, hostingType, hostingNameStr, null /* abiOverride */);
    }

    @GuardedBy(""this"")
    private final boolean startProcessLocked(ProcessRecord app,
            String hostingType, String hostingNameStr, String abiOverride) {
        return startProcessLocked(app, hostingType, hostingNameStr,
                false /* disableHiddenApiChecks */, abiOverride);
    }

    /**
     * @return {@code true} if process start is successful, false otherwise.
     */
    @GuardedBy(""this"")
    private final boolean startProcessLocked(ProcessRecord app, String hostingType,
            String hostingNameStr, boolean disableHiddenApiChecks, String abiOverride) {
        if (app.pendingStart) {
            return true;
        }
        long startTime = SystemClock.elapsedRealtime();
        if (app.pid > 0 && app.pid != MY_PID) {
            checkTime(startTime, ""startProcess: removing from pids map"");
            synchronized (mPidsSelfLocked) {
                mPidsSelfLocked.remove(app.pid);
                mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
            }
            checkTime(startTime, ""startProcess: done removing from pids map"");
            app.setPid(0);
        }

        if (DEBUG_PROCESSES && mProcessesOnHold.contains(app)) Slog.v(TAG_PROCESSES,
                ""startProcessLocked removing on hold: "" + app);
        mProcessesOnHold.remove(app);

        checkTime(startTime, ""startProcess: starting to update cpu stats"");
        updateCpuStats();
        checkTime(startTime, ""startProcess: done updating cpu stats"");

        try {
            try {
                final int userId = UserHandle.getUserId(app.uid);
                AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }

            int uid = app.uid;
            int[] gids = null;
            int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
            if (!app.isolated) {
                int[] permGids = null;
                try {
                    checkTime(startTime, ""startProcess: getting gids from package manager"");
                    final IPackageManager pm = AppGlobals.getPackageManager();
                    permGids = pm.getPackageGids(app.info.packageName,
                            MATCH_DEBUG_TRIAGED_MISSING, app.userId);
                    StorageManagerInternal storageManagerInternal = LocalServices.getService(
                            StorageManagerInternal.class);
                    mountExternal = storageManagerInternal.getExternalStorageMountMode(uid,
                            app.info.packageName);
                } catch (RemoteException e) {
                    throw e.rethrowAsRuntimeException();
                }

                /*
                 * Add shared application and profile GIDs so applications can share some
                 * resources like shared libraries and access user-wide resources
                 */
                if (ArrayUtils.isEmpty(permGids)) {
                    gids = new int[3];
                } else {
                    gids = new int[permGids.length + 3];
                    System.arraycopy(permGids, 0, gids, 3, permGids.length);
                }
                gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
                gids[1] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid));
                gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid));

                // Replace any invalid GIDs
                if (gids[0] == UserHandle.ERR_GID) gids[0] = gids[2];
                if (gids[1] == UserHandle.ERR_GID) gids[1] = gids[2];
            }
            checkTime(startTime, ""startProcess: building args"");
            if (mAtmInternal.isFactoryTestProcess(app.getWindowProcessController())) {
                uid = 0;
            }
            int runtimeFlags = 0;
            if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_JDWP;
                runtimeFlags |= Zygote.DEBUG_JAVA_DEBUGGABLE;
                // Also turn on CheckJNI for debuggable apps. It's quite
                // awkward to turn on otherwise.
                runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
            }
            // Run the app in safe mode if its manifest requests so or the
            // system is booted in safe mode.
            if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 ||
                mSafeMode == true) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
            }
            if (""1"".equals(SystemProperties.get(""debug.checkjni""))) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
            }
            String genDebugInfoProperty = SystemProperties.get(""debug.generate-debug-info"");
            if (""1"".equals(genDebugInfoProperty) || ""true"".equals(genDebugInfoProperty)) {
                runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
            }
            String genMiniDebugInfoProperty = SystemProperties.get(""dalvik.vm.minidebuginfo"");
            if (""1"".equals(genMiniDebugInfoProperty) || ""true"".equals(genMiniDebugInfoProperty)) {
                runtimeFlags |= Zygote.DEBUG_GENERATE_MINI_DEBUG_INFO;
            }
            if (""1"".equals(SystemProperties.get(""debug.jni.logging""))) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
            }
            if (""1"".equals(SystemProperties.get(""debug.assert""))) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_ASSERT;
            }
            if (mNativeDebuggingApp != null && mNativeDebuggingApp.equals(app.processName)) {
                // Enable all debug flags required by the native debugger.
                runtimeFlags |= Zygote.DEBUG_ALWAYS_JIT;          // Don't interpret anything
                runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO; // Generate debug info
                runtimeFlags |= Zygote.DEBUG_NATIVE_DEBUGGABLE;   // Disbale optimizations
                mNativeDebuggingApp = null;
            }

            if (app.info.isPrivilegedApp() &&
                    DexManager.isPackageSelectedToRunOob(app.pkgList.mPkgList.keySet())) {
                runtimeFlags |= Zygote.ONLY_USE_SYSTEM_OAT_FILES;
            }

            if (!disableHiddenApiChecks && !mHiddenApiBlacklist.isDisabled()) {
                app.info.maybeUpdateHiddenApiEnforcementPolicy(
                        mHiddenApiBlacklist.getPolicyForPrePApps(),
                        mHiddenApiBlacklist.getPolicyForPApps());
                @HiddenApiEnforcementPolicy int policy =
                        app.info.getHiddenApiEnforcementPolicy();
                int policyBits = (policy << Zygote.API_ENFORCEMENT_POLICY_SHIFT);
                if ((policyBits & Zygote.API_ENFORCEMENT_POLICY_MASK) != policyBits) {
                    throw new IllegalStateException(""Invalid API policy: "" + policy);
                }
                runtimeFlags |= policyBits;
            }

            String invokeWith = null;
            if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
                // Debuggable apps may include a wrapper script with their library directory.
                String wrapperFileName = app.info.nativeLibraryDir + ""/wrap.sh"";
                StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
                try {
                    if (new File(wrapperFileName).exists()) {
                        invokeWith = ""/system/bin/logwrapper "" + wrapperFileName;
                    }
                } finally {
                    StrictMode.setThreadPolicy(oldPolicy);
                }
            }

            String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi;
            if (requiredAbi == null) {
                requiredAbi = Build.SUPPORTED_ABIS[0];
            }

            String instructionSet = null;
            if (app.info.primaryCpuAbi != null) {
                instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
            }

            app.gids = gids;
            app.setRequiredAbi(requiredAbi);
            app.instructionSet = instructionSet;

            // the per-user SELinux context must be set
            if (TextUtils.isEmpty(app.info.seInfoUser)) {
                Slog.wtf(TAG, ""SELinux tag not defined"",
                        new IllegalStateException(""SELinux tag not defined for ""
                        + app.info.packageName + "" (uid "" + app.uid + "")""));
            }
            final String seInfo = app.info.seInfo
                    + (TextUtils.isEmpty(app.info.seInfoUser) ? """" : app.info.seInfoUser);
            // Start the process.  It will either succeed and return a result containing
            // the PID of the new process, or else throw a RuntimeException.
            final String entryPoint = ""android.app.ActivityThread"";

            return startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids,
                    runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,
                    startTime);
        } catch (RuntimeException e) {
            Slog.e(TAG, ""Failure starting process "" + app.processName, e);

            // Something went very wrong while trying to start this process; one
            // common case is when the package is frozen due to an active
            // upgrade. To recover, clean up any active bookkeeping related to
            // starting this process. (We already invoked this method once when
            // the package was initially frozen through KILL_APPLICATION_MSG, so
            // it doesn't hurt to use it again.)
            forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false,
                    false, true, false, false, app.userId, ""start failure"");
            return false;
        }
    }

    @GuardedBy(""this"")
    private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint,
            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,
            String seInfo, String requiredAbi, String instructionSet, String invokeWith,
            long startTime) {
        app.pendingStart = true;
        app.killedByAm = false;
        app.removed = false;
        app.killed = false;
        final long startSeq = app.startSeq = ++mProcStartSeqCounter;
        app.setStartParams(uid, hostingType, hostingNameStr, seInfo, startTime);
        if (mConstants.FLAG_PROCESS_START_ASYNC) {
            if (DEBUG_PROCESSES) Slog.i(TAG_PROCESSES,
                    ""Posting procStart msg for "" + app.toShortString());
            mProcStartHandler.post(() -> {
                try {
                    synchronized (ActivityManagerService.this) {
                        final String reason = isProcStartValidLocked(app, startSeq);
                        if (reason != null) {
                            Slog.w(TAG_PROCESSES, app + "" not valid anymore,""
                                    + "" don't start process, "" + reason);
                            app.pendingStart = false;
                            return;
                        }
                        app.setUsingWrapper(invokeWith != null
                                || SystemProperties.get(""wrap."" + app.processName) != null);
                        mPendingStarts.put(startSeq, app);
                    }
                    final ProcessStartResult startResult = startProcess(app.hostingType, entryPoint,
                            app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo,
                            requiredAbi, instructionSet, invokeWith, app.startTime);
                    synchronized (ActivityManagerService.this) {
                        handleProcessStartedLocked(app, startResult, startSeq);
                    }
                } catch (RuntimeException e) {
                    synchronized (ActivityManagerService.this) {
                        Slog.e(TAG, ""Failure starting process "" + app.processName, e);
                        mPendingStarts.remove(startSeq);
                        app.pendingStart = false;
                        forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),
                                false, false, true, false, false, app.userId, ""start failure"");
                    }
                }
            });
            return true;
        } else {
            try {
                final ProcessStartResult startResult = startProcess(hostingType, entryPoint, app,
                        uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,
                        invokeWith, startTime);
                handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,
                        startSeq, false);
            } catch (RuntimeException e) {
                Slog.e(TAG, ""Failure starting process "" + app.processName, e);
                app.pendingStart = false;
                forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),
                        false, false, true, false, false, app.userId, ""start failure"");
            }
            return app.pid > 0;
        }
    }

    private ProcessStartResult startProcess(String hostingType, String entryPoint,
            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,
            String seInfo, String requiredAbi, String instructionSet, String invokeWith,
            long startTime) {
        try {
            final String[] packageNames = mContext.getPackageManager().getPackagesForUid(uid);
            final String[] visibleVolIds = LocalServices.getService(StorageManagerInternal.class)
                    .getVisibleVolumesForUser(UserHandle.getUserId(uid));
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""Start proc: "" +
                    app.processName);
            checkTime(startTime, ""startProcess: asking zygote to start proc"");
            final ProcessStartResult startResult;
            if (hostingType.equals(""webview_service"")) {
                startResult = startWebView(entryPoint,
                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, null, app.info.packageName,
                        packageNames, visibleVolIds,
                        new String[] {PROC_START_SEQ_IDENT + app.startSeq});
            }
            else {
                startResult = Process.start(entryPoint,
                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, invokeWith, app.info.packageName,
                        packageNames, visibleVolIds,
                        new String[] {PROC_START_SEQ_IDENT + app.startSeq});
            }

            if (mPerfServiceStartHint == null) {
                mPerfServiceStartHint = new BoostFramework();
            }
            if (mPerfServiceStartHint != null) {
                mPerfServiceStartHint.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST, app.processName, -1, BoostFramework.Launch.TYPE_SERVICE_START);
            }

            checkTime(startTime, ""startProcess: returned from zygote!"");
            return startResult;
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        }
    }

    @GuardedBy(""this"")
    private String isProcStartValidLocked(ProcessRecord app, long expectedStartSeq) {
        StringBuilder sb = null;
        if (app.killedByAm) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""killedByAm=true;"");
        }
        if (mProcessNames.get(app.processName, app.uid) != app) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""No entry in mProcessNames;"");
        }
        if (!app.pendingStart) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""pendingStart=false;"");
        }
        if (app.startSeq > expectedStartSeq) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""seq="" + app.startSeq + "",expected="" + expectedStartSeq + "";"");
        }
        return sb == null ? null : sb.toString();
    }

    @GuardedBy(""this"")
    private boolean handleProcessStartedLocked(ProcessRecord pending,
            ProcessStartResult startResult, long expectedStartSeq) {
        // Indicates that this process start has been taken care of.
        if (mPendingStarts.get(expectedStartSeq) == null) {
            if (pending.pid == startResult.pid) {
                pending.setUsingWrapper(startResult.usingWrapper);
                // TODO: Update already existing clients of usingWrapper
            }
            return false;
        }
        return handleProcessStartedLocked(pending, startResult.pid, startResult.usingWrapper,
                expectedStartSeq, false);
    }

    @GuardedBy(""this"")
    private boolean handleProcessStartedLocked(ProcessRecord app, int pid, boolean usingWrapper,
            long expectedStartSeq, boolean procAttached) {
        mPendingStarts.remove(expectedStartSeq);
        final String reason = isProcStartValidLocked(app, expectedStartSeq);
        if (reason != null) {
            Slog.w(TAG_PROCESSES, app + "" start not valid, killing pid="" + pid
                    + "", "" + reason);
            app.pendingStart = false;
            Process.killProcessQuiet(pid);
            Process.killProcessGroup(app.uid, app.pid);
            return false;
        }
        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        checkTime(app.startTime, ""startProcess: done updating battery stats"");

        EventLog.writeEvent(EventLogTags.AM_PROC_START,
                UserHandle.getUserId(app.startUid), pid, app.startUid,
                app.processName, app.hostingType,
                app.hostingNameStr != null ? app.hostingNameStr : """");

        try {
            AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid,
                    app.seInfo, app.info.sourceDir, pid);
        } catch (RemoteException ex) {
            // Ignore
        }

        if (app.isPersistent()) {
            Watchdog.getInstance().processStarted(app.processName, pid);
        }

        checkTime(app.startTime, ""startProcess: building log message"");
        StringBuilder buf = mStringBuilder;
        buf.setLength(0);
        buf.append(""Start proc "");
        buf.append(pid);
        buf.append(':');
        buf.append(app.processName);
        buf.append('/');
        UserHandle.formatUid(buf, app.startUid);
        if (app.isolatedEntryPoint != null) {
            buf.append("" ["");
            buf.append(app.isolatedEntryPoint);
            buf.append(""]"");
        }
        buf.append("" for "");
        buf.append(app.hostingType);
        if (app.hostingNameStr != null) {
            buf.append("" "");
            buf.append(app.hostingNameStr);
        }
        reportUidInfoMessageLocked(TAG, buf.toString(), app.startUid);
        app.setPid(pid);
        app.setUsingWrapper(usingWrapper);
        app.pendingStart = false;
        checkTime(app.startTime, ""startProcess: starting to update pids map"");
        ProcessRecord oldApp;
        synchronized (mPidsSelfLocked) {
            oldApp = mPidsSelfLocked.get(pid);
        }
        // If there is already an app occupying that pid that hasn't been cleaned up
        if (oldApp != null && !app.isolated) {
            // Clean up anything relating to this pid first
            Slog.w(TAG, ""Reusing pid "" + pid
                    + "" while app is still mapped to it"");
            cleanUpApplicationRecordLocked(oldApp, false, false, -1,
                    true /*replacingPid*/);
        }
        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(pid, app);
            if (!procAttached) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, usingWrapper
                        ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
        checkTime(app.startTime, ""startProcess: done updating pids map"");
        return true;
    }

","    @GuardedBy(""this"")
    private final void startProcessLocked(ProcessRecord app,
            String hostingType, String hostingNameStr) {
        startProcessLocked(app, hostingType, hostingNameStr, null /* abiOverride */);
    }

    @GuardedBy(""this"")
    private final boolean startProcessLocked(ProcessRecord app,
            String hostingType, String hostingNameStr, String abiOverride) {
        return startProcessLocked(app, hostingType, hostingNameStr,
                false /* disableHiddenApiChecks */, abiOverride);
    }

    /**
     * @return {@code true} if process start is successful, false otherwise.
     */
    @GuardedBy(""this"")
    private final boolean startProcessLocked(ProcessRecord app, String hostingType,
            String hostingNameStr, boolean disableHiddenApiChecks, String abiOverride) {
        if (app.pendingStart) {
            return true;
        }
        long startTime = SystemClock.elapsedRealtime();
        if (app.pid > 0 && app.pid != MY_PID) {
            checkTime(startTime, ""startProcess: removing from pids map"");
            synchronized (mPidsSelfLocked) {
                mPidsSelfLocked.remove(app.pid);
                mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
            }
            checkTime(startTime, ""startProcess: done removing from pids map"");
            app.setPid(0);
        }

        if (DEBUG_PROCESSES && mProcessesOnHold.contains(app)) Slog.v(TAG_PROCESSES,
                ""startProcessLocked removing on hold: "" + app);
        mProcessesOnHold.remove(app);

        checkTime(startTime, ""startProcess: starting to update cpu stats"");
        updateCpuStats();
        checkTime(startTime, ""startProcess: done updating cpu stats"");

        try {
            try {
                final int userId = UserHandle.getUserId(app.uid);
                AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }

            int uid = app.uid;
            int[] gids = null;
            int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
            if (!app.isolated) {
                int[] permGids = null;
                try {
                    checkTime(startTime, ""startProcess: getting gids from package manager"");
                    final IPackageManager pm = AppGlobals.getPackageManager();
                    permGids = pm.getPackageGids(app.info.packageName,
                            MATCH_DEBUG_TRIAGED_MISSING, app.userId);
                    StorageManagerInternal storageManagerInternal = LocalServices.getService(
                            StorageManagerInternal.class);
                    mountExternal = storageManagerInternal.getExternalStorageMountMode(uid,
                            app.info.packageName);
                } catch (RemoteException e) {
                    throw e.rethrowAsRuntimeException();
                }

                /*
                 * Add shared application and profile GIDs so applications can share some
                 * resources like shared libraries and access user-wide resources
                 */
                if (ArrayUtils.isEmpty(permGids)) {
                    gids = new int[3];
                } else {
                    gids = new int[permGids.length + 3];
                    System.arraycopy(permGids, 0, gids, 3, permGids.length);
                }
                gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
                gids[1] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid));
                gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid));

                // Replace any invalid GIDs
                if (gids[0] == UserHandle.ERR_GID) gids[0] = gids[2];
                if (gids[1] == UserHandle.ERR_GID) gids[1] = gids[2];
            }
            checkTime(startTime, ""startProcess: building args"");
            if (mAtmInternal.isFactoryTestProcess(app.getWindowProcessController())) {
                uid = 0;
            }
            int runtimeFlags = 0;
            if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_JDWP;
                runtimeFlags |= Zygote.DEBUG_JAVA_DEBUGGABLE;
                // Also turn on CheckJNI for debuggable apps. It's quite
                // awkward to turn on otherwise.
                runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
            }
            // Run the app in safe mode if its manifest requests so or the
            // system is booted in safe mode.
            if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 ||
                mSafeMode == true) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
            }
            if (""1"".equals(SystemProperties.get(""debug.checkjni""))) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
            }
            String genDebugInfoProperty = SystemProperties.get(""debug.generate-debug-info"");
            if (""1"".equals(genDebugInfoProperty) || ""true"".equals(genDebugInfoProperty)) {
                runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
            }
            String genMiniDebugInfoProperty = SystemProperties.get(""dalvik.vm.minidebuginfo"");
            if (""1"".equals(genMiniDebugInfoProperty) || ""true"".equals(genMiniDebugInfoProperty)) {
                runtimeFlags |= Zygote.DEBUG_GENERATE_MINI_DEBUG_INFO;
            }
            if (""1"".equals(SystemProperties.get(""debug.jni.logging""))) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
            }
            if (""1"".equals(SystemProperties.get(""debug.assert""))) {
                runtimeFlags |= Zygote.DEBUG_ENABLE_ASSERT;
            }
            if (mNativeDebuggingApp != null && mNativeDebuggingApp.equals(app.processName)) {
                // Enable all debug flags required by the native debugger.
                runtimeFlags |= Zygote.DEBUG_ALWAYS_JIT;          // Don't interpret anything
                runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO; // Generate debug info
                runtimeFlags |= Zygote.DEBUG_NATIVE_DEBUGGABLE;   // Disbale optimizations
                mNativeDebuggingApp = null;
            }

            if (app.info.isPrivilegedApp() &&
                    DexManager.isPackageSelectedToRunOob(app.pkgList.mPkgList.keySet())) {
                runtimeFlags |= Zygote.ONLY_USE_SYSTEM_OAT_FILES;
            }

            if (!disableHiddenApiChecks && !mHiddenApiBlacklist.isDisabled()) {
                app.info.maybeUpdateHiddenApiEnforcementPolicy(
                        mHiddenApiBlacklist.getPolicyForPrePApps(),
                        mHiddenApiBlacklist.getPolicyForPApps());
                @HiddenApiEnforcementPolicy int policy =
                        app.info.getHiddenApiEnforcementPolicy();
                int policyBits = (policy << Zygote.API_ENFORCEMENT_POLICY_SHIFT);
                if ((policyBits & Zygote.API_ENFORCEMENT_POLICY_MASK) != policyBits) {
                    throw new IllegalStateException(""Invalid API policy: "" + policy);
                }
                runtimeFlags |= policyBits;
            }

            String invokeWith = null;
            if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
                // Debuggable apps may include a wrapper script with their library directory.
                String wrapperFileName = app.info.nativeLibraryDir + ""/wrap.sh"";
                StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
                try {
                    if (new File(wrapperFileName).exists()) {
                        invokeWith = ""/system/bin/logwrapper "" + wrapperFileName;
                    }
                } finally {
                    StrictMode.setThreadPolicy(oldPolicy);
                }
            }

            String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi;
            if (requiredAbi == null) {
                requiredAbi = Build.SUPPORTED_ABIS[0];
            }

            String instructionSet = null;
            if (app.info.primaryCpuAbi != null) {
                instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
            }

            app.gids = gids;
            app.setRequiredAbi(requiredAbi);
            app.instructionSet = instructionSet;

            // the per-user SELinux context must be set
            if (TextUtils.isEmpty(app.info.seInfoUser)) {
                Slog.wtf(TAG, ""SELinux tag not defined"",
                        new IllegalStateException(""SELinux tag not defined for ""
                        + app.info.packageName + "" (uid "" + app.uid + "")""));
            }
            final String seInfo = app.info.seInfo
                    + (TextUtils.isEmpty(app.info.seInfoUser) ? """" : app.info.seInfoUser);
            // Start the process.  It will either succeed and return a result containing
            // the PID of the new process, or else throw a RuntimeException.
            final String entryPoint = ""android.app.ActivityThread"";

            return startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids,
                    runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,
                    startTime);
        } catch (RuntimeException e) {
            Slog.e(TAG, ""Failure starting process "" + app.processName, e);

            // Something went very wrong while trying to start this process; one
            // common case is when the package is frozen due to an active
            // upgrade. To recover, clean up any active bookkeeping related to
            // starting this process. (We already invoked this method once when
            // the package was initially frozen through KILL_APPLICATION_MSG, so
            // it doesn't hurt to use it again.)
            forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false,
                    false, true, false, false, app.userId, ""start failure"");
            return false;
        }
    }

    @GuardedBy(""this"")
    private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint,
            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,
            String seInfo, String requiredAbi, String instructionSet, String invokeWith,
            long startTime) {
        app.pendingStart = true;
        app.killedByAm = false;
        app.removed = false;
        app.killed = false;
        final long startSeq = app.startSeq = ++mProcStartSeqCounter;
        app.setStartParams(uid, hostingType, hostingNameStr, seInfo, startTime);
        if (mConstants.FLAG_PROCESS_START_ASYNC) {
            if (DEBUG_PROCESSES) Slog.i(TAG_PROCESSES,
                    ""Posting procStart msg for "" + app.toShortString());
            mProcStartHandler.post(() -> {
                try {
                    synchronized (ActivityManagerService.this) {
                        final String reason = isProcStartValidLocked(app, startSeq);
                        if (reason != null) {
                            Slog.w(TAG_PROCESSES, app + "" not valid anymore,""
                                    + "" don't start process, "" + reason);
                            app.pendingStart = false;
                            return;
                        }
                        app.setUsingWrapper(invokeWith != null
                                || SystemProperties.get(""wrap."" + app.processName) != null);
                        mPendingStarts.put(startSeq, app);
                    }
                    final ProcessStartResult startResult = startProcess(app.hostingType, entryPoint,
                            app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo,
                            requiredAbi, instructionSet, invokeWith, app.startTime);
                    synchronized (ActivityManagerService.this) {
                        handleProcessStartedLocked(app, startResult, startSeq);
                    }
                } catch (RuntimeException e) {
                    synchronized (ActivityManagerService.this) {
                        Slog.e(TAG, ""Failure starting process "" + app.processName, e);
                        mPendingStarts.remove(startSeq);
                        app.pendingStart = false;
                        forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),
                                false, false, true, false, false, app.userId, ""start failure"");
                    }
                }
            });
            return true;
        } else {
            try {
                final ProcessStartResult startResult = startProcess(hostingType, entryPoint, app,
                        uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,
                        invokeWith, startTime);
                handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,
                        startSeq, false);
            } catch (RuntimeException e) {
                Slog.e(TAG, ""Failure starting process "" + app.processName, e);
                app.pendingStart = false;
                forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),
                        false, false, true, false, false, app.userId, ""start failure"");
            }
            return app.pid > 0;
        }
    }

    private ProcessStartResult startProcess(String hostingType, String entryPoint,
            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,
            String seInfo, String requiredAbi, String instructionSet, String invokeWith,
            long startTime) {
        try {
            final String[] packageNames = mContext.getPackageManager().getPackagesForUid(uid);
            final String[] visibleVolIds = LocalServices.getService(StorageManagerInternal.class)
                    .getVisibleVolumesForUser(UserHandle.getUserId(uid));
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""Start proc: "" +
                    app.processName);
            checkTime(startTime, ""startProcess: asking zygote to start proc"");
            final ProcessStartResult startResult;
            if (hostingType.equals(""webview_service"")) {
                startResult = startWebView(entryPoint,
                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, null, app.info.packageName,
                        packageNames, visibleVolIds,
                        new String[] {PROC_START_SEQ_IDENT + app.startSeq});
            }
            else {
                startResult = Process.start(entryPoint,
                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, invokeWith, app.info.packageName,
                        packageNames, visibleVolIds,
                        new String[] {PROC_START_SEQ_IDENT + app.startSeq});
            }

            if (mPerfServiceStartHint == null) {
                mPerfServiceStartHint = new BoostFramework();
            }
            if (mPerfServiceStartHint != null) {
                mPerfServiceStartHint.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST, app.processName, -1, BoostFramework.Launch.TYPE_SERVICE_START);
            }

            checkTime(startTime, ""startProcess: returned from zygote!"");
            return startResult;
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        }
    }

    @GuardedBy(""this"")
    private String isProcStartValidLocked(ProcessRecord app, long expectedStartSeq) {
        StringBuilder sb = null;
        if (app.killedByAm) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""killedByAm=true;"");
        }
        if (mProcessNames.get(app.processName, app.uid) != app) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""No entry in mProcessNames;"");
        }
        if (!app.pendingStart) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""pendingStart=false;"");
        }
        if (app.startSeq > expectedStartSeq) {
            if (sb == null) sb = new StringBuilder();
            sb.append(""seq="" + app.startSeq + "",expected="" + expectedStartSeq + "";"");
        }
        return sb == null ? null : sb.toString();
    }

    @GuardedBy(""this"")
    private boolean handleProcessStartedLocked(ProcessRecord pending,
            ProcessStartResult startResult, long expectedStartSeq) {
        // Indicates that this process start has been taken care of.
        if (mPendingStarts.get(expectedStartSeq) == null) {
            if (pending.pid == startResult.pid) {
                pending.setUsingWrapper(startResult.usingWrapper);
                // TODO: Update already existing clients of usingWrapper
            }
            return false;
        }
        return handleProcessStartedLocked(pending, startResult.pid, startResult.usingWrapper,
                expectedStartSeq, false);
    }

    @GuardedBy(""this"")
    private boolean handleProcessStartedLocked(ProcessRecord app, int pid, boolean usingWrapper,
            long expectedStartSeq, boolean procAttached) {
        mPendingStarts.remove(expectedStartSeq);
        final String reason = isProcStartValidLocked(app, expectedStartSeq);
        if (reason != null) {
            Slog.w(TAG_PROCESSES, app + "" start not valid, killing pid="" + pid
                    + "", "" + reason);
            app.pendingStart = false;
            Process.killProcessQuiet(pid);
            Process.killProcessGroup(app.uid, app.pid);
            return false;
        }
        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        checkTime(app.startTime, ""startProcess: done updating battery stats"");

        EventLog.writeEvent(EventLogTags.AM_PROC_START,
                UserHandle.getUserId(app.startUid), pid, app.startUid,
                app.processName, app.hostingType,
                app.hostingNameStr != null ? app.hostingNameStr : """");

        try {
            AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid,
                    app.seInfo, app.info.sourceDir, pid);
        } catch (RemoteException ex) {
            // Ignore
        }

        if (app.isPersistent()) {
            Watchdog.getInstance().processStarted(app.processName, pid);
        }

        checkTime(app.startTime, ""startProcess: building log message"");
        StringBuilder buf = mStringBuilder;
        buf.setLength(0);
        buf.append(""Start proc "");
        buf.append(pid);
        buf.append(':');
        buf.append(app.processName);
        buf.append('/');
        UserHandle.formatUid(buf, app.startUid);
        if (app.isolatedEntryPoint != null) {
            buf.append("" ["");
            buf.append(app.isolatedEntryPoint);
            buf.append(""]"");
        }
        buf.append("" for "");
        buf.append(app.hostingType);
        if (app.hostingNameStr != null) {
            buf.append("" "");
            buf.append(app.hostingNameStr);
        }
        reportUidInfoMessageLocked(TAG, buf.toString(), app.startUid);
        app.setPid(pid);
        app.setUsingWrapper(usingWrapper);
        app.pendingStart = false;
        checkTime(app.startTime, ""startProcess: starting to update pids map"");
        ProcessRecord oldApp;
        synchronized (mPidsSelfLocked) {
            oldApp = mPidsSelfLocked.get(pid);
        }
        // If there is already an app occupying that pid that hasn't been cleaned up
        if (oldApp != null && !app.isolated) {
            // Clean up anything relating to this pid first
            Slog.w(TAG, ""Reusing pid "" + pid
                    + "" while app is still mapped to it"");
            cleanUpApplicationRecordLocked(oldApp, false, false, -1,
                    true /*replacingPid*/);
        }
        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(pid, app);
            if (!procAttached) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, usingWrapper
                        ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
        checkTime(app.startTime, ""startProcess: done updating pids map"");
        return true;
    }

","[1.0, 1.0]"
491,"['ba167de93776a7e5d1b347d1ee646e161cf24ce5', 'ba167de93776a7e5d1b347d1ee646e161cf24ce5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(18492, 18505, 14), (18492, 18505, 14)]","        if (app.curRawAdj != app.setRawAdj) {
            String seempStr = ""app_uid="" + app.uid
                + "",app_pid="" + app.pid + "",oom_adj="" + app.curAdj
                + "",setAdj="" + app.setAdj + "",hasShownUi="" + (app.hasShownUi ? 1 : 0)
                + "",cached="" + (app.cached ? 1 : 0)
                + "",fA="" + (app.foregroundActivities ? 1 : 0)
                + "",fS="" + (app.hasForegroundServices() ? 1 : 0)
                + "",systemNoUi="" + (app.systemNoUi ? 1 : 0)
                + "",curSchedGroup="" + app.getCurrentSchedulingGroup()
                + "",curProcState="" + app.curProcState + "",setProcState="" + app.setProcState
                + "",killed="" + (app.killed ? 1 : 0) + "",killedByAm="" + (app.killedByAm ? 1 : 0)
                + "",isDebugging="" + (app.isDebugging() ? 1 : 0);
            android.util.SeempLog.record_str(385, seempStr);
            app.setRawAdj = app.curRawAdj;
","        if (app.curRawAdj != app.setRawAdj) {
            String seempStr = ""app_uid="" + app.uid
                + "",app_pid="" + app.pid + "",oom_adj="" + app.curAdj
                + "",setAdj="" + app.setAdj + "",hasShownUi="" + (app.hasShownUi ? 1 : 0)
                + "",cached="" + (app.cached ? 1 : 0)
                + "",fA="" + (app.foregroundActivities ? 1 : 0)
                + "",fS="" + (app.hasForegroundServices() ? 1 : 0)
                + "",systemNoUi="" + (app.systemNoUi ? 1 : 0)
                + "",curSchedGroup="" + app.getCurrentSchedulingGroup()
                + "",curProcState="" + app.curProcState + "",setProcState="" + app.setProcState
                + "",killed="" + (app.killed ? 1 : 0) + "",killedByAm="" + (app.killedByAm ? 1 : 0)
                + "",isDebugging="" + (app.isDebugging() ? 1 : 0);
            android.util.SeempLog.record_str(385, seempStr);
            app.setRawAdj = app.curRawAdj;
","        if (app.curRawAdj != app.setRawAdj) {
            String seempStr = ""app_uid="" + app.uid
                + "",app_pid="" + app.pid + "",oom_adj="" + app.curAdj
                + "",setAdj="" + app.setAdj + "",hasShownUi="" + (app.hasShownUi ? 1 : 0)
                + "",cached="" + (app.cached ? 1 : 0)
                + "",fA="" + (app.foregroundActivities ? 1 : 0)
                + "",fS="" + (app.hasForegroundServices() ? 1 : 0)
                + "",systemNoUi="" + (app.systemNoUi ? 1 : 0)
                + "",curSchedGroup="" + app.getCurrentSchedulingGroup()
                + "",curProcState="" + app.curProcState + "",setProcState="" + app.setProcState
                + "",killed="" + (app.killed ? 1 : 0) + "",killedByAm="" + (app.killedByAm ? 1 : 0)
                + "",isDebugging="" + (app.isDebugging() ? 1 : 0);
            android.util.SeempLog.record_str(385, seempStr);
            app.setRawAdj = app.curRawAdj;
","[1.0, 1.0]"
492,"['ba167de93776a7e5d1b347d1ee646e161cf24ce5', 'ba167de93776a7e5d1b347d1ee646e161cf24ce5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(19140, 19168, 29), (19140, 19168, 29)]","            ProcessRecord app = mLruProcesses.get(i);
            if (mEnableBServicePropagation && app.serviceb
                    && (app.curAdj == ProcessList.SERVICE_B_ADJ)) {
                numBServices++;
                for (int s = app.services.size() - 1; s >= 0; s--) {
                    ServiceRecord sr = app.services.valueAt(s);
                    if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + app.processName
                            + "" serviceb = "" + app.serviceb + "" s = "" + s + "" sr.lastActivity = ""
                            + sr.lastActivity + "" packageName = "" + sr.packageName
                            + "" processName = "" + sr.processName);
                    if (SystemClock.uptimeMillis() - sr.lastActivity
                            < mMinBServiceAgingTime) {
                        if (DEBUG_OOM_ADJ) {
                            Slog.d(TAG,""Not aged enough!!!"");
                        }
                        continue;
                    }
                    if (serviceLastActivity == 0) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    } else if (sr.lastActivity < serviceLastActivity) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    }
                }
            }
            if (DEBUG_OOM_ADJ && selectedAppRecord != null) Slog.d(TAG,
                    ""Identified app.processName = "" + selectedAppRecord.processName
                    + "" app.pid = "" + selectedAppRecord.pid);
","            ProcessRecord app = mLruProcesses.get(i);
            if (mEnableBServicePropagation && app.serviceb
                    && (app.curAdj == ProcessList.SERVICE_B_ADJ)) {
                numBServices++;
                for (int s = app.services.size() - 1; s >= 0; s--) {
                    ServiceRecord sr = app.services.valueAt(s);
                    if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + app.processName
                            + "" serviceb = "" + app.serviceb + "" s = "" + s + "" sr.lastActivity = ""
                            + sr.lastActivity + "" packageName = "" + sr.packageName
                            + "" processName = "" + sr.processName);
                    if (SystemClock.uptimeMillis() - sr.lastActivity
                            < mMinBServiceAgingTime) {
                        if (DEBUG_OOM_ADJ) {
                            Slog.d(TAG,""Not aged enough!!!"");
                        }
                        continue;
                    }
                    if (serviceLastActivity == 0) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    } else if (sr.lastActivity < serviceLastActivity) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    }
                }
            }
            if (DEBUG_OOM_ADJ && selectedAppRecord != null) Slog.d(TAG,
                    ""Identified app.processName = "" + selectedAppRecord.processName
                    + "" app.pid = "" + selectedAppRecord.pid);
","            ProcessRecord app = mLruProcesses.get(i);
            if (mEnableBServicePropagation && app.serviceb
                    && (app.curAdj == ProcessList.SERVICE_B_ADJ)) {
                numBServices++;
                for (int s = app.services.size() - 1; s >= 0; s--) {
                    ServiceRecord sr = app.services.valueAt(s);
                    if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + app.processName
                            + "" serviceb = "" + app.serviceb + "" s = "" + s + "" sr.lastActivity = ""
                            + sr.lastActivity + "" packageName = "" + sr.packageName
                            + "" processName = "" + sr.processName);
                    if (SystemClock.uptimeMillis() - sr.lastActivity
                            < mMinBServiceAgingTime) {
                        if (DEBUG_OOM_ADJ) {
                            Slog.d(TAG,""Not aged enough!!!"");
                        }
                        continue;
                    }
                    if (serviceLastActivity == 0) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    } else if (sr.lastActivity < serviceLastActivity) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    }
                }
            }
            if (DEBUG_OOM_ADJ && selectedAppRecord != null) Slog.d(TAG,
                    ""Identified app.processName = "" + selectedAppRecord.processName
                    + "" app.pid = "" + selectedAppRecord.pid);
","[1.0, 1.0]"
493,"['cf03be865b65f49562f1e442ee0e7510ee597aa8', 'cf03be865b65f49562f1e442ee0e7510ee597aa8']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(62, 62, 1), (62, 62, 1)]","import android.telephony.SubscriptionInfo;
","import android.telephony.SubscriptionInfo;
","import android.telephony.SubscriptionInfo;
","[1.0, 1.0]"
494,"['cf03be865b65f49562f1e442ee0e7510ee597aa8', 'cf03be865b65f49562f1e442ee0e7510ee597aa8']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/WiredAccessoryManager.java,"[(163, 164, 2), (163, 164, 2)]","            updateLocked(NAME_H2W, """",
                (mHeadsetState & ~(BIT_HEADSET | BIT_HEADSET_NO_MIC | BIT_LINEOUT)) | headset);
","            updateLocked(NAME_H2W, """",
                (mHeadsetState & ~(BIT_HEADSET | BIT_HEADSET_NO_MIC | BIT_LINEOUT)) | headset);
","            updateLocked(NAME_H2W, """",
                (mHeadsetState & ~(BIT_HEADSET | BIT_HEADSET_NO_MIC | BIT_LINEOUT)) | headset);
","[1.0, 1.0]"
495,"['cf03be865b65f49562f1e442ee0e7510ee597aa8', 'cf03be865b65f49562f1e442ee0e7510ee597aa8']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/WiredAccessoryManager.java,"[(303, 312, 10), (303, 312, 10)]","                if (LOG) {
                    Slog.v(TAG, ""Output device address "" + (hs.length > 1 ? hs[1] : """")
                           + "" name "" + hs[0]);
                }
                mAudioManager.setWiredDeviceConnectionState(outDevice, state,
                                                             (hs.length > 1 ? hs[1] : """"), hs[0]);
            }
            if (inDevice != 0) {
              mAudioManager.setWiredDeviceConnectionState(inDevice, state,
                                                           (hs.length > 1 ? hs[1] : """"), hs[0]);
","                if (LOG) {
                    Slog.v(TAG, ""Output device address "" + (hs.length > 1 ? hs[1] : """")
                           + "" name "" + hs[0]);
                }
                mAudioManager.setWiredDeviceConnectionState(outDevice, state,
                                                             (hs.length > 1 ? hs[1] : """"), hs[0]);
            }
            if (inDevice != 0) {
              mAudioManager.setWiredDeviceConnectionState(inDevice, state,
                                                           (hs.length > 1 ? hs[1] : """"), hs[0]);
","                if (LOG) {
                    Slog.v(TAG, ""Output device address "" + (hs.length > 1 ? hs[1] : """")
                           + "" name "" + hs[0]);
                }
                mAudioManager.setWiredDeviceConnectionState(outDevice, state,
                                                             (hs.length > 1 ? hs[1] : """"), hs[0]);
            }
            if (inDevice != 0) {
              mAudioManager.setWiredDeviceConnectionState(inDevice, state,
                                                           (hs.length > 1 ? hs[1] : """"), hs[0]);
","[1.0, 1.0]"
496,"['db8a16a19bc4c35bc8ba2ff9a3fd4341177e1e26', 'db8a16a19bc4c35bc8ba2ff9a3fd4341177e1e26']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarFragment.java,"[(644, 648, 5), (644, 648, 5)]","        int nbMode = mStatusBar.computeBarMode(0, mSystemUiVisibility,
                View.NAVIGATION_BAR_TRANSIENT, View.NAVIGATION_BAR_TRANSLUCENT,
                View.NAVIGATION_BAR_TRANSPARENT);
        if ( nbMode != -1 ) {
            mNavigationBarMode = nbMode;
","        int nbMode = mStatusBar.computeBarMode(0, mSystemUiVisibility,
                View.NAVIGATION_BAR_TRANSIENT, View.NAVIGATION_BAR_TRANSLUCENT,
                View.NAVIGATION_BAR_TRANSPARENT);
        if ( nbMode != -1 ) {
            mNavigationBarMode = nbMode;
","        int nbMode = mStatusBar.computeBarMode(0, mSystemUiVisibility,
                View.NAVIGATION_BAR_TRANSIENT, View.NAVIGATION_BAR_TRANSLUCENT,
                View.NAVIGATION_BAR_TRANSPARENT);
        if ( nbMode != -1 ) {
            mNavigationBarMode = nbMode;
","[1.0, 1.0]"
503,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']","['aospa-quartz-SAP-block_text', 'omnirom-10-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(570, 633, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
504,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(570, 633, 64), (651, 714, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
505,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(570, 633, 64), (669, 732, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
506,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(570, 633, 64), (677, 740, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
507,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', '7fe8671fd7b5388dd9be6295dbea6d31209468f9']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(570, 633, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
508,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"[(33, 33, 1), (33, 34, 2)]","import android.bluetooth.BluetoothDun;
","import android.bluetooth.BluetoothDun;
import android.bluetooth.BluetoothSap;
","import android.bluetooth.BluetoothDun;
","[1.0, 0.5]"
509,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(1812, 1813, 2), (1812, 1813, 2)]","        // Configure whether mobile data is always on.
        mHandler.sendMessage(mHandler.obtainMessage(EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON));
","        // Configure whether mobile data is always on.
        mHandler.sendMessage(mHandler.obtainMessage(EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON));
","        // Configure whether mobile data is always on.
        mHandler.sendMessage(mHandler.obtainMessage(EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON));
","[1.0, 1.0]"
510,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(5961, 6026, 66), (5961, 6026, 66)]","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (getIntSpecifier(agentNc.getNetworkSpecifier()) == SubscriptionManager
                                    .getDefaultDataSubscriptionId()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
","[1.0, 1.0]"
511,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java,"[(190, 204, 15), (190, 204, 15)]","    @Override
    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
","    @Override
    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
","    @Override
    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
","[1.0, 1.0]"
512,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(32, 34, 3), (32, 34, 3)]","import androidx.annotation.VisibleForTesting;
import android.os.SystemProperties;

","import androidx.annotation.VisibleForTesting;
import android.os.SystemProperties;

","import androidx.annotation.VisibleForTesting;
import android.os.SystemProperties;

","[1.0, 1.0]"
513,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(110, 123, 14), (110, 123, 14)]","    /* Gets Device for seondary TWS device
     * @param mDevice Primary TWS device  to get secondary
     * @return Description of the device
     */

    private BluetoothDevice getTwsPeerDevice() {
      BluetoothAdapter bluetoothAdapter;
      BluetoothDevice peerDevice = null;
      if (mDevice.isTwsPlusDevice()) {
        bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        String peerAddress = mDevice.getTwsPlusPeerAddress();
        peerDevice = bluetoothAdapter.getRemoteDevice(peerAddress);
      }
      return peerDevice;
","    /* Gets Device for seondary TWS device
     * @param mDevice Primary TWS device  to get secondary
     * @return Description of the device
     */

    private BluetoothDevice getTwsPeerDevice() {
      BluetoothAdapter bluetoothAdapter;
      BluetoothDevice peerDevice = null;
      if (mDevice.isTwsPlusDevice()) {
        bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        String peerAddress = mDevice.getTwsPlusPeerAddress();
        peerDevice = bluetoothAdapter.getRemoteDevice(peerAddress);
      }
      return peerDevice;
","    /* Gets Device for seondary TWS device
     * @param mDevice Primary TWS device  to get secondary
     * @return Description of the device
     */

    private BluetoothDevice getTwsPeerDevice() {
      BluetoothAdapter bluetoothAdapter;
      BluetoothDevice peerDevice = null;
      if (mDevice.isTwsPlusDevice()) {
        bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        String peerAddress = mDevice.getTwsPlusPeerAddress();
        peerDevice = bluetoothAdapter.getRemoteDevice(peerAddress);
      }
      return peerDevice;
","[1.0, 1.0]"
514,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"[(33, 33, 1), (33, 33, 1)]","import android.bluetooth.BluetoothDun;
","import android.bluetooth.BluetoothDun;
","import android.bluetooth.BluetoothDun;
","[1.0, 1.0]"
515,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"[(216, 220, 5), (216, 220, 5)]","        if (mDunProfile == null && supportedList.contains(BluetoothProfile.DUN)) {
            if(DEBUG) Log.d(TAG, ""Adding local DUN profile"");
            mDunProfile = new DunServerProfile(mContext);
            addProfile(mDunProfile, DunServerProfile.NAME,
                    BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);
","        if (mDunProfile == null && supportedList.contains(BluetoothProfile.DUN)) {
            if(DEBUG) Log.d(TAG, ""Adding local DUN profile"");
            mDunProfile = new DunServerProfile(mContext);
            addProfile(mDunProfile, DunServerProfile.NAME,
                    BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);
","        if (mDunProfile == null && supportedList.contains(BluetoothProfile.DUN)) {
            if(DEBUG) Log.d(TAG, ""Adding local DUN profile"");
            mDunProfile = new DunServerProfile(mContext);
            addProfile(mDunProfile, DunServerProfile.NAME,
                    BluetoothDun.ACTION_CONNECTION_STATE_CHANGED);
","[1.0, 1.0]"
516,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/TaskTapPointerEventListener.java,"[(50, 52, 3), (50, 52, 3)]","        if (mPerfObj == null) {
            mPerfObj = new BoostFramework();
        }
","        if (mPerfObj == null) {
            mPerfObj = new BoostFramework();
        }
","        if (mPerfObj == null) {
            mPerfObj = new BoostFramework();
        }
","[1.0, 1.0]"
517,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/WindowManagerService.java,"[(230, 230, 1), (230, 230, 1)]","import com.android.internal.app.ActivityTrigger;
","import com.android.internal.app.ActivityTrigger;
","import com.android.internal.app.ActivityTrigger;
","[1.0, 1.0]"
518,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(570, 633, 64), (570, 633, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
519,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(570, 633, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
520,"['e449737f6ea4d11d082f1cdec4d067f64d5ba95e', 'e449737f6ea4d11d082f1cdec4d067f64d5ba95e']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/LocalDisplayAdapter.java,"[(184, 186, 3), (184, 186, 3)]","                int[] colorModes, int activeColorMode, boolean isInternal) {
            super(LocalDisplayAdapter.this, displayToken, UNIQUE_ID_PREFIX + physicalDisplayId,
                  physicalDisplayId);
","                int[] colorModes, int activeColorMode, boolean isInternal) {
            super(LocalDisplayAdapter.this, displayToken, UNIQUE_ID_PREFIX + physicalDisplayId,
                  physicalDisplayId);
","                int[] colorModes, int activeColorMode, boolean isInternal) {
            super(LocalDisplayAdapter.this, displayToken, UNIQUE_ID_PREFIX + physicalDisplayId,
                  physicalDisplayId);
","[1.0, 1.0]"
521,"['f9f9f03acdeb05e6978feca02f6ef20ff57d06bc', 'f9f9f03acdeb05e6978feca02f6ef20ff57d06bc']","['aospa-quartz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(124, 127, 4), (124, 127, 4)]","        mPhoneStateListener = new MobilePhoneStateListener(info.getSubscriptionId(),
                receiverLooper);
        mFiveGStateListener = new FiveGStateListener();
        mFiveGState = new FiveGServiceState();
","        mPhoneStateListener = new MobilePhoneStateListener(info.getSubscriptionId(),
                receiverLooper);
        mFiveGStateListener = new FiveGStateListener();
        mFiveGState = new FiveGServiceState();
","        mPhoneStateListener = new MobilePhoneStateListener(info.getSubscriptionId(),
                receiverLooper);
        mFiveGStateListener = new FiveGStateListener();
        mFiveGState = new FiveGServiceState();
","[1.0, 1.0]"
527,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '96e5fca97c43ea282d5ad4b7c6fad40acd91586d']","['aospa-ruby-SAP-block_text', 'lineage-17.1-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java,"[(1215, 1215, 1), (1365, 1365, 1)]","                new Handler(), mKeyguardUpdateMonitor, Dependency.get(TunerService.class));
","                new Handler(), mKeyguardUpdateMonitor, mKeyguardBypassController);
","                new Handler(), mKeyguardUpdateMonitor, ","[0.598, 0.663]"
528,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']","['aospa-ruby-SAP-block_text', 'omnirom-10-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/notification/row/wrapper/NotificationMediaTemplateViewWrapper.java,"[(72, 72, 1), (72, 72, 1)]","    private boolean mOnPreDrawListenerRegistered = false;
","    private boolean mOnPreDrawListenerRegistered = false;
","    private boolean mOnPreDrawListenerRegistered = false;
","[1.0, 1.0]"
529,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']","['aospa-ruby-SAP-block_text', 'omnirom-10-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/notification/row/wrapper/NotificationMediaTemplateViewWrapper.java,"[(224, 239, 16), (224, 239, 16)]","        addOnPreDrawListener();
    }


    private void addOnPreDrawListener() {
        if ( !mOnPreDrawListenerRegistered ) {
            mOnPreDrawListenerRegistered = true;
            mSeekBarView.getViewTreeObserver().addOnPreDrawListener(mPreDrawListener);
        }
    }

    private void removeOnPreDrawListener() {
        if ( mOnPreDrawListenerRegistered ) {
            mSeekBarView.getViewTreeObserver().removeOnPreDrawListener(mPreDrawListener);
            mHandler.postDelayed(mOnUpdateTimerTick, PROGRESS_UPDATE_INTERVAL);
            mOnPreDrawListenerRegistered = false;
","        addOnPreDrawListener();
    }


    private void addOnPreDrawListener() {
        if ( !mOnPreDrawListenerRegistered ) {
            mOnPreDrawListenerRegistered = true;
            mSeekBarView.getViewTreeObserver().addOnPreDrawListener(mPreDrawListener);
        }
    }

    private void removeOnPreDrawListener() {
        if ( mOnPreDrawListenerRegistered ) {
            mSeekBarView.getViewTreeObserver().removeOnPreDrawListener(mPreDrawListener);
            mHandler.postDelayed(mOnUpdateTimerTick, PROGRESS_UPDATE_INTERVAL);
            mOnPreDrawListenerRegistered = false;
","        addOnPreDrawListener();
    }


    private void addOnPreDrawListener() {
        if ( !mOnPreDrawListenerRegistered ) {
            mOnPreDrawListenerRegistered = true;
            mSeekBarView.getViewTreeObserver().addOnPreDrawListener(mPreDrawListener);
        }
    }

    private void removeOnPreDrawListener() {
        if ( mOnPreDrawListenerRegistered ) {
            mSeekBarView.getViewTreeObserver().removeOnPreDrawListener(mPreDrawListener);
            mHandler.postDelayed(mOnUpdateTimerTick, PROGRESS_UPDATE_INTERVAL);
            mOnPreDrawListenerRegistered = false;
","[1.0, 1.0]"
530,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']","['aospa-ruby-SAP-block_text', 'omnirom-10-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(651, 714, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
531,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']","['aospa-ruby-SAP-block_text', 'omnirom-10-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java,"[(1215, 1215, 1), (1270, 1270, 1)]","                new Handler(), mKeyguardUpdateMonitor, Dependency.get(TunerService.class));
","                new Handler(), mKeyguardUpdateMonitor, Dependency.get(TunerService.class));
","                new Handler(), mKeyguardUpdateMonitor, Dependency.get(TunerService.class));
","[1.0, 1.0]"
532,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']","['aospa-ruby-SAP-block_text', 'omnirom-10-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1797, 1807, 11), (1799, 1807, 9)]","            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
        checkPasswordReadPermission(userId);
        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        false, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        false, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        false, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","[0.812, 1.0]"
533,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(2270, 2288, 19), (2270, 2288, 19)]","    // Overridden for testing purposes to avoid writing to SystemProperties.
    @VisibleForTesting
    protected MockableSystemProperties getSystemProperties() {
        return new MockableSystemProperties();
    }

    private void updateTcpBufferSizes(NetworkAgentInfo nai) {
        if (isDefaultNetwork(nai) == false) {
            return;
        }

        String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
        if(nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)){
            tcpBufferSizes = NetPluginDelegate.get5GTcpBuffers(tcpBufferSizes,
                nai.networkCapabilities.getNetworkSpecifier());
        }
        updateTcpBufferSizes(tcpBufferSizes);
    }

","    // Overridden for testing purposes to avoid writing to SystemProperties.
    @VisibleForTesting
    protected MockableSystemProperties getSystemProperties() {
        return new MockableSystemProperties();
    }

    private void updateTcpBufferSizes(NetworkAgentInfo nai) {
        if (isDefaultNetwork(nai) == false) {
            return;
        }

        String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
        if(nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)){
            tcpBufferSizes = NetPluginDelegate.get5GTcpBuffers(tcpBufferSizes,
                nai.networkCapabilities.getNetworkSpecifier());
        }
        updateTcpBufferSizes(tcpBufferSizes);
    }

","    // Overridden for testing purposes to avoid writing to SystemProperties.
    @VisibleForTesting
    protected MockableSystemProperties getSystemProperties() {
        return new MockableSystemProperties();
    }

    private void updateTcpBufferSizes(NetworkAgentInfo nai) {
        if (isDefaultNetwork(nai) == false) {
            return;
        }

        String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
        if(nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)){
            tcpBufferSizes = NetPluginDelegate.get5GTcpBuffers(tcpBufferSizes,
                nai.networkCapabilities.getNetworkSpecifier());
        }
        updateTcpBufferSizes(tcpBufferSizes);
    }

","[1.0, 1.0]"
534,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceInventory.java,"[(846, 846, 1), (846, 846, 1)]","            delay = SystemProperties.getInt(""audio.sys.noisy.broadcast.delay"", 700);
","            delay = SystemProperties.getInt(""audio.sys.noisy.broadcast.delay"", 700);
","            delay = SystemProperties.getInt(""audio.sys.noisy.broadcast.delay"", 700);
","[1.0, 1.0]"
535,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(2329, 2329, 1), (2329, 2329, 1)]","        android.util.SeempLog.record(48);
","        android.util.SeempLog.record(48);
","        android.util.SeempLog.record(48);
","[1.0, 1.0]"
536,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(2857, 2860, 4), (2857, 2860, 4)]","        final DisplayContent dc = getDisplay().mDisplayContent;
        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
","        final DisplayContent dc = getDisplay().mDisplayContent;
        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
","        final DisplayContent dc = getDisplay().mDisplayContent;
        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
","[1.0, 1.0]"
537,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(3245, 3252, 8), (3245, 3252, 8)]","        task.setFrontOfTask();

        if (mActivityPluginDelegate != null) {
            mActivityPluginDelegate.activityInvokeNotification
                (r.appInfo.packageName, r.fullscreen);
        }

        if (!isHomeOrRecentsStack() || numActivities() > 0) {
","        task.setFrontOfTask();

        if (mActivityPluginDelegate != null) {
            mActivityPluginDelegate.activityInvokeNotification
                (r.appInfo.packageName, r.fullscreen);
        }

        if (!isHomeOrRecentsStack() || numActivities() > 0) {
","        task.setFrontOfTask();

        if (mActivityPluginDelegate != null) {
            mActivityPluginDelegate.activityInvokeNotification
                (r.appInfo.packageName, r.fullscreen);
        }

        if (!isHomeOrRecentsStack() || numActivities() > 0) {
","[1.0, 1.0]"
538,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(3988, 4249, 262), (3988, 4249, 262)]","    final boolean finishActivityAffinityLocked(ActivityRecord r) {
        ArrayList<ActivityRecord> activities = r.getTaskRecord().mActivities;
        for (int index = activities.indexOf(r); index >= 0; --index) {
            ActivityRecord cur = activities.get(index);
            if (!Objects.equals(cur.taskAffinity, r.taskAffinity)) {
                break;
            }
            finishActivityLocked(cur, Activity.RESULT_CANCELED, null, ""request-affinity"", true);
        }
        return true;
    }

    private void finishActivityResultsLocked(ActivityRecord r, int resultCode, Intent resultData) {
        // send the result
        ActivityRecord resultTo = r.resultTo;
        if (resultTo != null) {
            if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, ""Adding result to "" + resultTo
                    + "" who="" + r.resultWho + "" req="" + r.requestCode
                    + "" res="" + resultCode + "" data="" + resultData);
            if (resultTo.mUserId != r.mUserId) {
                if (resultData != null) {
                    resultData.prepareToLeaveUser(r.mUserId);
                }
            }
            if (r.info.applicationInfo.uid > 0) {
                mService.mUgmInternal.grantUriPermissionFromIntent(r.info.applicationInfo.uid,
                        resultTo.packageName, resultData,
                        resultTo.getUriPermissionsLocked(), resultTo.mUserId);
            }
            resultTo.addResultLocked(r, r.resultWho, r.requestCode, resultCode, resultData);
            r.resultTo = null;
        }
        else if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, ""No result destination from "" + r);

        // Make sure this HistoryRecord is not holding on to other resources,
        // because clients have remote IPC references to this object so we
        // can't assume that will go away and want to avoid circular IPC refs.
        r.results = null;
        r.pendingResults = null;
        r.newIntents = null;
        r.icicle = null;
    }

    /**
     * See {@link #finishActivityLocked(ActivityRecord, int, Intent, String, boolean, boolean)}
     */
    final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData,
            String reason, boolean oomAdj) {
        return finishActivityLocked(r, resultCode, resultData, reason, oomAdj, !PAUSE_IMMEDIATELY);
    }

    /**
     * @return Returns true if this activity has been removed from the history
     * list, or false if it is still in the list and will be removed later.
     */
    final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData,
            String reason, boolean oomAdj, boolean pauseImmediately) {
        if (r.finishing) {
            Slog.w(TAG, ""Duplicate finish request for "" + r);
            return false;
        }

        mWindowManager.deferSurfaceLayout();
        try {
            r.makeFinishingLocked();
            final TaskRecord task = r.getTaskRecord();
            EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,
                    r.mUserId, System.identityHashCode(r),
                    task.taskId, r.shortComponentName, reason);
            final ArrayList<ActivityRecord> activities = task.mActivities;
            final int index = activities.indexOf(r);
            if (index < (activities.size() - 1)) {
                task.setFrontOfTask();
                if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) {
                    // If the caller asked that this activity (and all above it)
                    // be cleared when the task is reset, don't lose that information,
                    // but propagate it up to the next activity.
                    ActivityRecord next = activities.get(index+1);
                    next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
                }
            }

            r.pauseKeyDispatchingLocked();

            adjustFocusedActivityStack(r, ""finishActivity"");

            finishActivityResultsLocked(r, resultCode, resultData);

            final boolean endTask = index <= 0 && !task.isClearingToReuseTask();
            final int transit = endTask ? TRANSIT_TASK_CLOSE : TRANSIT_ACTIVITY_CLOSE;
            if (mResumedActivity == r) {
                if (DEBUG_VISIBILITY || DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,
                        ""Prepare close transition: finishing "" + r);
                if (endTask) {
                    mService.getTaskChangeNotificationController().notifyTaskRemovalStarted(
                            task.getTaskInfo());
                }
                getDisplay().mDisplayContent.prepareAppTransition(transit, false);

                // Tell window manager to prepare for this one to be removed.
                r.setVisibility(false);

                if (mPausingActivity == null) {
                    if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, ""Finish needs to pause: "" + r);
                    if (DEBUG_USER_LEAVING) Slog.v(TAG_USER_LEAVING,
                            ""finish() => pause with userLeaving=false"");
                    startPausingLocked(false, false, null, pauseImmediately);
                }

                if (endTask) {
                    mService.getLockTaskController().clearLockedTask(task);
                }
            } else if (!r.isState(PAUSING)) {
                // If the activity is PAUSING, we will complete the finish once
                // it is done pausing; else we can just directly finish it here.
                if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, ""Finish not pausing: "" + r);
                if (r.visible) {
                    prepareActivityHideTransitionAnimation(r, transit);
                }

                final int finishMode = (r.visible || r.nowVisible) ? FINISH_AFTER_VISIBLE
                        : FINISH_AFTER_PAUSE;
                final boolean removedActivity = finishCurrentActivityLocked(r, finishMode, oomAdj,
                        ""finishActivityLocked"") == null;

                // The following code is an optimization. When the last non-task overlay activity
                // is removed from the task, we remove the entire task from the stack. However,
                // since that is done after the scheduled destroy callback from the activity, that
                // call to change the visibility of the task overlay activities would be out of
                // sync with the activitiy visibility being set for this finishing activity above.
                // In this case, we can set the visibility of all the task overlay activities when
                // we detect the last one is finishing to keep them in sync.
                if (task.onlyHasTaskOverlayActivities(true /* excludeFinishing */)) {
                    for (ActivityRecord taskOverlay : task.mActivities) {
                        if (!taskOverlay.mTaskOverlay) {
                            continue;
                        }
                        prepareActivityHideTransitionAnimation(taskOverlay, transit);
                    }
                }
                return removedActivity;
            } else {
                if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, ""Finish waiting for pause of: "" + r);
            }

            return false;
        } finally {
            mWindowManager.continueSurfaceLayout();
        }
    }

    private void prepareActivityHideTransitionAnimation(ActivityRecord r, int transit) {
        final DisplayContent dc = getDisplay().mDisplayContent;
        dc.prepareAppTransition(transit, false);
        r.setVisibility(false);
        dc.executeAppTransition();
    }

    static final int FINISH_IMMEDIATELY = 0;
    static final int FINISH_AFTER_PAUSE = 1;
    static final int FINISH_AFTER_VISIBLE = 2;

    final ActivityRecord finishCurrentActivityLocked(ActivityRecord r, int mode, boolean oomAdj,
            String reason) {
        // First things first: if this activity is currently visible,
        // and the resumed activity is not yet visible, then hold off on
        // finishing until the resumed one becomes visible.

        // The activity that we are finishing may be over the lock screen. In this case, we do not
        // want to consider activities that cannot be shown on the lock screen as running and should
        // proceed with finishing the activity if there is no valid next top running activity.
        // Note that if this finishing activity is floating task, we don't need to wait the
        // next activity resume and can destroy it directly.
        final ActivityDisplay display = getDisplay();
        final ActivityRecord next = display.topRunningActivity(true /* considerKeyguardState */);
        final boolean isFloating = r.getConfiguration().windowConfiguration.tasksAreFloating();

        if (mode == FINISH_AFTER_VISIBLE && (r.visible || r.nowVisible)
                && next != null && !next.nowVisible && !isFloating) {
            if (!mStackSupervisor.mStoppingActivities.contains(r)) {
                addToStopping(r, false /* scheduleIdle */, false /* idleDelayed */,
                        ""finishCurrentActivityLocked"");
            }
            if (DEBUG_STATES) Slog.v(TAG_STATES,
                    ""Moving to STOPPING: ""+ r + "" (finish requested)"");
            if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
                mActivityPluginDelegate.activitySuspendNotification
                    (r.appInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
            }
            r.setState(STOPPING, ""finishCurrentActivityLocked"");
            if (oomAdj) {
                mService.updateOomAdj();
            }
            return r;
        }

        // make sure the record is cleaned out of other places.
        mStackSupervisor.mStoppingActivities.remove(r);
        mStackSupervisor.mGoingToSleepActivities.remove(r);
        final ActivityState prevState = r.getState();
        if (DEBUG_STATES) Slog.v(TAG_STATES, ""Moving to FINISHING: "" + r);

        if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
            mActivityPluginDelegate.activitySuspendNotification
                (r.appInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
        }

        r.setState(FINISHING, ""finishCurrentActivityLocked"");

        // Don't destroy activity immediately if the display contains home stack, although there is
        // no next activity at the moment but another home activity should be started later. Keep
        // this activity alive until next home activity is resumed then user won't see a temporary
        // black screen.
        final boolean noRunningStack = next == null && display.topRunningActivity() == null
                && display.getHomeStack() == null;
        final boolean noFocusedStack = r.getActivityStack() != display.getFocusedStack();
        final boolean finishingInNonFocusedStackOrNoRunning = mode == FINISH_AFTER_VISIBLE
                && prevState == PAUSED && (noFocusedStack || noRunningStack);

        if (mode == FINISH_IMMEDIATELY
                || (prevState == PAUSED
                    && (mode == FINISH_AFTER_PAUSE || inPinnedWindowingMode()))
                || finishingInNonFocusedStackOrNoRunning
                || prevState == STOPPING
                || prevState == STOPPED
                || prevState == ActivityState.INITIALIZING) {
            r.makeFinishingLocked();
            boolean activityRemoved = destroyActivityLocked(r, true, ""finish-imm:"" + reason);

            if (finishingInNonFocusedStackOrNoRunning) {
                // Finishing activity that was in paused state and it was in not currently focused
                // stack, need to make something visible in its place. Also if the display does not
                // have running activity, the configuration may need to be updated for restoring
                // original orientation of the display.
                mRootActivityContainer.ensureVisibilityAndConfig(next, mDisplayId,
                        false /* markFrozenIfConfigChanged */, true /* deferResume */);
            }
            if (activityRemoved) {
                mRootActivityContainer.resumeFocusedStacksTopActivities();
            }
            if (DEBUG_CONTAINERS) Slog.d(TAG_CONTAINERS,
                    ""destroyActivityLocked: finishCurrentActivityLocked r="" + r +
                    "" destroy returned removed="" + activityRemoved);
            return activityRemoved ? null : r;
        }

        // Need to go through the full pause cycle to get this
        // activity into the stopped state and then finish it.
        if (DEBUG_ALL) Slog.v(TAG, ""Enqueueing pending finish: "" + r);
        mStackSupervisor.mFinishingActivities.add(r);
        r.resumeKeyDispatchingLocked();
        mRootActivityContainer.resumeFocusedStacksTopActivities();
        // If activity was not paused at this point - explicitly pause it to start finishing
        // process. Finishing will be completed once it reports pause back.
        if (r.isState(RESUMED) && mPausingActivity != null) {
            startPausingLocked(false /* userLeaving */, false /* uiSleeping */, next /* resuming */,
                    false /* dontWait */);
        }
        return r;
    }

    void finishAllActivitiesLocked(boolean immediately) {
","    final boolean finishActivityAffinityLocked(ActivityRecord r) {
        ArrayList<ActivityRecord> activities = r.getTaskRecord().mActivities;
        for (int index = activities.indexOf(r); index >= 0; --index) {
            ActivityRecord cur = activities.get(index);
            if (!Objects.equals(cur.taskAffinity, r.taskAffinity)) {
                break;
            }
            finishActivityLocked(cur, Activity.RESULT_CANCELED, null, ""request-affinity"", true);
        }
        return true;
    }

    private void finishActivityResultsLocked(ActivityRecord r, int resultCode, Intent resultData) {
        // send the result
        ActivityRecord resultTo = r.resultTo;
        if (resultTo != null) {
            if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, ""Adding result to "" + resultTo
                    + "" who="" + r.resultWho + "" req="" + r.requestCode
                    + "" res="" + resultCode + "" data="" + resultData);
            if (resultTo.mUserId != r.mUserId) {
                if (resultData != null) {
                    resultData.prepareToLeaveUser(r.mUserId);
                }
            }
            if (r.info.applicationInfo.uid > 0) {
                mService.mUgmInternal.grantUriPermissionFromIntent(r.info.applicationInfo.uid,
                        resultTo.packageName, resultData,
                        resultTo.getUriPermissionsLocked(), resultTo.mUserId);
            }
            resultTo.addResultLocked(r, r.resultWho, r.requestCode, resultCode, resultData);
            r.resultTo = null;
        }
        else if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, ""No result destination from "" + r);

        // Make sure this HistoryRecord is not holding on to other resources,
        // because clients have remote IPC references to this object so we
        // can't assume that will go away and want to avoid circular IPC refs.
        r.results = null;
        r.pendingResults = null;
        r.newIntents = null;
        r.icicle = null;
    }

    /**
     * See {@link #finishActivityLocked(ActivityRecord, int, Intent, String, boolean, boolean)}
     */
    final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData,
            String reason, boolean oomAdj) {
        return finishActivityLocked(r, resultCode, resultData, reason, oomAdj, !PAUSE_IMMEDIATELY);
    }

    /**
     * @return Returns true if this activity has been removed from the history
     * list, or false if it is still in the list and will be removed later.
     */
    final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData,
            String reason, boolean oomAdj, boolean pauseImmediately) {
        if (r.finishing) {
            Slog.w(TAG, ""Duplicate finish request for "" + r);
            return false;
        }

        mWindowManager.deferSurfaceLayout();
        try {
            r.makeFinishingLocked();
            final TaskRecord task = r.getTaskRecord();
            EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,
                    r.mUserId, System.identityHashCode(r),
                    task.taskId, r.shortComponentName, reason);
            final ArrayList<ActivityRecord> activities = task.mActivities;
            final int index = activities.indexOf(r);
            if (index < (activities.size() - 1)) {
                task.setFrontOfTask();
                if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) {
                    // If the caller asked that this activity (and all above it)
                    // be cleared when the task is reset, don't lose that information,
                    // but propagate it up to the next activity.
                    ActivityRecord next = activities.get(index+1);
                    next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
                }
            }

            r.pauseKeyDispatchingLocked();

            adjustFocusedActivityStack(r, ""finishActivity"");

            finishActivityResultsLocked(r, resultCode, resultData);

            final boolean endTask = index <= 0 && !task.isClearingToReuseTask();
            final int transit = endTask ? TRANSIT_TASK_CLOSE : TRANSIT_ACTIVITY_CLOSE;
            if (mResumedActivity == r) {
                if (DEBUG_VISIBILITY || DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,
                        ""Prepare close transition: finishing "" + r);
                if (endTask) {
                    mService.getTaskChangeNotificationController().notifyTaskRemovalStarted(
                            task.getTaskInfo());
                }
                getDisplay().mDisplayContent.prepareAppTransition(transit, false);

                // Tell window manager to prepare for this one to be removed.
                r.setVisibility(false);

                if (mPausingActivity == null) {
                    if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, ""Finish needs to pause: "" + r);
                    if (DEBUG_USER_LEAVING) Slog.v(TAG_USER_LEAVING,
                            ""finish() => pause with userLeaving=false"");
                    startPausingLocked(false, false, null, pauseImmediately);
                }

                if (endTask) {
                    mService.getLockTaskController().clearLockedTask(task);
                }
            } else if (!r.isState(PAUSING)) {
                // If the activity is PAUSING, we will complete the finish once
                // it is done pausing; else we can just directly finish it here.
                if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, ""Finish not pausing: "" + r);
                if (r.visible) {
                    prepareActivityHideTransitionAnimation(r, transit);
                }

                final int finishMode = (r.visible || r.nowVisible) ? FINISH_AFTER_VISIBLE
                        : FINISH_AFTER_PAUSE;
                final boolean removedActivity = finishCurrentActivityLocked(r, finishMode, oomAdj,
                        ""finishActivityLocked"") == null;

                // The following code is an optimization. When the last non-task overlay activity
                // is removed from the task, we remove the entire task from the stack. However,
                // since that is done after the scheduled destroy callback from the activity, that
                // call to change the visibility of the task overlay activities would be out of
                // sync with the activitiy visibility being set for this finishing activity above.
                // In this case, we can set the visibility of all the task overlay activities when
                // we detect the last one is finishing to keep them in sync.
                if (task.onlyHasTaskOverlayActivities(true /* excludeFinishing */)) {
                    for (ActivityRecord taskOverlay : task.mActivities) {
                        if (!taskOverlay.mTaskOverlay) {
                            continue;
                        }
                        prepareActivityHideTransitionAnimation(taskOverlay, transit);
                    }
                }
                return removedActivity;
            } else {
                if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, ""Finish waiting for pause of: "" + r);
            }

            return false;
        } finally {
            mWindowManager.continueSurfaceLayout();
        }
    }

    private void prepareActivityHideTransitionAnimation(ActivityRecord r, int transit) {
        final DisplayContent dc = getDisplay().mDisplayContent;
        dc.prepareAppTransition(transit, false);
        r.setVisibility(false);
        dc.executeAppTransition();
    }

    static final int FINISH_IMMEDIATELY = 0;
    static final int FINISH_AFTER_PAUSE = 1;
    static final int FINISH_AFTER_VISIBLE = 2;

    final ActivityRecord finishCurrentActivityLocked(ActivityRecord r, int mode, boolean oomAdj,
            String reason) {
        // First things first: if this activity is currently visible,
        // and the resumed activity is not yet visible, then hold off on
        // finishing until the resumed one becomes visible.

        // The activity that we are finishing may be over the lock screen. In this case, we do not
        // want to consider activities that cannot be shown on the lock screen as running and should
        // proceed with finishing the activity if there is no valid next top running activity.
        // Note that if this finishing activity is floating task, we don't need to wait the
        // next activity resume and can destroy it directly.
        final ActivityDisplay display = getDisplay();
        final ActivityRecord next = display.topRunningActivity(true /* considerKeyguardState */);
        final boolean isFloating = r.getConfiguration().windowConfiguration.tasksAreFloating();

        if (mode == FINISH_AFTER_VISIBLE && (r.visible || r.nowVisible)
                && next != null && !next.nowVisible && !isFloating) {
            if (!mStackSupervisor.mStoppingActivities.contains(r)) {
                addToStopping(r, false /* scheduleIdle */, false /* idleDelayed */,
                        ""finishCurrentActivityLocked"");
            }
            if (DEBUG_STATES) Slog.v(TAG_STATES,
                    ""Moving to STOPPING: ""+ r + "" (finish requested)"");
            if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
                mActivityPluginDelegate.activitySuspendNotification
                    (r.appInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
            }
            r.setState(STOPPING, ""finishCurrentActivityLocked"");
            if (oomAdj) {
                mService.updateOomAdj();
            }
            return r;
        }

        // make sure the record is cleaned out of other places.
        mStackSupervisor.mStoppingActivities.remove(r);
        mStackSupervisor.mGoingToSleepActivities.remove(r);
        final ActivityState prevState = r.getState();
        if (DEBUG_STATES) Slog.v(TAG_STATES, ""Moving to FINISHING: "" + r);

        if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
            mActivityPluginDelegate.activitySuspendNotification
                (r.appInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
        }

        r.setState(FINISHING, ""finishCurrentActivityLocked"");

        // Don't destroy activity immediately if the display contains home stack, although there is
        // no next activity at the moment but another home activity should be started later. Keep
        // this activity alive until next home activity is resumed then user won't see a temporary
        // black screen.
        final boolean noRunningStack = next == null && display.topRunningActivity() == null
                && display.getHomeStack() == null;
        final boolean noFocusedStack = r.getActivityStack() != display.getFocusedStack();
        final boolean finishingInNonFocusedStackOrNoRunning = mode == FINISH_AFTER_VISIBLE
                && prevState == PAUSED && (noFocusedStack || noRunningStack);

        if (mode == FINISH_IMMEDIATELY
                || (prevState == PAUSED
                    && (mode == FINISH_AFTER_PAUSE || inPinnedWindowingMode()))
                || finishingInNonFocusedStackOrNoRunning
                || prevState == STOPPING
                || prevState == STOPPED
                || prevState == ActivityState.INITIALIZING) {
            r.makeFinishingLocked();
            boolean activityRemoved = destroyActivityLocked(r, true, ""finish-imm:"" + reason);

            if (finishingInNonFocusedStackOrNoRunning) {
                // Finishing activity that was in paused state and it was in not currently focused
                // stack, need to make something visible in its place. Also if the display does not
                // have running activity, the configuration may need to be updated for restoring
                // original orientation of the display.
                mRootActivityContainer.ensureVisibilityAndConfig(next, mDisplayId,
                        false /* markFrozenIfConfigChanged */, true /* deferResume */);
            }
            if (activityRemoved) {
                mRootActivityContainer.resumeFocusedStacksTopActivities();
            }
            if (DEBUG_CONTAINERS) Slog.d(TAG_CONTAINERS,
                    ""destroyActivityLocked: finishCurrentActivityLocked r="" + r +
                    "" destroy returned removed="" + activityRemoved);
            return activityRemoved ? null : r;
        }

        // Need to go through the full pause cycle to get this
        // activity into the stopped state and then finish it.
        if (DEBUG_ALL) Slog.v(TAG, ""Enqueueing pending finish: "" + r);
        mStackSupervisor.mFinishingActivities.add(r);
        r.resumeKeyDispatchingLocked();
        mRootActivityContainer.resumeFocusedStacksTopActivities();
        // If activity was not paused at this point - explicitly pause it to start finishing
        // process. Finishing will be completed once it reports pause back.
        if (r.isState(RESUMED) && mPausingActivity != null) {
            startPausingLocked(false /* userLeaving */, false /* uiSleeping */, next /* resuming */,
                    false /* dontWait */);
        }
        return r;
    }

    void finishAllActivitiesLocked(boolean immediately) {
","    final boolean finishActivityAffinityLocked(ActivityRecord r) {
        ArrayList<ActivityRecord> activities = r.getTaskRecord().mActivities;
        for (int index = activities.indexOf(r); index >= 0; --index) {
            ActivityRecord cur = activities.get(index);
            if (!Objects.equals(cur.taskAffinity, r.taskAffinity)) {
                break;
            }
            finishActivityLocked(cur, Activity.RESULT_CANCELED, null, ""request-affinity"", true);
        }
        return true;
    }

    private void finishActivityResultsLocked(ActivityRecord r, int resultCode, Intent resultData) {
        // send the result
        ActivityRecord resultTo = r.resultTo;
        if (resultTo != null) {
            if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, ""Adding result to "" + resultTo
                    + "" who="" + r.resultWho + "" req="" + r.requestCode
                    + "" res="" + resultCode + "" data="" + resultData);
            if (resultTo.mUserId != r.mUserId) {
                if (resultData != null) {
                    resultData.prepareToLeaveUser(r.mUserId);
                }
            }
            if (r.info.applicationInfo.uid > 0) {
                mService.mUgmInternal.grantUriPermissionFromIntent(r.info.applicationInfo.uid,
                        resultTo.packageName, resultData,
                        resultTo.getUriPermissionsLocked(), resultTo.mUserId);
            }
            resultTo.addResultLocked(r, r.resultWho, r.requestCode, resultCode, resultData);
            r.resultTo = null;
        }
        else if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, ""No result destination from "" + r);

        // Make sure this HistoryRecord is not holding on to other resources,
        // because clients have remote IPC references to this object so we
        // can't assume that will go away and want to avoid circular IPC refs.
        r.results = null;
        r.pendingResults = null;
        r.newIntents = null;
        r.icicle = null;
    }

    /**
     * See {@link #finishActivityLocked(ActivityRecord, int, Intent, String, boolean, boolean)}
     */
    final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData,
            String reason, boolean oomAdj) {
        return finishActivityLocked(r, resultCode, resultData, reason, oomAdj, !PAUSE_IMMEDIATELY);
    }

    /**
     * @return Returns true if this activity has been removed from the history
     * list, or false if it is still in the list and will be removed later.
     */
    final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData,
            String reason, boolean oomAdj, boolean pauseImmediately) {
        if (r.finishing) {
            Slog.w(TAG, ""Duplicate finish request for "" + r);
            return false;
        }

        mWindowManager.deferSurfaceLayout();
        try {
            r.makeFinishingLocked();
            final TaskRecord task = r.getTaskRecord();
            EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY,
                    r.mUserId, System.identityHashCode(r),
                    task.taskId, r.shortComponentName, reason);
            final ArrayList<ActivityRecord> activities = task.mActivities;
            final int index = activities.indexOf(r);
            if (index < (activities.size() - 1)) {
                task.setFrontOfTask();
                if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) {
                    // If the caller asked that this activity (and all above it)
                    // be cleared when the task is reset, don't lose that information,
                    // but propagate it up to the next activity.
                    ActivityRecord next = activities.get(index+1);
                    next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
                }
            }

            r.pauseKeyDispatchingLocked();

            adjustFocusedActivityStack(r, ""finishActivity"");

            finishActivityResultsLocked(r, resultCode, resultData);

            final boolean endTask = index <= 0 && !task.isClearingToReuseTask();
            final int transit = endTask ? TRANSIT_TASK_CLOSE : TRANSIT_ACTIVITY_CLOSE;
            if (mResumedActivity == r) {
                if (DEBUG_VISIBILITY || DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,
                        ""Prepare close transition: finishing "" + r);
                if (endTask) {
                    mService.getTaskChangeNotificationController().notifyTaskRemovalStarted(
                            task.getTaskInfo());
                }
                getDisplay().mDisplayContent.prepareAppTransition(transit, false);

                // Tell window manager to prepare for this one to be removed.
                r.setVisibility(false);

                if (mPausingActivity == null) {
                    if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, ""Finish needs to pause: "" + r);
                    if (DEBUG_USER_LEAVING) Slog.v(TAG_USER_LEAVING,
                            ""finish() => pause with userLeaving=false"");
                    startPausingLocked(false, false, null, pauseImmediately);
                }

                if (endTask) {
                    mService.getLockTaskController().clearLockedTask(task);
                }
            } else if (!r.isState(PAUSING)) {
                // If the activity is PAUSING, we will complete the finish once
                // it is done pausing; else we can just directly finish it here.
                if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, ""Finish not pausing: "" + r);
                if (r.visible) {
                    prepareActivityHideTransitionAnimation(r, transit);
                }

                final int finishMode = (r.visible || r.nowVisible) ? FINISH_AFTER_VISIBLE
                        : FINISH_AFTER_PAUSE;
                final boolean removedActivity = finishCurrentActivityLocked(r, finishMode, oomAdj,
                        ""finishActivityLocked"") == null;

                // The following code is an optimization. When the last non-task overlay activity
                // is removed from the task, we remove the entire task from the stack. However,
                // since that is done after the scheduled destroy callback from the activity, that
                // call to change the visibility of the task overlay activities would be out of
                // sync with the activitiy visibility being set for this finishing activity above.
                // In this case, we can set the visibility of all the task overlay activities when
                // we detect the last one is finishing to keep them in sync.
                if (task.onlyHasTaskOverlayActivities(true /* excludeFinishing */)) {
                    for (ActivityRecord taskOverlay : task.mActivities) {
                        if (!taskOverlay.mTaskOverlay) {
                            continue;
                        }
                        prepareActivityHideTransitionAnimation(taskOverlay, transit);
                    }
                }
                return removedActivity;
            } else {
                if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, ""Finish waiting for pause of: "" + r);
            }

            return false;
        } finally {
            mWindowManager.continueSurfaceLayout();
        }
    }

    private void prepareActivityHideTransitionAnimation(ActivityRecord r, int transit) {
        final DisplayContent dc = getDisplay().mDisplayContent;
        dc.prepareAppTransition(transit, false);
        r.setVisibility(false);
        dc.executeAppTransition();
    }

    static final int FINISH_IMMEDIATELY = 0;
    static final int FINISH_AFTER_PAUSE = 1;
    static final int FINISH_AFTER_VISIBLE = 2;

    final ActivityRecord finishCurrentActivityLocked(ActivityRecord r, int mode, boolean oomAdj,
            String reason) {
        // First things first: if this activity is currently visible,
        // and the resumed activity is not yet visible, then hold off on
        // finishing until the resumed one becomes visible.

        // The activity that we are finishing may be over the lock screen. In this case, we do not
        // want to consider activities that cannot be shown on the lock screen as running and should
        // proceed with finishing the activity if there is no valid next top running activity.
        // Note that if this finishing activity is floating task, we don't need to wait the
        // next activity resume and can destroy it directly.
        final ActivityDisplay display = getDisplay();
        final ActivityRecord next = display.topRunningActivity(true /* considerKeyguardState */);
        final boolean isFloating = r.getConfiguration().windowConfiguration.tasksAreFloating();

        if (mode == FINISH_AFTER_VISIBLE && (r.visible || r.nowVisible)
                && next != null && !next.nowVisible && !isFloating) {
            if (!mStackSupervisor.mStoppingActivities.contains(r)) {
                addToStopping(r, false /* scheduleIdle */, false /* idleDelayed */,
                        ""finishCurrentActivityLocked"");
            }
            if (DEBUG_STATES) Slog.v(TAG_STATES,
                    ""Moving to STOPPING: ""+ r + "" (finish requested)"");
            if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
                mActivityPluginDelegate.activitySuspendNotification
                    (r.appInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
            }
            r.setState(STOPPING, ""finishCurrentActivityLocked"");
            if (oomAdj) {
                mService.updateOomAdj();
            }
            return r;
        }

        // make sure the record is cleaned out of other places.
        mStackSupervisor.mStoppingActivities.remove(r);
        mStackSupervisor.mGoingToSleepActivities.remove(r);
        final ActivityState prevState = r.getState();
        if (DEBUG_STATES) Slog.v(TAG_STATES, ""Moving to FINISHING: "" + r);

        if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
            mActivityPluginDelegate.activitySuspendNotification
                (r.appInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
        }

        r.setState(FINISHING, ""finishCurrentActivityLocked"");

        // Don't destroy activity immediately if the display contains home stack, although there is
        // no next activity at the moment but another home activity should be started later. Keep
        // this activity alive until next home activity is resumed then user won't see a temporary
        // black screen.
        final boolean noRunningStack = next == null && display.topRunningActivity() == null
                && display.getHomeStack() == null;
        final boolean noFocusedStack = r.getActivityStack() != display.getFocusedStack();
        final boolean finishingInNonFocusedStackOrNoRunning = mode == FINISH_AFTER_VISIBLE
                && prevState == PAUSED && (noFocusedStack || noRunningStack);

        if (mode == FINISH_IMMEDIATELY
                || (prevState == PAUSED
                    && (mode == FINISH_AFTER_PAUSE || inPinnedWindowingMode()))
                || finishingInNonFocusedStackOrNoRunning
                || prevState == STOPPING
                || prevState == STOPPED
                || prevState == ActivityState.INITIALIZING) {
            r.makeFinishingLocked();
            boolean activityRemoved = destroyActivityLocked(r, true, ""finish-imm:"" + reason);

            if (finishingInNonFocusedStackOrNoRunning) {
                // Finishing activity that was in paused state and it was in not currently focused
                // stack, need to make something visible in its place. Also if the display does not
                // have running activity, the configuration may need to be updated for restoring
                // original orientation of the display.
                mRootActivityContainer.ensureVisibilityAndConfig(next, mDisplayId,
                        false /* markFrozenIfConfigChanged */, true /* deferResume */);
            }
            if (activityRemoved) {
                mRootActivityContainer.resumeFocusedStacksTopActivities();
            }
            if (DEBUG_CONTAINERS) Slog.d(TAG_CONTAINERS,
                    ""destroyActivityLocked: finishCurrentActivityLocked r="" + r +
                    "" destroy returned removed="" + activityRemoved);
            return activityRemoved ? null : r;
        }

        // Need to go through the full pause cycle to get this
        // activity into the stopped state and then finish it.
        if (DEBUG_ALL) Slog.v(TAG, ""Enqueueing pending finish: "" + r);
        mStackSupervisor.mFinishingActivities.add(r);
        r.resumeKeyDispatchingLocked();
        mRootActivityContainer.resumeFocusedStacksTopActivities();
        // If activity was not paused at this point - explicitly pause it to start finishing
        // process. Finishing will be completed once it reports pause back.
        if (r.isState(RESUMED) && mPausingActivity != null) {
            startPausingLocked(false /* userLeaving */, false /* uiSleeping */, next /* resuming */,
                    false /* dontWait */);
        }
        return r;
    }

    void finishAllActivitiesLocked(boolean immediately) {
","[1.0, 1.0]"
539,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ScreenRotationAnimation.java,"[(56, 91, 36), (56, 91, 36)]","    static final int SCREEN_FREEZE_LAYER_BASE       = WINDOW_FREEZE_LAYER + TYPE_LAYER_MULTIPLIER;
    static final int SCREEN_FREEZE_LAYER_ENTER      = SCREEN_FREEZE_LAYER_BASE;
    static final int SCREEN_FREEZE_LAYER_SCREENSHOT = SCREEN_FREEZE_LAYER_BASE + 1;
    static final int SCREEN_FREEZE_LAYER_EXIT       = SCREEN_FREEZE_LAYER_BASE + 2;
    static final int SCREEN_FREEZE_LAYER_CUSTOM     = SCREEN_FREEZE_LAYER_BASE + 3;

    private BoostFramework mPerf = null;
    private boolean mIsPerfLockAcquired = false;
    final Context mContext;
    final DisplayContent mDisplayContent;
    SurfaceControl mSurfaceControl;
    BlackFrame mCustomBlackFrame;
    BlackFrame mExitingBlackFrame;
    BlackFrame mEnteringBlackFrame;
    int mWidth, mHeight;

    int mOriginalRotation;
    int mOriginalWidth, mOriginalHeight;
    int mCurRotation;
    Rect mOriginalDisplayRect = new Rect();
    Rect mCurrentDisplayRect = new Rect();

    // For all animations, ""exit"" is for the UI elements that are going
    // away (that is the snapshot of the old screen), and ""enter"" is for
    // the new UI elements that are appearing (that is the active windows
    // in their final orientation).

    // The starting animation for the exiting and entering elements.  This
    // animation applies a transformation while the rotation is in progress.
    // It is started immediately, before the new entering UI is ready.
    Animation mStartExitAnimation;
    final Transformation mStartExitTransformation = new Transformation();
    Animation mStartEnterAnimation;
    final Transformation mStartEnterTransformation = new Transformation();
    Animation mStartFrameAnimation;
    final Transformation mStartFrameTransformation = new Transformation();
","    static final int SCREEN_FREEZE_LAYER_BASE       = WINDOW_FREEZE_LAYER + TYPE_LAYER_MULTIPLIER;
    static final int SCREEN_FREEZE_LAYER_ENTER      = SCREEN_FREEZE_LAYER_BASE;
    static final int SCREEN_FREEZE_LAYER_SCREENSHOT = SCREEN_FREEZE_LAYER_BASE + 1;
    static final int SCREEN_FREEZE_LAYER_EXIT       = SCREEN_FREEZE_LAYER_BASE + 2;
    static final int SCREEN_FREEZE_LAYER_CUSTOM     = SCREEN_FREEZE_LAYER_BASE + 3;

    private BoostFramework mPerf = null;
    private boolean mIsPerfLockAcquired = false;
    final Context mContext;
    final DisplayContent mDisplayContent;
    SurfaceControl mSurfaceControl;
    BlackFrame mCustomBlackFrame;
    BlackFrame mExitingBlackFrame;
    BlackFrame mEnteringBlackFrame;
    int mWidth, mHeight;

    int mOriginalRotation;
    int mOriginalWidth, mOriginalHeight;
    int mCurRotation;
    Rect mOriginalDisplayRect = new Rect();
    Rect mCurrentDisplayRect = new Rect();

    // For all animations, ""exit"" is for the UI elements that are going
    // away (that is the snapshot of the old screen), and ""enter"" is for
    // the new UI elements that are appearing (that is the active windows
    // in their final orientation).

    // The starting animation for the exiting and entering elements.  This
    // animation applies a transformation while the rotation is in progress.
    // It is started immediately, before the new entering UI is ready.
    Animation mStartExitAnimation;
    final Transformation mStartExitTransformation = new Transformation();
    Animation mStartEnterAnimation;
    final Transformation mStartEnterTransformation = new Transformation();
    Animation mStartFrameAnimation;
    final Transformation mStartFrameTransformation = new Transformation();
","    static final int SCREEN_FREEZE_LAYER_BASE       = WINDOW_FREEZE_LAYER + TYPE_LAYER_MULTIPLIER;
    static final int SCREEN_FREEZE_LAYER_ENTER      = SCREEN_FREEZE_LAYER_BASE;
    static final int SCREEN_FREEZE_LAYER_SCREENSHOT = SCREEN_FREEZE_LAYER_BASE + 1;
    static final int SCREEN_FREEZE_LAYER_EXIT       = SCREEN_FREEZE_LAYER_BASE + 2;
    static final int SCREEN_FREEZE_LAYER_CUSTOM     = SCREEN_FREEZE_LAYER_BASE + 3;

    private BoostFramework mPerf = null;
    private boolean mIsPerfLockAcquired = false;
    final Context mContext;
    final DisplayContent mDisplayContent;
    SurfaceControl mSurfaceControl;
    BlackFrame mCustomBlackFrame;
    BlackFrame mExitingBlackFrame;
    BlackFrame mEnteringBlackFrame;
    int mWidth, mHeight;

    int mOriginalRotation;
    int mOriginalWidth, mOriginalHeight;
    int mCurRotation;
    Rect mOriginalDisplayRect = new Rect();
    Rect mCurrentDisplayRect = new Rect();

    // For all animations, ""exit"" is for the UI elements that are going
    // away (that is the snapshot of the old screen), and ""enter"" is for
    // the new UI elements that are appearing (that is the active windows
    // in their final orientation).

    // The starting animation for the exiting and entering elements.  This
    // animation applies a transformation while the rotation is in progress.
    // It is started immediately, before the new entering UI is ready.
    Animation mStartExitAnimation;
    final Transformation mStartExitTransformation = new Transformation();
    Animation mStartEnterAnimation;
    final Transformation mStartEnterTransformation = new Transformation();
    Animation mStartFrameAnimation;
    final Transformation mStartFrameTransformation = new Transformation();
","[1.0, 1.0]"
540,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ScreenRotationAnimation.java,"[(854, 878, 25), (854, 878, 25)]","        if (USE_CUSTOM_BLACK_FRAME && !mMoreStartFrame && !mMoreRotateFrame && !mMoreFinishFrame) {
            if (mStartFrameAnimation != null) {
                if (DEBUG_STATE) Slog.v(TAG, ""Frame animations done, clearing start frame anim!"");
                mStartFrameAnimation.cancel();
                mStartFrameAnimation = null;
                mStartFrameTransformation.clear();
            }
            if (mFinishFrameAnimation != null) {
                if (DEBUG_STATE) Slog.v(TAG, ""Frame animations done, clearing finish frame anim!"");
                mFinishFrameAnimation.cancel();
                mFinishFrameAnimation = null;
                mFinishFrameTransformation.clear();
            }
            if (mRotateFrameAnimation != null) {
                if (DEBUG_STATE) Slog.v(TAG, ""Frame animations done, clearing rotate frame anim!"");
                mRotateFrameAnimation.cancel();
                mRotateFrameAnimation = null;
                mRotateFrameTransformation.clear();
            }
            if (mPerf != null && mIsPerfLockAcquired) {
                mPerf.perfLockRelease();
                mIsPerfLockAcquired = false;
            }
        }

","        if (USE_CUSTOM_BLACK_FRAME && !mMoreStartFrame && !mMoreRotateFrame && !mMoreFinishFrame) {
            if (mStartFrameAnimation != null) {
                if (DEBUG_STATE) Slog.v(TAG, ""Frame animations done, clearing start frame anim!"");
                mStartFrameAnimation.cancel();
                mStartFrameAnimation = null;
                mStartFrameTransformation.clear();
            }
            if (mFinishFrameAnimation != null) {
                if (DEBUG_STATE) Slog.v(TAG, ""Frame animations done, clearing finish frame anim!"");
                mFinishFrameAnimation.cancel();
                mFinishFrameAnimation = null;
                mFinishFrameTransformation.clear();
            }
            if (mRotateFrameAnimation != null) {
                if (DEBUG_STATE) Slog.v(TAG, ""Frame animations done, clearing rotate frame anim!"");
                mRotateFrameAnimation.cancel();
                mRotateFrameAnimation = null;
                mRotateFrameTransformation.clear();
            }
            if (mPerf != null && mIsPerfLockAcquired) {
                mPerf.perfLockRelease();
                mIsPerfLockAcquired = false;
            }
        }

","        if (USE_CUSTOM_BLACK_FRAME && !mMoreStartFrame && !mMoreRotateFrame && !mMoreFinishFrame) {
            if (mStartFrameAnimation != null) {
                if (DEBUG_STATE) Slog.v(TAG, ""Frame animations done, clearing start frame anim!"");
                mStartFrameAnimation.cancel();
                mStartFrameAnimation = null;
                mStartFrameTransformation.clear();
            }
            if (mFinishFrameAnimation != null) {
                if (DEBUG_STATE) Slog.v(TAG, ""Frame animations done, clearing finish frame anim!"");
                mFinishFrameAnimation.cancel();
                mFinishFrameAnimation = null;
                mFinishFrameTransformation.clear();
            }
            if (mRotateFrameAnimation != null) {
                if (DEBUG_STATE) Slog.v(TAG, ""Frame animations done, clearing rotate frame anim!"");
                mRotateFrameAnimation.cancel();
                mRotateFrameAnimation = null;
                mRotateFrameTransformation.clear();
            }
            if (mPerf != null && mIsPerfLockAcquired) {
                mPerf.perfLockRelease();
                mIsPerfLockAcquired = false;
            }
        }

","[1.0, 1.0]"
541,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/view/ViewRootImpl.java,"[(612, 613, 2), (612, 613, 2)]","    boolean mHaveMoveEvent = false;

","    boolean mHaveMoveEvent = false;

","    boolean mHaveMoveEvent = false;

","[1.0, 1.0]"
542,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(16283, 16285, 3), (16283, 16285, 3)]","        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
        synchronized (mPackages) {
","        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
        synchronized (mPackages) {
","        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
        synchronized (mPackages) {
","[1.0, 1.0]"
543,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(22684, 22688, 5), (22684, 22688, 5)]","        final StorageManager sm = mContext.getSystemService(StorageManager.class);
        final UserManager um = mContext.getSystemService(UserManager.class);
        UserManagerInternal umInternal = getUserManagerInternal();
        for (UserInfo user : um.getUsers()) {
            int flags = 0;
","        final StorageManager sm = mContext.getSystemService(StorageManager.class);
        final UserManager um = mContext.getSystemService(UserManager.class);
        UserManagerInternal umInternal = getUserManagerInternal();
        for (UserInfo user : um.getUsers()) {
            int flags = 0;
","        final StorageManager sm = mContext.getSystemService(StorageManager.class);
        final UserManager um = mContext.getSystemService(UserManager.class);
        UserManagerInternal umInternal = getUserManagerInternal();
        for (UserInfo user : um.getUsers()) {
            int flags = 0;
","[1.0, 1.0]"
544,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/com/android/internal/widget/LockPatternUtils.java,"[(1254, 1270, 17), (1254, 1270, 17)]","    }

    /**
     * Transform a pattern byte array to base zero form.
     * @param bytes pattern byte array.
     * @return The pattern in base zero form.
     */
    public static byte[] patternByteArrayToBaseZero(byte[] bytes) {
        if (bytes == null) {
            return new byte[0];
        }
        final int patternSize = bytes.length;
        byte[] res = new byte[patternSize];
        for (int i = 0; i < patternSize; i++) {
            res[i] = (byte) (bytes[i] - '1');
        }
        return res;
","    }

    /**
     * Transform a pattern byte array to base zero form.
     * @param bytes pattern byte array.
     * @return The pattern in base zero form.
     */
    public static byte[] patternByteArrayToBaseZero(byte[] bytes) {
        if (bytes == null) {
            return new byte[0];
        }
        final int patternSize = bytes.length;
        byte[] res = new byte[patternSize];
        for (int i = 0; i < patternSize; i++) {
            res[i] = (byte) (bytes[i] - '1');
        }
        return res;
","    }

    /**
     * Transform a pattern byte array to base zero form.
     * @param bytes pattern byte array.
     * @return The pattern in base zero form.
     */
    public static byte[] patternByteArrayToBaseZero(byte[] bytes) {
        if (bytes == null) {
            return new byte[0];
        }
        final int patternSize = bytes.length;
        byte[] res = new byte[patternSize];
        for (int i = 0; i < patternSize; i++) {
            res[i] = (byte) (bytes[i] - '1');
        }
        return res;
","[1.0, 1.0]"
545,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/WifiDisplayController.java,"[(102, 102, 1), (102, 102, 1)]","    private final WifiP2pManager mWifiP2pManager;
","    private final WifiP2pManager mWifiP2pManager;
","    private final WifiP2pManager mWifiP2pManager;
","[1.0, 1.0]"
546,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/WifiDisplayController.java,"[(176, 177, 2), (176, 177, 2)]","        mWifiP2pManager = (WifiP2pManager)context.getSystemService(Context.WIFI_P2P_SERVICE);

","        mWifiP2pManager = (WifiP2pManager)context.getSystemService(Context.WIFI_P2P_SERVICE);

","        mWifiP2pManager = (WifiP2pManager)context.getSystemService(Context.WIFI_P2P_SERVICE);

","[1.0, 1.0]"
547,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/WifiDisplayController.java,"[(202, 209, 8), (202, 209, 8)]","    private Channel getWifiP2pChannel() {
        if(mWifiP2pChannel == null) {
            mWifiP2pChannel = mWifiP2pManager.initialize(mContext, mHandler.getLooper(), null);
            if(DEBUG) {
                Slog.d(TAG, ""Creating WifiP2pChannel"");
            }
        }
        return mWifiP2pChannel;
","    private Channel getWifiP2pChannel() {
        if(mWifiP2pChannel == null) {
            mWifiP2pChannel = mWifiP2pManager.initialize(mContext, mHandler.getLooper(), null);
            if(DEBUG) {
                Slog.d(TAG, ""Creating WifiP2pChannel"");
            }
        }
        return mWifiP2pChannel;
","    private Channel getWifiP2pChannel() {
        if(mWifiP2pChannel == null) {
            mWifiP2pChannel = mWifiP2pManager.initialize(mContext, mHandler.getLooper(), null);
            if(DEBUG) {
                Slog.d(TAG, ""Creating WifiP2pChannel"");
            }
        }
        return mWifiP2pChannel;
","[1.0, 1.0]"
548,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/notification/row/wrapper/NotificationMediaTemplateViewWrapper.java,"[(72, 72, 1), (72, 72, 1)]","    private boolean mOnPreDrawListenerRegistered = false;
","    private boolean mOnPreDrawListenerRegistered = false;
","    private boolean mOnPreDrawListenerRegistered = false;
","[1.0, 1.0]"
549,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/notification/row/wrapper/NotificationMediaTemplateViewWrapper.java,"[(224, 239, 16), (224, 239, 16)]","        addOnPreDrawListener();
    }


    private void addOnPreDrawListener() {
        if ( !mOnPreDrawListenerRegistered ) {
            mOnPreDrawListenerRegistered = true;
            mSeekBarView.getViewTreeObserver().addOnPreDrawListener(mPreDrawListener);
        }
    }

    private void removeOnPreDrawListener() {
        if ( mOnPreDrawListenerRegistered ) {
            mSeekBarView.getViewTreeObserver().removeOnPreDrawListener(mPreDrawListener);
            mHandler.postDelayed(mOnUpdateTimerTick, PROGRESS_UPDATE_INTERVAL);
            mOnPreDrawListenerRegistered = false;
","        addOnPreDrawListener();
    }


    private void addOnPreDrawListener() {
        if ( !mOnPreDrawListenerRegistered ) {
            mOnPreDrawListenerRegistered = true;
            mSeekBarView.getViewTreeObserver().addOnPreDrawListener(mPreDrawListener);
        }
    }

    private void removeOnPreDrawListener() {
        if ( mOnPreDrawListenerRegistered ) {
            mSeekBarView.getViewTreeObserver().removeOnPreDrawListener(mPreDrawListener);
            mHandler.postDelayed(mOnUpdateTimerTick, PROGRESS_UPDATE_INTERVAL);
            mOnPreDrawListenerRegistered = false;
","        addOnPreDrawListener();
    }


    private void addOnPreDrawListener() {
        if ( !mOnPreDrawListenerRegistered ) {
            mOnPreDrawListenerRegistered = true;
            mSeekBarView.getViewTreeObserver().addOnPreDrawListener(mPreDrawListener);
        }
    }

    private void removeOnPreDrawListener() {
        if ( mOnPreDrawListenerRegistered ) {
            mSeekBarView.getViewTreeObserver().removeOnPreDrawListener(mPreDrawListener);
            mHandler.postDelayed(mOnUpdateTimerTick, PROGRESS_UPDATE_INTERVAL);
            mOnPreDrawListenerRegistered = false;
","[1.0, 1.0]"
550,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/WiredAccessoryManager.java,"[(797, 797, 1), (797, 797, 1)]","                updateLocked(name, """", mHeadsetState | (mask & state) & ~(mask & ~state));
","                updateLocked(name, """", mHeadsetState | (mask & state) & ~(mask & ~state));
","                updateLocked(name, """", mHeadsetState | (mask & state) & ~(mask & ~state));
","[1.0, 1.0]"
551,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/CarrierTextController.java,"[(77, 79, 3), (77, 79, 3)]","    @VisibleForTesting
    protected boolean mDisplayOpportunisticSubscriptionCarrierText;
    private FiveGServiceClient mFiveGServiceClient;
","    @VisibleForTesting
    protected boolean mDisplayOpportunisticSubscriptionCarrierText;
    private FiveGServiceClient mFiveGServiceClient;
","    @VisibleForTesting
    protected boolean mDisplayOpportunisticSubscriptionCarrierText;
    private FiveGServiceClient mFiveGServiceClient;
","[1.0, 1.0]"
552,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/OomAdjuster.java,"[(184, 195, 12), (184, 195, 12)]","        if(mPerf != null) {
            mMinBServiceAgingTime = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bservice_age"", ""5000""));
            mBServiceAppThreshold = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bservice_limit"", ""5""));
            mEnableBServicePropagation = Boolean.parseBoolean(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bservice_enable"", ""false""));
        }

        // The process group is usually critical to the response time of foreground app, so the
        // setter should apply it as soon as possible.
        final ServiceThread adjusterThread = new ServiceThread(TAG, TOP_APP_PRIORITY_BOOST,
                false /* allowIo */);
        adjusterThread.start();
        Process.setThreadGroupAndCpuset(adjusterThread.getThreadId(), THREAD_GROUP_TOP_APP);
","        if(mPerf != null) {
            mMinBServiceAgingTime = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bservice_age"", ""5000""));
            mBServiceAppThreshold = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bservice_limit"", ""5""));
            mEnableBServicePropagation = Boolean.parseBoolean(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bservice_enable"", ""false""));
        }

        // The process group is usually critical to the response time of foreground app, so the
        // setter should apply it as soon as possible.
        final ServiceThread adjusterThread = new ServiceThread(TAG, TOP_APP_PRIORITY_BOOST,
                false /* allowIo */);
        adjusterThread.start();
        Process.setThreadGroupAndCpuset(adjusterThread.getThreadId(), THREAD_GROUP_TOP_APP);
","        if(mPerf != null) {
            mMinBServiceAgingTime = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bservice_age"", ""5000""));
            mBServiceAppThreshold = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bservice_limit"", ""5""));
            mEnableBServicePropagation = Boolean.parseBoolean(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bservice_enable"", ""false""));
        }

        // The process group is usually critical to the response time of foreground app, so the
        // setter should apply it as soon as possible.
        final ServiceThread adjusterThread = new ServiceThread(TAG, TOP_APP_PRIORITY_BOOST,
                false /* allowIo */);
        adjusterThread.start();
        Process.setThreadGroupAndCpuset(adjusterThread.getThreadId(), THREAD_GROUP_TOP_APP);
","[1.0, 1.0]"
553,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(343, 436, 94), (343, 436, 94)]","    /** @hide */
    public static final int QOS_UNAVAILABLE = 78;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 79;
    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 80;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 81;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 82;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 85;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 86;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 87;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 88;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 89;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 90;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 91;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 94;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 95;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 96;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 97;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 98;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 99;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 100;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 101;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 102;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 103;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 106;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 107;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 108;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 109;
    /** @hide */
    public static final int CALL_REJECTED = 110;
    /** @hide */
    public static final int NUMBER_CHANGED = 111;
    /** @hide */
    public static final int PREEMPTION = 112;
    /** @hide */
    public static final int FACILITY_REJECTED = 113;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 114;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 115;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 116;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 117;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 118;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 119;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 120;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 121;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 122;
","    /** @hide */
    public static final int QOS_UNAVAILABLE = 78;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 79;
    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 80;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 81;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 82;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 85;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 86;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 87;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 88;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 89;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 90;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 91;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 94;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 95;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 96;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 97;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 98;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 99;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 100;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 101;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 102;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 103;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 106;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 107;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 108;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 109;
    /** @hide */
    public static final int CALL_REJECTED = 110;
    /** @hide */
    public static final int NUMBER_CHANGED = 111;
    /** @hide */
    public static final int PREEMPTION = 112;
    /** @hide */
    public static final int FACILITY_REJECTED = 113;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 114;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 115;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 116;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 117;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 118;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 119;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 120;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 121;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 122;
","    /** @hide */
    public static final int QOS_UNAVAILABLE = 78;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 79;
    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 80;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 81;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 82;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 85;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 86;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 87;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 88;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 89;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 90;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 91;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 94;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 95;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 96;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 97;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 98;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 99;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 100;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 101;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 102;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 103;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 106;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 107;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 108;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 109;
    /** @hide */
    public static final int CALL_REJECTED = 110;
    /** @hide */
    public static final int NUMBER_CHANGED = 111;
    /** @hide */
    public static final int PREEMPTION = 112;
    /** @hide */
    public static final int FACILITY_REJECTED = 113;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 114;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 115;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 116;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 117;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 118;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 119;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 120;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 121;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 122;
","[1.0, 1.0]"
554,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(651, 714, 64), (651, 714, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
555,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,"[(60, 64, 5), (60, 64, 5)]","        if (wifiManager != null) {
            wifiManager.registerTrafficStateCallback(new WifiTrafficStateCallback(), null);
        }

        mDefaultWifiIconGroup = new IconGroup(
","        if (wifiManager != null) {
            wifiManager.registerTrafficStateCallback(new WifiTrafficStateCallback(), null);
        }

        mDefaultWifiIconGroup = new IconGroup(
","        if (wifiManager != null) {
            wifiManager.registerTrafficStateCallback(new WifiTrafficStateCallback(), null);
        }

        mDefaultWifiIconGroup = new IconGroup(
","[1.0, 1.0]"
556,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(980, 1044, 65), (980, 1044, 65)]","        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
","        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
","        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
","[1.0, 1.0]"
557,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 22, 4), (19, 22, 4)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","[1.0, 1.0]"
558,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(2069, 2075, 7), (2069, 2075, 7)]","        for (int j = 0; j < mCallbacks.size(); j++) {
            KeyguardUpdateMonitorCallback cb = mCallbacks.get(j).get();
            if (cb != null) {
                cb.onRefreshCarrierInfo();
                cb.onServiceStateChanged(subId, serviceState);
            }
        }
","        for (int j = 0; j < mCallbacks.size(); j++) {
            KeyguardUpdateMonitorCallback cb = mCallbacks.get(j).get();
            if (cb != null) {
                cb.onRefreshCarrierInfo();
                cb.onServiceStateChanged(subId, serviceState);
            }
        }
","        for (int j = 0; j < mCallbacks.size(); j++) {
            KeyguardUpdateMonitorCallback cb = mCallbacks.get(j).get();
            if (cb != null) {
                cb.onRefreshCarrierInfo();
                cb.onServiceStateChanged(subId, serviceState);
            }
        }
","[1.0, 1.0]"
559,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/WindowManagerService.java,"[(5471, 5484, 14), (5471, 5484, 14)]","        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
        if (mPerf != null) {
            mPerf.perfHint(BoostFramework.VENDOR_HINT_ROTATION_LATENCY_BOOST, null);
        }
        if (CUSTOM_SCREEN_ROTATION) {
            mExitAnimId = exitAnim;
            mEnterAnimId = enterAnim;
            ScreenRotationAnimation screenRotationAnimation =
                    mAnimator.getScreenRotationAnimationLocked(mFrozenDisplayId);
            if (screenRotationAnimation != null) {
                screenRotationAnimation.kill();
            }
","        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
        if (mPerf != null) {
            mPerf.perfHint(BoostFramework.VENDOR_HINT_ROTATION_LATENCY_BOOST, null);
        }
        if (CUSTOM_SCREEN_ROTATION) {
            mExitAnimId = exitAnim;
            mEnterAnimId = enterAnim;
            ScreenRotationAnimation screenRotationAnimation =
                    mAnimator.getScreenRotationAnimationLocked(mFrozenDisplayId);
            if (screenRotationAnimation != null) {
                screenRotationAnimation.kill();
            }
","        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
        if (mPerf != null) {
            mPerf.perfHint(BoostFramework.VENDOR_HINT_ROTATION_LATENCY_BOOST, null);
        }
        if (CUSTOM_SCREEN_ROTATION) {
            mExitAnimId = exitAnim;
            mEnterAnimId = enterAnim;
            ScreenRotationAnimation screenRotationAnimation =
                    mAnimator.getScreenRotationAnimationLocked(mFrozenDisplayId);
            if (screenRotationAnimation != null) {
                screenRotationAnimation.kill();
            }
","[1.0, 1.0]"
560,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java,"[(1215, 1215, 1), (1215, 1215, 1)]","                new Handler(), mKeyguardUpdateMonitor, Dependency.get(TunerService.class));
","                new Handler(), mKeyguardUpdateMonitor, Dependency.get(TunerService.class));
","                new Handler(), mKeyguardUpdateMonitor, Dependency.get(TunerService.class));
","[1.0, 1.0]"
561,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/java/com/android/server/SystemServer.java,"[(1398, 1426, 29), (1398, 1426, 29)]","            if (enableWigig) {
                try {
                    Slog.i(TAG, ""Wigig Service"");
                    String wigigClassPath =
                        ""/system/framework/wigig-service.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.supptunnel-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.netperftuner-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.capabilityconfigstore-V1.0-java.jar"";
                    PathClassLoader wigigClassLoader =
                            new PathClassLoader(wigigClassPath, getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl"");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigP2pServiceImpl class"");
                    ServiceManager.addService(""wigigp2p"", (IBinder) wigigP2pService);

                    Class wigigClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.WigigService"");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigService class"");
                    ServiceManager.addService(""wigig"", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf(""starting WigigService"", e);
                }
            }

            traceBeginAndSlog(""StartNsdService"");
","            if (enableWigig) {
                try {
                    Slog.i(TAG, ""Wigig Service"");
                    String wigigClassPath =
                        ""/system/framework/wigig-service.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.supptunnel-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.netperftuner-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.capabilityconfigstore-V1.0-java.jar"";
                    PathClassLoader wigigClassLoader =
                            new PathClassLoader(wigigClassPath, getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl"");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigP2pServiceImpl class"");
                    ServiceManager.addService(""wigigp2p"", (IBinder) wigigP2pService);

                    Class wigigClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.WigigService"");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigService class"");
                    ServiceManager.addService(""wigig"", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf(""starting WigigService"", e);
                }
            }

            traceBeginAndSlog(""StartNsdService"");
","            if (enableWigig) {
                try {
                    Slog.i(TAG, ""Wigig Service"");
                    String wigigClassPath =
                        ""/system/framework/wigig-service.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.supptunnel-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.netperftuner-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.capabilityconfigstore-V1.0-java.jar"";
                    PathClassLoader wigigClassLoader =
                            new PathClassLoader(wigigClassPath, getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl"");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigP2pServiceImpl class"");
                    ServiceManager.addService(""wigigp2p"", (IBinder) wigigP2pService);

                    Class wigigClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.WigigService"");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigService class"");
                    ServiceManager.addService(""wigig"", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf(""starting WigigService"", e);
                }
            }

            traceBeginAndSlog(""StartNsdService"");
","[1.0, 1.0]"
562,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/java/com/android/server/SystemServer.java,"[(1981, 2001, 21), (1981, 2001, 21)]","        // Wigig services are not registered as system services because of class loader
        // limitations, send boot phase notification separately
        if (enableWigig) {
            try {
                Slog.i(TAG, ""calling onBootPhase for Wigig Services"");
                Class wigigP2pClass = wigigP2pService.getClass();
                Method m = wigigP2pClass.getMethod(""onBootPhase"", int.class);
                m.invoke(wigigP2pService, new Integer(
                    SystemService.PHASE_SYSTEM_SERVICES_READY));

                Class wigigClass = wigigService.getClass();
                m = wigigClass.getMethod(""onBootPhase"", int.class);
                m.invoke(wigigService, new Integer(
                    SystemService.PHASE_SYSTEM_SERVICES_READY));
            } catch (Throwable e) {
                reportWtf(""Wigig services ready"", e);
            }
        }

        traceBeginAndSlog(""MakeWindowManagerServiceReady"");

","        // Wigig services are not registered as system services because of class loader
        // limitations, send boot phase notification separately
        if (enableWigig) {
            try {
                Slog.i(TAG, ""calling onBootPhase for Wigig Services"");
                Class wigigP2pClass = wigigP2pService.getClass();
                Method m = wigigP2pClass.getMethod(""onBootPhase"", int.class);
                m.invoke(wigigP2pService, new Integer(
                    SystemService.PHASE_SYSTEM_SERVICES_READY));

                Class wigigClass = wigigService.getClass();
                m = wigigClass.getMethod(""onBootPhase"", int.class);
                m.invoke(wigigService, new Integer(
                    SystemService.PHASE_SYSTEM_SERVICES_READY));
            } catch (Throwable e) {
                reportWtf(""Wigig services ready"", e);
            }
        }

        traceBeginAndSlog(""MakeWindowManagerServiceReady"");

","        // Wigig services are not registered as system services because of class loader
        // limitations, send boot phase notification separately
        if (enableWigig) {
            try {
                Slog.i(TAG, ""calling onBootPhase for Wigig Services"");
                Class wigigP2pClass = wigigP2pService.getClass();
                Method m = wigigP2pClass.getMethod(""onBootPhase"", int.class);
                m.invoke(wigigP2pService, new Integer(
                    SystemService.PHASE_SYSTEM_SERVICES_READY));

                Class wigigClass = wigigService.getClass();
                m = wigigClass.getMethod(""onBootPhase"", int.class);
                m.invoke(wigigService, new Integer(
                    SystemService.PHASE_SYSTEM_SERVICES_READY));
            } catch (Throwable e) {
                reportWtf(""Wigig services ready"", e);
            }
        }

        traceBeginAndSlog(""MakeWindowManagerServiceReady"");

","[1.0, 1.0]"
563,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(953, 957, 5), (953, 957, 5)]","    private static final int MSG_L_HEARING_AID_DEVICE_CONNECTION_CHANGE_EXT = 28;
    // process external command to (dis)connect or change active A2DP device
    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = 29;
    // a ScoClient died in BtHelper
    private static final int MSG_L_SCOCLIENT_DIED = 30;
","    private static final int MSG_L_HEARING_AID_DEVICE_CONNECTION_CHANGE_EXT = 28;
    // process external command to (dis)connect or change active A2DP device
    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = 29;
    // a ScoClient died in BtHelper
    private static final int MSG_L_SCOCLIENT_DIED = 30;
","    private static final int MSG_L_HEARING_AID_DEVICE_CONNECTION_CHANGE_EXT = 28;
    // process external command to (dis)connect or change active A2DP device
    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = 29;
    // a ScoClient died in BtHelper
    private static final int MSG_L_SCOCLIENT_DIED = 30;
","[1.0, 1.0]"
564,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(338, 338, 1), (338, 338, 1)]","        } catch (NoSuchAlgorithmException | RemoteException e) {
","        } catch (NoSuchAlgorithmException | RemoteException e) {
","        } catch (NoSuchAlgorithmException | RemoteException e) {
","[1.0, 1.0]"
565,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(628, 641, 14), (628, 641, 14)]","            try {
                final long handle = getSyntheticPasswordHandleLocked(userId);
                final byte[] noCredential = null;
                AuthenticationResult result =
                        mSpManager.unwrapPasswordBasedSyntheticPassword(
                                getGateKeeperService(), handle, noCredential, userId, null);
                if (result.authToken != null) {
                    Slog.i(TAG, ""Retrieved auth token for user "" + userId);
                    onAuthTokenKnownForUser(userId, result.authToken);
                } else {
                    Slog.e(TAG, ""Auth token not available for user "" + userId);
                }
            } catch (RemoteException e) {
                Slog.e(TAG, ""Failure retrieving auth token"", e);
","            try {
                final long handle = getSyntheticPasswordHandleLocked(userId);
                final byte[] noCredential = null;
                AuthenticationResult result =
                        mSpManager.unwrapPasswordBasedSyntheticPassword(
                                getGateKeeperService(), handle, noCredential, userId, null);
                if (result.authToken != null) {
                    Slog.i(TAG, ""Retrieved auth token for user "" + userId);
                    onAuthTokenKnownForUser(userId, result.authToken);
                } else {
                    Slog.e(TAG, ""Auth token not available for user "" + userId);
                }
            } catch (RemoteException e) {
                Slog.e(TAG, ""Failure retrieving auth token"", e);
","            try {
                final long handle = getSyntheticPasswordHandleLocked(userId);
                final byte[] noCredential = null;
                AuthenticationResult result =
                        mSpManager.unwrapPasswordBasedSyntheticPassword(
                                getGateKeeperService(), handle, noCredential, userId, null);
                if (result.authToken != null) {
                    Slog.i(TAG, ""Retrieved auth token for user "" + userId);
                    onAuthTokenKnownForUser(userId, result.authToken);
                } else {
                    Slog.e(TAG, ""Auth token not available for user "" + userId);
                }
            } catch (RemoteException e) {
                Slog.e(TAG, ""Failure retrieving auth token"", e);
","[1.0, 1.0]"
566,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1122, 1160, 39), (1122, 1160, 39)]","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

","[1.0, 1.0]"
567,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1342, 1342, 1), (1342, 1342, 1)]","            Map<Integer, byte[]> profilePasswordMap) throws RemoteException {
","            Map<Integer, byte[]> profilePasswordMap) throws RemoteException {
","            Map<Integer, byte[]> profilePasswordMap) throws RemoteException {
","[1.0, 1.0]"
568,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1482, 1482, 1), (1482, 1482, 1)]","            boolean isLockTiedToParent) throws RemoteException {
","            boolean isLockTiedToParent) throws RemoteException {
","            boolean isLockTiedToParent) throws RemoteException {
","[1.0, 1.0]"
569,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1482, 1482, 1), (2718, 2718, 1)]","            boolean isLockTiedToParent) throws RemoteException {
","            boolean allowUntrustedChange, boolean isLockTiedToParent) throws RemoteException {
"," boolean isLockTiedToParent) throws RemoteException {
","[0.831, 0.568]"
570,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1557, 1558, 2), (1557, 1558, 2)]","            GateKeeperResponse gkResponse = getGateKeeperService()
                    .verifyChallenge(userId, 0, willStore.hash, credential);
","            GateKeeperResponse gkResponse = getGateKeeperService()
                    .verifyChallenge(userId, 0, willStore.hash, credential);
","            GateKeeperResponse gkResponse = getGateKeeperService()
                    .verifyChallenge(userId, 0, willStore.hash, credential);
","[1.0, 1.0]"
571,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1637, 1641, 5), (1637, 1641, 5)]","            byte[] enrolledCredential, byte[] toEnroll, int userId)
            throws RemoteException {
        checkWritePermission(userId);
        GateKeeperResponse response = getGateKeeperService().enroll(userId, enrolledHandle,
                enrolledCredential, toEnroll);
","            byte[] enrolledCredential, byte[] toEnroll, int userId)
            throws RemoteException {
        checkWritePermission(userId);
        GateKeeperResponse response = getGateKeeperService().enroll(userId, enrolledHandle,
                enrolledCredential, toEnroll);
","            byte[] enrolledCredential, byte[] toEnroll, int userId)
            throws RemoteException {
        checkWritePermission(userId);
        GateKeeperResponse response = getGateKeeperService().enroll(userId, enrolledHandle,
                enrolledCredential, toEnroll);
","[1.0, 1.0]"
572,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1662, 1663, 2), (1662, 1663, 2)]","    private void setUserKeyProtection(int userId, byte[] credential, VerifyCredentialResponse vcr)
            throws RemoteException {
","    private void setUserKeyProtection(int userId, byte[] credential, VerifyCredentialResponse vcr)
            throws RemoteException {
","    private void setUserKeyProtection(int userId, byte[] credential, VerifyCredentialResponse vcr)
            throws RemoteException {
","[1.0, 1.0]"
573,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1684, 1696, 13), (1684, 1696, 13)]","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(byte[] credential) throws RemoteException {
","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(byte[] credential) throws RemoteException {
","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(byte[] credential) throws RemoteException {
","[1.0, 1.0]"
574,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1797, 1807, 11), (1797, 1807, 11)]","            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
        checkPasswordReadPermission(userId);
        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        false, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
        checkPasswordReadPermission(userId);
        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        false, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
        checkPasswordReadPermission(userId);
        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        false, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","[1.0, 1.0]"
575,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1812, 1812, 1), (1812, 1812, 1)]","            int userId) throws RemoteException {
","            int userId) throws RemoteException {
","            int userId) throws RemoteException {
","[1.0, 1.0]"
576,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1812, 1812, 1), (1883, 1883, 1)]","            int userId) throws RemoteException {
","            long challenge, int userId) throws RemoteException {
"," int userId) throws RemoteException {
","[0.776, 0.585]"
577,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1823, 1824, 2), (1823, 1824, 2)]","            boolean hasChallenge, long challenge, int userId,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
","            boolean hasChallenge, long challenge, int userId,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
","            boolean hasChallenge, long challenge, int userId,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
","[1.0, 1.0]"
578,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1823, 1824, 2), (1924, 1925, 2)]","            boolean hasChallenge, long challenge, int userId,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
","            byte[] credential, boolean hasChallenge, long challenge,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
",",
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
","[0.6, 0.573]"
579,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1823, 1824, 2), (2555, 2557, 3)]","            boolean hasChallenge, long challenge, int userId,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
","            @CredentialType int credentialType, boolean hasChallenge, long challenge, int userId,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""spBasedDoVerifyCredential: user="" + userId);
"," boolean hasChallenge, long challenge, int userId,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
","[0.927, 0.529]"
580,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1856, 1867, 12), (1856, 1867, 12)]","        boolean shouldReEnrollBaseZero = storedHash.type == CREDENTIAL_TYPE_PATTERN
                && storedHash.isBaseZeroPattern;

        byte[] credentialToVerify;
        if (shouldReEnrollBaseZero) {
            credentialToVerify = LockPatternUtils.patternByteArrayToBaseZero(credential);
        } else {
            credentialToVerify = credential;
        }

        response = verifyCredential(userId, storedHash, credentialToVerify,
                hasChallenge, challenge, progressCallback);
","        boolean shouldReEnrollBaseZero = storedHash.type == CREDENTIAL_TYPE_PATTERN
                && storedHash.isBaseZeroPattern;

        byte[] credentialToVerify;
        if (shouldReEnrollBaseZero) {
            credentialToVerify = LockPatternUtils.patternByteArrayToBaseZero(credential);
        } else {
            credentialToVerify = credential;
        }

        response = verifyCredential(userId, storedHash, credentialToVerify,
                hasChallenge, challenge, progressCallback);
","        boolean shouldReEnrollBaseZero = storedHash.type == CREDENTIAL_TYPE_PATTERN
                && storedHash.isBaseZeroPattern;

        byte[] credentialToVerify;
        if (shouldReEnrollBaseZero) {
            credentialToVerify = LockPatternUtils.patternByteArrayToBaseZero(credential);
        } else {
            credentialToVerify = credential;
        }

        response = verifyCredential(userId, storedHash, credentialToVerify,
                hasChallenge, challenge, progressCallback);
","[1.0, 1.0]"
581,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1883, 1883, 1), (1883, 1883, 1)]","            long challenge, int userId) throws RemoteException {
","            long challenge, int userId) throws RemoteException {
","            long challenge, int userId) throws RemoteException {
","[1.0, 1.0]"
582,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1924, 1925, 2), (1924, 1925, 2)]","            byte[] credential, boolean hasChallenge, long challenge,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
","            byte[] credential, boolean hasChallenge, long challenge,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
","            byte[] credential, boolean hasChallenge, long challenge,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
","[1.0, 1.0]"
583,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1940, 1981, 42), (1940, 1981, 42)]","        if (storedHash.version == CredentialHash.VERSION_LEGACY) {
            final byte[] hash;
            if (storedHash.type == CREDENTIAL_TYPE_PATTERN) {
                hash = LockPatternUtils.patternToHash(
                        LockPatternUtils.byteArrayToPattern(credential));
            } else {
                hash = mLockPatternUtils.legacyPasswordToHash(credential, userId).getBytes();
            }
            if (Arrays.equals(hash, storedHash.hash)) {
                if (storedHash.type == CREDENTIAL_TYPE_PATTERN) {
                    unlockKeystore(LockPatternUtils.patternByteArrayToBaseZero(credential), userId);
                } else {
                    unlockKeystore(credential, userId);
                }
                // Users with legacy credentials don't have credential-backed
                // FBE keys, so just pass through a fake token/secret
                Slog.i(TAG, ""Unlocking user with fake token: "" + userId);
                final byte[] fakeToken = String.valueOf(userId).getBytes();
                unlockUser(userId, fakeToken, fakeToken);

                // migrate credential to GateKeeper
                setLockCredentialInternal(credential, storedHash.type, null,
                        storedHash.type == CREDENTIAL_TYPE_PATTERN
                                ? DevicePolicyManager.PASSWORD_QUALITY_SOMETHING
                                : DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC
                                /* TODO(roosa): keep the same password quality */,
                        userId, false, /* isLockTiedToParent= */ false);
                if (!hasChallenge) {
                    notifyActivePasswordMetricsAvailable(storedHash.type, credential, userId);
                    // Use credentials to create recoverable keystore snapshot.
                    sendCredentialsOnUnlockIfRequired(storedHash.type, credential, userId);
                    return VerifyCredentialResponse.OK;
                }
                // Fall through to get the auth token. Technically this should never happen,
                // as a user that had a legacy credential would have to unlock their device
                // before getting to a flow with a challenge, but supporting for consistency.
            } else {
                return VerifyCredentialResponse.ERROR;
            }
        }
        GateKeeperResponse gateKeeperResponse = getGateKeeperService()
                .verifyChallenge(userId, challenge, storedHash.hash, credential);
","        if (storedHash.version == CredentialHash.VERSION_LEGACY) {
            final byte[] hash;
            if (storedHash.type == CREDENTIAL_TYPE_PATTERN) {
                hash = LockPatternUtils.patternToHash(
                        LockPatternUtils.byteArrayToPattern(credential));
            } else {
                hash = mLockPatternUtils.legacyPasswordToHash(credential, userId).getBytes();
            }
            if (Arrays.equals(hash, storedHash.hash)) {
                if (storedHash.type == CREDENTIAL_TYPE_PATTERN) {
                    unlockKeystore(LockPatternUtils.patternByteArrayToBaseZero(credential), userId);
                } else {
                    unlockKeystore(credential, userId);
                }
                // Users with legacy credentials don't have credential-backed
                // FBE keys, so just pass through a fake token/secret
                Slog.i(TAG, ""Unlocking user with fake token: "" + userId);
                final byte[] fakeToken = String.valueOf(userId).getBytes();
                unlockUser(userId, fakeToken, fakeToken);

                // migrate credential to GateKeeper
                setLockCredentialInternal(credential, storedHash.type, null,
                        storedHash.type == CREDENTIAL_TYPE_PATTERN
                                ? DevicePolicyManager.PASSWORD_QUALITY_SOMETHING
                                : DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC
                                /* TODO(roosa): keep the same password quality */,
                        userId, false, /* isLockTiedToParent= */ false);
                if (!hasChallenge) {
                    notifyActivePasswordMetricsAvailable(storedHash.type, credential, userId);
                    // Use credentials to create recoverable keystore snapshot.
                    sendCredentialsOnUnlockIfRequired(storedHash.type, credential, userId);
                    return VerifyCredentialResponse.OK;
                }
                // Fall through to get the auth token. Technically this should never happen,
                // as a user that had a legacy credential would have to unlock their device
                // before getting to a flow with a challenge, but supporting for consistency.
            } else {
                return VerifyCredentialResponse.ERROR;
            }
        }
        GateKeeperResponse gateKeeperResponse = getGateKeeperService()
                .verifyChallenge(userId, challenge, storedHash.hash, credential);
","        if (storedHash.version == CredentialHash.VERSION_LEGACY) {
            final byte[] hash;
            if (storedHash.type == CREDENTIAL_TYPE_PATTERN) {
                hash = LockPatternUtils.patternToHash(
                        LockPatternUtils.byteArrayToPattern(credential));
            } else {
                hash = mLockPatternUtils.legacyPasswordToHash(credential, userId).getBytes();
            }
            if (Arrays.equals(hash, storedHash.hash)) {
                if (storedHash.type == CREDENTIAL_TYPE_PATTERN) {
                    unlockKeystore(LockPatternUtils.patternByteArrayToBaseZero(credential), userId);
                } else {
                    unlockKeystore(credential, userId);
                }
                // Users with legacy credentials don't have credential-backed
                // FBE keys, so just pass through a fake token/secret
                Slog.i(TAG, ""Unlocking user with fake token: "" + userId);
                final byte[] fakeToken = String.valueOf(userId).getBytes();
                unlockUser(userId, fakeToken, fakeToken);

                // migrate credential to GateKeeper
                setLockCredentialInternal(credential, storedHash.type, null,
                        storedHash.type == CREDENTIAL_TYPE_PATTERN
                                ? DevicePolicyManager.PASSWORD_QUALITY_SOMETHING
                                : DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC
                                /* TODO(roosa): keep the same password quality */,
                        userId, false, /* isLockTiedToParent= */ false);
                if (!hasChallenge) {
                    notifyActivePasswordMetricsAvailable(storedHash.type, credential, userId);
                    // Use credentials to create recoverable keystore snapshot.
                    sendCredentialsOnUnlockIfRequired(storedHash.type, credential, userId);
                    return VerifyCredentialResponse.OK;
                }
                // Fall through to get the auth token. Technically this should never happen,
                // as a user that had a legacy credential would have to unlock their device
                // before getting to a flow with a challenge, but supporting for consistency.
            } else {
                return VerifyCredentialResponse.ERROR;
            }
        }
        GateKeeperResponse gateKeeperResponse = getGateKeeperService()
                .verifyChallenge(userId, challenge, storedHash.hash, credential);
","[1.0, 1.0]"
584,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(2493, 2494, 2), (2493, 2494, 2)]","            byte[] credential, int credentialType, int requestedQuality,
            int userId) throws RemoteException {
","            byte[] credential, int credentialType, int requestedQuality,
            int userId) throws RemoteException {
","            byte[] credential, int credentialType, int requestedQuality,
            int userId) throws RemoteException {
","[1.0, 1.0]"
585,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(2555, 2557, 3), (2555, 2557, 3)]","            @CredentialType int credentialType, boolean hasChallenge, long challenge, int userId,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""spBasedDoVerifyCredential: user="" + userId);
","            @CredentialType int credentialType, boolean hasChallenge, long challenge, int userId,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""spBasedDoVerifyCredential: user="" + userId);
","            @CredentialType int credentialType, boolean hasChallenge, long challenge, int userId,
            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""spBasedDoVerifyCredential: user="" + userId);
","[1.0, 1.0]"
586,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(2718, 2718, 1), (2718, 2718, 1)]","            boolean allowUntrustedChange, boolean isLockTiedToParent) throws RemoteException {
","            boolean allowUntrustedChange, boolean isLockTiedToParent) throws RemoteException {
","            boolean allowUntrustedChange, boolean isLockTiedToParent) throws RemoteException {
","[1.0, 1.0]"
587,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(2794, 2794, 1), (2794, 2794, 1)]","    public byte[] getHashFactor(byte[] currentCredential, int userId) throws RemoteException {
","    public byte[] getHashFactor(byte[] currentCredential, int userId) throws RemoteException {
","    public byte[] getHashFactor(byte[] currentCredential, int userId) throws RemoteException {
","[1.0, 1.0]"
588,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(2900, 2900, 1), (2900, 2900, 1)]","            byte[] token, int requestedQuality, int userId) throws RemoteException {
","            byte[] token, int requestedQuality, int userId) throws RemoteException {
","            byte[] token, int requestedQuality, int userId) throws RemoteException {
","[1.0, 1.0]"
589,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(2927, 2928, 2), (2927, 2928, 2)]","            long tokenHandle, byte[] token, int requestedQuality, int userId)
                    throws RemoteException {
","            long tokenHandle, byte[] token, int requestedQuality, int userId)
                    throws RemoteException {
","            long tokenHandle, byte[] token, int requestedQuality, int userId)
                    throws RemoteException {
","[1.0, 1.0]"
590,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(3158, 3163, 6), (3158, 3163, 6)]","            try {
                return LockSettingsService.this.setLockCredentialWithToken(credential, type,
                        tokenHandle, token, requestedQuality, userId);
            } catch (RemoteException re) {
                throw re.rethrowFromSystemServer();
            }
","            try {
                return LockSettingsService.this.setLockCredentialWithToken(credential, type,
                        tokenHandle, token, requestedQuality, userId);
            } catch (RemoteException re) {
                throw re.rethrowFromSystemServer();
            }
","            try {
                return LockSettingsService.this.setLockCredentialWithToken(credential, type,
                        tokenHandle, token, requestedQuality, userId);
            } catch (RemoteException re) {
                throw re.rethrowFromSystemServer();
            }
","[1.0, 1.0]"
591,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(196, 196, 1), (196, 196, 1)]","import android.util.BoostFramework;
","import android.util.BoostFramework;
","import android.util.BoostFramework;
","[1.0, 1.0]"
592,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/view/SurfaceControl.java,"[(94, 94, 1), (94, 94, 1)]","            IBinder layerHandleToken, Rect sourceCrop, float frameScale, IBinder[] excludeLayers);
","            IBinder layerHandleToken, Rect sourceCrop, float frameScale, IBinder[] excludeLayers);
","            IBinder layerHandleToken, Rect sourceCrop, float frameScale, IBinder[] excludeLayers);
","[1.0, 1.0]"
593,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '24f36fd2514856aaafe6a32a99050e272a6bd361']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(2857, 2860, 4), (2117, 2120, 4)]","        final DisplayContent dc = getDisplay().mDisplayContent;
        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
","        final DisplayContent dc = display.mDisplayContent;
        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
",".mDisplayContent;
        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
","[0.683, 0.707]"
594,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '24f36fd2514856aaafe6a32a99050e272a6bd361']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/view/ViewRootImpl.java,"[(612, 613, 2), (694, 694, 1)]","    boolean mHaveMoveEvent = false;

","    boolean mHaveMoveEvent = false;
","    boolean mHaveMoveEvent = false;
","[0.973, 1.0]"
595,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '24f36fd2514856aaafe6a32a99050e272a6bd361']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 22, 4), (19, 20, 2)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","[0.652, 1.0]"
596,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/java/com/android/server/SystemServer.java,"[(1398, 1426, 29), (1382, 1417, 36)]","            if (enableWigig) {
                try {
                    Slog.i(TAG, ""Wigig Service"");
                    String wigigClassPath =
                        ""/system/framework/wigig-service.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.supptunnel-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.netperftuner-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.capabilityconfigstore-V1.0-java.jar"";
                    PathClassLoader wigigClassLoader =
                            new PathClassLoader(wigigClassPath, getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl"");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigP2pServiceImpl class"");
                    ServiceManager.addService(""wigigp2p"", (IBinder) wigigP2pService);

                    Class wigigClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.WigigService"");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigService class"");
                    ServiceManager.addService(""wigig"", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf(""starting WigigService"", e);
                }
            }

            traceBeginAndSlog(""StartNsdService"");
","            traceBeginAndSlog(""StartNetworkStack"");
            try {
                NetworkStackClient.getInstance().start(context);
            } catch (Throwable e) {
                reportWtf(""starting Network Stack"", e);
            }
            traceEnd();

            if (enableWigig) {
                try {
                    Slog.i(TAG, ""Wigig Service"");
                    String wigigClassPath =
                        ""/system/framework/wigig-service.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.supptunnel-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.netperftuner-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.capabilityconfigstore-V1.0-java.jar"";
                    PathClassLoader wigigClassLoader =
                            new PathClassLoader(wigigClassPath, getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl"");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigP2pServiceImpl class"");
                    ServiceManager.addService(""wigigp2p"", (IBinder) wigigP2pService);

                    Class wigigClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.WigigService"");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigService class"");
                    ServiceManager.addService(""wigig"", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf(""starting WigigService"", e);
                }
            }

","            if (enableWigig) {
                try {
                    Slog.i(TAG, ""Wigig Service"");
                    String wigigClassPath =
                        ""/system/framework/wigig-service.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.supptunnel-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.wigig.netperftuner-V1.0-java.jar"" + "":"" +
                        ""/system/product/framework/vendor.qti.hardware.capabilityconfigstore-V1.0-java.jar"";
                    PathClassLoader wigigClassLoader =
                            new PathClassLoader(wigigClassPath, getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl"");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigP2pServiceImpl class"");
                    ServiceManager.addService(""wigigp2p"", (IBinder) wigigP2pService);

                    Class wigigClass = wigigClassLoader.loadClass(
                        ""com.qualcomm.qti.server.wigig.WigigService"");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, ""Successfully loaded WigigService class"");
                    ServiceManager.addService(""wigig"", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf(""starting WigigService"", e);
                }
            }

","[0.972, 0.867]"
597,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/CarrierTextController.java,"[(77, 79, 3), (78, 80, 3)]","    @VisibleForTesting
    protected boolean mDisplayOpportunisticSubscriptionCarrierText;
    private FiveGServiceClient mFiveGServiceClient;
","    @VisibleForTesting
    protected boolean mDisplayOpportunisticSubscriptionCarrierText;
    private FiveGServiceClient mFiveGServiceClient;
","    @VisibleForTesting
    protected boolean mDisplayOpportunisticSubscriptionCarrierText;
    private FiveGServiceClient mFiveGServiceClient;
","[1.0, 1.0]"
598,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '3a5272699e3e16fbfdc397480898bb27abeb2caa']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1122, 1160, 39), (1108, 1147, 40)]","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

    private void setKeystorePassword(String password, int userHandle) {
","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

","[1.0, 0.947]"
599,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '3a5272699e3e16fbfdc397480898bb27abeb2caa']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1684, 1696, 13), (1577, 1589, 13)]","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(byte[] credential) throws RemoteException {
","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(String credential) throws RemoteException {
","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(","[0.934, 0.934]"
600,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(980, 1044, 65), (1181, 1246, 66)]","        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
","        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
    };
","        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
","[1.0, 0.997]"
601,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 22, 4), (19, 20, 2)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","[0.652, 1.0]"
602,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(343, 436, 94), (357, 450, 94)]","    /** @hide */
    public static final int QOS_UNAVAILABLE = 78;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 79;
    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 80;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 81;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 82;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 85;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 86;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 87;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 88;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 89;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 90;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 91;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 94;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 95;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 96;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 97;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 98;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 99;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 100;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 101;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 102;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 103;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 106;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 107;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 108;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 109;
    /** @hide */
    public static final int CALL_REJECTED = 110;
    /** @hide */
    public static final int NUMBER_CHANGED = 111;
    /** @hide */
    public static final int PREEMPTION = 112;
    /** @hide */
    public static final int FACILITY_REJECTED = 113;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 114;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 115;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 116;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 117;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 118;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 119;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 120;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 121;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 122;
","    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 80;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 81;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 82;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 85;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 86;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 87;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 88;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 89;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 90;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 91;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 94;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 95;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 96;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 97;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 98;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 99;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 100;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 101;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 102;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 103;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 106;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 107;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 108;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 109;
    /** @hide */
    public static final int CALL_REJECTED = 110;
    /** @hide */
    public static final int NUMBER_CHANGED = 111;
    /** @hide */
    public static final int PREEMPTION = 112;
    /** @hide */
    public static final int FACILITY_REJECTED = 113;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 114;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 115;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 116;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 117;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 118;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 119;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 120;
    /** @hide */
    public static final int QOS_UNAVAILABLE = 121;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 122;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 123;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 124;
","    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 80;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 81;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 82;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 85;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 86;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 87;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 88;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 89;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 90;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 91;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 94;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 95;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 96;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 97;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 98;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 99;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 100;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 101;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 102;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 103;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 106;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 107;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 108;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 109;
    /** @hide */
    public static final int CALL_REJECTED = 110;
    /** @hide */
    public static final int NUMBER_CHANGED = 111;
    /** @hide */
    public static final int PREEMPTION = 112;
    /** @hide */
    public static final int FACILITY_REJECTED = 113;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 114;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 115;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 116;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 117;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 118;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 119;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 120;
","[0.897, 0.897]"
603,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(651, 714, 64), (669, 732, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
604,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(651, 714, 64), (677, 740, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
605,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '784ecc8e9194775f58ad5a45422ed16570bcbee6']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(196, 196, 1), (271, 271, 1)]","import android.util.BoostFramework;
","import android.util.BoostFramework;
","import android.util.BoostFramework;
","[1.0, 1.0]"
606,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1684, 1696, 13), (1749, 1763, 15)]","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(byte[] credential) throws RemoteException {
","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } catch (RemoteException e) {
            throw new IllegalStateException(""clearUserKeyAuth failed user="" + userId);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(byte[] credential) {
"," {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } ","[0.597, 0.534]"
607,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1797, 1807, 11), (1875, 1883, 9)]","            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
        checkPasswordReadPermission(userId);
        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        false, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        CHALLENGE_NONE, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
",", 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","[0.634, 0.768]"
608,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '7fe8671fd7b5388dd9be6295dbea6d31209468f9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(651, 714, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
609,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 22, 4), (19, 22, 4)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","[1.0, 1.0]"
610,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '8d21ad0d966c1e9f96e5a65144efad2582391957']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(2270, 2288, 19), (2083, 2092, 10)]","    // Overridden for testing purposes to avoid writing to SystemProperties.
    @VisibleForTesting
    protected MockableSystemProperties getSystemProperties() {
        return new MockableSystemProperties();
    }

    private void updateTcpBufferSizes(NetworkAgentInfo nai) {
        if (isDefaultNetwork(nai) == false) {
            return;
        }

        String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
        if(nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)){
            tcpBufferSizes = NetPluginDelegate.get5GTcpBuffers(tcpBufferSizes,
                nai.networkCapabilities.getNetworkSpecifier());
        }
        updateTcpBufferSizes(tcpBufferSizes);
    }

","    private void updateTcpBufferSizes(NetworkAgentInfo nai) {
        if (isDefaultNetwork(nai) == false) {
            return;
        }

        String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
        if(nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)){
            tcpBufferSizes = NetPluginDelegate.get5GTcpBuffers(tcpBufferSizes,
                nai.networkCapabilities.getNetworkSpecifier());
        }
","    private void updateTcpBufferSizes(NetworkAgentInfo nai) {
        if (isDefaultNetwork(nai) == false) {
            return;
        }

        String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
        if(nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)){
            tcpBufferSizes = NetPluginDelegate.get5GTcpBuffers(tcpBufferSizes,
                nai.networkCapabilities.getNetworkSpecifier());
        }
","[0.627, 1.0]"
611,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 22, 4), (19, 22, 4)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_","[0.943, 0.7]"
612,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'a97ca47ee3713a075711c311c49e3951264007ef']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(2329, 2329, 1), (1780, 1781, 2)]","        android.util.SeempLog.record(48);
","        android.util.SeempLog.record(43);
        return false;
",        android.util.SeempLog.record(4,"[0.905, 0.594]"
613,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(16283, 16285, 3), (15147, 15149, 3)]","        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
        synchronized (mPackages) {
","        if (DEBUG_INSTALL) Slog.d(TAG, ""New package installed in "" + pkg.codePath);
        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
","        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
","[0.759, 0.567]"
614,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 22, 4), (19, 21, 3)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","[0.995, 1.0]"
615,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(651, 714, 64), (593, 656, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
616,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(651, 714, 64), (570, 633, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
617,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceInventory.java,"[(846, 846, 1), (854, 854, 1)]","            delay = SystemProperties.getInt(""audio.sys.noisy.broadcast.delay"", 700);
","            delay = SystemProperties.getInt(""audio.sys.noisy.broadcast.delay"", 700);
","            delay = SystemProperties.getInt(""audio.sys.noisy.broadcast.delay"", 700);
","[1.0, 1.0]"
618,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(3245, 3252, 8), (3246, 3251, 6)]","        task.setFrontOfTask();

        if (mActivityPluginDelegate != null) {
            mActivityPluginDelegate.activityInvokeNotification
                (r.appInfo.packageName, r.fullscreen);
        }

        if (!isHomeOrRecentsStack() || numActivities() > 0) {
","        if (mActivityPluginDelegate != null) {
            mActivityPluginDelegate.activityInvokeNotification
                (r.appInfo.packageName, r.fullscreen);
        }

        if (!isHomeOrRecentsStack() || numActivities() > 0) {
","        if (mActivityPluginDelegate != null) {
            mActivityPluginDelegate.activityInvokeNotification
                (r.appInfo.packageName, r.fullscreen);
        }

        if (!isHomeOrRecentsStack() || numActivities() > 0) {
","[0.881, 1.0]"
619,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/notification/row/wrapper/NotificationMediaTemplateViewWrapper.java,"[(72, 72, 1), (72, 72, 1)]","    private boolean mOnPreDrawListenerRegistered = false;
","    private boolean mOnPreDrawListenerRegistered = false;
","    private boolean mOnPreDrawListenerRegistered = false;
","[1.0, 1.0]"
620,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/notification/row/wrapper/NotificationMediaTemplateViewWrapper.java,"[(224, 239, 16), (224, 239, 16)]","        addOnPreDrawListener();
    }


    private void addOnPreDrawListener() {
        if ( !mOnPreDrawListenerRegistered ) {
            mOnPreDrawListenerRegistered = true;
            mSeekBarView.getViewTreeObserver().addOnPreDrawListener(mPreDrawListener);
        }
    }

    private void removeOnPreDrawListener() {
        if ( mOnPreDrawListenerRegistered ) {
            mSeekBarView.getViewTreeObserver().removeOnPreDrawListener(mPreDrawListener);
            mHandler.postDelayed(mOnUpdateTimerTick, PROGRESS_UPDATE_INTERVAL);
            mOnPreDrawListenerRegistered = false;
","        addOnPreDrawListener();
    }


    private void addOnPreDrawListener() {
        if ( !mOnPreDrawListenerRegistered ) {
            mOnPreDrawListenerRegistered = true;
            mSeekBarView.getViewTreeObserver().addOnPreDrawListener(mPreDrawListener);
        }
    }

    private void removeOnPreDrawListener() {
        if ( mOnPreDrawListenerRegistered ) {
            mSeekBarView.getViewTreeObserver().removeOnPreDrawListener(mPreDrawListener);
            mHandler.postDelayed(mOnUpdateTimerTick, PROGRESS_UPDATE_INTERVAL);
            mOnPreDrawListenerRegistered = false;
","        addOnPreDrawListener();
    }


    private void addOnPreDrawListener() {
        if ( !mOnPreDrawListenerRegistered ) {
            mOnPreDrawListenerRegistered = true;
            mSeekBarView.getViewTreeObserver().addOnPreDrawListener(mPreDrawListener);
        }
    }

    private void removeOnPreDrawListener() {
        if ( mOnPreDrawListenerRegistered ) {
            mSeekBarView.getViewTreeObserver().removeOnPreDrawListener(mPreDrawListener);
            mHandler.postDelayed(mOnUpdateTimerTick, PROGRESS_UPDATE_INTERVAL);
            mOnPreDrawListenerRegistered = false;
","[1.0, 1.0]"
621,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/WiredAccessoryManager.java,"[(797, 797, 1), (797, 797, 1)]","                updateLocked(name, """", mHeadsetState | (mask & state) & ~(mask & ~state));
","                updateLocked(name, """", mHeadsetState | (mask & state) & ~(mask & ~state));
","                updateLocked(name, """", mHeadsetState | (mask & state) & ~(mask & ~state));
","[1.0, 1.0]"
622,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(651, 714, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
623,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(980, 1044, 65), (980, 1044, 65)]","        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
","        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
","        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
","[1.0, 1.0]"
624,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java,"[(1215, 1215, 1), (1218, 1218, 1)]","                new Handler(), mKeyguardUpdateMonitor, Dependency.get(TunerService.class));
","                new Handler(), mKeyguardUpdateMonitor, Dependency.get(TunerService.class));
","                new Handler(), mKeyguardUpdateMonitor, Dependency.get(TunerService.class));
","[1.0, 1.0]"
625,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(953, 957, 5), (957, 961, 5)]","    private static final int MSG_L_HEARING_AID_DEVICE_CONNECTION_CHANGE_EXT = 28;
    // process external command to (dis)connect or change active A2DP device
    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = 29;
    // a ScoClient died in BtHelper
    private static final int MSG_L_SCOCLIENT_DIED = 30;
","    private static final int MSG_L_HEARING_AID_DEVICE_CONNECTION_CHANGE_EXT = 28;
    // process external command to (dis)connect or change active A2DP device
    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = 29;
    // a ScoClient died in BtHelper
    private static final int MSG_L_SCOCLIENT_DIED = 30;
","    private static final int MSG_L_HEARING_AID_DEVICE_CONNECTION_CHANGE_EXT = 28;
    // process external command to (dis)connect or change active A2DP device
    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = 29;
    // a ScoClient died in BtHelper
    private static final int MSG_L_SCOCLIENT_DIED = 30;
","[1.0, 1.0]"
626,"['18970c4d9d55a44040fe6fb762dac93a077c64b5', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1797, 1807, 11), (1799, 1807, 9)]","            ICheckCredentialProgressCallback progressCallback) throws RemoteException {
        checkPasswordReadPermission(userId);
        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        false, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        false, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        false, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","[0.812, 1.0]"
627,"['19ac51594dd13e5a2e702d2c50b290f1f71a9fc0', '19ac51594dd13e5a2e702d2c50b290f1f71a9fc0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,"[(147, 157, 11), (147, 157, 11)]","        mTileLayout.setListening(mListening);
        addView((View) mTileLayout);

        mQsTileRevealController = new QSTileRevealController(mContext, this,
                (PagedTileLayout) mTileLayout);

        addDivider();

        mFooter = new QSSecurityFooter(this, context);
        addView(mFooter.getView());

","        mTileLayout.setListening(mListening);
        addView((View) mTileLayout);

        mQsTileRevealController = new QSTileRevealController(mContext, this,
                (PagedTileLayout) mTileLayout);

        addDivider();

        mFooter = new QSSecurityFooter(this, context);
        addView(mFooter.getView());

","        mTileLayout.setListening(mListening);
        addView((View) mTileLayout);

        mQsTileRevealController = new QSTileRevealController(mContext, this,
                (PagedTileLayout) mTileLayout);

        addDivider();

        mFooter = new QSSecurityFooter(this, context);
        addView(mFooter.getView());

","[1.0, 1.0]"
628,"['21f5f0690d944268de9d3f082d41d4580e5f6c16', '21f5f0690d944268de9d3f082d41d4580e5f6c16']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(8252, 8320, 69), (8252, 8320, 69)]","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (mPreferredSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) return true;

            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == mPreferredSubId)) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    public boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        int specifier = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof TelephonyNetworkSpecifier) {
            specifier = ((TelephonyNetworkSpecifier) networkSpecifierObj).getSubscriptionId();
        }
        return specifier;
    }

    public boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }

    private void handleUpdateActiveDataSubId(int subId) {
        log(""Setting mPreferredSubId to "" + subId);
        mPreferredSubId = subId;
        rematchAllNetworksAndRequests();
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (mPreferredSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) return true;

            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == mPreferredSubId)) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    public boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        int specifier = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof TelephonyNetworkSpecifier) {
            specifier = ((TelephonyNetworkSpecifier) networkSpecifierObj).getSubscriptionId();
        }
        return specifier;
    }

    public boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }

    private void handleUpdateActiveDataSubId(int subId) {
        log(""Setting mPreferredSubId to "" + subId);
        mPreferredSubId = subId;
        rematchAllNetworksAndRequests();
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (mPreferredSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) return true;

            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == mPreferredSubId)) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    public boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        int specifier = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof TelephonyNetworkSpecifier) {
            specifier = ((TelephonyNetworkSpecifier) networkSpecifierObj).getSubscriptionId();
        }
        return specifier;
    }

    public boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }

    private void handleUpdateActiveDataSubId(int subId) {
        log(""Setting mPreferredSubId to "" + subId);
        mPreferredSubId = subId;
        rematchAllNetworksAndRequests();
","[1.0, 1.0]"
631,"['240d78276b3206717587bea012131945c6f60179', '240d78276b3206717587bea012131945c6f60179']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java,"[(235, 247, 13), (235, 247, 13)]","    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback();
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
","    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback();
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
","    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback();
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
","[1.0, 1.0]"
632,"['240d78276b3206717587bea012131945c6f60179', '240d78276b3206717587bea012131945c6f60179']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/data/ApnSetting.java,"[(1216, 1216, 1), (1216, 1216, 1)]","    // Equal or one is null or """".
","    // Equal or one is null or """".
","    // Equal or one is null or """".
","[1.0, 1.0]"
633,"['240d78276b3206717587bea012131945c6f60179', '240d78276b3206717587bea012131945c6f60179']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(1931, 1931, 1), (1931, 1931, 1)]","                .append("" OWE Transition mode Iface: "").append(this.oweTransIfaceName)
","                .append("" OWE Transition mode Iface: "").append(this.oweTransIfaceName)
","                .append("" OWE Transition mode Iface: "").append(this.oweTransIfaceName)
","[1.0, 1.0]"
634,"['240d78276b3206717587bea012131945c6f60179', '240d78276b3206717587bea012131945c6f60179']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2546, 2546, 1), (2546, 2546, 1)]","            oweTransIfaceName = source.oweTransIfaceName;
","            oweTransIfaceName = source.oweTransIfaceName;
","            oweTransIfaceName = source.oweTransIfaceName;
","[1.0, 1.0]"
635,"['240d78276b3206717587bea012131945c6f60179', '240d78276b3206717587bea012131945c6f60179']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2624, 2625, 2), (2624, 2625, 2)]","        dest.writeLong(randomizedMacLastModifiedTimeMs);
        dest.writeString(oweTransIfaceName);
","        dest.writeLong(randomizedMacLastModifiedTimeMs);
        dest.writeString(oweTransIfaceName);
","        dest.writeLong(randomizedMacLastModifiedTimeMs);
        dest.writeString(oweTransIfaceName);
","[1.0, 1.0]"
636,"['240d78276b3206717587bea012131945c6f60179', '240d78276b3206717587bea012131945c6f60179']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2705, 2706, 2), (2705, 2706, 2)]","                config.randomizedMacLastModifiedTimeMs = in.readLong();
                config.oweTransIfaceName = in.readString();
","                config.randomizedMacLastModifiedTimeMs = in.readLong();
                config.oweTransIfaceName = in.readString();
","                config.randomizedMacLastModifiedTimeMs = in.readLong();
                config.oweTransIfaceName = in.readString();
","[1.0, 1.0]"
637,"['240d78276b3206717587bea012131945c6f60179', '240d78276b3206717587bea012131945c6f60179']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(3424, 3440, 17), (3424, 3440, 17)]","        public abstract void onNumClientsChanged(int numClients);

        /**
         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(String Macaddr, int numClients);
","        public abstract void onNumClientsChanged(int numClients);

        /**
         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(String Macaddr, int numClients);
","        public abstract void onNumClientsChanged(int numClients);

        /**
         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(String Macaddr, int numClients);
","[1.0, 1.0]"
638,"['240d78276b3206717587bea012131945c6f60179', '5358a994b854c7a6627858c48d6947e8acff6ea9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2546, 2546, 1), (2568, 2568, 1)]","            oweTransIfaceName = source.oweTransIfaceName;
","            oweTransIfaceName = source.oweTransIfaceName;
","            oweTransIfaceName = source.oweTransIfaceName;
","[1.0, 1.0]"
639,"['240d78276b3206717587bea012131945c6f60179', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java,"[(235, 247, 13), (190, 204, 15)]","    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback();
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
","    @Override
    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
","    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(","[0.672, 0.525]"
640,"['240d78276b3206717587bea012131945c6f60179', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2705, 2706, 2), (2740, 2741, 2)]","                config.randomizedMacLastModifiedTimeMs = in.readLong();
                config.oweTransIfaceName = in.readString();
","                config.clonedNetworkConfigKey = in.readString();
                config.oweTransIfaceName = in.readString();
","ng();
                config.oweTransIfaceName = in.readString();
","[0.5, 0.528]"
641,"['240d78276b3206717587bea012131945c6f60179', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java,"[(235, 247, 13), (190, 204, 15)]","    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback();
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
","    @Override
    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
","    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(","[0.672, 0.525]"
642,"['240d78276b3206717587bea012131945c6f60179', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(3424, 3440, 17), (3477, 3490, 14)]","        public abstract void onNumClientsChanged(int numClients);

        /**
         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(String Macaddr, int numClients);
","         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(String Macaddr, int numClients);
","         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(String Macaddr, int numClients);
","[0.881, 1.0]"
654,"['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/WifiEntryPreference.java,"[(67, 69, 3), (67, 69, 3)]","    private int mWifiStandard;
    private boolean mVhtMax8SpatialStreamsSupport;
    private boolean mHe8ssCapableAp;
","    private int mWifiStandard;
    private boolean mVhtMax8SpatialStreamsSupport;
    private boolean mHe8ssCapableAp;
","    private int mWifiStandard;
    private boolean mVhtMax8SpatialStreamsSupport;
    private boolean mHe8ssCapableAp;
","[1.0, 1.0]"
655,"['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/WifiEntryPreference.java,"[(142, 152, 11), (142, 152, 11)]","        final int standard = mWifiEntry.getWifiStandard();
        final boolean vhtMax8SpatialStreamsSupport = mWifiEntry.isVhtMax8SpatialStreamsSupported();
        final boolean he8ssCapableAp = mWifiEntry.isHe8ssCapableAp();

        if (level != mLevel || standard != mWifiStandard || he8ssCapableAp != mHe8ssCapableAp ||
                vhtMax8SpatialStreamsSupport != mVhtMax8SpatialStreamsSupport) {
            mLevel = level;
            mWifiStandard = standard;
            mHe8ssCapableAp = he8ssCapableAp;
            mVhtMax8SpatialStreamsSupport = vhtMax8SpatialStreamsSupport;
            updateIcon(mLevel, mWifiStandard, mHe8ssCapableAp && mVhtMax8SpatialStreamsSupport);
","        final int standard = mWifiEntry.getWifiStandard();
        final boolean vhtMax8SpatialStreamsSupport = mWifiEntry.isVhtMax8SpatialStreamsSupported();
        final boolean he8ssCapableAp = mWifiEntry.isHe8ssCapableAp();

        if (level != mLevel || standard != mWifiStandard || he8ssCapableAp != mHe8ssCapableAp ||
                vhtMax8SpatialStreamsSupport != mVhtMax8SpatialStreamsSupport) {
            mLevel = level;
            mWifiStandard = standard;
            mHe8ssCapableAp = he8ssCapableAp;
            mVhtMax8SpatialStreamsSupport = vhtMax8SpatialStreamsSupport;
            updateIcon(mLevel, mWifiStandard, mHe8ssCapableAp && mVhtMax8SpatialStreamsSupport);
","        final int standard = mWifiEntry.getWifiStandard();
        final boolean vhtMax8SpatialStreamsSupport = mWifiEntry.isVhtMax8SpatialStreamsSupported();
        final boolean he8ssCapableAp = mWifiEntry.isHe8ssCapableAp();

        if (level != mLevel || standard != mWifiStandard || he8ssCapableAp != mHe8ssCapableAp ||
                vhtMax8SpatialStreamsSupport != mVhtMax8SpatialStreamsSupport) {
            mLevel = level;
            mWifiStandard = standard;
            mHe8ssCapableAp = he8ssCapableAp;
            mVhtMax8SpatialStreamsSupport = vhtMax8SpatialStreamsSupport;
            updateIcon(mLevel, mWifiStandard, mHe8ssCapableAp && mVhtMax8SpatialStreamsSupport);
","[1.0, 1.0]"
656,"['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/WifiEntryPreference.java,"[(211, 211, 1), (211, 211, 1)]","    private void updateIcon(int level, int standard, boolean isReady) {
","    private void updateIcon(int level, int standard, boolean isReady) {
","    private void updateIcon(int level, int standard, boolean isReady) {
","[1.0, 1.0]"
657,"['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/WifiEntryPreference.java,"[(217, 217, 1), (217, 217, 1)]","        final Drawable drawable = mIconInjector.getIcon(level, standard, isReady);
","        final Drawable drawable = mIconInjector.getIcon(level, standard, isReady);
","        final Drawable drawable = mIconInjector.getIcon(level, standard, isReady);
","[1.0, 1.0]"
658,"['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3715, 3716, 2), (3715, 3716, 2)]","            Log.i(TAG, ""In binderDied(), calling setModeOwnerPid()"");
            mDeviceBroker.postSetModeOwnerPid(newModeOwnerPid);
","            Log.i(TAG, ""In binderDied(), calling setModeOwnerPid()"");
            mDeviceBroker.postSetModeOwnerPid(newModeOwnerPid);
","            Log.i(TAG, ""In binderDied(), calling setModeOwnerPid()"");
            mDeviceBroker.postSetModeOwnerPid(newModeOwnerPid);
","[1.0, 1.0]"
659,"['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/Utils.java,"[(380, 380, 1), (380, 380, 1)]","        return getWifiIconResource(level, 0 /* standard */, false /* isReady */);
","        return getWifiIconResource(level, 0 /* standard */, false /* isReady */);
","        return getWifiIconResource(level, 0 /* standard */, false /* isReady */);
","[1.0, 1.0]"
660,"['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/Utils.java,"[(386, 407, 22), (386, 407, 22)]","     * @param level The number of bars to show (0-4)
     * @throws IllegalArgumentException if an invalid RSSI level is given.
     */
    public static int getWifiIconResource(int level, int standard, boolean isReady) {
        if (level < 0 || level >= WIFI_PIE.length) {
            throw new IllegalArgumentException(""No Wifi icon found for level: "" + level);
        }

        switch (standard) {
            case 4:
                return WIFI_4_PIE[level];
            case 5:
                if (isReady) {
                    return WIFI_6_PIE[level];
                } else {
                    return WIFI_5_PIE[level];
                }
            case 6:
                return WIFI_6_PIE[level];
            default:
                return WIFI_PIE[level];
       }
","     * @param level The number of bars to show (0-4)
     * @throws IllegalArgumentException if an invalid RSSI level is given.
     */
    public static int getWifiIconResource(int level, int standard, boolean isReady) {
        if (level < 0 || level >= WIFI_PIE.length) {
            throw new IllegalArgumentException(""No Wifi icon found for level: "" + level);
        }

        switch (standard) {
            case 4:
                return WIFI_4_PIE[level];
            case 5:
                if (isReady) {
                    return WIFI_6_PIE[level];
                } else {
                    return WIFI_5_PIE[level];
                }
            case 6:
                return WIFI_6_PIE[level];
            default:
                return WIFI_PIE[level];
       }
","     * @param level The number of bars to show (0-4)
     * @throws IllegalArgumentException if an invalid RSSI level is given.
     */
    public static int getWifiIconResource(int level, int standard, boolean isReady) {
        if (level < 0 || level >= WIFI_PIE.length) {
            throw new IllegalArgumentException(""No Wifi icon found for level: "" + level);
        }

        switch (standard) {
            case 4:
                return WIFI_4_PIE[level];
            case 5:
                if (isReady) {
                    return WIFI_6_PIE[level];
                } else {
                    return WIFI_5_PIE[level];
                }
            case 6:
                return WIFI_6_PIE[level];
            default:
                return WIFI_PIE[level];
       }
","[1.0, 1.0]"
661,"['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(98, 98, 1), (98, 98, 1)]","    private static final String BLUETOOTH_PRIVILEGED_PERM = android.Manifest.permission.BLUETOOTH_PRIVILEGED;
","    private static final String BLUETOOTH_PRIVILEGED_PERM = android.Manifest.permission.BLUETOOTH_PRIVILEGED;
","    private static final String BLUETOOTH_PRIVILEGED_PERM = android.Manifest.permission.BLUETOOTH_PRIVILEGED;
","[1.0, 1.0]"
662,"['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/CachedAppOptimizer.java,"[(286, 358, 73), (286, 358, 73)]","        Process.setThreadGroupAndCpuset(mCachedAppOptimizerThread.getThreadId(),
                Process.THREAD_GROUP_SYSTEM);
        setAppCompactProperties();
    }

    private void setAppCompactProperties() {
        boolean useCompaction =
                    Boolean.valueOf(mPerf.perfGetProp(""vendor.appcompact.enable_app_compact"",
                        ""false""));
        int someCompactionType =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.some_compact_type"",
                        String.valueOf(COMPACT_ACTION_ANON_FLAG)));
        int fullCompactionType =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.full_compact_type"",
                        String.valueOf(COMPACT_ACTION_ANON_FLAG)));
        int compactThrottleSomeSome =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_somesome"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_1)));
        int compactThrottleSomeFull =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_somefull"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_2)));
        int compactThrottleFullSome =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_fullsome"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_3)));
        int compactThrottleFullFull =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_fullfull"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_4)));
        int compactThrottleBfgs =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_bfgs"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_5)));
        int compactThrottlePersistent =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_persistent"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_6)));
        int fullRssThrottleKB =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.rss_throttle_kb"",
                        String.valueOf(DEFAULT_COMPACT_FULL_RSS_THROTTLE_KB)));
        int deltaRssThrottleKB =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.delta_rss_throttle_kb"",
                        String.valueOf(DEFAULT_COMPACT_FULL_DELTA_RSS_THROTTLE_KB)));

        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_ACTION_1,
                        String.valueOf(someCompactionType), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_ACTION_2,
                        String.valueOf(fullCompactionType), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_1,
                        String.valueOf(compactThrottleSomeSome), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_2,
                        String.valueOf(compactThrottleSomeFull), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_3,
                        String.valueOf(compactThrottleFullSome), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_4,
                        String.valueOf(compactThrottleFullFull), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_5,
                        String.valueOf(compactThrottleBfgs), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_6,
                        String.valueOf(compactThrottlePersistent), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_FULL_RSS_THROTTLE_KB,
                        String.valueOf(fullRssThrottleKB), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_FULL_DELTA_RSS_THROTTLE_KB,
                        String.valueOf(deltaRssThrottleKB), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_USE_COMPACTION,
                        String.valueOf(useCompaction), true);
","        Process.setThreadGroupAndCpuset(mCachedAppOptimizerThread.getThreadId(),
                Process.THREAD_GROUP_SYSTEM);
        setAppCompactProperties();
    }

    private void setAppCompactProperties() {
        boolean useCompaction =
                    Boolean.valueOf(mPerf.perfGetProp(""vendor.appcompact.enable_app_compact"",
                        ""false""));
        int someCompactionType =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.some_compact_type"",
                        String.valueOf(COMPACT_ACTION_ANON_FLAG)));
        int fullCompactionType =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.full_compact_type"",
                        String.valueOf(COMPACT_ACTION_ANON_FLAG)));
        int compactThrottleSomeSome =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_somesome"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_1)));
        int compactThrottleSomeFull =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_somefull"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_2)));
        int compactThrottleFullSome =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_fullsome"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_3)));
        int compactThrottleFullFull =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_fullfull"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_4)));
        int compactThrottleBfgs =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_bfgs"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_5)));
        int compactThrottlePersistent =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_persistent"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_6)));
        int fullRssThrottleKB =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.rss_throttle_kb"",
                        String.valueOf(DEFAULT_COMPACT_FULL_RSS_THROTTLE_KB)));
        int deltaRssThrottleKB =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.delta_rss_throttle_kb"",
                        String.valueOf(DEFAULT_COMPACT_FULL_DELTA_RSS_THROTTLE_KB)));

        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_ACTION_1,
                        String.valueOf(someCompactionType), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_ACTION_2,
                        String.valueOf(fullCompactionType), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_1,
                        String.valueOf(compactThrottleSomeSome), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_2,
                        String.valueOf(compactThrottleSomeFull), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_3,
                        String.valueOf(compactThrottleFullSome), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_4,
                        String.valueOf(compactThrottleFullFull), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_5,
                        String.valueOf(compactThrottleBfgs), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_6,
                        String.valueOf(compactThrottlePersistent), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_FULL_RSS_THROTTLE_KB,
                        String.valueOf(fullRssThrottleKB), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_FULL_DELTA_RSS_THROTTLE_KB,
                        String.valueOf(deltaRssThrottleKB), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_USE_COMPACTION,
                        String.valueOf(useCompaction), true);
","        Process.setThreadGroupAndCpuset(mCachedAppOptimizerThread.getThreadId(),
                Process.THREAD_GROUP_SYSTEM);
        setAppCompactProperties();
    }

    private void setAppCompactProperties() {
        boolean useCompaction =
                    Boolean.valueOf(mPerf.perfGetProp(""vendor.appcompact.enable_app_compact"",
                        ""false""));
        int someCompactionType =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.some_compact_type"",
                        String.valueOf(COMPACT_ACTION_ANON_FLAG)));
        int fullCompactionType =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.full_compact_type"",
                        String.valueOf(COMPACT_ACTION_ANON_FLAG)));
        int compactThrottleSomeSome =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_somesome"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_1)));
        int compactThrottleSomeFull =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_somefull"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_2)));
        int compactThrottleFullSome =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_fullsome"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_3)));
        int compactThrottleFullFull =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_fullfull"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_4)));
        int compactThrottleBfgs =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_bfgs"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_5)));
        int compactThrottlePersistent =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_persistent"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_6)));
        int fullRssThrottleKB =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.rss_throttle_kb"",
                        String.valueOf(DEFAULT_COMPACT_FULL_RSS_THROTTLE_KB)));
        int deltaRssThrottleKB =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.delta_rss_throttle_kb"",
                        String.valueOf(DEFAULT_COMPACT_FULL_DELTA_RSS_THROTTLE_KB)));

        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_ACTION_1,
                        String.valueOf(someCompactionType), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_ACTION_2,
                        String.valueOf(fullCompactionType), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_1,
                        String.valueOf(compactThrottleSomeSome), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_2,
                        String.valueOf(compactThrottleSomeFull), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_3,
                        String.valueOf(compactThrottleFullSome), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_4,
                        String.valueOf(compactThrottleFullFull), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_5,
                        String.valueOf(compactThrottleBfgs), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_6,
                        String.valueOf(compactThrottlePersistent), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_FULL_RSS_THROTTLE_KB,
                        String.valueOf(fullRssThrottleKB), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_FULL_DELTA_RSS_THROTTLE_KB,
                        String.valueOf(deltaRssThrottleKB), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_USE_COMPACTION,
                        String.valueOf(useCompaction), true);
","[1.0, 1.0]"
663,"['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/BluetoothCodecConfig.java,"[(64, 78, 15), (64, 78, 15)]","    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 4;

    public static final int SOURCE_CODEC_TYPE_LDAC = 5;

    public static final int SOURCE_CODEC_TYPE_APTX_TWSP = 6;

    public static final int SOURCE_CODEC_TYPE_MAX = 7;

    /* CELT is not an A2DP Codec and only used to fetch encoder
    ** format for BA usecase, moving out of a2dp codec value list
    */
    public static final int SOURCE_CODEC_TYPE_CELT = 8;

    public static final int SOURCE_CODEC_TYPE_LC3 = 9;

","    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 4;

    public static final int SOURCE_CODEC_TYPE_LDAC = 5;

    public static final int SOURCE_CODEC_TYPE_APTX_TWSP = 6;

    public static final int SOURCE_CODEC_TYPE_MAX = 7;

    /* CELT is not an A2DP Codec and only used to fetch encoder
    ** format for BA usecase, moving out of a2dp codec value list
    */
    public static final int SOURCE_CODEC_TYPE_CELT = 8;

    public static final int SOURCE_CODEC_TYPE_LC3 = 9;

","    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 4;

    public static final int SOURCE_CODEC_TYPE_LDAC = 5;

    public static final int SOURCE_CODEC_TYPE_APTX_TWSP = 6;

    public static final int SOURCE_CODEC_TYPE_MAX = 7;

    /* CELT is not an A2DP Codec and only used to fetch encoder
    ** format for BA usecase, moving out of a2dp codec value list
    */
    public static final int SOURCE_CODEC_TYPE_CELT = 8;

    public static final int SOURCE_CODEC_TYPE_LC3 = 9;

","[1.0, 1.0]"
664,"['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/ScreenDecorations.java,"[(597, 597, 1), (597, 597, 1)]","        int newRoundedDefault = mContext.getResources().getDimensionPixelSize(
","        int newRoundedDefault = mContext.getResources().getDimensionPixelSize(
","        int newRoundedDefault = mContext.getResources().getDimensionPixelSize(
","[1.0, 1.0]"
665,"['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,"[(127, 127, 1), (127, 127, 1)]","                        || !mHasMobileDataFeature || mWifiTracker.isDefaultNetwork);
","                        || !mHasMobileDataFeature || mWifiTracker.isDefaultNetwork);
","                        || !mHasMobileDataFeature || mWifiTracker.isDefaultNetwork);
","[1.0, 1.0]"
666,"['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '2b1a920917d6b9235c008921845152448c7e5fc7']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/ScreenDecorations.java,"[(597, 597, 1), (597, 597, 1)]","        int newRoundedDefault = mContext.getResources().getDimensionPixelSize(
","        int newRoundedDefault = mContext.getResources().getDimensionPixelSize(
","        int newRoundedDefault = mContext.getResources().getDimensionPixelSize(
","[1.0, 1.0]"
667,"['24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba', '2b1a920917d6b9235c008921845152448c7e5fc7']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,"[(127, 127, 1), (127, 127, 1)]","                        || !mHasMobileDataFeature || mWifiTracker.isDefaultNetwork);
","                        || !mHasMobileDataFeature || mWifiTracker.isDefaultNetwork);
","                        || !mHasMobileDataFeature || mWifiTracker.isDefaultNetwork);
","[1.0, 1.0]"
668,"['24f36fd2514856aaafe6a32a99050e272a6bd361', '24f36fd2514856aaafe6a32a99050e272a6bd361']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(350, 353, 4), (350, 353, 4)]","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
        //Log.i(TAG, ""setBluetoothScoOnInt: "" + on + "" "" + eventSource);
","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
        //Log.i(TAG, ""setBluetoothScoOnInt: "" + on + "" "" + eventSource);
","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
        //Log.i(TAG, ""setBluetoothScoOnInt: "" + on + "" "" + eventSource);
","[1.0, 1.0]"
669,"['24f36fd2514856aaafe6a32a99050e272a6bd361', '24f36fd2514856aaafe6a32a99050e272a6bd361']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/view/ViewRootImpl.java,"[(694, 694, 1), (694, 694, 1)]","    boolean mHaveMoveEvent = false;
","    boolean mHaveMoveEvent = false;
","    boolean mHaveMoveEvent = false;
","[1.0, 1.0]"
670,"['24f36fd2514856aaafe6a32a99050e272a6bd361', '24f36fd2514856aaafe6a32a99050e272a6bd361']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(2117, 2120, 4), (2117, 2120, 4)]","        final DisplayContent dc = display.mDisplayContent;
        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
","        final DisplayContent dc = display.mDisplayContent;
        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
","        final DisplayContent dc = display.mDisplayContent;
        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
","[1.0, 1.0]"
671,"['24f36fd2514856aaafe6a32a99050e272a6bd361', '24f36fd2514856aaafe6a32a99050e272a6bd361']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 20, 2), (19, 20, 2)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","[1.0, 1.0]"
672,"['24f36fd2514856aaafe6a32a99050e272a6bd361', '24f36fd2514856aaafe6a32a99050e272a6bd361']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/BtHelper.java,"[(864, 939, 76), (864, 939, 76)]","        // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
        // @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
        @GuardedBy(""BtHelper.this"")
        void incCount(int scoAudioMode) {
            Log.i(TAG, ""In incCount(), mStartcount = "" + mStartcount);
            if (!requestScoState(BluetoothHeadset.STATE_AUDIO_CONNECTED, scoAudioMode)) {
                Log.e(TAG, ""Request sco connected with scoAudioMode(""
                        + scoAudioMode + "") failed"");
                return;
            }
            if (mStartcount == 0) {
                try {
                    mCb.linkToDeath(this, 0);
                } catch (RemoteException e) {
                    // client has already died!
                    Log.w(TAG, ""ScoClient incCount() could not link to ""+mCb+"" binder death"");
                }
            }
            //mStartCount should always be either 0 or 1 only if the startBluetoothSco
            //is called by the same app multiple times by mistake. This will ensure that
            //SCO gets disconnected when app calls stopBluetoothSco only once.
            //Also, if SCO is already there, we just need to select the SCO devices by
            //calling setBluetoothScoOn(true) in system context.
            if (mStartcount == 1) {
                Log.i(TAG, ""mStartcount is 1, calling setBluetoothScoOn(true)""
                            + ""in system context"");
                mDeviceBroker.setBluetoothScoOn(true, ""BtHelper.incCount"");
            } else if (mStartcount == 0) {
                mStartcount++;
                Log.i(TAG, ""mStartcount is 0, incrementing by 1"");
            }
        }

        // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
        // @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
        @GuardedBy(""BtHelper.this"")
        void decCount() {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In decCount(), mStartcount: "" + mStartcount);
            }
            if (mStartcount == 0) {
                Log.w(TAG, ""ScoClient.decCount() already 0"");
            } else {
                mStartcount--;
                if (mStartcount == 0) {
                    try {
                        mCb.unlinkToDeath(this, 0);
                    } catch (NoSuchElementException e) {
                        Log.w(TAG, ""decCount() going to 0 but not registered to binder"");
                    }
                }
                if (!requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED, 0)) {
                    Log.w(TAG, ""Request sco disconnected with scoAudioMode(0) failed"");
                }
            }
        }

        // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
        // @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
        @GuardedBy(""BtHelper.this"")
        void clearCount(boolean stopSco) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In clearCount(), stopSco: "" + stopSco + "", mStartcount: ""
                            + mStartcount);
            }
            if (mStartcount != 0) {
                try {
                    mCb.unlinkToDeath(this, 0);
                } catch (NoSuchElementException e) {
                    Log.w(TAG, ""clearCount() mStartcount: ""
                            + mStartcount + "" != 0 but not registered to binder"");
                }
            }
            mStartcount = 0;
            if (stopSco) {
                boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED, 0);
","        // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
        // @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
        @GuardedBy(""BtHelper.this"")
        void incCount(int scoAudioMode) {
            Log.i(TAG, ""In incCount(), mStartcount = "" + mStartcount);
            if (!requestScoState(BluetoothHeadset.STATE_AUDIO_CONNECTED, scoAudioMode)) {
                Log.e(TAG, ""Request sco connected with scoAudioMode(""
                        + scoAudioMode + "") failed"");
                return;
            }
            if (mStartcount == 0) {
                try {
                    mCb.linkToDeath(this, 0);
                } catch (RemoteException e) {
                    // client has already died!
                    Log.w(TAG, ""ScoClient incCount() could not link to ""+mCb+"" binder death"");
                }
            }
            //mStartCount should always be either 0 or 1 only if the startBluetoothSco
            //is called by the same app multiple times by mistake. This will ensure that
            //SCO gets disconnected when app calls stopBluetoothSco only once.
            //Also, if SCO is already there, we just need to select the SCO devices by
            //calling setBluetoothScoOn(true) in system context.
            if (mStartcount == 1) {
                Log.i(TAG, ""mStartcount is 1, calling setBluetoothScoOn(true)""
                            + ""in system context"");
                mDeviceBroker.setBluetoothScoOn(true, ""BtHelper.incCount"");
            } else if (mStartcount == 0) {
                mStartcount++;
                Log.i(TAG, ""mStartcount is 0, incrementing by 1"");
            }
        }

        // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
        // @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
        @GuardedBy(""BtHelper.this"")
        void decCount() {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In decCount(), mStartcount: "" + mStartcount);
            }
            if (mStartcount == 0) {
                Log.w(TAG, ""ScoClient.decCount() already 0"");
            } else {
                mStartcount--;
                if (mStartcount == 0) {
                    try {
                        mCb.unlinkToDeath(this, 0);
                    } catch (NoSuchElementException e) {
                        Log.w(TAG, ""decCount() going to 0 but not registered to binder"");
                    }
                }
                if (!requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED, 0)) {
                    Log.w(TAG, ""Request sco disconnected with scoAudioMode(0) failed"");
                }
            }
        }

        // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
        // @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
        @GuardedBy(""BtHelper.this"")
        void clearCount(boolean stopSco) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In clearCount(), stopSco: "" + stopSco + "", mStartcount: ""
                            + mStartcount);
            }
            if (mStartcount != 0) {
                try {
                    mCb.unlinkToDeath(this, 0);
                } catch (NoSuchElementException e) {
                    Log.w(TAG, ""clearCount() mStartcount: ""
                            + mStartcount + "" != 0 but not registered to binder"");
                }
            }
            mStartcount = 0;
            if (stopSco) {
                boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED, 0);
","        // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
        // @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
        @GuardedBy(""BtHelper.this"")
        void incCount(int scoAudioMode) {
            Log.i(TAG, ""In incCount(), mStartcount = "" + mStartcount);
            if (!requestScoState(BluetoothHeadset.STATE_AUDIO_CONNECTED, scoAudioMode)) {
                Log.e(TAG, ""Request sco connected with scoAudioMode(""
                        + scoAudioMode + "") failed"");
                return;
            }
            if (mStartcount == 0) {
                try {
                    mCb.linkToDeath(this, 0);
                } catch (RemoteException e) {
                    // client has already died!
                    Log.w(TAG, ""ScoClient incCount() could not link to ""+mCb+"" binder death"");
                }
            }
            //mStartCount should always be either 0 or 1 only if the startBluetoothSco
            //is called by the same app multiple times by mistake. This will ensure that
            //SCO gets disconnected when app calls stopBluetoothSco only once.
            //Also, if SCO is already there, we just need to select the SCO devices by
            //calling setBluetoothScoOn(true) in system context.
            if (mStartcount == 1) {
                Log.i(TAG, ""mStartcount is 1, calling setBluetoothScoOn(true)""
                            + ""in system context"");
                mDeviceBroker.setBluetoothScoOn(true, ""BtHelper.incCount"");
            } else if (mStartcount == 0) {
                mStartcount++;
                Log.i(TAG, ""mStartcount is 0, incrementing by 1"");
            }
        }

        // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
        // @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
        @GuardedBy(""BtHelper.this"")
        void decCount() {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In decCount(), mStartcount: "" + mStartcount);
            }
            if (mStartcount == 0) {
                Log.w(TAG, ""ScoClient.decCount() already 0"");
            } else {
                mStartcount--;
                if (mStartcount == 0) {
                    try {
                        mCb.unlinkToDeath(this, 0);
                    } catch (NoSuchElementException e) {
                        Log.w(TAG, ""decCount() going to 0 but not registered to binder"");
                    }
                }
                if (!requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED, 0)) {
                    Log.w(TAG, ""Request sco disconnected with scoAudioMode(0) failed"");
                }
            }
        }

        // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
        // @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
        @GuardedBy(""BtHelper.this"")
        void clearCount(boolean stopSco) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In clearCount(), stopSco: "" + stopSco + "", mStartcount: ""
                            + mStartcount);
            }
            if (mStartcount != 0) {
                try {
                    mCb.unlinkToDeath(this, 0);
                } catch (NoSuchElementException e) {
                    Log.w(TAG, ""clearCount() mStartcount: ""
                            + mStartcount + "" != 0 but not registered to binder"");
                }
            }
            mStartcount = 0;
            if (stopSco) {
                boolean ScoState = requestScoState(BluetoothHeadset.STATE_AUDIO_DISCONNECTED, 0);
","[1.0, 1.0]"
673,"['24f36fd2514856aaafe6a32a99050e272a6bd361', '24f36fd2514856aaafe6a32a99050e272a6bd361']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/BtHelper.java,"[(955, 965, 11), (955, 965, 11)]","        private int totalCount() {
            int count = 0;
            for (ScoClient mScoClient : mScoClients) {
                count += mScoClient.getCount();
            }
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In totalCount(), count: "" + count);
            }
            return count;
        }

","        private int totalCount() {
            int count = 0;
            for (ScoClient mScoClient : mScoClients) {
                count += mScoClient.getCount();
            }
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In totalCount(), count: "" + count);
            }
            return count;
        }

","        private int totalCount() {
            int count = 0;
            for (ScoClient mScoClient : mScoClients) {
                count += mScoClient.getCount();
            }
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In totalCount(), count: "" + count);
            }
            return count;
        }

","[1.0, 1.0]"
674,"['24f36fd2514856aaafe6a32a99050e272a6bd361', '24f36fd2514856aaafe6a32a99050e272a6bd361']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/BtHelper.java,"[(179, 179, 1), (179, 179, 1)]","            return false;
","            return false;
","            return false;
","[1.0, 1.0]"
675,"['24f36fd2514856aaafe6a32a99050e272a6bd361', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 20, 2), (19, 20, 2)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","[1.0, 1.0]"
676,"['24f36fd2514856aaafe6a32a99050e272a6bd361', '4a30c150e58ec67edb92a7bec5ea48cebd6b90d4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/BtHelper.java,"[(179, 179, 1), (429, 429, 1)]","            return false;
","            return false;
","            return false;
","[1.0, 1.0]"
677,"['24f36fd2514856aaafe6a32a99050e272a6bd361', '4a30c150e58ec67edb92a7bec5ea48cebd6b90d4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/BtHelper.java,"[(179, 179, 1), (954, 954, 1)]","            return false;
","                    return false ;
",            return false,"[0.923, 0.686]"
678,"['24f36fd2514856aaafe6a32a99050e272a6bd361', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(350, 353, 4), (348, 350, 3)]","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
        //Log.i(TAG, ""setBluetoothScoOnInt: "" + on + "" "" + eventSource);
","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
","[0.622, 1.0]"
679,"['24f36fd2514856aaafe6a32a99050e272a6bd361', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 20, 2), (19, 22, 4)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","[1.0, 0.652]"
680,"['24f36fd2514856aaafe6a32a99050e272a6bd361', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 20, 2), (19, 21, 3)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","[1.0, 0.656]"
681,"['24f36fd2514856aaafe6a32a99050e272a6bd361', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(350, 353, 4), (351, 354, 4)]","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
        //Log.i(TAG, ""setBluetoothScoOnInt: "" + on + "" "" + eventSource);
","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
        synchronized (mDeviceStateLock) {
","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
        ","[0.663, 0.79]"
682,"['29c143c9ac800bdd15598250e6f2207f05c9a5b0', '29c143c9ac800bdd15598250e6f2207f05c9a5b0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/BtHelper.java,"[(411, 423, 13), (411, 423, 13)]","                    if (checkAndUpdatTwsPlusScoState(intent,
                           BluetoothHeadset.STATE_AUDIO_DISCONNECTED)) {
                        mDeviceBroker.setBluetoothScoOn(false, ""BtHelper.receiveBtEvent"");
                        scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                        // startBluetoothSco called after stopBluetoothSco
                        if (mScoAudioState == SCO_STATE_ACTIVATE_REQ) {
                            if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null
                                    && connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                    mBluetoothHeadsetDevice, mScoAudioMode)) {
                                mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                                broadcast = false;
                                break;
                            }
","                    if (checkAndUpdatTwsPlusScoState(intent,
                           BluetoothHeadset.STATE_AUDIO_DISCONNECTED)) {
                        mDeviceBroker.setBluetoothScoOn(false, ""BtHelper.receiveBtEvent"");
                        scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                        // startBluetoothSco called after stopBluetoothSco
                        if (mScoAudioState == SCO_STATE_ACTIVATE_REQ) {
                            if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null
                                    && connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                    mBluetoothHeadsetDevice, mScoAudioMode)) {
                                mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                                broadcast = false;
                                break;
                            }
","                    if (checkAndUpdatTwsPlusScoState(intent,
                           BluetoothHeadset.STATE_AUDIO_DISCONNECTED)) {
                        mDeviceBroker.setBluetoothScoOn(false, ""BtHelper.receiveBtEvent"");
                        scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                        // startBluetoothSco called after stopBluetoothSco
                        if (mScoAudioState == SCO_STATE_ACTIVATE_REQ) {
                            if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null
                                    && connectBluetoothScoAudioHelper(mBluetoothHeadset,
                                    mBluetoothHeadsetDevice, mScoAudioMode)) {
                                mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                                broadcast = false;
                                break;
                            }
","[1.0, 1.0]"
683,"['2ac0c608ad88dc1f3372e099b5359013be7b14c7', '2ac0c608ad88dc1f3372e099b5359013be7b14c7']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(2009, 2017, 9), (2009, 2017, 9)]","        VerifyCredentialResponse response = doVerifyCredential(credential, CHALLENGE_NONE,
                                             0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use LockscreenCredential
                String credentialString = credential.isNone() ? null : new String(credential.getCredential());
                retainPassword(credentialString);
        }
        return response;
","        VerifyCredentialResponse response = doVerifyCredential(credential, CHALLENGE_NONE,
                                             0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use LockscreenCredential
                String credentialString = credential.isNone() ? null : new String(credential.getCredential());
                retainPassword(credentialString);
        }
        return response;
","        VerifyCredentialResponse response = doVerifyCredential(credential, CHALLENGE_NONE,
                                             0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use LockscreenCredential
                String credentialString = credential.isNone() ? null : new String(credential.getCredential());
                retainPassword(credentialString);
        }
        return response;
","[1.0, 1.0]"
684,"['32c3556fef45f3b7fb003880f4e23227cda95f74', '32c3556fef45f3b7fb003880f4e23227cda95f74']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/BluetoothAdapter.java,"[(1021, 1022, 2), (1021, 1022, 2)]","        android.util.SeempLog.record(63);
        int state = mBluetoothGetStateCache.query(null);
","        android.util.SeempLog.record(63);
        int state = mBluetoothGetStateCache.query(null);
","        android.util.SeempLog.record(63);
        int state = mBluetoothGetStateCache.query(null);
","[1.0, 1.0]"
689,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/LocalDisplayAdapter.java,"[(526, 532, 7), (526, 532, 7)]","                final boolean isBuiltIn = ((mInfo.address) != null) ?
                   (((DisplayAddress.Physical) mInfo.address).getPort() < 0) : false;
                if (mIsInternal) {
                    mInfo.name = res.getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_DEFAULT_DISPLAY
                            | DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;
","                final boolean isBuiltIn = ((mInfo.address) != null) ?
                   (((DisplayAddress.Physical) mInfo.address).getPort() < 0) : false;
                if (mIsInternal) {
                    mInfo.name = res.getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_DEFAULT_DISPLAY
                            | DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;
","                final boolean isBuiltIn = ((mInfo.address) != null) ?
                   (((DisplayAddress.Physical) mInfo.address).getPort() < 0) : false;
                if (mIsInternal) {
                    mInfo.name = res.getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_DEFAULT_DISPLAY
                            | DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;
","[1.0, 1.0]"
690,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/LocalDisplayAdapter.java,"[(544, 565, 22), (544, 565, 22)]","                    mInfo.type = Display.TYPE_BUILT_IN;
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                } else if (isBuiltIn) {
                    mInfo.type = Display.TYPE_BUILT_IN;
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                    mInfo.name = getContext().getResources().getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;

                    if (SystemProperties.getBoolean(
                                    ""vendor.display.builtin_presentation"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRESENTATION;
                    } else {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRIVATE;
                    }

                    if (!SystemProperties.getBoolean(
                                    ""vendor.display.builtin_mirroring"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_OWN_CONTENT_ONLY;
                    }

                    mInfo.setAssumedDensityForExternalDisplay(config.width, config.height);
","                    mInfo.type = Display.TYPE_BUILT_IN;
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                } else if (isBuiltIn) {
                    mInfo.type = Display.TYPE_BUILT_IN;
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                    mInfo.name = getContext().getResources().getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;

                    if (SystemProperties.getBoolean(
                                    ""vendor.display.builtin_presentation"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRESENTATION;
                    } else {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRIVATE;
                    }

                    if (!SystemProperties.getBoolean(
                                    ""vendor.display.builtin_mirroring"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_OWN_CONTENT_ONLY;
                    }

                    mInfo.setAssumedDensityForExternalDisplay(config.width, config.height);
","                    mInfo.type = Display.TYPE_BUILT_IN;
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                } else if (isBuiltIn) {
                    mInfo.type = Display.TYPE_BUILT_IN;
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                    mInfo.name = getContext().getResources().getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;

                    if (SystemProperties.getBoolean(
                                    ""vendor.display.builtin_presentation"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRESENTATION;
                    } else {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRIVATE;
                    }

                    if (!SystemProperties.getBoolean(
                                    ""vendor.display.builtin_mirroring"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_OWN_CONTENT_ONLY;
                    }

                    mInfo.setAssumedDensityForExternalDisplay(config.width, config.height);
","[1.0, 1.0]"
691,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(3446, 3459, 14), (3446, 3459, 14)]","            if (nri.request.isRequest() && nai.satisfies(nri.request)
                    && satisfiesMobileMultiNetworkDataCheck(nai.networkCapabilities,
                       nri.request.networkCapabilities)
                    && (nai.isSatisfyingRequest(nri.request.requestId) ||
                    // Note that this catches two important cases:
                    // 1. Unvalidated cellular will not be reaped when unvalidated WiFi
                    //    is currently satisfying the request.  This is desirable when
                    //    cellular ends up validating but WiFi does not.
                    // 2. Unvalidated WiFi will not be reaped when validated cellular
                    //    is currently satisfying the request.  This is desirable when
                    //    WiFi ends up validating and out scoring cellular.
                    ((nri.mSatisfier != null)
                    && (nri.mSatisfier.getCurrentScore()
                            < nai.getCurrentScoreAsValidated())))) {
","            if (nri.request.isRequest() && nai.satisfies(nri.request)
                    && satisfiesMobileMultiNetworkDataCheck(nai.networkCapabilities,
                       nri.request.networkCapabilities)
                    && (nai.isSatisfyingRequest(nri.request.requestId) ||
                    // Note that this catches two important cases:
                    // 1. Unvalidated cellular will not be reaped when unvalidated WiFi
                    //    is currently satisfying the request.  This is desirable when
                    //    cellular ends up validating but WiFi does not.
                    // 2. Unvalidated WiFi will not be reaped when validated cellular
                    //    is currently satisfying the request.  This is desirable when
                    //    WiFi ends up validating and out scoring cellular.
                    ((nri.mSatisfier != null)
                    && (nri.mSatisfier.getCurrentScore()
                            < nai.getCurrentScoreAsValidated())))) {
","            if (nri.request.isRequest() && nai.satisfies(nri.request)
                    && satisfiesMobileMultiNetworkDataCheck(nai.networkCapabilities,
                       nri.request.networkCapabilities)
                    && (nai.isSatisfyingRequest(nri.request.requestId) ||
                    // Note that this catches two important cases:
                    // 1. Unvalidated cellular will not be reaped when unvalidated WiFi
                    //    is currently satisfying the request.  This is desirable when
                    //    cellular ends up validating but WiFi does not.
                    // 2. Unvalidated WiFi will not be reaped when validated cellular
                    //    is currently satisfying the request.  This is desirable when
                    //    WiFi ends up validating and out scoring cellular.
                    ((nri.mSatisfier != null)
                    && (nri.mSatisfier.getCurrentScore()
                            < nai.getCurrentScoreAsValidated())))) {
","[1.0, 1.0]"
692,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java,"[(1160, 1179, 20), (1160, 1179, 20)]","        public String patternOfCarrierSpecificDataIcon = """";
        public long nrIconDisplayGracePeriodMs;

        boolean showRsrpSignalLevelforLTE = false;
        boolean hideNoInternetState = false;
        boolean showVolteIcon = false;
        boolean alwaysShowNetworkTypeIcon = false;
        /**
         * Mapping from NR 5G status string to an integer. The NR 5G status string should match
         * those in carrier config.
         */
        private static final Map<String, Integer> NR_STATUS_STRING_TO_INDEX;
        static {
            NR_STATUS_STRING_TO_INDEX = new HashMap<>(5);
            NR_STATUS_STRING_TO_INDEX.put(""connected_mmwave"", NR_CONNECTED_MMWAVE);
            NR_STATUS_STRING_TO_INDEX.put(""connected"", NR_CONNECTED);
            NR_STATUS_STRING_TO_INDEX.put(""not_restricted_rrc_idle"", NR_NOT_RESTRICTED_RRC_IDLE);
            NR_STATUS_STRING_TO_INDEX.put(""not_restricted_rrc_con"", NR_NOT_RESTRICTED_RRC_CON);
            NR_STATUS_STRING_TO_INDEX.put(""restricted"", NR_RESTRICTED);
        }
","        public String patternOfCarrierSpecificDataIcon = """";
        public long nrIconDisplayGracePeriodMs;

        boolean showRsrpSignalLevelforLTE = false;
        boolean hideNoInternetState = false;
        boolean showVolteIcon = false;
        boolean alwaysShowNetworkTypeIcon = false;
        /**
         * Mapping from NR 5G status string to an integer. The NR 5G status string should match
         * those in carrier config.
         */
        private static final Map<String, Integer> NR_STATUS_STRING_TO_INDEX;
        static {
            NR_STATUS_STRING_TO_INDEX = new HashMap<>(5);
            NR_STATUS_STRING_TO_INDEX.put(""connected_mmwave"", NR_CONNECTED_MMWAVE);
            NR_STATUS_STRING_TO_INDEX.put(""connected"", NR_CONNECTED);
            NR_STATUS_STRING_TO_INDEX.put(""not_restricted_rrc_idle"", NR_NOT_RESTRICTED_RRC_IDLE);
            NR_STATUS_STRING_TO_INDEX.put(""not_restricted_rrc_con"", NR_NOT_RESTRICTED_RRC_CON);
            NR_STATUS_STRING_TO_INDEX.put(""restricted"", NR_RESTRICTED);
        }
","        public String patternOfCarrierSpecificDataIcon = """";
        public long nrIconDisplayGracePeriodMs;

        boolean showRsrpSignalLevelforLTE = false;
        boolean hideNoInternetState = false;
        boolean showVolteIcon = false;
        boolean alwaysShowNetworkTypeIcon = false;
        /**
         * Mapping from NR 5G status string to an integer. The NR 5G status string should match
         * those in carrier config.
         */
        private static final Map<String, Integer> NR_STATUS_STRING_TO_INDEX;
        static {
            NR_STATUS_STRING_TO_INDEX = new HashMap<>(5);
            NR_STATUS_STRING_TO_INDEX.put(""connected_mmwave"", NR_CONNECTED_MMWAVE);
            NR_STATUS_STRING_TO_INDEX.put(""connected"", NR_CONNECTED);
            NR_STATUS_STRING_TO_INDEX.put(""not_restricted_rrc_idle"", NR_NOT_RESTRICTED_RRC_IDLE);
            NR_STATUS_STRING_TO_INDEX.put(""not_restricted_rrc_con"", NR_NOT_RESTRICTED_RRC_CON);
            NR_STATUS_STRING_TO_INDEX.put(""restricted"", NR_RESTRICTED);
        }
","[1.0, 1.0]"
693,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Connection.java,"[(392, 398, 7), (392, 398, 7)]","     * Remote device supports RTT.
     * @hide
     */
    public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x08000000;

    //**********************************************************************************************
    // Next CAPABILITY value: 0x10000000
","     * Remote device supports RTT.
     * @hide
     */
    public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x08000000;

    //**********************************************************************************************
    // Next CAPABILITY value: 0x10000000
","     * Remote device supports RTT.
     * @hide
     */
    public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x08000000;

    //**********************************************************************************************
    // Next CAPABILITY value: 0x10000000
","[1.0, 1.0]"
694,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Connection.java,"[(977, 978, 2), (977, 978, 2)]","        if ((capabilities & CAPABILITY_SUPPORTS_RTT_REMOTE) == CAPABILITY_SUPPORTS_RTT_REMOTE) {
            builder.append(isLong ? "" CAPABILITY_SUPPORTS_RTT_REMOTE"" : "" sup_rtt"");
","        if ((capabilities & CAPABILITY_SUPPORTS_RTT_REMOTE) == CAPABILITY_SUPPORTS_RTT_REMOTE) {
            builder.append(isLong ? "" CAPABILITY_SUPPORTS_RTT_REMOTE"" : "" sup_rtt"");
","        if ((capabilities & CAPABILITY_SUPPORTS_RTT_REMOTE) == CAPABILITY_SUPPORTS_RTT_REMOTE) {
            builder.append(isLong ? "" CAPABILITY_SUPPORTS_RTT_REMOTE"" : "" sup_rtt"");
","[1.0, 1.0]"
695,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/tiles/HotspotTile.java,"[(20, 21, 2), (20, 21, 2)]","import android.content.ComponentName;
import android.content.Context;
","import android.content.ComponentName;
import android.content.Context;
","import android.content.ComponentName;
import android.content.Context;
","[1.0, 1.0]"
696,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/PanelViewController.java,"[(260, 261, 2), (260, 261, 2)]","
        mPerf = new BoostFramework();
","
        mPerf = new BoostFramework();
","
        mPerf = new BoostFramework();
","[1.0, 1.0]"
697,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 20, 2), (19, 20, 2)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","[1.0, 1.0]"
698,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(199, 200, 2), (199, 200, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
699,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java,"[(649, 675, 27), (649, 675, 27)]","    private void updateHotspotIcon() {
        int generation;
        if (mWifiManager != null) {
            generation = mWifiManager.getSoftApWifiGeneration();
        } else {
            generation = WifiManager.WIFI_GENERATION_DEFAULT; // boot not completed yet
        }
        if (generation == WifiManager.WIFI_GENERATION_6) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_6_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        } else if (generation == WifiManager.WIFI_GENERATION_5) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_5_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        } else if (generation == WifiManager.WIFI_GENERATION_4) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_4_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        } else {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        }
    }

    private void handleBootCompleted() {
        mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
        // hotspot
        updateHotspotIcon();
        mIconController.setIconVisibility(mSlotHotspot, mHotspot.isHotspotEnabled());
","    private void updateHotspotIcon() {
        int generation;
        if (mWifiManager != null) {
            generation = mWifiManager.getSoftApWifiGeneration();
        } else {
            generation = WifiManager.WIFI_GENERATION_DEFAULT; // boot not completed yet
        }
        if (generation == WifiManager.WIFI_GENERATION_6) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_6_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        } else if (generation == WifiManager.WIFI_GENERATION_5) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_5_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        } else if (generation == WifiManager.WIFI_GENERATION_4) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_4_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        } else {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        }
    }

    private void handleBootCompleted() {
        mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
        // hotspot
        updateHotspotIcon();
        mIconController.setIconVisibility(mSlotHotspot, mHotspot.isHotspotEnabled());
","    private void updateHotspotIcon() {
        int generation;
        if (mWifiManager != null) {
            generation = mWifiManager.getSoftApWifiGeneration();
        } else {
            generation = WifiManager.WIFI_GENERATION_DEFAULT; // boot not completed yet
        }
        if (generation == WifiManager.WIFI_GENERATION_6) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_6_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        } else if (generation == WifiManager.WIFI_GENERATION_5) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_5_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        } else if (generation == WifiManager.WIFI_GENERATION_4) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_4_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        } else {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_hotspot,
                mContext.getString(R.string.accessibility_status_bar_hotspot));
        }
    }

    private void handleBootCompleted() {
        mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
        // hotspot
        updateHotspotIcon();
        mIconController.setIconVisibility(mSlotHotspot, mHotspot.isHotspotEnabled());
","[1.0, 1.0]"
700,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(18, 21, 4), (18, 21, 4)]","import static android.telephony.AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
import static android.telephony.NetworkRegistrationInfo.DOMAIN_PS;

import android.content.BroadcastReceiver;
","import static android.telephony.AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
import static android.telephony.NetworkRegistrationInfo.DOMAIN_PS;

import android.content.BroadcastReceiver;
","import static android.telephony.AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
import static android.telephony.NetworkRegistrationInfo.DOMAIN_PS;

import android.content.BroadcastReceiver;
","[1.0, 1.0]"
701,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(37, 42, 6), (37, 42, 6)]","import android.telephony.CellSignalStrengthNr;
import android.telephony.DataSpecificRegistrationInfo;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
import android.telephony.NetworkRegistrationInfo;
","import android.telephony.CellSignalStrengthNr;
import android.telephony.DataSpecificRegistrationInfo;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
import android.telephony.NetworkRegistrationInfo;
","import android.telephony.CellSignalStrengthNr;
import android.telephony.DataSpecificRegistrationInfo;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
import android.telephony.NetworkRegistrationInfo;
","[1.0, 1.0]"
702,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(109, 109, 1), (109, 109, 1)]","    private DataState mMMSDataState = DataState.DISCONNECTED;
","    private DataState mMMSDataState = DataState.DISCONNECTED;
","    private DataState mMMSDataState = DataState.DISCONNECTED;
","[1.0, 1.0]"
703,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(1062, 1063, 2), (1062, 1063, 2)]","        pw.println(""  mIsShowingIconGracefully="" + mIsShowingIconGracefully + "","");
        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mIsShowingIconGracefully="" + mIsShowingIconGracefully + "","");
        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mIsShowingIconGracefully="" + mIsShowingIconGracefully + "","");
        pw.println(""  mFiveGState="" + mFiveGState + "","");
","[1.0, 1.0]"
704,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(1181, 1246, 66), (1181, 1246, 66)]","        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
    };
","        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
    };
","        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
    };
","[1.0, 1.0]"
705,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Call.java,"[(470, 476, 7), (470, 476, 7)]","         * Remote device supports RTT.
         * @hide
         */
        public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x04000000;

        //******************************************************************************************
        // Next CAPABILITY value: 0x08000000
","         * Remote device supports RTT.
         * @hide
         */
        public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x04000000;

        //******************************************************************************************
        // Next CAPABILITY value: 0x08000000
","         * Remote device supports RTT.
         * @hide
         */
        public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x04000000;

        //******************************************************************************************
        // Next CAPABILITY value: 0x08000000
","[1.0, 1.0]"
706,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Call.java,"[(709, 710, 2), (709, 710, 2)]","            if (can(capabilities, CAPABILITY_SUPPORTS_RTT_REMOTE)) {
                builder.append("" CAPABILITY_SUPPORTS_RTT_REMOTE"");
","            if (can(capabilities, CAPABILITY_SUPPORTS_RTT_REMOTE)) {
                builder.append("" CAPABILITY_SUPPORTS_RTT_REMOTE"");
","            if (can(capabilities, CAPABILITY_SUPPORTS_RTT_REMOTE)) {
                builder.append("" CAPABILITY_SUPPORTS_RTT_REMOTE"");
","[1.0, 1.0]"
707,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(258, 260, 3), (258, 260, 3)]","            @SecurityType int securityType, int maxNumberOfClients, int shutdownTimeoutMillis,
            boolean clientControlByUser, @NonNull List<MacAddress> blockedList,
            @NonNull List<MacAddress> allowedList, @Nullable String oweTransIfaceName) {
","            @SecurityType int securityType, int maxNumberOfClients, int shutdownTimeoutMillis,
            boolean clientControlByUser, @NonNull List<MacAddress> blockedList,
            @NonNull List<MacAddress> allowedList, @Nullable String oweTransIfaceName) {
","            @SecurityType int securityType, int maxNumberOfClients, int shutdownTimeoutMillis,
            boolean clientControlByUser, @NonNull List<MacAddress> blockedList,
            @NonNull List<MacAddress> allowedList, @Nullable String oweTransIfaceName) {
","[1.0, 1.0]"
708,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(303, 304, 2), (303, 304, 2)]","                mBand, mChannel, mSecurityType, mMaxNumberOfClients, mShutdownTimeoutMillis,
                mClientControlByUser, mBlockedClientList, mAllowedClientList, mOweTransIfaceName);
","                mBand, mChannel, mSecurityType, mMaxNumberOfClients, mShutdownTimeoutMillis,
                mClientControlByUser, mBlockedClientList, mAllowedClientList, mOweTransIfaceName);
","                mBand, mChannel, mSecurityType, mMaxNumberOfClients, mShutdownTimeoutMillis,
                mClientControlByUser, mBlockedClientList, mAllowedClientList, mOweTransIfaceName);
","[1.0, 1.0]"
709,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(639, 640, 2), (639, 640, 2)]","                    mShutdownTimeoutMillis, mClientControlByUser, mBlockedClientList,
                    mAllowedClientList, mOweTransIfaceName);
","                    mShutdownTimeoutMillis, mClientControlByUser, mBlockedClientList,
                    mAllowedClientList, mOweTransIfaceName);
","                    mShutdownTimeoutMillis, mClientControlByUser, mBlockedClientList,
                    mAllowedClientList, mOweTransIfaceName);
","[1.0, 1.0]"
710,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerConstants.java,"[(28, 29, 2), (28, 29, 2)]","import android.os.SystemProperties;
import android.os.Process;
","import android.os.SystemProperties;
import android.os.Process;
","import android.os.SystemProperties;
import android.os.Process;
","[1.0, 1.0]"
711,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(199, 200, 2), (184, 185, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
712,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerConstants.java,"[(28, 29, 2), (25, 26, 2)]","import android.os.SystemProperties;
import android.os.Process;
","import android.os.SystemProperties;
import android.os.Process;
","import android.os.SystemProperties;
import android.os.Process;
","[1.0, 1.0]"
713,"['3d2fc559e13b7293212955f1858d443f4fe8234e', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 20, 2), (19, 22, 4)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","[1.0, 0.652]"
714,"['3d2fc559e13b7293212955f1858d443f4fe8234e', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Connection.java,"[(977, 978, 2), (970, 971, 2)]","        if ((capabilities & CAPABILITY_SUPPORTS_RTT_REMOTE) == CAPABILITY_SUPPORTS_RTT_REMOTE) {
            builder.append(isLong ? "" CAPABILITY_SUPPORTS_RTT_REMOTE"" : "" sup_rtt"");
","        if ((capabilities & CAPABILITY_SUPPORTS_RTT_REMOTE) == CAPABILITY_SUPPORTS_RTT_REMOTE) {
            builder.append(isLong ? "" CAPABILITY_SUPPORTS_RTT_REMOTE"" : "" sup_rtt"");
","        if ((capabilities & CAPABILITY_SUPPORTS_RTT_REMOTE) == CAPABILITY_SUPPORTS_RTT_REMOTE) {
            builder.append(isLong ? "" CAPABILITY_SUPPORTS_RTT_REMOTE"" : "" sup_rtt"");
","[1.0, 1.0]"
715,"['3d2fc559e13b7293212955f1858d443f4fe8234e', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 20, 2), (19, 21, 3)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
","[1.0, 0.656]"
716,"['3d2fc559e13b7293212955f1858d443f4fe8234e', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(199, 200, 2), (198, 199, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
717,"['3d2fc559e13b7293212955f1858d443f4fe8234e', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Call.java,"[(709, 710, 2), (707, 708, 2)]","            if (can(capabilities, CAPABILITY_SUPPORTS_RTT_REMOTE)) {
                builder.append("" CAPABILITY_SUPPORTS_RTT_REMOTE"");
","            if (can(capabilities, CAPABILITY_SUPPORTS_RTT_REMOTE)) {
                builder.append("" CAPABILITY_SUPPORTS_RTT_REMOTE"");
","            if (can(capabilities, CAPABILITY_SUPPORTS_RTT_REMOTE)) {
                builder.append("" CAPABILITY_SUPPORTS_RTT_REMOTE"");
","[1.0, 1.0]"
718,"['3d2fc559e13b7293212955f1858d443f4fe8234e', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(199, 200, 2), (191, 192, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
719,"['3d2fc559e13b7293212955f1858d443f4fe8234e', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(1181, 1246, 66), (980, 1044, 65)]","        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
    };
","        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
","        public void onCallStateChanged(int state, String phoneNumber) {
            if (DEBUG) {
                Log.d(mTag, ""onCallStateChanged: state="" + state);
            }
            mCallState = state;
            updateTelephony();
        }
    };

    class FiveGStateListener implements IFiveGStateListener{

        public void onStateChanged(FiveGServiceState state) {
            if (DEBUG) {
                Log.d(mTag, ""onStateChanged: state="" + state);
            }
            mFiveGState = state;
            updateTelephony();
            notifyListeners();
        }
    }

    private ImsMmTelManager.CapabilityCallback mCapabilityCallback = new ImsMmTelManager.CapabilityCallback() {
        @Override
        public void onCapabilitiesStatusChanged(MmTelFeature.MmTelCapabilities config) {
            mCurrentState.voiceCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
            mCurrentState.videoCapable =
                    config.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
            Log.d(mTag, ""onCapabilitiesStatusChanged isVoiceCapable="" + mCurrentState.voiceCapable
                    + "" isVideoCapable="" + mCurrentState.videoCapable);
            notifyListenersIfNecessary();
        }
    };

    private final ImsMmTelManager.RegistrationCallback mImsRegistrationCallback =
            new ImsMmTelManager.RegistrationCallback() {
                @Override
                public void onRegistered(int imsTransportType) {
                    Log.d(mTag, ""onRegistered imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = true;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onRegistering(int imsTransportType) {
                    Log.d(mTag, ""onRegistering imsTransportType="" + imsTransportType);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }

                @Override
                public void onUnregistered(ImsReasonInfo info) {
                    Log.d(mTag, ""onDeregistered imsReasonInfo="" + info);
                    mCurrentState.imsRegistered = false;
                    notifyListenersIfNecessary();
                }
    };

    private final BroadcastReceiver mVolteSwitchObserver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            Log.d(mTag, ""action="" + intent.getAction());
            if ( mConfig.showVolteIcon ) {
                notifyListeners();
            }
        }
","[0.997, 1.0]"
721,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/LocalDisplayAdapter.java,"[(771, 791, 21), (771, 791, 21)]","            SurfaceControl.setAllowedDisplayConfigs(getDisplayTokenLocked(), allowedPhysIndexes);
            int activePhysIndex = SurfaceControl.getActiveConfig(getDisplayTokenLocked());
            if (activePhysIndex < 0) {
                return false;
            }
            return updateActiveModeLocked(activePhysIndex);
        }

        public boolean requestColorModeLocked(int colorMode) {
            if (mActiveColorMode == colorMode) {
                return false;
            }
            if (!mSupportedColorModes.contains(colorMode)) {
                Slog.w(TAG, ""Unable to find color mode "" + colorMode
                        + "", ignoring request."");
                return false;
            }
            SurfaceControl.setActiveColorMode(getDisplayTokenLocked(), colorMode);
            mActiveColorMode = colorMode;
            mActiveColorModeInvalid = false;
            return true;
","            SurfaceControl.setAllowedDisplayConfigs(getDisplayTokenLocked(), allowedPhysIndexes);
            int activePhysIndex = SurfaceControl.getActiveConfig(getDisplayTokenLocked());
            if (activePhysIndex < 0) {
                return false;
            }
            return updateActiveModeLocked(activePhysIndex);
        }

        public boolean requestColorModeLocked(int colorMode) {
            if (mActiveColorMode == colorMode) {
                return false;
            }
            if (!mSupportedColorModes.contains(colorMode)) {
                Slog.w(TAG, ""Unable to find color mode "" + colorMode
                        + "", ignoring request."");
                return false;
            }
            SurfaceControl.setActiveColorMode(getDisplayTokenLocked(), colorMode);
            mActiveColorMode = colorMode;
            mActiveColorModeInvalid = false;
            return true;
","            SurfaceControl.setAllowedDisplayConfigs(getDisplayTokenLocked(), allowedPhysIndexes);
            int activePhysIndex = SurfaceControl.getActiveConfig(getDisplayTokenLocked());
            if (activePhysIndex < 0) {
                return false;
            }
            return updateActiveModeLocked(activePhysIndex);
        }

        public boolean requestColorModeLocked(int colorMode) {
            if (mActiveColorMode == colorMode) {
                return false;
            }
            if (!mSupportedColorModes.contains(colorMode)) {
                Slog.w(TAG, ""Unable to find color mode "" + colorMode
                        + "", ignoring request."");
                return false;
            }
            SurfaceControl.setActiveColorMode(getDisplayTokenLocked(), colorMode);
            mActiveColorMode = colorMode;
            mActiveColorModeInvalid = false;
            return true;
","[1.0, 1.0]"
722,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(14136, 14217, 82), (14136, 14217, 82)]","                // TODO: http://b/22976637
                // Apps installed for ""all"" users use the device owner to verify the app
                UserHandle verifierUser = getUser();
                if (verifierUser == UserHandle.ALL) {
                    verifierUser = UserHandle.SYSTEM;
                }

                /*
                 * Determine if we have any installed package verifiers. If we
                 * do, then we'll defer to them to verify the packages.
                 */
                final int requiredUid = mRequiredVerifierPackage == null ? -1
                        : getPackageUid(mRequiredVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING,
                                verifierUser.getIdentifier());

                final int optionalUid = mOptionalVerifierPackage == null ? -1
                        : getPackageUid(mOptionalVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING,
                                verifierUser.getIdentifier());

                final int installerUid =
                        verificationInfo == null ? -1 : verificationInfo.installerUid;
                if (!origin.existing && (requiredUid != -1 || optionalUid != -1)
                        && isVerificationEnabled(
                                verifierUser.getIdentifier(), installFlags, installerUid)) {
                    final Intent verification = new Intent(
                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);
                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),
                            PACKAGE_MIME_TYPE);
                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);

                    // Query all live verifiers based on current user state
                    final List<ResolveInfo> receivers = queryIntentReceiversInternal(verification,
                            PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(),
                            false /*allowDynamicSplits*/);

                    if (DEBUG_VERIFY) {
                        Slog.d(TAG, ""Found "" + receivers.size() + "" verifiers for intent ""
                                + verification.toString() + "" with "" + pkgLite.verifiers.length
                                + "" optional verifiers"");
                    }

                    final int verificationId = mPendingVerificationToken++;

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,
                            installSource.installerPackageName);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,
                            installFlags);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,
                            pkgLite.packageName);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,
                            pkgLite.versionCode);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_LONG_VERSION_CODE,
                            pkgLite.getLongVersionCode());

                    if (verificationInfo != null) {
                        if (verificationInfo.originatingUri != null) {
                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,
                                    verificationInfo.originatingUri);
                        }
                        if (verificationInfo.referrer != null) {
                            verification.putExtra(Intent.EXTRA_REFERRER,
                                    verificationInfo.referrer);
                        }
                        if (verificationInfo.originatingUid >= 0) {
                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,
                                    verificationInfo.originatingUid);
                        }
                        if (verificationInfo.installerUid >= 0) {
                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,
                                    verificationInfo.installerUid);
                        }
                    }

                    final PackageVerificationState verificationState = new PackageVerificationState(
                            requiredUid, this);
","                // TODO: http://b/22976637
                // Apps installed for ""all"" users use the device owner to verify the app
                UserHandle verifierUser = getUser();
                if (verifierUser == UserHandle.ALL) {
                    verifierUser = UserHandle.SYSTEM;
                }

                /*
                 * Determine if we have any installed package verifiers. If we
                 * do, then we'll defer to them to verify the packages.
                 */
                final int requiredUid = mRequiredVerifierPackage == null ? -1
                        : getPackageUid(mRequiredVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING,
                                verifierUser.getIdentifier());

                final int optionalUid = mOptionalVerifierPackage == null ? -1
                        : getPackageUid(mOptionalVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING,
                                verifierUser.getIdentifier());

                final int installerUid =
                        verificationInfo == null ? -1 : verificationInfo.installerUid;
                if (!origin.existing && (requiredUid != -1 || optionalUid != -1)
                        && isVerificationEnabled(
                                verifierUser.getIdentifier(), installFlags, installerUid)) {
                    final Intent verification = new Intent(
                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);
                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),
                            PACKAGE_MIME_TYPE);
                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);

                    // Query all live verifiers based on current user state
                    final List<ResolveInfo> receivers = queryIntentReceiversInternal(verification,
                            PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(),
                            false /*allowDynamicSplits*/);

                    if (DEBUG_VERIFY) {
                        Slog.d(TAG, ""Found "" + receivers.size() + "" verifiers for intent ""
                                + verification.toString() + "" with "" + pkgLite.verifiers.length
                                + "" optional verifiers"");
                    }

                    final int verificationId = mPendingVerificationToken++;

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,
                            installSource.installerPackageName);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,
                            installFlags);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,
                            pkgLite.packageName);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,
                            pkgLite.versionCode);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_LONG_VERSION_CODE,
                            pkgLite.getLongVersionCode());

                    if (verificationInfo != null) {
                        if (verificationInfo.originatingUri != null) {
                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,
                                    verificationInfo.originatingUri);
                        }
                        if (verificationInfo.referrer != null) {
                            verification.putExtra(Intent.EXTRA_REFERRER,
                                    verificationInfo.referrer);
                        }
                        if (verificationInfo.originatingUid >= 0) {
                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,
                                    verificationInfo.originatingUid);
                        }
                        if (verificationInfo.installerUid >= 0) {
                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,
                                    verificationInfo.installerUid);
                        }
                    }

                    final PackageVerificationState verificationState = new PackageVerificationState(
                            requiredUid, this);
","                // TODO: http://b/22976637
                // Apps installed for ""all"" users use the device owner to verify the app
                UserHandle verifierUser = getUser();
                if (verifierUser == UserHandle.ALL) {
                    verifierUser = UserHandle.SYSTEM;
                }

                /*
                 * Determine if we have any installed package verifiers. If we
                 * do, then we'll defer to them to verify the packages.
                 */
                final int requiredUid = mRequiredVerifierPackage == null ? -1
                        : getPackageUid(mRequiredVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING,
                                verifierUser.getIdentifier());

                final int optionalUid = mOptionalVerifierPackage == null ? -1
                        : getPackageUid(mOptionalVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING,
                                verifierUser.getIdentifier());

                final int installerUid =
                        verificationInfo == null ? -1 : verificationInfo.installerUid;
                if (!origin.existing && (requiredUid != -1 || optionalUid != -1)
                        && isVerificationEnabled(
                                verifierUser.getIdentifier(), installFlags, installerUid)) {
                    final Intent verification = new Intent(
                            Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);
                    verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
                    verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),
                            PACKAGE_MIME_TYPE);
                    verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);

                    // Query all live verifiers based on current user state
                    final List<ResolveInfo> receivers = queryIntentReceiversInternal(verification,
                            PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(),
                            false /*allowDynamicSplits*/);

                    if (DEBUG_VERIFY) {
                        Slog.d(TAG, ""Found "" + receivers.size() + "" verifiers for intent ""
                                + verification.toString() + "" with "" + pkgLite.verifiers.length
                                + "" optional verifiers"");
                    }

                    final int verificationId = mPendingVerificationToken++;

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,
                            installSource.installerPackageName);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,
                            installFlags);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME,
                            pkgLite.packageName);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE,
                            pkgLite.versionCode);

                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_LONG_VERSION_CODE,
                            pkgLite.getLongVersionCode());

                    if (verificationInfo != null) {
                        if (verificationInfo.originatingUri != null) {
                            verification.putExtra(Intent.EXTRA_ORIGINATING_URI,
                                    verificationInfo.originatingUri);
                        }
                        if (verificationInfo.referrer != null) {
                            verification.putExtra(Intent.EXTRA_REFERRER,
                                    verificationInfo.referrer);
                        }
                        if (verificationInfo.originatingUid >= 0) {
                            verification.putExtra(Intent.EXTRA_ORIGINATING_UID,
                                    verificationInfo.originatingUid);
                        }
                        if (verificationInfo.installerUid >= 0) {
                            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID,
                                    verificationInfo.installerUid);
                        }
                    }

                    final PackageVerificationState verificationState = new PackageVerificationState(
                            requiredUid, this);
","[1.0, 1.0]"
723,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(14251, 14311, 61), (14251, 14311, 61)]","                    if (mOptionalVerifierPackage != null) {
                        final Intent optionalIntent = new Intent(verification);
                        optionalIntent.setAction(""com.qualcomm.qti.intent.action.PACKAGE_NEEDS_OPTIONAL_VERIFICATION"");
                        final List<ResolveInfo> optional_receivers = queryIntentReceiversInternal(optionalIntent,
                            PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(), false /*allowDynamicSplits*/);
                        final ComponentName optionalVerifierComponent = matchComponentForVerifier(
                            mOptionalVerifierPackage, optional_receivers);
                        optionalIntent.setComponent(optionalVerifierComponent);
                        verificationState.addOptionalVerifier(optionalUid);
                        if (mRequiredVerifierPackage != null) {
                            mContext.sendBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT);
                        } else {
                            mContext.sendOrderedBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,
                            new BroadcastReceiver() {
                                @Override
                                public void onReceive(Context context, Intent intent) {
                                    final Message msg = mHandler.obtainMessage(CHECK_PENDING_VERIFICATION);
                                    msg.arg1 = verificationId;
                                    mHandler.sendMessageDelayed(msg, getVerificationTimeout());
                                }
                            }, null, 0, null, null);

                            /*
                             * We don't want the copy to proceed until
                             * verification succeeds.
                             */
                            mVerificationCompleted = false;
                        }
                    }
                    if (ret == PackageManager.INSTALL_SUCCEEDED
                            && mRequiredVerifierPackage != null) {
                        final ComponentName requiredVerifierComponent = matchComponentForVerifier(
                                mRequiredVerifierPackage, receivers);
                        Trace.asyncTraceBegin(
                                TRACE_TAG_PACKAGE_MANAGER, ""verification"", verificationId);
                        /*
                         * Send the intent to the required verification agent,
                         * but only start the verification timeout after the
                         * target BroadcastReceivers have run.
                         */
                        verification.setComponent(requiredVerifierComponent);
                        idleController.addPowerSaveTempWhitelistApp(Process.myUid(),
                                mRequiredVerifierPackage, idleDuration,
                                verifierUser.getIdentifier(), false, ""package verifier"");
                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,
                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,
                                new BroadcastReceiver() {
                                    @Override
                                    public void onReceive(Context context, Intent intent) {
                                        final Message msg = mHandler
                                                .obtainMessage(CHECK_PENDING_VERIFICATION);
                                        msg.arg1 = verificationId;
                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());
                                    }
                                }, null, 0, null, null);

                        /*
                         * We don't want the copy to proceed until verification
                         * succeeds.
                         */
                        mVerificationCompleted = false;
","                    if (mOptionalVerifierPackage != null) {
                        final Intent optionalIntent = new Intent(verification);
                        optionalIntent.setAction(""com.qualcomm.qti.intent.action.PACKAGE_NEEDS_OPTIONAL_VERIFICATION"");
                        final List<ResolveInfo> optional_receivers = queryIntentReceiversInternal(optionalIntent,
                            PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(), false /*allowDynamicSplits*/);
                        final ComponentName optionalVerifierComponent = matchComponentForVerifier(
                            mOptionalVerifierPackage, optional_receivers);
                        optionalIntent.setComponent(optionalVerifierComponent);
                        verificationState.addOptionalVerifier(optionalUid);
                        if (mRequiredVerifierPackage != null) {
                            mContext.sendBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT);
                        } else {
                            mContext.sendOrderedBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,
                            new BroadcastReceiver() {
                                @Override
                                public void onReceive(Context context, Intent intent) {
                                    final Message msg = mHandler.obtainMessage(CHECK_PENDING_VERIFICATION);
                                    msg.arg1 = verificationId;
                                    mHandler.sendMessageDelayed(msg, getVerificationTimeout());
                                }
                            }, null, 0, null, null);

                            /*
                             * We don't want the copy to proceed until
                             * verification succeeds.
                             */
                            mVerificationCompleted = false;
                        }
                    }
                    if (ret == PackageManager.INSTALL_SUCCEEDED
                            && mRequiredVerifierPackage != null) {
                        final ComponentName requiredVerifierComponent = matchComponentForVerifier(
                                mRequiredVerifierPackage, receivers);
                        Trace.asyncTraceBegin(
                                TRACE_TAG_PACKAGE_MANAGER, ""verification"", verificationId);
                        /*
                         * Send the intent to the required verification agent,
                         * but only start the verification timeout after the
                         * target BroadcastReceivers have run.
                         */
                        verification.setComponent(requiredVerifierComponent);
                        idleController.addPowerSaveTempWhitelistApp(Process.myUid(),
                                mRequiredVerifierPackage, idleDuration,
                                verifierUser.getIdentifier(), false, ""package verifier"");
                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,
                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,
                                new BroadcastReceiver() {
                                    @Override
                                    public void onReceive(Context context, Intent intent) {
                                        final Message msg = mHandler
                                                .obtainMessage(CHECK_PENDING_VERIFICATION);
                                        msg.arg1 = verificationId;
                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());
                                    }
                                }, null, 0, null, null);

                        /*
                         * We don't want the copy to proceed until verification
                         * succeeds.
                         */
                        mVerificationCompleted = false;
","                    if (mOptionalVerifierPackage != null) {
                        final Intent optionalIntent = new Intent(verification);
                        optionalIntent.setAction(""com.qualcomm.qti.intent.action.PACKAGE_NEEDS_OPTIONAL_VERIFICATION"");
                        final List<ResolveInfo> optional_receivers = queryIntentReceiversInternal(optionalIntent,
                            PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(), false /*allowDynamicSplits*/);
                        final ComponentName optionalVerifierComponent = matchComponentForVerifier(
                            mOptionalVerifierPackage, optional_receivers);
                        optionalIntent.setComponent(optionalVerifierComponent);
                        verificationState.addOptionalVerifier(optionalUid);
                        if (mRequiredVerifierPackage != null) {
                            mContext.sendBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT);
                        } else {
                            mContext.sendOrderedBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,
                            new BroadcastReceiver() {
                                @Override
                                public void onReceive(Context context, Intent intent) {
                                    final Message msg = mHandler.obtainMessage(CHECK_PENDING_VERIFICATION);
                                    msg.arg1 = verificationId;
                                    mHandler.sendMessageDelayed(msg, getVerificationTimeout());
                                }
                            }, null, 0, null, null);

                            /*
                             * We don't want the copy to proceed until
                             * verification succeeds.
                             */
                            mVerificationCompleted = false;
                        }
                    }
                    if (ret == PackageManager.INSTALL_SUCCEEDED
                            && mRequiredVerifierPackage != null) {
                        final ComponentName requiredVerifierComponent = matchComponentForVerifier(
                                mRequiredVerifierPackage, receivers);
                        Trace.asyncTraceBegin(
                                TRACE_TAG_PACKAGE_MANAGER, ""verification"", verificationId);
                        /*
                         * Send the intent to the required verification agent,
                         * but only start the verification timeout after the
                         * target BroadcastReceivers have run.
                         */
                        verification.setComponent(requiredVerifierComponent);
                        idleController.addPowerSaveTempWhitelistApp(Process.myUid(),
                                mRequiredVerifierPackage, idleDuration,
                                verifierUser.getIdentifier(), false, ""package verifier"");
                        mContext.sendOrderedBroadcastAsUser(verification, verifierUser,
                                android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,
                                new BroadcastReceiver() {
                                    @Override
                                    public void onReceive(Context context, Intent intent) {
                                        final Message msg = mHandler
                                                .obtainMessage(CHECK_PENDING_VERIFICATION);
                                        msg.arg1 = verificationId;
                                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());
                                    }
                                }, null, 0, null, null);

                        /*
                         * We don't want the copy to proceed until verification
                         * succeeds.
                         */
                        mVerificationCompleted = false;
","[1.0, 1.0]"
724,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(197, 210, 14), (197, 210, 14)]","        * IEEE 802.11ai FILS SK with SHA256
         * @hide
        */
        public static final int FILS_SHA256 = 13;
        /**
         * IEEE 802.11ai FILS SK with SHA384:
         * @hide
         */
        public static final int FILS_SHA384 = 14;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        public static final int DPP = 15;
","        * IEEE 802.11ai FILS SK with SHA256
         * @hide
        */
        public static final int FILS_SHA256 = 13;
        /**
         * IEEE 802.11ai FILS SK with SHA384:
         * @hide
         */
        public static final int FILS_SHA384 = 14;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        public static final int DPP = 15;
","        * IEEE 802.11ai FILS SK with SHA256
         * @hide
        */
        public static final int FILS_SHA256 = 13;
        /**
         * IEEE 802.11ai FILS SK with SHA384:
         * @hide
         */
        public static final int FILS_SHA384 = 14;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        public static final int DPP = 15;
","[1.0, 1.0]"
725,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(217, 218, 2), (217, 218, 2)]","                ""FILS_SHA256"", ""FILS_SHA384"", ""DPP"",
        };
","                ""FILS_SHA256"", ""FILS_SHA384"", ""DPP"",
        };
","                ""FILS_SHA256"", ""FILS_SHA384"", ""DPP"",
        };
","[1.0, 1.0]"
726,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(413, 415, 3), (413, 415, 3)]","    public static final int SECURITY_TYPE_FILS_SHA256 = 7;
    /** @hide */
    public static final int SECURITY_TYPE_FILS_SHA384 = 8;
","    public static final int SECURITY_TYPE_FILS_SHA256 = 7;
    /** @hide */
    public static final int SECURITY_TYPE_FILS_SHA384 = 8;
","    public static final int SECURITY_TYPE_FILS_SHA256 = 7;
    /** @hide */
    public static final int SECURITY_TYPE_FILS_SHA384 = 8;
","[1.0, 1.0]"
727,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(427, 428, 2), (427, 428, 2)]","            SECURITY_TYPE_FILS_SHA256,
            SECURITY_TYPE_FILS_SHA384
","            SECURITY_TYPE_FILS_SHA256,
            SECURITY_TYPE_FILS_SHA384
","            SECURITY_TYPE_FILS_SHA256,
            SECURITY_TYPE_FILS_SHA384
","[1.0, 1.0]"
728,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(480, 484, 5), (480, 484, 5)]","            case SECURITY_TYPE_FILS_SHA256:
                allowedKeyManagement.set(WifiConfiguration.KeyMgmt.FILS_SHA256);
                break;
            case SECURITY_TYPE_FILS_SHA384:
                allowedKeyManagement.set(WifiConfiguration.KeyMgmt.FILS_SHA384);
","            case SECURITY_TYPE_FILS_SHA256:
                allowedKeyManagement.set(WifiConfiguration.KeyMgmt.FILS_SHA256);
                break;
            case SECURITY_TYPE_FILS_SHA384:
                allowedKeyManagement.set(WifiConfiguration.KeyMgmt.FILS_SHA384);
","            case SECURITY_TYPE_FILS_SHA256:
                allowedKeyManagement.set(WifiConfiguration.KeyMgmt.FILS_SHA256);
                break;
            case SECURITY_TYPE_FILS_SHA384:
                allowedKeyManagement.set(WifiConfiguration.KeyMgmt.FILS_SHA384);
","[1.0, 1.0]"
729,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2486, 2487, 2), (2486, 2487, 2)]","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","[1.0, 1.0]"
730,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStackSupervisor.java,"[(55, 55, 1), (55, 55, 1)]","import static com.android.server.wm.ActivityStack.ActivityState.DESTROYED;
","import static com.android.server.wm.ActivityStack.ActivityState.DESTROYED;
","import static com.android.server.wm.ActivityStack.ActivityState.DESTROYED;
","[1.0, 1.0]"
731,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStackSupervisor.java,"[(257, 257, 1), (257, 257, 1)]","    public RootActivityContainer mRootActivityContainer;
","    public RootActivityContainer mRootActivityContainer;
","    public RootActivityContainer mRootActivityContainer;
","[1.0, 1.0]"
732,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceInventory.java,"[(758, 769, 12), (758, 769, 12)]","        final int res = AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
                                AudioSystem.DEVICE_STATE_AVAILABLE, address, name, a2dpCodec);
        if (res != AudioSystem.AUDIO_STATUS_OK) {
            Slog.e(TAG, ""not connecting device 0x""
                    + Integer.toHexString(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)
                    + "" due to command error "" + res);
            return;
        }
        mConnectedDevices.put(
                DeviceInfo.makeDeviceListKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, address),
                new DeviceInfo(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, name,
                        address, a2dpCodec));
","        final int res = AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
                                AudioSystem.DEVICE_STATE_AVAILABLE, address, name, a2dpCodec);
        if (res != AudioSystem.AUDIO_STATUS_OK) {
            Slog.e(TAG, ""not connecting device 0x""
                    + Integer.toHexString(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)
                    + "" due to command error "" + res);
            return;
        }
        mConnectedDevices.put(
                DeviceInfo.makeDeviceListKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, address),
                new DeviceInfo(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, name,
                        address, a2dpCodec));
","        final int res = AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
                                AudioSystem.DEVICE_STATE_AVAILABLE, address, name, a2dpCodec);
        if (res != AudioSystem.AUDIO_STATUS_OK) {
            Slog.e(TAG, ""not connecting device 0x""
                    + Integer.toHexString(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)
                    + "" due to command error "" + res);
            return;
        }
        mConnectedDevices.put(
                DeviceInfo.makeDeviceListKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, address),
                new DeviceInfo(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, name,
                        address, a2dpCodec));
","[1.0, 1.0]"
733,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(766, 781, 16), (766, 781, 16)]","        if (bondState == BluetoothDevice.BOND_BONDED) {
            boolean mIsBondingInitiatedLocally = mDevice.isBondingInitiatedLocally();
            Log.w(TAG, ""mIsBondingInitiatedLocally"" + mIsBondingInitiatedLocally);
            if (mIsBondingInitiatedLocally) {
                mDevice.setBondingInitiatedLocally(false);
            }
            if (mDevice.isBluetoothDock()) {
                onBondingDockConnect();
            } else if (mIsTwsConnectEnabled) {
                Log.d(TAG, ""Initiating connection to"" + mDevice);
                if (mIsBondingInitiatedLocally || mDevice.isTwsPlusDevice()) {
                    connect(false);
                }
            } else if (mIsBondingInitiatedLocally) {
                 connect(false);
            }
","        if (bondState == BluetoothDevice.BOND_BONDED) {
            boolean mIsBondingInitiatedLocally = mDevice.isBondingInitiatedLocally();
            Log.w(TAG, ""mIsBondingInitiatedLocally"" + mIsBondingInitiatedLocally);
            if (mIsBondingInitiatedLocally) {
                mDevice.setBondingInitiatedLocally(false);
            }
            if (mDevice.isBluetoothDock()) {
                onBondingDockConnect();
            } else if (mIsTwsConnectEnabled) {
                Log.d(TAG, ""Initiating connection to"" + mDevice);
                if (mIsBondingInitiatedLocally || mDevice.isTwsPlusDevice()) {
                    connect(false);
                }
            } else if (mIsBondingInitiatedLocally) {
                 connect(false);
            }
","        if (bondState == BluetoothDevice.BOND_BONDED) {
            boolean mIsBondingInitiatedLocally = mDevice.isBondingInitiatedLocally();
            Log.w(TAG, ""mIsBondingInitiatedLocally"" + mIsBondingInitiatedLocally);
            if (mIsBondingInitiatedLocally) {
                mDevice.setBondingInitiatedLocally(false);
            }
            if (mDevice.isBluetoothDock()) {
                onBondingDockConnect();
            } else if (mIsTwsConnectEnabled) {
                Log.d(TAG, ""Initiating connection to"" + mDevice);
                if (mIsBondingInitiatedLocally || mDevice.isTwsPlusDevice()) {
                    connect(false);
                }
            } else if (mIsBondingInitiatedLocally) {
                 connect(false);
            }
","[1.0, 1.0]"
734,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(280, 289, 10), (280, 289, 10)]","    final ActivityTaskManagerService mService;
    final WindowManagerService mWindowManager;

    public BoostFramework mPerf = null;
    /**
     * List of running activities, sorted by recent usage.
     * The first entry in the list is the least recently used.
     * It contains HistoryRecord objects.
     */
    private final ArrayList<ActivityRecord> mLruActivities = new ArrayList<>();
","    final ActivityTaskManagerService mService;
    final WindowManagerService mWindowManager;

    public BoostFramework mPerf = null;
    /**
     * List of running activities, sorted by recent usage.
     * The first entry in the list is the least recently used.
     * It contains HistoryRecord objects.
     */
    private final ArrayList<ActivityRecord> mLruActivities = new ArrayList<>();
","    final ActivityTaskManagerService mService;
    final WindowManagerService mWindowManager;

    public BoostFramework mPerf = null;
    /**
     * List of running activities, sorted by recent usage.
     * The first entry in the list is the least recently used.
     * It contains HistoryRecord objects.
     */
    private final ArrayList<ActivityRecord> mLruActivities = new ArrayList<>();
","[1.0, 1.0]"
735,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/content/Intent.java,"[(11064, 11064, 1), (11064, 11064, 1)]","                case ACTION_PACKAGE_NEEDS_OPTIONAL_VERIFICATION:
","                case ACTION_PACKAGE_NEEDS_OPTIONAL_VERIFICATION:
","                case ACTION_PACKAGE_NEEDS_OPTIONAL_VERIFICATION:
","[1.0, 1.0]"
736,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/ScanResult.java,"[(172, 184, 13), (172, 184, 13)]","     * Security key management scheme: DPP.
     */
    public static final int KEY_MGMT_DPP = 13;
    /**
     * @hide
     * Security key management scheme: FILS_SHA256.
     */
    public static final int KEY_MGMT_FILS_SHA256 = 14;
    /**
     * @hide
     * Security key management scheme: FILS_SHA384.
     */
    public static final int KEY_MGMT_FILS_SHA384 = 15;
","     * Security key management scheme: DPP.
     */
    public static final int KEY_MGMT_DPP = 13;
    /**
     * @hide
     * Security key management scheme: FILS_SHA256.
     */
    public static final int KEY_MGMT_FILS_SHA256 = 14;
    /**
     * @hide
     * Security key management scheme: FILS_SHA384.
     */
    public static final int KEY_MGMT_FILS_SHA384 = 15;
","     * Security key management scheme: DPP.
     */
    public static final int KEY_MGMT_DPP = 13;
    /**
     * @hide
     * Security key management scheme: FILS_SHA256.
     */
    public static final int KEY_MGMT_FILS_SHA256 = 14;
    /**
     * @hide
     * Security key management scheme: FILS_SHA384.
     */
    public static final int KEY_MGMT_FILS_SHA384 = 15;
","[1.0, 1.0]"
737,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(164, 164, 1), (164, 164, 1)]","            @SecurityType int securityType, @Nullable String oweTransIfaceName) {
","            @SecurityType int securityType, @Nullable String oweTransIfaceName) {
","            @SecurityType int securityType, @Nullable String oweTransIfaceName) {
","[1.0, 1.0]"
738,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(172, 172, 1), (172, 172, 1)]","        mOweTransIfaceName = oweTransIfaceName;
","        mOweTransIfaceName = oweTransIfaceName;
","        mOweTransIfaceName = oweTransIfaceName;
","[1.0, 1.0]"
739,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(172, 172, 1), (359, 359, 1)]","        mOweTransIfaceName = oweTransIfaceName;
","            mOweTransIfaceName = null;
",        mOweTransIfaceName = ,"[0.604, 0.744]"
740,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(172, 172, 1), (374, 374, 1)]","        mOweTransIfaceName = oweTransIfaceName;
","            mOweTransIfaceName = other.mOweTransIfaceName;
",        mOweTransIfaceName = o,"[0.625, 0.508]"
741,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(191, 191, 1), (191, 191, 1)]","                && mOweTransIfaceName == other.mOweTransIfaceName;
","                && mOweTransIfaceName == other.mOweTransIfaceName;
","                && mOweTransIfaceName == other.mOweTransIfaceName;
","[1.0, 1.0]"
742,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(197, 197, 1), (197, 197, 1)]","                mBand, mChannel, mSecurityType, mOweTransIfaceName);
","                mBand, mChannel, mSecurityType, mOweTransIfaceName);
","                mBand, mChannel, mSecurityType, mOweTransIfaceName);
","[1.0, 1.0]"
743,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(211, 211, 1), (211, 211, 1)]","        sbuf.append("" \n OWE Transition mode Iface ="").append(mOweTransIfaceName);
","        sbuf.append("" \n OWE Transition mode Iface ="").append(mOweTransIfaceName);
","        sbuf.append("" \n OWE Transition mode Iface ="").append(mOweTransIfaceName);
","[1.0, 1.0]"
744,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(224, 224, 1), (224, 224, 1)]","        dest.writeString(mOweTransIfaceName);
","        dest.writeString(mOweTransIfaceName);
","        dest.writeString(mOweTransIfaceName);
","[1.0, 1.0]"
745,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(240, 240, 1), (240, 240, 1)]","                    in.readString());
","                    in.readString());
","                    in.readString());
","[1.0, 1.0]"
746,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(311, 318, 8), (311, 318, 8)]","     * Return the iface name for OWE transition mode for the AP.
     * {@link #setOweTransIfaceName(String)}.
     *
     * @hide
     */
    @Nullable
    public String getOweTransIfaceName() {
      return mOweTransIfaceName;
","     * Return the iface name for OWE transition mode for the AP.
     * {@link #setOweTransIfaceName(String)}.
     *
     * @hide
     */
    @Nullable
    public String getOweTransIfaceName() {
      return mOweTransIfaceName;
","     * Return the iface name for OWE transition mode for the AP.
     * {@link #setOweTransIfaceName(String)}.
     *
     * @hide
     */
    @Nullable
    public String getOweTransIfaceName() {
      return mOweTransIfaceName;
","[1.0, 1.0]"
747,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(335, 335, 1), (335, 335, 1)]","        private String mOweTransIfaceName;
","        private String mOweTransIfaceName;
","        private String mOweTransIfaceName;
","[1.0, 1.0]"
748,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(359, 359, 1), (359, 359, 1)]","            mOweTransIfaceName = null;
","            mOweTransIfaceName = null;
","            mOweTransIfaceName = null;
","[1.0, 1.0]"
749,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(359, 359, 1), (374, 374, 1)]","            mOweTransIfaceName = null;
","            mOweTransIfaceName = other.mOweTransIfaceName;
",            mOweTransIfaceName = ,"[0.846, 0.559]"
750,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(374, 374, 1), (374, 374, 1)]","            mOweTransIfaceName = other.mOweTransIfaceName;
","            mOweTransIfaceName = other.mOweTransIfaceName;
","            mOweTransIfaceName = other.mOweTransIfaceName;
","[1.0, 1.0]"
751,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(385, 385, 1), (385, 385, 1)]","                mHiddenSsid, mBand, mChannel, setSecurityType(), mOweTransIfaceName);
","                mHiddenSsid, mBand, mChannel, setSecurityType(), mOweTransIfaceName);
","                mHiddenSsid, mBand, mChannel, setSecurityType(), mOweTransIfaceName);
","[1.0, 1.0]"
752,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(514, 525, 12), (514, 525, 12)]","         * Specifies an iface name for OWE transition mode for the AP.
         * <p>
         * <li>If not set, defaults to null.</li>
         *
         * @param oweTransIfaceName iface name for OWE transition mode.
         * @return Builder for chaining.
         *
         * @hide
         */
        @NonNull
        public Builder setOweTransIfaceName(@Nullable String oweTransIfaceName) {
            mOweTransIfaceName = oweTransIfaceName;
","         * Specifies an iface name for OWE transition mode for the AP.
         * <p>
         * <li>If not set, defaults to null.</li>
         *
         * @param oweTransIfaceName iface name for OWE transition mode.
         * @return Builder for chaining.
         *
         * @hide
         */
        @NonNull
        public Builder setOweTransIfaceName(@Nullable String oweTransIfaceName) {
            mOweTransIfaceName = oweTransIfaceName;
","         * Specifies an iface name for OWE transition mode for the AP.
         * <p>
         * <li>If not set, defaults to null.</li>
         *
         * @param oweTransIfaceName iface name for OWE transition mode.
         * @return Builder for chaining.
         *
         * @hide
         */
        @NonNull
        public Builder setOweTransIfaceName(@Nullable String oweTransIfaceName) {
            mOweTransIfaceName = oweTransIfaceName;
","[1.0, 1.0]"
753,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiEnterpriseConfig.java,"[(64, 67, 4), (64, 67, 4)]","    /** @hide */
    public static final String EAP_ERP             = ""eap_erp"";
    /** @hide */
    public static final String KEY_SIMNUM          = ""sim_num"";
","    /** @hide */
    public static final String EAP_ERP             = ""eap_erp"";
    /** @hide */
    public static final String KEY_SIMNUM          = ""sim_num"";
","    /** @hide */
    public static final String EAP_ERP             = ""eap_erp"";
    /** @hide */
    public static final String KEY_SIMNUM          = ""sim_num"";
","[1.0, 1.0]"
754,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ProcessList.java,"[(409, 412, 4), (409, 412, 4)]","    /**
     * BoostFramework Object
     */
    public static BoostFramework mPerfServiceStartHint = new BoostFramework();
","    /**
     * BoostFramework Object
     */
    public static BoostFramework mPerfServiceStartHint = new BoostFramework();
","    /**
     * BoostFramework Object
     */
    public static BoostFramework mPerfServiceStartHint = new BoostFramework();
","[1.0, 1.0]"
755,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/EmergencyButton.java,"[(31, 31, 1), (31, 31, 1)]","import android.telephony.ServiceState;
","import android.telephony.ServiceState;
","import android.telephony.ServiceState;
","[1.0, 1.0]"
756,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(3588, 3601, 14), (3588, 3601, 14)]","         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(@NonNull String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(@NonNull String Macaddr, int numClients);
","         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(@NonNull String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(@NonNull String Macaddr, int numClients);
","         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(@NonNull String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(@NonNull String Macaddr, int numClients);
","[1.0, 1.0]"
757,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(3657, 3670, 14), (3657, 3670, 14)]","        public void onStaConnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaConnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaConnected(Macaddr, numClients);
            });
        }

        @Override
        public void onStaDisconnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaDisconnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaDisconnected(Macaddr, numClients);
","        public void onStaConnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaConnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaConnected(Macaddr, numClients);
            });
        }

        @Override
        public void onStaDisconnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaDisconnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaDisconnected(Macaddr, numClients);
","        public void onStaConnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaConnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaConnected(Macaddr, numClients);
            });
        }

        @Override
        public void onStaDisconnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaDisconnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaDisconnected(Macaddr, numClients);
","[1.0, 1.0]"
758,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/SmsManager.java,"[(1646, 1649, 4), (1646, 1649, 4)]","    @UnsupportedAppUsage
    public boolean
    deleteMessageFromIcc(int messageIndex) {
        android.util.SeempLog.record(80);
","    @UnsupportedAppUsage
    public boolean
    deleteMessageFromIcc(int messageIndex) {
        android.util.SeempLog.record(80);
","    @UnsupportedAppUsage
    public boolean
    deleteMessageFromIcc(int messageIndex) {
        android.util.SeempLog.record(80);
","[1.0, 1.0]"
759,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/SmsManager.java,"[(2007, 2013, 7), (2007, 2013, 7)]","     * Get the capacity count of sms on Icc card
     *
     * @return the capacity count of sms on Icc card
     * @hide
     */
    public int getSmsCapacityOnIcc() {
        int ret = -1;
","     * Get the capacity count of sms on Icc card
     *
     * @return the capacity count of sms on Icc card
     * @hide
     */
    public int getSmsCapacityOnIcc() {
        int ret = -1;
","     * Get the capacity count of sms on Icc card
     *
     * @return the capacity count of sms on Icc card
     * @hide
     */
    public int getSmsCapacityOnIcc() {
        int ret = -1;
","[1.0, 1.0]"
760,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/content/ContentResolver.java,"[(1002, 1003, 2), (1002, 1003, 2)]","        android.util.SeempLog.record_uri(13, uri);
        Preconditions.checkNotNull(uri, ""uri"");
","        android.util.SeempLog.record_uri(13, uri);
        Preconditions.checkNotNull(uri, ""uri"");
","        android.util.SeempLog.record_uri(13, uri);
        Preconditions.checkNotNull(uri, ""uri"");
","[1.0, 1.0]"
761,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/content/ContentResolver.java,"[(1938, 1939, 2), (1938, 1939, 2)]","        android.util.SeempLog.record_uri(37, url);
        Preconditions.checkNotNull(url, ""url"");
","        android.util.SeempLog.record_uri(37, url);
        Preconditions.checkNotNull(url, ""url"");
","        android.util.SeempLog.record_uri(37, url);
        Preconditions.checkNotNull(url, ""url"");
","[1.0, 1.0]"
762,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ProcessRecord.java,"[(66, 66, 1), (66, 66, 1)]","import com.android.server.Watchdog;
","import com.android.server.Watchdog;
","import com.android.server.Watchdog;
","[1.0, 1.0]"
763,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '5358a994b854c7a6627858c48d6947e8acff6ea9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/content/ContentResolver.java,"[(1938, 1939, 2), (1863, 1863, 1)]","        android.util.SeempLog.record_uri(37, url);
        Preconditions.checkNotNull(url, ""url"");
","        android.util.SeempLog.record_uri(37, url);
","        android.util.SeempLog.record_uri(37, url);
","[0.515, 1.0]"
764,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(172, 172, 1), (223, 223, 1)]","        mOweTransIfaceName = oweTransIfaceName;
","        mOweTransIfaceName = oweTransIfaceName;
","        mOweTransIfaceName = oweTransIfaceName;
","[1.0, 1.0]"
765,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(172, 172, 1), (423, 423, 1)]","        mOweTransIfaceName = oweTransIfaceName;
","            mOweTransIfaceName = null;
",        mOweTransIfaceName = ,"[0.604, 0.744]"
766,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(172, 172, 1), (439, 439, 1)]","        mOweTransIfaceName = oweTransIfaceName;
","            mOweTransIfaceName = other.mOweTransIfaceName;
",        mOweTransIfaceName = o,"[0.625, 0.508]"
767,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(191, 191, 1), (243, 243, 1)]","                && mOweTransIfaceName == other.mOweTransIfaceName;
","                && mOweTransIfaceName == other.mOweTransIfaceName;
","                && mOweTransIfaceName == other.mOweTransIfaceName;
","[1.0, 1.0]"
768,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(211, 211, 1), (264, 264, 1)]","        sbuf.append("" \n OWE Transition mode Iface ="").append(mOweTransIfaceName);
","        sbuf.append("" \n OWE Transition mode Iface ="").append(mOweTransIfaceName);
","        sbuf.append("" \n OWE Transition mode Iface ="").append(mOweTransIfaceName);
","[1.0, 1.0]"
769,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(224, 224, 1), (278, 278, 1)]","        dest.writeString(mOweTransIfaceName);
","        dest.writeString(mOweTransIfaceName);
","        dest.writeString(mOweTransIfaceName);
","[1.0, 1.0]"
770,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(240, 240, 1), (294, 294, 1)]","                    in.readString());
","                    in.readInt(), in.readString());
",                    in.read,"[0.711, 0.519]"
771,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(311, 318, 8), (373, 380, 8)]","     * Return the iface name for OWE transition mode for the AP.
     * {@link #setOweTransIfaceName(String)}.
     *
     * @hide
     */
    @Nullable
    public String getOweTransIfaceName() {
      return mOweTransIfaceName;
","     * Return the iface name for OWE transition mode for the AP.
     * {@link #setOweTransIfaceName(String)}.
     *
     * @hide
     */
    @Nullable
    public String getOweTransIfaceName() {
      return mOweTransIfaceName;
","     * Return the iface name for OWE transition mode for the AP.
     * {@link #setOweTransIfaceName(String)}.
     *
     * @hide
     */
    @Nullable
    public String getOweTransIfaceName() {
      return mOweTransIfaceName;
","[1.0, 1.0]"
772,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(359, 359, 1), (223, 223, 1)]","            mOweTransIfaceName = null;
","        mOweTransIfaceName = oweTransIfaceName;
",        mOweTransIfaceName = ,"[0.744, 0.604]"
773,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(359, 359, 1), (423, 423, 1)]","            mOweTransIfaceName = null;
","            mOweTransIfaceName = null;
","            mOweTransIfaceName = null;
","[1.0, 1.0]"
774,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(359, 359, 1), (439, 439, 1)]","            mOweTransIfaceName = null;
","            mOweTransIfaceName = other.mOweTransIfaceName;
",            mOweTransIfaceName = ,"[0.846, 0.559]"
775,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(374, 374, 1), (223, 223, 1)]","            mOweTransIfaceName = other.mOweTransIfaceName;
","        mOweTransIfaceName = oweTransIfaceName;
",        mOweTransIfaceName = o,"[0.508, 0.625]"
776,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(374, 374, 1), (423, 423, 1)]","            mOweTransIfaceName = other.mOweTransIfaceName;
","            mOweTransIfaceName = null;
",            mOweTransIfaceName = ,"[0.559, 0.846]"
777,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(374, 374, 1), (439, 439, 1)]","            mOweTransIfaceName = other.mOweTransIfaceName;
","            mOweTransIfaceName = other.mOweTransIfaceName;
","            mOweTransIfaceName = other.mOweTransIfaceName;
","[1.0, 1.0]"
778,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(514, 525, 12), (627, 638, 12)]","         * Specifies an iface name for OWE transition mode for the AP.
         * <p>
         * <li>If not set, defaults to null.</li>
         *
         * @param oweTransIfaceName iface name for OWE transition mode.
         * @return Builder for chaining.
         *
         * @hide
         */
        @NonNull
        public Builder setOweTransIfaceName(@Nullable String oweTransIfaceName) {
            mOweTransIfaceName = oweTransIfaceName;
","         * Specifies an iface name for OWE transition mode for the AP.
         * <p>
         * <li>If not set, defaults to null.</li>
         *
         * @param oweTransIfaceName iface name for OWE transition mode.
         * @return Builder for chaining.
         *
         * @hide
         */
        @NonNull
        public Builder setOweTransIfaceName(@Nullable String oweTransIfaceName) {
            mOweTransIfaceName = oweTransIfaceName;
","         * Specifies an iface name for OWE transition mode for the AP.
         * <p>
         * <li>If not set, defaults to null.</li>
         *
         * @param oweTransIfaceName iface name for OWE transition mode.
         * @return Builder for chaining.
         *
         * @hide
         */
        @NonNull
        public Builder setOweTransIfaceName(@Nullable String oweTransIfaceName) {
            mOweTransIfaceName = oweTransIfaceName;
","[1.0, 1.0]"
779,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(3588, 3601, 14), (3604, 3617, 14)]","         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(@NonNull String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(@NonNull String Macaddr, int numClients);
","         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(@NonNull String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(@NonNull String Macaddr, int numClients);
","         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(@NonNull String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(@NonNull String Macaddr, int numClients);
","[1.0, 1.0]"
780,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(3657, 3670, 14), (3686, 3699, 14)]","        public void onStaConnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaConnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaConnected(Macaddr, numClients);
            });
        }

        @Override
        public void onStaDisconnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaDisconnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaDisconnected(Macaddr, numClients);
","        public void onStaConnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaConnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaConnected(Macaddr, numClients);
            });
        }

        @Override
        public void onStaDisconnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaDisconnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaDisconnected(Macaddr, numClients);
","        public void onStaConnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaConnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaConnected(Macaddr, numClients);
            });
        }

        @Override
        public void onStaDisconnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaDisconnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaDisconnected(Macaddr, numClients);
","[1.0, 1.0]"
781,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2486, 2487, 2), (2637, 2638, 2)]","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","[1.0, 1.0]"
782,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiEnterpriseConfig.java,"[(64, 67, 4), (96, 97, 2)]","    /** @hide */
    public static final String EAP_ERP             = ""eap_erp"";
    /** @hide */
    public static final String KEY_SIMNUM          = ""sim_num"";
","    /** @hide */
    public static final String KEY_SIMNUM          = ""sim_num"";
","    /** @hide */
    public static final String KEY_SIMNUM          = ""sim_num"";
","[0.5, 1.0]"
783,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ProcessRecord.java,"[(66, 66, 1), (70, 70, 1)]","import com.android.server.Watchdog;
","import com.android.server.Watchdog;
","import com.android.server.Watchdog;
","[1.0, 1.0]"
784,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2486, 2487, 2), (2059, 2060, 2)]","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            return KeyMgmt.DPP;
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            ","[0.626, 0.783]"
785,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2486, 2487, 2), (2098, 2099, 2)]","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","            } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            ","[0.626, 0.585]"
786,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ProcessRecord.java,"[(66, 66, 1), (69, 69, 1)]","import com.android.server.Watchdog;
","import com.android.server.Watchdog;
","import com.android.server.Watchdog;
","[1.0, 1.0]"
787,"['43ceded8caaffead0a2a1967f42a4ef4bb658ced', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStackSupervisor.java,"[(55, 55, 1), (55, 56, 2)]","import static com.android.server.wm.ActivityStack.ActivityState.DESTROYED;
","import static com.android.server.wm.ActivityStack.ActivityState.DESTROYED;
import static com.android.server.wm.ActivityStack.REMOVE_TASK_MODE_MOVING;
","import static com.android.server.wm.ActivityStack.ActivityState.DESTROYED;
","[1.0, 0.5]"
788,"['4986b8091f9beefea4189a5884e7a9edd7f53034', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/CornerHandleView.java,"[(174, 175, 2), (158, 159, 2)]","                com.android.internal.R.dimen.rounded_corner_radius_bottom);
        if (radius == 0 && mDisableRoundedCorner == 0) {
","                com.android.internal.R.dimen.rounded_corner_radius_bottom);
        if (radius == 0 && mDisableRoundedCorner == 0) {
","                com.android.internal.R.dimen.rounded_corner_radius_bottom);
        if (radius == 0 && mDisableRoundedCorner == 0) {
","[1.0, 1.0]"
789,"['4986b8091f9beefea4189a5884e7a9edd7f53034', '4986b8091f9beefea4189a5884e7a9edd7f53034']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/CornerHandleView.java,"[(174, 175, 2), (174, 175, 2)]","                com.android.internal.R.dimen.rounded_corner_radius_bottom);
        if (radius == 0 && mDisableRoundedCorner == 0) {
","                com.android.internal.R.dimen.rounded_corner_radius_bottom);
        if (radius == 0 && mDisableRoundedCorner == 0) {
","                com.android.internal.R.dimen.rounded_corner_radius_bottom);
        if (radius == 0 && mDisableRoundedCorner == 0) {
","[1.0, 1.0]"
790,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '5358a994b854c7a6627858c48d6947e8acff6ea9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(147, 148, 2), (147, 148, 2)]","import com.android.internal.app.ActivityTrigger;

","import com.android.internal.app.ActivityTrigger;

","import com.android.internal.app.ActivityTrigger;

","[1.0, 1.0]"
791,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '5358a994b854c7a6627858c48d6947e8acff6ea9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(173, 173, 1), (173, 173, 1)]","public class ActivityStack extends TaskStack {
","public class ActivityStack extends TaskStack {
","public class ActivityStack extends TaskStack {
","[1.0, 1.0]"
792,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '5358a994b854c7a6627858c48d6947e8acff6ea9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/WifiDisplayController.java,"[(347, 347, 1), (347, 347, 1)]","                mWifiP2pManager.setWFDInfo(getWifiP2pChannel(), wfdInfo, new ActionListener() {
","                mWifiP2pManager.setWFDInfo(getWifiP2pChannel(), wfdInfo, new ActionListener() {
","                mWifiP2pManager.setWFDInfo(getWifiP2pChannel(), wfdInfo, new ActionListener() {
","[1.0, 1.0]"
793,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '5358a994b854c7a6627858c48d6947e8acff6ea9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(1880, 1882, 3), (1880, 1882, 3)]","        } else if (result.capabilities.contains(""PSK"")
                   && result.capabilities.contains(""SAE"")) {
            return SECURITY_PSK_SAE_TRANSITION;
","        } else if (result.capabilities.contains(""PSK"")
                   && result.capabilities.contains(""SAE"")) {
            return SECURITY_PSK_SAE_TRANSITION;
","        } else if (result.capabilities.contains(""PSK"")
                   && result.capabilities.contains(""SAE"")) {
            return SECURITY_PSK_SAE_TRANSITION;
","[1.0, 1.0]"
794,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '5358a994b854c7a6627858c48d6947e8acff6ea9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/content/ContentResolver.java,"[(1863, 1863, 1), (1863, 1863, 1)]","        android.util.SeempLog.record_uri(37, url);
","        android.util.SeempLog.record_uri(37, url);
","        android.util.SeempLog.record_uri(37, url);
","[1.0, 1.0]"
795,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '5358a994b854c7a6627858c48d6947e8acff6ea9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(1888, 1892, 5), (1888, 1892, 5)]","        dppConnector = null;
        dppNetAccessKey = null;
        dppNetAccessKeyExpiry = -1;
        dppCsign = null;
        oweTransIfaceName = null;
","        dppConnector = null;
        dppNetAccessKey = null;
        dppNetAccessKeyExpiry = -1;
        dppCsign = null;
        oweTransIfaceName = null;
","        dppConnector = null;
        dppNetAccessKey = null;
        dppNetAccessKeyExpiry = -1;
        dppCsign = null;
        oweTransIfaceName = null;
","[1.0, 1.0]"
796,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '5358a994b854c7a6627858c48d6947e8acff6ea9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2568, 2568, 1), (2568, 2568, 1)]","            oweTransIfaceName = source.oweTransIfaceName;
","            oweTransIfaceName = source.oweTransIfaceName;
","            oweTransIfaceName = source.oweTransIfaceName;
","[1.0, 1.0]"
797,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '5358a994b854c7a6627858c48d6947e8acff6ea9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2649, 2649, 1), (2649, 2649, 1)]","        dest.writeString(oweTransIfaceName);
","        dest.writeString(oweTransIfaceName);
","        dest.writeString(oweTransIfaceName);
","[1.0, 1.0]"
798,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '5358a994b854c7a6627858c48d6947e8acff6ea9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2732, 2732, 1), (2732, 2732, 1)]","                config.oweTransIfaceName = in.readString();
","                config.oweTransIfaceName = in.readString();
","                config.oweTransIfaceName = in.readString();
","[1.0, 1.0]"
799,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '5358a994b854c7a6627858c48d6947e8acff6ea9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/p2p/WifiP2pWfdInfo.java,"[(38, 47, 10), (38, 47, 10)]","    private int mR2DeviceInfo;

    public static final int WFD_SOURCE              = 0;
    public static final int PRIMARY_SINK            = 1;
    public static final int SECONDARY_SINK          = 2;
    public static final int SOURCE_OR_PRIMARY_SINK  = 3;

    /* Device information bitmap */
    /** One of {@link #WFD_SOURCE}, {@link #PRIMARY_SINK}, {@link #SECONDARY_SINK}
     * or {@link #SOURCE_OR_PRIMARY_SINK}
","    private int mR2DeviceInfo;

    public static final int WFD_SOURCE              = 0;
    public static final int PRIMARY_SINK            = 1;
    public static final int SECONDARY_SINK          = 2;
    public static final int SOURCE_OR_PRIMARY_SINK  = 3;

    /* Device information bitmap */
    /** One of {@link #WFD_SOURCE}, {@link #PRIMARY_SINK}, {@link #SECONDARY_SINK}
     * or {@link #SOURCE_OR_PRIMARY_SINK}
","    private int mR2DeviceInfo;

    public static final int WFD_SOURCE              = 0;
    public static final int PRIMARY_SINK            = 1;
    public static final int SECONDARY_SINK          = 2;
    public static final int SOURCE_OR_PRIMARY_SINK  = 3;

    /* Device information bitmap */
    /** One of {@link #WFD_SOURCE}, {@link #PRIMARY_SINK}, {@link #SECONDARY_SINK}
     * or {@link #SOURCE_OR_PRIMARY_SINK}
","[1.0, 1.0]"
800,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '5358a994b854c7a6627858c48d6947e8acff6ea9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/p2p/WifiP2pWfdInfo.java,"[(78, 82, 5), (78, 82, 5)]","    public boolean isWfdR2Supported() {
        return (mR2DeviceInfo<0?false:true);
    }

    @UnsupportedAppUsage
","    public boolean isWfdR2Supported() {
        return (mR2DeviceInfo<0?false:true);
    }

    @UnsupportedAppUsage
","    public boolean isWfdR2Supported() {
        return (mR2DeviceInfo<0?false:true);
    }

    @UnsupportedAppUsage
","[1.0, 1.0]"
801,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '5358a994b854c7a6627858c48d6947e8acff6ea9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/p2p/WifiP2pWfdInfo.java,"[(87, 91, 5), (87, 91, 5)]","    public void setWfdR2Device(int r2DeviceInfo) {
        mR2DeviceInfo = r2DeviceInfo;
    }

    @UnsupportedAppUsage
","    public void setWfdR2Device(int r2DeviceInfo) {
        mR2DeviceInfo = r2DeviceInfo;
    }

    @UnsupportedAppUsage
","    public void setWfdR2Device(int r2DeviceInfo) {
        mR2DeviceInfo = r2DeviceInfo;
    }

    @UnsupportedAppUsage
","[1.0, 1.0]"
802,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '5358a994b854c7a6627858c48d6947e8acff6ea9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/p2p/WifiP2pWfdInfo.java,"[(167, 170, 4), (167, 170, 4)]","    public String getR2DeviceInfoHex() {
        return String.format(
                Locale.US, ""%04x%04x"", 2, mR2DeviceInfo);
    }
","    public String getR2DeviceInfoHex() {
        return String.format(
                Locale.US, ""%04x%04x"", 2, mR2DeviceInfo);
    }
","    public String getR2DeviceInfoHex() {
        return String.format(
                Locale.US, ""%04x%04x"", 2, mR2DeviceInfo);
    }
","[1.0, 1.0]"
803,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(147, 148, 2), (151, 153, 3)]","import com.android.internal.app.ActivityTrigger;

","import android.view.SurfaceControl;
import com.android.internal.app.ActivityTrigger;

","import com.android.internal.app.ActivityTrigger;

","[1.0, 0.581]"
804,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(1888, 1892, 5), (1892, 1897, 6)]","        dppConnector = null;
        dppNetAccessKey = null;
        dppNetAccessKeyExpiry = -1;
        dppCsign = null;
        oweTransIfaceName = null;
","        clonedNetworkConfigKey = null;
        dppConnector = null;
        dppNetAccessKey = null;
        dppNetAccessKeyExpiry = -1;
        dppCsign = null;
        oweTransIfaceName = null;
","        dppConnector = null;
        dppNetAccessKey = null;
        dppNetAccessKeyExpiry = -1;
        dppCsign = null;
        oweTransIfaceName = null;
","[1.0, 0.8]"
805,"['5358a994b854c7a6627858c48d6947e8acff6ea9', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(173, 173, 1), (208, 208, 1)]","public class ActivityStack extends TaskStack {
","public class ActivityStack extends Task implements BoundsAnimationTarget {
",public class ActivityStack extends Task,"[0.83, 0.52]"
806,"['5358a994b854c7a6627858c48d6947e8acff6ea9', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(173, 173, 1), (173, 173, 1)]","public class ActivityStack extends TaskStack {
","public class ActivityStack extends ConfigurationContainer {
",public class ActivityStack extends ,"[0.745, 0.583]"
807,"['5358a994b854c7a6627858c48d6947e8acff6ea9', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2649, 2649, 1), (2616, 2616, 1)]","        dest.writeString(oweTransIfaceName);
","        dest.writeString(oweTransIfaceName);
","        dest.writeString(oweTransIfaceName);
","[1.0, 1.0]"
808,"['5358a994b854c7a6627858c48d6947e8acff6ea9', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2732, 2732, 1), (2695, 2695, 1)]","                config.oweTransIfaceName = in.readString();
","                config.oweTransIfaceName = in.readString();
","                config.oweTransIfaceName = in.readString();
","[1.0, 1.0]"
813,"['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActiveServices.java,"[(3198, 3204, 7), (2547, 2552, 6)]","                    app.services.remove(r);
                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");
                    }
","                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortName + "" in "" + r.restartDelay + ""ms"");
                    }
","                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.short","[0.705, 0.815]"
814,"['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(4056, 4056, 1), (3546, 3547, 2)]","        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
","        Log.i(TAG, ""In startBluetoothSco()"");
        int scoAudioMode =
","        Log.i(TAG, ""In startBluetoothSco","[0.702, 0.548]"
815,"['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(4064, 4064, 1), (3546, 3547, 2)]","        Log.i(TAG, ""In startBluetoothScoInt(), scoAudioMode: "" + scoAudioMode);
","        Log.i(TAG, ""In startBluetoothSco()"");
        int scoAudioMode =
","        Log.i(TAG, ""In startBluetoothSco","[0.5, 0.548]"
816,"['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3971, 3974, 4), (3971, 3974, 4)]","                .append("") from u/pid:"").append(Binder.getCallingUid()).append(""/"")
                .append(Binder.getCallingPid()).toString();
        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

","                .append("") from u/pid:"").append(Binder.getCallingUid()).append(""/"")
                .append(Binder.getCallingPid()).toString();
        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

","                .append("") from u/pid:"").append(Binder.getCallingUid()).append(""/"")
                .append(Binder.getCallingPid()).toString();
        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

","[1.0, 1.0]"
817,"['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3971, 3974, 4), (4009, 4011, 3)]","                .append("") from u/pid:"").append(Binder.getCallingUid()).append(""/"")
                .append(Binder.getCallingPid()).toString();
        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

","                .append("") from u/pid:"").append(Binder.getCallingUid()).append(""/"")
                .append(Binder.getCallingPid()).toString();
        Log.i(TAG, ""In setBluetoothScoOn(), eventSource: "" + eventSource);
","                .append("") from u/pid:"").append(Binder.getCallingUid()).append(""/"")
                .append(Binder.getCallingPid()).toString();
        Log.i(TAG, ""In set","[0.72, 0.776]"
818,"['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(4009, 4011, 3), (4009, 4011, 3)]","                .append("") from u/pid:"").append(Binder.getCallingUid()).append(""/"")
                .append(Binder.getCallingPid()).toString();
        Log.i(TAG, ""In setBluetoothScoOn(), eventSource: "" + eventSource);
","                .append("") from u/pid:"").append(Binder.getCallingUid()).append(""/"")
                .append(Binder.getCallingPid()).toString();
        Log.i(TAG, ""In setBluetoothScoOn(), eventSource: "" + eventSource);
","                .append("") from u/pid:"").append(Binder.getCallingUid()).append(""/"")
                .append(Binder.getCallingPid()).toString();
        Log.i(TAG, ""In setBluetoothScoOn(), eventSource: "" + eventSource);
","[1.0, 1.0]"
819,"['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(4039, 4044, 6), (4039, 4044, 6)]","        Log.i(TAG, ""In startBluetoothSco()"");
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if ((adapter == null) || (adapter.getState() != BluetoothAdapter.STATE_ON)) {
             Log.i(TAG, ""startBluetoothSco(), BT is not turned ON or adapter is null"");
             return;
        }
","        Log.i(TAG, ""In startBluetoothSco()"");
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if ((adapter == null) || (adapter.getState() != BluetoothAdapter.STATE_ON)) {
             Log.i(TAG, ""startBluetoothSco(), BT is not turned ON or adapter is null"");
             return;
        }
","        Log.i(TAG, ""In startBluetoothSco()"");
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if ((adapter == null) || (adapter.getState() != BluetoothAdapter.STATE_ON)) {
             Log.i(TAG, ""startBluetoothSco(), BT is not turned ON or adapter is null"");
             return;
        }
","[1.0, 1.0]"
820,"['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(4056, 4056, 1), (4056, 4056, 1)]","        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
","        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
","        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
","[1.0, 1.0]"
821,"['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(4056, 4056, 1), (4064, 4064, 1)]","        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
","        Log.i(TAG, ""In startBluetoothScoInt(), scoAudioMode: "" + scoAudioMode);
","        Log.i(TAG, ""In startBluetoothSco","[0.702, 0.5]"
822,"['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(4064, 4064, 1), (4064, 4064, 1)]","        Log.i(TAG, ""In startBluetoothScoInt(), scoAudioMode: "" + scoAudioMode);
","        Log.i(TAG, ""In startBluetoothScoInt(), scoAudioMode: "" + scoAudioMode);
","        Log.i(TAG, ""In startBluetoothScoInt(), scoAudioMode: "" + scoAudioMode);
","[1.0, 1.0]"
823,"['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(151, 153, 3), (151, 153, 3)]","import android.view.SurfaceControl;
import com.android.internal.app.ActivityTrigger;

","import android.view.SurfaceControl;
import com.android.internal.app.ActivityTrigger;

","import android.view.SurfaceControl;
import com.android.internal.app.ActivityTrigger;

","[1.0, 1.0]"
824,"['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(932, 995, 64), (932, 995, 64)]","    public ActivityRecord topRunningActivity() {
        return topRunningActivity(false /* focusableOnly */);
    }

    ActivityRecord topRunningActivity(boolean focusableOnly) {
        // Split into 2 to avoid object creation due to variable capture.
        if (focusableOnly) {
            return getActivity((r) -> r.canBeTopRunning() && r.isFocusable());
        } else {
            return getActivity(ActivityRecord::canBeTopRunning);
        }
    }

    private ActivityRecord topRunningNonOverlayTaskActivity() {
        return getActivity((r) -> (r.canBeTopRunning() && !r.isTaskOverlay()));
    }

    ActivityRecord topRunningNonDelayedActivityLocked(ActivityRecord notTop) {
        final PooledPredicate p = PooledLambda.obtainPredicate(ActivityStack::isTopRunningNonDelayed
                , PooledLambda.__(ActivityRecord.class), notTop);
        final ActivityRecord r = getActivity(p);
        p.recycle();
        return r;
    }

    private static boolean isTopRunningNonDelayed(ActivityRecord r, ActivityRecord notTop) {
        return !r.delayedResume && r != notTop && r.canBeTopRunning();
    }

    /**
     * This is a simplified version of topRunningActivity that provides a number of
     * optional skip-over modes.  It is intended for use with the ActivityController hook only.
     *
     * @param token If non-null, any history records matching this token will be skipped.
     * @param taskId If non-zero, we'll attempt to skip over records with the same task ID.
     *
     * @return Returns the HistoryRecord of the next activity on the stack.
     */
    ActivityRecord topRunningActivity(IBinder token, int taskId) {
        final PooledPredicate p = PooledLambda.obtainPredicate(ActivityStack::isTopRunning,
                PooledLambda.__(ActivityRecord.class), taskId, token);
        final ActivityRecord r = getActivity(p);
        p.recycle();
        return r;
    }

    private static boolean isTopRunning(ActivityRecord r, int taskId, IBinder notTop) {
        return r.getTask().mTaskId != taskId && r.appToken != notTop && r.canBeTopRunning();
    }

    ActivityRecord isInStackLocked(ActivityRecord r) {
        if (r == null) {
            return null;
        }
        final Task task = r.getRootTask();
        if (task != null && r.isDescendantOf(task)) {
            if (task != this) Slog.w(TAG, ""Illegal state! task does not point to stack it is in. ""
                    + ""stack="" + this + "" task="" + task + "" r="" + r
                    + "" callers="" + Debug.getCallers(15, ""\n""));
            return r;
        }
        return null;
    }

","    public ActivityRecord topRunningActivity() {
        return topRunningActivity(false /* focusableOnly */);
    }

    ActivityRecord topRunningActivity(boolean focusableOnly) {
        // Split into 2 to avoid object creation due to variable capture.
        if (focusableOnly) {
            return getActivity((r) -> r.canBeTopRunning() && r.isFocusable());
        } else {
            return getActivity(ActivityRecord::canBeTopRunning);
        }
    }

    private ActivityRecord topRunningNonOverlayTaskActivity() {
        return getActivity((r) -> (r.canBeTopRunning() && !r.isTaskOverlay()));
    }

    ActivityRecord topRunningNonDelayedActivityLocked(ActivityRecord notTop) {
        final PooledPredicate p = PooledLambda.obtainPredicate(ActivityStack::isTopRunningNonDelayed
                , PooledLambda.__(ActivityRecord.class), notTop);
        final ActivityRecord r = getActivity(p);
        p.recycle();
        return r;
    }

    private static boolean isTopRunningNonDelayed(ActivityRecord r, ActivityRecord notTop) {
        return !r.delayedResume && r != notTop && r.canBeTopRunning();
    }

    /**
     * This is a simplified version of topRunningActivity that provides a number of
     * optional skip-over modes.  It is intended for use with the ActivityController hook only.
     *
     * @param token If non-null, any history records matching this token will be skipped.
     * @param taskId If non-zero, we'll attempt to skip over records with the same task ID.
     *
     * @return Returns the HistoryRecord of the next activity on the stack.
     */
    ActivityRecord topRunningActivity(IBinder token, int taskId) {
        final PooledPredicate p = PooledLambda.obtainPredicate(ActivityStack::isTopRunning,
                PooledLambda.__(ActivityRecord.class), taskId, token);
        final ActivityRecord r = getActivity(p);
        p.recycle();
        return r;
    }

    private static boolean isTopRunning(ActivityRecord r, int taskId, IBinder notTop) {
        return r.getTask().mTaskId != taskId && r.appToken != notTop && r.canBeTopRunning();
    }

    ActivityRecord isInStackLocked(ActivityRecord r) {
        if (r == null) {
            return null;
        }
        final Task task = r.getRootTask();
        if (task != null && r.isDescendantOf(task)) {
            if (task != this) Slog.w(TAG, ""Illegal state! task does not point to stack it is in. ""
                    + ""stack="" + this + "" task="" + task + "" r="" + r
                    + "" callers="" + Debug.getCallers(15, ""\n""));
            return r;
        }
        return null;
    }

","    public ActivityRecord topRunningActivity() {
        return topRunningActivity(false /* focusableOnly */);
    }

    ActivityRecord topRunningActivity(boolean focusableOnly) {
        // Split into 2 to avoid object creation due to variable capture.
        if (focusableOnly) {
            return getActivity((r) -> r.canBeTopRunning() && r.isFocusable());
        } else {
            return getActivity(ActivityRecord::canBeTopRunning);
        }
    }

    private ActivityRecord topRunningNonOverlayTaskActivity() {
        return getActivity((r) -> (r.canBeTopRunning() && !r.isTaskOverlay()));
    }

    ActivityRecord topRunningNonDelayedActivityLocked(ActivityRecord notTop) {
        final PooledPredicate p = PooledLambda.obtainPredicate(ActivityStack::isTopRunningNonDelayed
                , PooledLambda.__(ActivityRecord.class), notTop);
        final ActivityRecord r = getActivity(p);
        p.recycle();
        return r;
    }

    private static boolean isTopRunningNonDelayed(ActivityRecord r, ActivityRecord notTop) {
        return !r.delayedResume && r != notTop && r.canBeTopRunning();
    }

    /**
     * This is a simplified version of topRunningActivity that provides a number of
     * optional skip-over modes.  It is intended for use with the ActivityController hook only.
     *
     * @param token If non-null, any history records matching this token will be skipped.
     * @param taskId If non-zero, we'll attempt to skip over records with the same task ID.
     *
     * @return Returns the HistoryRecord of the next activity on the stack.
     */
    ActivityRecord topRunningActivity(IBinder token, int taskId) {
        final PooledPredicate p = PooledLambda.obtainPredicate(ActivityStack::isTopRunning,
                PooledLambda.__(ActivityRecord.class), taskId, token);
        final ActivityRecord r = getActivity(p);
        p.recycle();
        return r;
    }

    private static boolean isTopRunning(ActivityRecord r, int taskId, IBinder notTop) {
        return r.getTask().mTaskId != taskId && r.appToken != notTop && r.canBeTopRunning();
    }

    ActivityRecord isInStackLocked(ActivityRecord r) {
        if (r == null) {
            return null;
        }
        final Task task = r.getRootTask();
        if (task != null && r.isDescendantOf(task)) {
            if (task != this) Slog.w(TAG, ""Illegal state! task does not point to stack it is in. ""
                    + ""stack="" + this + "" task="" + task + "" r="" + r
                    + "" callers="" + Debug.getCallers(15, ""\n""));
            return r;
        }
        return null;
    }

","[1.0, 1.0]"
825,"['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActiveServices.java,"[(3198, 3204, 7), (3198, 3204, 7)]","                    app.services.remove(r);
                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");
                    }
","                    app.services.remove(r);
                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");
                    }
","                    app.services.remove(r);
                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");
                    }
","[1.0, 1.0]"
826,"['62f4dee264cabcd5595e6e4c0a6ab3228281d3e0', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,"[(181, 183, 3), (181, 183, 3)]","                findViewById(R.id.brightness_slider), broadcastDispatcher);

        updateResources();
","                findViewById(R.id.brightness_slider), broadcastDispatcher);

        updateResources();
","                findViewById(R.id.brightness_slider), broadcastDispatcher);

        updateResources();
","[1.0, 1.0]"
829,"['69bee5bb55994d647b678b2cb2ce1becd3d77b32', '69bee5bb55994d647b678b2cb2ce1becd3d77b32']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/TaskDisplayArea.java,"[(147, 154, 8), (147, 154, 8)]","    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = null;
    public BoostFramework mUxPerf = null;

    TaskDisplayArea(DisplayContent displayContent, WindowManagerService service) {
        super(service, Type.ANY, ""TaskContainers"", FEATURE_TASK_CONTAINER);
","    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = null;
    public BoostFramework mUxPerf = null;

    TaskDisplayArea(DisplayContent displayContent, WindowManagerService service) {
        super(service, Type.ANY, ""TaskContainers"", FEATURE_TASK_CONTAINER);
","    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = null;
    public BoostFramework mUxPerf = null;

    TaskDisplayArea(DisplayContent displayContent, WindowManagerService service) {
        super(service, Type.ANY, ""TaskContainers"", FEATURE_TASK_CONTAINER);
","[1.0, 1.0]"
830,"['69bee5bb55994d647b678b2cb2ce1becd3d77b32', '69bee5bb55994d647b678b2cb2ce1becd3d77b32']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(123, 125, 3), (123, 125, 3)]","    private static final int MESSAGE_REGISTER_ADAPTER = 20;
    private static final int MESSAGE_UNREGISTER_ADAPTER = 21;
    private static final int MESSAGE_INFORM_ADAPTER_SERVICE_UP = 22;
","    private static final int MESSAGE_REGISTER_ADAPTER = 20;
    private static final int MESSAGE_UNREGISTER_ADAPTER = 21;
    private static final int MESSAGE_INFORM_ADAPTER_SERVICE_UP = 22;
","    private static final int MESSAGE_REGISTER_ADAPTER = 20;
    private static final int MESSAGE_UNREGISTER_ADAPTER = 21;
    private static final int MESSAGE_INFORM_ADAPTER_SERVICE_UP = 22;
","[1.0, 1.0]"
831,"['69bee5bb55994d647b678b2cb2ce1becd3d77b32', '69bee5bb55994d647b678b2cb2ce1becd3d77b32']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1663, 1671, 9), (1663, 1671, 9)]","        try {
            mBluetoothLock.writeLock().lock();
            int n = mCallbacks.beginBroadcast();
            Slog.d(TAG, ""Broadcasting onBluetoothServiceUp() to "" + n + "" receivers."");
            for (int i = 0; i < n; i++) {
                try {
                    mCallbacks.getBroadcastItem(i).onBluetoothServiceUp(mBluetooth);
                } catch (RemoteException e) {
                    Slog.e(TAG, ""Unable to call onBluetoothServiceUp() on callback #"" + i, e);
","        try {
            mBluetoothLock.writeLock().lock();
            int n = mCallbacks.beginBroadcast();
            Slog.d(TAG, ""Broadcasting onBluetoothServiceUp() to "" + n + "" receivers."");
            for (int i = 0; i < n; i++) {
                try {
                    mCallbacks.getBroadcastItem(i).onBluetoothServiceUp(mBluetooth);
                } catch (RemoteException e) {
                    Slog.e(TAG, ""Unable to call onBluetoothServiceUp() on callback #"" + i, e);
","        try {
            mBluetoothLock.writeLock().lock();
            int n = mCallbacks.beginBroadcast();
            Slog.d(TAG, ""Broadcasting onBluetoothServiceUp() to "" + n + "" receivers."");
            for (int i = 0; i < n; i++) {
                try {
                    mCallbacks.getBroadcastItem(i).onBluetoothServiceUp(mBluetooth);
                } catch (RemoteException e) {
                    Slog.e(TAG, ""Unable to call onBluetoothServiceUp() on callback #"" + i, e);
","[1.0, 1.0]"
832,"['69bee5bb55994d647b678b2cb2ce1becd3d77b32', '69bee5bb55994d647b678b2cb2ce1becd3d77b32']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1674, 1676, 3), (1674, 1676, 3)]","        } finally {
            mCallbacks.finishBroadcast();
            mBluetoothLock.writeLock().unlock();
","        } finally {
            mCallbacks.finishBroadcast();
            mBluetoothLock.writeLock().unlock();
","        } finally {
            mCallbacks.finishBroadcast();
            mBluetoothLock.writeLock().unlock();
","[1.0, 1.0]"
833,"['69bee5bb55994d647b678b2cb2ce1becd3d77b32', '69bee5bb55994d647b678b2cb2ce1becd3d77b32']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(2064, 2081, 18), (2064, 2081, 18)]","
                case MESSAGE_REGISTER_ADAPTER: {
                    if (DBG) Slog.d(TAG,""MESSAGE_REGISTER_ADAPTER"");
                    IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                    mCallbacks.register(callback);
                    break;
                }
                case MESSAGE_UNREGISTER_ADAPTER: {
                    if (DBG) Slog.d(TAG,""MESSAGE_UNREGISTER_ADAPTER"");
                    IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                    mCallbacks.unregister(callback);
                    break;
                }
                case MESSAGE_INFORM_ADAPTER_SERVICE_UP: {
                    if (DBG) Slog.d(TAG,""MESSAGE_INFORM_ADAPTER_SERVICE_UP"");
                    sendBluetoothServiceUpCallback();
                    break;
                }
","
                case MESSAGE_REGISTER_ADAPTER: {
                    if (DBG) Slog.d(TAG,""MESSAGE_REGISTER_ADAPTER"");
                    IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                    mCallbacks.register(callback);
                    break;
                }
                case MESSAGE_UNREGISTER_ADAPTER: {
                    if (DBG) Slog.d(TAG,""MESSAGE_UNREGISTER_ADAPTER"");
                    IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                    mCallbacks.unregister(callback);
                    break;
                }
                case MESSAGE_INFORM_ADAPTER_SERVICE_UP: {
                    if (DBG) Slog.d(TAG,""MESSAGE_INFORM_ADAPTER_SERVICE_UP"");
                    sendBluetoothServiceUpCallback();
                    break;
                }
","
                case MESSAGE_REGISTER_ADAPTER: {
                    if (DBG) Slog.d(TAG,""MESSAGE_REGISTER_ADAPTER"");
                    IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                    mCallbacks.register(callback);
                    break;
                }
                case MESSAGE_UNREGISTER_ADAPTER: {
                    if (DBG) Slog.d(TAG,""MESSAGE_UNREGISTER_ADAPTER"");
                    IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                    mCallbacks.unregister(callback);
                    break;
                }
                case MESSAGE_INFORM_ADAPTER_SERVICE_UP: {
                    if (DBG) Slog.d(TAG,""MESSAGE_INFORM_ADAPTER_SERVICE_UP"");
                    sendBluetoothServiceUpCallback();
                    break;
                }
","[1.0, 1.0]"
834,"['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf', '6aa497092f6337fbafb5b9858a3ec8f28c9d3caf']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(14763, 14765, 3), (14763, 14765, 3)]","            if (!origin.existing && (requiredUid != -1 || optionalUid != -1)
                    && isVerificationEnabled(
                            pkgLite, verifierUser.getIdentifier(), installFlags, installerUid)) {
","            if (!origin.existing && (requiredUid != -1 || optionalUid != -1)
                    && isVerificationEnabled(
                            pkgLite, verifierUser.getIdentifier(), installFlags, installerUid)) {
","            if (!origin.existing && (requiredUid != -1 || optionalUid != -1)
                    && isVerificationEnabled(
                            pkgLite, verifierUser.getIdentifier(), installFlags, installerUid)) {
","[1.0, 1.0]"
835,"['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf', '6aa497092f6337fbafb5b9858a3ec8f28c9d3caf']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(14831, 14858, 28), (14831, 14858, 28)]","                if (mOptionalVerifierPackage != null) {
                    final Intent optionalIntent = new Intent(verification);
                    optionalIntent.setAction(""com.qualcomm.qti.intent.action.PACKAGE_NEEDS_OPTIONAL_VERIFICATION"");
                    final List<ResolveInfo> optional_receivers = queryIntentReceiversInternal(optionalIntent,
                        PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(), false /*allowDynamicSplits*/);
                    final ComponentName optionalVerifierComponent = matchComponentForVerifier(
                        mOptionalVerifierPackage, optional_receivers);
                    optionalIntent.setComponent(optionalVerifierComponent);
                    verificationState.addOptionalVerifier(optionalUid);
                    if (mRequiredVerifierPackage != null) {
                        mContext.sendBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT);
                    } else {
                        mContext.sendOrderedBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,
                        new BroadcastReceiver() {
                            @Override
                            public void onReceive(Context context, Intent intent) {
                                final Message msg = mHandler.obtainMessage(CHECK_PENDING_VERIFICATION);
                                msg.arg1 = verificationId;
                                mHandler.sendMessageDelayed(msg, getVerificationTimeout());
                            }
                        }, null, 0, null, null);
                        /*
                         * We don't want the copy to proceed until
                         * verification succeeds.
                         */
                        mVerificationCompleted = false;
                    }
                }
","                if (mOptionalVerifierPackage != null) {
                    final Intent optionalIntent = new Intent(verification);
                    optionalIntent.setAction(""com.qualcomm.qti.intent.action.PACKAGE_NEEDS_OPTIONAL_VERIFICATION"");
                    final List<ResolveInfo> optional_receivers = queryIntentReceiversInternal(optionalIntent,
                        PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(), false /*allowDynamicSplits*/);
                    final ComponentName optionalVerifierComponent = matchComponentForVerifier(
                        mOptionalVerifierPackage, optional_receivers);
                    optionalIntent.setComponent(optionalVerifierComponent);
                    verificationState.addOptionalVerifier(optionalUid);
                    if (mRequiredVerifierPackage != null) {
                        mContext.sendBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT);
                    } else {
                        mContext.sendOrderedBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,
                        new BroadcastReceiver() {
                            @Override
                            public void onReceive(Context context, Intent intent) {
                                final Message msg = mHandler.obtainMessage(CHECK_PENDING_VERIFICATION);
                                msg.arg1 = verificationId;
                                mHandler.sendMessageDelayed(msg, getVerificationTimeout());
                            }
                        }, null, 0, null, null);
                        /*
                         * We don't want the copy to proceed until
                         * verification succeeds.
                         */
                        mVerificationCompleted = false;
                    }
                }
","                if (mOptionalVerifierPackage != null) {
                    final Intent optionalIntent = new Intent(verification);
                    optionalIntent.setAction(""com.qualcomm.qti.intent.action.PACKAGE_NEEDS_OPTIONAL_VERIFICATION"");
                    final List<ResolveInfo> optional_receivers = queryIntentReceiversInternal(optionalIntent,
                        PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(), false /*allowDynamicSplits*/);
                    final ComponentName optionalVerifierComponent = matchComponentForVerifier(
                        mOptionalVerifierPackage, optional_receivers);
                    optionalIntent.setComponent(optionalVerifierComponent);
                    verificationState.addOptionalVerifier(optionalUid);
                    if (mRequiredVerifierPackage != null) {
                        mContext.sendBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT);
                    } else {
                        mContext.sendOrderedBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,
                        new BroadcastReceiver() {
                            @Override
                            public void onReceive(Context context, Intent intent) {
                                final Message msg = mHandler.obtainMessage(CHECK_PENDING_VERIFICATION);
                                msg.arg1 = verificationId;
                                mHandler.sendMessageDelayed(msg, getVerificationTimeout());
                            }
                        }, null, 0, null, null);
                        /*
                         * We don't want the copy to proceed until
                         * verification succeeds.
                         */
                        mVerificationCompleted = false;
                    }
                }
","[1.0, 1.0]"
836,"['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf', '6aa497092f6337fbafb5b9858a3ec8f28c9d3caf']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/os/Process.java,"[(932, 953, 22), (932, 953, 22)]","     * Sets the scheduling group for processes in the same cgroup.procs of uid and pid
     * @hide
     * @param uid The user identifier of the process to change.
     * @param pid The identifier of the process to change.
     * @param group The target group for this process from THREAD_GROUP_*.
     *
     * @throws IllegalArgumentException Throws IllegalArgumentException if
     * <var>tid</var> does not exist.
     * @throws SecurityException Throws SecurityException if your process does
     * not have permission to modify the given thread, or to use the given
     * priority.
     *
     * group == THREAD_GROUP_DEFAULT means to move all non-background priority
     * threads to the foreground scheduling group, but to leave background
     * priority threads alone.  group == THREAD_GROUP_BG_NONINTERACTIVE moves all
     * threads, regardless of priority, to the background scheduling group.
     * group == THREAD_GROUP_FOREGROUND is not allowed.
     *
     * Always sets cpusets.
     */
    public static final native void setCgroupProcsProcessGroup(int uid, int pid, int group)
            throws IllegalArgumentException, SecurityException;
","     * Sets the scheduling group for processes in the same cgroup.procs of uid and pid
     * @hide
     * @param uid The user identifier of the process to change.
     * @param pid The identifier of the process to change.
     * @param group The target group for this process from THREAD_GROUP_*.
     *
     * @throws IllegalArgumentException Throws IllegalArgumentException if
     * <var>tid</var> does not exist.
     * @throws SecurityException Throws SecurityException if your process does
     * not have permission to modify the given thread, or to use the given
     * priority.
     *
     * group == THREAD_GROUP_DEFAULT means to move all non-background priority
     * threads to the foreground scheduling group, but to leave background
     * priority threads alone.  group == THREAD_GROUP_BG_NONINTERACTIVE moves all
     * threads, regardless of priority, to the background scheduling group.
     * group == THREAD_GROUP_FOREGROUND is not allowed.
     *
     * Always sets cpusets.
     */
    public static final native void setCgroupProcsProcessGroup(int uid, int pid, int group)
            throws IllegalArgumentException, SecurityException;
","     * Sets the scheduling group for processes in the same cgroup.procs of uid and pid
     * @hide
     * @param uid The user identifier of the process to change.
     * @param pid The identifier of the process to change.
     * @param group The target group for this process from THREAD_GROUP_*.
     *
     * @throws IllegalArgumentException Throws IllegalArgumentException if
     * <var>tid</var> does not exist.
     * @throws SecurityException Throws SecurityException if your process does
     * not have permission to modify the given thread, or to use the given
     * priority.
     *
     * group == THREAD_GROUP_DEFAULT means to move all non-background priority
     * threads to the foreground scheduling group, but to leave background
     * priority threads alone.  group == THREAD_GROUP_BG_NONINTERACTIVE moves all
     * threads, regardless of priority, to the background scheduling group.
     * group == THREAD_GROUP_FOREGROUND is not allowed.
     *
     * Always sets cpusets.
     */
    public static final native void setCgroupProcsProcessGroup(int uid, int pid, int group)
            throws IllegalArgumentException, SecurityException;
","[1.0, 1.0]"
837,"['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf', '6aa497092f6337fbafb5b9858a3ec8f28c9d3caf']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,"[(222, 227, 6), (222, 227, 6)]","        if (V) Log.d(TAG, "" execute supportsHighQualityAudio()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
","        if (V) Log.d(TAG, "" execute supportsHighQualityAudio()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
","        if (V) Log.d(TAG, "" execute supportsHighQualityAudio()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
","[1.0, 1.0]"
838,"['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf', '6aa497092f6337fbafb5b9858a3ec8f28c9d3caf']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,"[(236, 241, 6), (236, 241, 6)]","        if (V) Log.d(TAG, "" execute isHighQualityAudioEnabled()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
","        if (V) Log.d(TAG, "" execute isHighQualityAudioEnabled()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
","        if (V) Log.d(TAG, "" execute isHighQualityAudioEnabled()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
","[1.0, 1.0]"
839,"['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf', '6aa497092f6337fbafb5b9858a3ec8f28c9d3caf']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,"[(267, 275, 9), (267, 275, 9)]","        if (V) Log.d(TAG, "" execute setHighQualityAudioEnabled()"");
        int prefValue = enabled
                ? BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED
                : BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED;
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return;
        }
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
","        if (V) Log.d(TAG, "" execute setHighQualityAudioEnabled()"");
        int prefValue = enabled
                ? BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED
                : BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED;
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return;
        }
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
","        if (V) Log.d(TAG, "" execute setHighQualityAudioEnabled()"");
        int prefValue = enabled
                ? BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED
                : BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED;
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return;
        }
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
","[1.0, 1.0]"
840,"['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf', '6aa497092f6337fbafb5b9858a3ec8f28c9d3caf']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,"[(291, 292, 2), (291, 292, 2)]","        if (V) Log.d(TAG, "" execute getHighQualityAudioOptionLabel()"");
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
","        if (V) Log.d(TAG, "" execute getHighQualityAudioOptionLabel()"");
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
","        if (V) Log.d(TAG, "" execute getHighQualityAudioOptionLabel()"");
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
","[1.0, 1.0]"
841,"['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf', 'b6292e3e1ba3616eac1032737a91925391d94b92']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,"[(222, 227, 6), (222, 227, 6)]","        if (V) Log.d(TAG, "" execute supportsHighQualityAudio()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
","        if (V) Log.d(TAG, "" execute supportsHighQualityAudio()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        int support = mService.supportsOptionalCodecs(device);
","        if (V) Log.d(TAG, "" execute supportsHighQualityAudio()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        ","[0.682, 0.778]"
842,"['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf', 'b6292e3e1ba3616eac1032737a91925391d94b92']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,"[(236, 241, 6), (232, 237, 6)]","        if (V) Log.d(TAG, "" execute isHighQualityAudioEnabled()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
","        if (V) Log.d(TAG, "" execute isHighQualityAudioEnabled()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        int enabled = mService.getOptionalCodecsEnabled(device);
","        if (V) Log.d(TAG, "" execute isHighQualityAudioEnabled()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        ","[0.683, 0.773]"
843,"['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf', 'b6292e3e1ba3616eac1032737a91925391d94b92']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,"[(267, 275, 9), (259, 268, 10)]","        if (V) Log.d(TAG, "" execute setHighQualityAudioEnabled()"");
        int prefValue = enabled
                ? BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED
                : BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED;
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return;
        }
        BluetoothDevice bluetoothDevice = (device == null) ? device : mService.getActiveDevice();
","        if (V) Log.d(TAG, "" execute setHighQualityAudioEnabled()"");
        int prefValue = enabled
                ? BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED
                : BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED;
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return;
        }
        mService.setOptionalCodecsEnabled(device, prefValue);
        if (getConnectionStatus(device) != BluetoothProfile.STATE_CONNECTED) {
","        if (V) Log.d(TAG, "" execute setHighQualityAudioEnabled()"");
        int prefValue = enabled
                ? BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED
                : BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED;
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return;
        }
        ","[0.793, 0.722]"
844,"['6aa497092f6337fbafb5b9858a3ec8f28c9d3caf', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/os/Process.java,"[(932, 953, 22), (859, 880, 22)]","     * Sets the scheduling group for processes in the same cgroup.procs of uid and pid
     * @hide
     * @param uid The user identifier of the process to change.
     * @param pid The identifier of the process to change.
     * @param group The target group for this process from THREAD_GROUP_*.
     *
     * @throws IllegalArgumentException Throws IllegalArgumentException if
     * <var>tid</var> does not exist.
     * @throws SecurityException Throws SecurityException if your process does
     * not have permission to modify the given thread, or to use the given
     * priority.
     *
     * group == THREAD_GROUP_DEFAULT means to move all non-background priority
     * threads to the foreground scheduling group, but to leave background
     * priority threads alone.  group == THREAD_GROUP_BG_NONINTERACTIVE moves all
     * threads, regardless of priority, to the background scheduling group.
     * group == THREAD_GROUP_FOREGROUND is not allowed.
     *
     * Always sets cpusets.
     */
    public static final native void setCgroupProcsProcessGroup(int uid, int pid, int group)
            throws IllegalArgumentException, SecurityException;
","     * Sets the scheduling group for processes in the same cgroup.procs of uid and pid
     * @hide
     * @param uid The user identifier of the process to change.
     * @param pid The identifier of the process to change.
     * @param group The target group for this process from THREAD_GROUP_*.
     *
     * @throws IllegalArgumentException Throws IllegalArgumentException if
     * <var>tid</var> does not exist.
     * @throws SecurityException Throws SecurityException if your process does
     * not have permission to modify the given thread, or to use the given
     * priority.
     *
     * group == THREAD_GROUP_DEFAULT means to move all non-background priority
     * threads to the foreground scheduling group, but to leave background
     * priority threads alone.  group == THREAD_GROUP_BG_NONINTERACTIVE moves all
     * threads, regardless of priority, to the background scheduling group.
     * group == THREAD_GROUP_FOREGROUND is not allowed.
     *
     * Always sets cpusets.
     */
    public static final native void setCgroupProcsProcessGroup(int uid, int pid, int group)
            throws IllegalArgumentException, SecurityException;
","     * Sets the scheduling group for processes in the same cgroup.procs of uid and pid
     * @hide
     * @param uid The user identifier of the process to change.
     * @param pid The identifier of the process to change.
     * @param group The target group for this process from THREAD_GROUP_*.
     *
     * @throws IllegalArgumentException Throws IllegalArgumentException if
     * <var>tid</var> does not exist.
     * @throws SecurityException Throws SecurityException if your process does
     * not have permission to modify the given thread, or to use the given
     * priority.
     *
     * group == THREAD_GROUP_DEFAULT means to move all non-background priority
     * threads to the foreground scheduling group, but to leave background
     * priority threads alone.  group == THREAD_GROUP_BG_NONINTERACTIVE moves all
     * threads, regardless of priority, to the background scheduling group.
     * group == THREAD_GROUP_FOREGROUND is not allowed.
     *
     * Always sets cpusets.
     */
    public static final native void setCgroupProcsProcessGroup(int uid, int pid, int group)
            throws IllegalArgumentException, SecurityException;
","[1.0, 1.0]"
846,"['6f47ceafbe6febe54aa5c376baed3415cdf848ad', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ScreenRotationAnimation.java,"[(39, 39, 1), (32, 33, 2)]","import android.util.BoostFramework;
","import android.os.IBinder;
import android.util.BoostFramework;
","import android.util.BoostFramework;
","[1.0, 0.571]"
847,"['6f47ceafbe6febe54aa5c376baed3415cdf848ad', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(32, 36, 5), (28, 30, 3)]","import android.telephony.CellSignalStrengthNr;
import android.telephony.DisplayInfo;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.stub.ImsRegistrationImplBase;
","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.","[0.527, 0.799]"
848,"['6f47ceafbe6febe54aa5c376baed3415cdf848ad', '6f47ceafbe6febe54aa5c376baed3415cdf848ad']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/content/pm/ApplicationInfo.java,"[(2211, 2212, 2), (2211, 2212, 2)]","    /** {@hide} */ public void setGwpAsanEnabled(@Nullable Boolean value) { enableGwpAsan = value; }
    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
","    /** {@hide} */ public void setGwpAsanEnabled(@Nullable Boolean value) { enableGwpAsan = value; }
    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
","    /** {@hide} */ public void setGwpAsanEnabled(@Nullable Boolean value) { enableGwpAsan = value; }
    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
","[1.0, 1.0]"
849,"['6f47ceafbe6febe54aa5c376baed3415cdf848ad', '6f47ceafbe6febe54aa5c376baed3415cdf848ad']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/content/pm/ApplicationInfo.java,"[(2224, 2226, 3), (2224, 2226, 3)]","    @Nullable
    public Boolean isGwpAsanEnabled() { return enableGwpAsan; }
    /** {@hide} */ public int canOverrideRes() { return overrideRes; }
","    @Nullable
    public Boolean isGwpAsanEnabled() { return enableGwpAsan; }
    /** {@hide} */ public int canOverrideRes() { return overrideRes; }
","    @Nullable
    public Boolean isGwpAsanEnabled() { return enableGwpAsan; }
    /** {@hide} */ public int canOverrideRes() { return overrideRes; }
","[1.0, 1.0]"
850,"['6f47ceafbe6febe54aa5c376baed3415cdf848ad', '6f47ceafbe6febe54aa5c376baed3415cdf848ad']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ProcessList.java,"[(516, 526, 11), (516, 526, 11)]","    interface LmkdKillListener {
        /**
         * Called when there is a process kill by lmkd.
         */
        void onLmkdKillOccurred(int pid, int uid);
    }

    /**
     * BoostFramework Object
     */
    public static BoostFramework mPerfServiceStartHint = new BoostFramework();
","    interface LmkdKillListener {
        /**
         * Called when there is a process kill by lmkd.
         */
        void onLmkdKillOccurred(int pid, int uid);
    }

    /**
     * BoostFramework Object
     */
    public static BoostFramework mPerfServiceStartHint = new BoostFramework();
","    interface LmkdKillListener {
        /**
         * Called when there is a process kill by lmkd.
         */
        void onLmkdKillOccurred(int pid, int uid);
    }

    /**
     * BoostFramework Object
     */
    public static BoostFramework mPerfServiceStartHint = new BoostFramework();
","[1.0, 1.0]"
851,"['6f47ceafbe6febe54aa5c376baed3415cdf848ad', '6f47ceafbe6febe54aa5c376baed3415cdf848ad']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ScreenRotationAnimation.java,"[(39, 39, 1), (39, 39, 1)]","import android.util.BoostFramework;
","import android.util.BoostFramework;
","import android.util.BoostFramework;
","[1.0, 1.0]"
852,"['6f47ceafbe6febe54aa5c376baed3415cdf848ad', '6f47ceafbe6febe54aa5c376baed3415cdf848ad']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(32, 36, 5), (32, 36, 5)]","import android.telephony.CellSignalStrengthNr;
import android.telephony.DisplayInfo;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.CellSignalStrengthNr;
import android.telephony.DisplayInfo;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.CellSignalStrengthNr;
import android.telephony.DisplayInfo;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","[1.0, 1.0]"
853,"['6f47ceafbe6febe54aa5c376baed3415cdf848ad', '6f47ceafbe6febe54aa5c376baed3415cdf848ad']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(94, 96, 3), (94, 96, 3)]","    private DataState mMMSDataState = DataState.DISCONNECTED;
    private DisplayInfo mDisplayInfo = new DisplayInfo(TelephonyManager.NETWORK_TYPE_UNKNOWN,
            DisplayInfo.OVERRIDE_NETWORK_TYPE_NONE);
","    private DataState mMMSDataState = DataState.DISCONNECTED;
    private DisplayInfo mDisplayInfo = new DisplayInfo(TelephonyManager.NETWORK_TYPE_UNKNOWN,
            DisplayInfo.OVERRIDE_NETWORK_TYPE_NONE);
","    private DataState mMMSDataState = DataState.DISCONNECTED;
    private DisplayInfo mDisplayInfo = new DisplayInfo(TelephonyManager.NETWORK_TYPE_UNKNOWN,
            DisplayInfo.OVERRIDE_NETWORK_TYPE_NONE);
","[1.0, 1.0]"
854,"['6f47ceafbe6febe54aa5c376baed3415cdf848ad', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/content/pm/ApplicationInfo.java,"[(2211, 2212, 2), (2190, 2190, 1)]","    /** {@hide} */ public void setGwpAsanEnabled(@Nullable Boolean value) { enableGwpAsan = value; }
    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
","    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
","    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
","[0.517, 1.0]"
855,"['6f47ceafbe6febe54aa5c376baed3415cdf848ad', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(32, 36, 5), (36, 39, 4)]","import android.telephony.CellSignalStrengthNr;
import android.telephony.DisplayInfo;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
",";
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","[0.633, 0.761]"
856,"['6f47ceafbe6febe54aa5c376baed3415cdf848ad', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(32, 36, 5), (29, 32, 4)]","import android.telephony.CellSignalStrengthNr;
import android.telephony.DisplayInfo;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
",";
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","[0.633, 0.761]"
857,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']","['aospa-ruby-SAP-block_text', 'omnirom-10-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(669, 732, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
858,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java,"[(170, 171, 2), (170, 171, 2)]","    @VisibleForTesting
    FiveGServiceClient mFiveGServiceClient;
","    @VisibleForTesting
    FiveGServiceClient mFiveGServiceClient;
","    @VisibleForTesting
    FiveGServiceClient mFiveGServiceClient;
","[1.0, 1.0]"
859,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '4a30c150e58ec67edb92a7bec5ea48cebd6b90d4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(578, 582, 5), (552, 557, 6)]","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
    public static boolean mForceStopKill = false;
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();

    final OomAdjuster mOomAdjuster;
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
","[0.794, 0.839]"
860,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(3356, 3359, 4), (3356, 3359, 4)]","            if (nri.request.isRequest() && nai.satisfies(nri.request)
                    && satisfiesMobileMultiNetworkDataCheck(nai.networkCapabilities,
                       nri.request.networkCapabilities)
                    && (nai.isSatisfyingRequest(nri.request.requestId) ||
","            if (nri.request.isRequest() && nai.satisfies(nri.request)
                    && satisfiesMobileMultiNetworkDataCheck(nai.networkCapabilities,
                       nri.request.networkCapabilities)
                    && (nai.isSatisfyingRequest(nri.request.requestId) ||
","            if (nri.request.isRequest() && nai.satisfies(nri.request)
                    && satisfiesMobileMultiNetworkDataCheck(nai.networkCapabilities,
                       nri.request.networkCapabilities)
                    && (nai.isSatisfyingRequest(nri.request.requestId) ||
","[1.0, 1.0]"
861,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(3367, 3369, 3), (3367, 3369, 3)]","                    ((getNetworkForRequest(nri.request.requestId) != null)
                    && (getNetworkForRequest(nri.request.requestId).getCurrentScore() <
                            nai.getCurrentScoreAsValidated())))) {
","                    ((getNetworkForRequest(nri.request.requestId) != null)
                    && (getNetworkForRequest(nri.request.requestId).getCurrentScore() <
                            nai.getCurrentScoreAsValidated())))) {
","                    ((getNetworkForRequest(nri.request.requestId) != null)
                    && (getNetworkForRequest(nri.request.requestId).getCurrentScore() <
                            nai.getCurrentScoreAsValidated())))) {
","[1.0, 1.0]"
862,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(6404, 6473, 70), (6404, 6473, 70)]","            final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
            final boolean satisfies = newNetwork.satisfies(nri.request);
            boolean satisfiesMobileMultiNetworkCheck = false;

            if (satisfies) {
                satisfiesMobileMultiNetworkCheck = satisfiesMobileMultiNetworkDataCheck(
                        newNetwork.networkCapabilities,
                        nri.request.networkCapabilities);
            }

            if (newNetwork == currentNetwork && satisfiesMobileMultiNetworkCheck) {
                if (VDBG) {
                    log(""Network "" + newNetwork.name() + "" was already satisfying"" +
                            "" request "" + nri.request.requestId + "". No change."");
                }
                keep = true;
                continue;
            }

            // check if it satisfies the NetworkCapabilities
            if (VDBG) log(""  checking if request is satisfied: "" + nri.request);
            if (satisfiesMobileMultiNetworkCheck) {
                // next check if it's better than any current network we're using for
                // this request
                if (VDBG || DDBG) {
                    log(""currentScore = "" +
                            (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) +
                            "", newScore = "" + score);
                }
                if (currentNetwork == null ||
                    isBestMobileMultiNetwork(currentNetwork,
                          currentNetwork.networkCapabilities,
                          newNetwork,
                          newNetwork.networkCapabilities,
                          nri.request.networkCapabilities) ||
                    currentNetwork.getCurrentScore() < score) {
                    if (VDBG) log(""rematch for "" + newNetwork.name());
                    if (currentNetwork != null) {
                        if (VDBG || DDBG){
                            log(""   accepting network in place of "" + currentNetwork.name());
                        }
                        currentNetwork.removeRequest(nri.request.requestId);
                        if (satisfiesMobileNetworkDataCheck(currentNetwork.networkCapabilities)) {
                            currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                        } else {
                            currentNetwork.lingerRequest(nri.request, now, mNonDefaultSubscriptionLingerDelayMs);
                        }
                        affectedNetworks.add(currentNetwork);
                    } else {
                        if (VDBG || DDBG) log(""   accepting network in place of null"");
                    }
                    newNetwork.unlingerRequest(nri.request);
                    setNetworkForRequest(nri.request.requestId, newNetwork);
                    if (!newNetwork.addRequest(nri.request)) {
                        Slog.wtf(TAG, ""BUG: "" + newNetwork.name() + "" already has "" + nri.request);
                    }
                    addedRequests.add(nri);
                    keep = true;
                    // Tell NetworkFactories about the new score, so they can stop
                    // trying to connect if they know they cannot match it.
                    // TODO - this could get expensive if we have a lot of requests for this
                    // network.  Think about if there is a way to reduce this.  Push
                    // netid->request mapping to each factory?
                    sendUpdatedScoreToFactories(nri.request, newNetwork);
                    if (isDefaultRequest(nri)) {
                        isNewDefault = true;
                        oldDefaultNetwork = currentNetwork;
                        if (currentNetwork != null) {
                            mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                        }
","            final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
            final boolean satisfies = newNetwork.satisfies(nri.request);
            boolean satisfiesMobileMultiNetworkCheck = false;

            if (satisfies) {
                satisfiesMobileMultiNetworkCheck = satisfiesMobileMultiNetworkDataCheck(
                        newNetwork.networkCapabilities,
                        nri.request.networkCapabilities);
            }

            if (newNetwork == currentNetwork && satisfiesMobileMultiNetworkCheck) {
                if (VDBG) {
                    log(""Network "" + newNetwork.name() + "" was already satisfying"" +
                            "" request "" + nri.request.requestId + "". No change."");
                }
                keep = true;
                continue;
            }

            // check if it satisfies the NetworkCapabilities
            if (VDBG) log(""  checking if request is satisfied: "" + nri.request);
            if (satisfiesMobileMultiNetworkCheck) {
                // next check if it's better than any current network we're using for
                // this request
                if (VDBG || DDBG) {
                    log(""currentScore = "" +
                            (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) +
                            "", newScore = "" + score);
                }
                if (currentNetwork == null ||
                    isBestMobileMultiNetwork(currentNetwork,
                          currentNetwork.networkCapabilities,
                          newNetwork,
                          newNetwork.networkCapabilities,
                          nri.request.networkCapabilities) ||
                    currentNetwork.getCurrentScore() < score) {
                    if (VDBG) log(""rematch for "" + newNetwork.name());
                    if (currentNetwork != null) {
                        if (VDBG || DDBG){
                            log(""   accepting network in place of "" + currentNetwork.name());
                        }
                        currentNetwork.removeRequest(nri.request.requestId);
                        if (satisfiesMobileNetworkDataCheck(currentNetwork.networkCapabilities)) {
                            currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                        } else {
                            currentNetwork.lingerRequest(nri.request, now, mNonDefaultSubscriptionLingerDelayMs);
                        }
                        affectedNetworks.add(currentNetwork);
                    } else {
                        if (VDBG || DDBG) log(""   accepting network in place of null"");
                    }
                    newNetwork.unlingerRequest(nri.request);
                    setNetworkForRequest(nri.request.requestId, newNetwork);
                    if (!newNetwork.addRequest(nri.request)) {
                        Slog.wtf(TAG, ""BUG: "" + newNetwork.name() + "" already has "" + nri.request);
                    }
                    addedRequests.add(nri);
                    keep = true;
                    // Tell NetworkFactories about the new score, so they can stop
                    // trying to connect if they know they cannot match it.
                    // TODO - this could get expensive if we have a lot of requests for this
                    // network.  Think about if there is a way to reduce this.  Push
                    // netid->request mapping to each factory?
                    sendUpdatedScoreToFactories(nri.request, newNetwork);
                    if (isDefaultRequest(nri)) {
                        isNewDefault = true;
                        oldDefaultNetwork = currentNetwork;
                        if (currentNetwork != null) {
                            mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                        }
","            final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
            final boolean satisfies = newNetwork.satisfies(nri.request);
            boolean satisfiesMobileMultiNetworkCheck = false;

            if (satisfies) {
                satisfiesMobileMultiNetworkCheck = satisfiesMobileMultiNetworkDataCheck(
                        newNetwork.networkCapabilities,
                        nri.request.networkCapabilities);
            }

            if (newNetwork == currentNetwork && satisfiesMobileMultiNetworkCheck) {
                if (VDBG) {
                    log(""Network "" + newNetwork.name() + "" was already satisfying"" +
                            "" request "" + nri.request.requestId + "". No change."");
                }
                keep = true;
                continue;
            }

            // check if it satisfies the NetworkCapabilities
            if (VDBG) log(""  checking if request is satisfied: "" + nri.request);
            if (satisfiesMobileMultiNetworkCheck) {
                // next check if it's better than any current network we're using for
                // this request
                if (VDBG || DDBG) {
                    log(""currentScore = "" +
                            (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) +
                            "", newScore = "" + score);
                }
                if (currentNetwork == null ||
                    isBestMobileMultiNetwork(currentNetwork,
                          currentNetwork.networkCapabilities,
                          newNetwork,
                          newNetwork.networkCapabilities,
                          nri.request.networkCapabilities) ||
                    currentNetwork.getCurrentScore() < score) {
                    if (VDBG) log(""rematch for "" + newNetwork.name());
                    if (currentNetwork != null) {
                        if (VDBG || DDBG){
                            log(""   accepting network in place of "" + currentNetwork.name());
                        }
                        currentNetwork.removeRequest(nri.request.requestId);
                        if (satisfiesMobileNetworkDataCheck(currentNetwork.networkCapabilities)) {
                            currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                        } else {
                            currentNetwork.lingerRequest(nri.request, now, mNonDefaultSubscriptionLingerDelayMs);
                        }
                        affectedNetworks.add(currentNetwork);
                    } else {
                        if (VDBG || DDBG) log(""   accepting network in place of null"");
                    }
                    newNetwork.unlingerRequest(nri.request);
                    setNetworkForRequest(nri.request.requestId, newNetwork);
                    if (!newNetwork.addRequest(nri.request)) {
                        Slog.wtf(TAG, ""BUG: "" + newNetwork.name() + "" already has "" + nri.request);
                    }
                    addedRequests.add(nri);
                    keep = true;
                    // Tell NetworkFactories about the new score, so they can stop
                    // trying to connect if they know they cannot match it.
                    // TODO - this could get expensive if we have a lot of requests for this
                    // network.  Think about if there is a way to reduce this.  Push
                    // netid->request mapping to each factory?
                    sendUpdatedScoreToFactories(nri.request, newNetwork);
                    if (isDefaultRequest(nri)) {
                        isNewDefault = true;
                        oldDefaultNetwork = currentNetwork;
                        if (currentNetwork != null) {
                            mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                        }
","[1.0, 1.0]"
863,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(274, 274, 1), (274, 274, 1)]","    private static final int MSG_ACCESSORY_PLUG_MEDIA_MUTE = 30;
","    private static final int MSG_ACCESSORY_PLUG_MEDIA_MUTE = 30;
","    private static final int MSG_ACCESSORY_PLUG_MEDIA_MUTE = 30;
","[1.0, 1.0]"
864,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(4439, 4465, 27), (4439, 4465, 27)]","    /**
     * @see AudioManager#handleBluetoothA2dpActiveDeviceChange(BluetoothDevice, int, int,
     *                                                        boolean, int)
     */
    public void handleBluetoothA2dpActiveDeviceChange(
            BluetoothDevice device, int state, int profile, boolean suppressNoisyIntent,
            int a2dpVolume) {
        if (device == null) {
                throw new IllegalArgumentException(""Illegal null device"");
        }
        if (profile != BluetoothProfile.A2DP && profile != BluetoothProfile.A2DP_SINK) {
            throw new IllegalArgumentException(""invalid profile "" + profile);
        }
        if (state != BluetoothProfile.STATE_CONNECTED
                && state != BluetoothProfile.STATE_DISCONNECTED) {
            throw new IllegalArgumentException(""Invalid state "" + state);
        }
        mDeviceBroker.postBluetoothA2dpDeviceConfigChangeExt(device, state, profile,
                suppressNoisyIntent, a2dpVolume);
    }

    private static final int DEVICE_MEDIA_UNMUTED_ON_PLUG =
            AudioSystem.DEVICE_OUT_WIRED_HEADSET | AudioSystem.DEVICE_OUT_WIRED_HEADPHONE |
            AudioSystem.DEVICE_OUT_LINE |
            AudioSystem.DEVICE_OUT_ALL_A2DP |
            AudioSystem.DEVICE_OUT_ALL_USB |
            AudioSystem.DEVICE_OUT_HDMI;
","    /**
     * @see AudioManager#handleBluetoothA2dpActiveDeviceChange(BluetoothDevice, int, int,
     *                                                        boolean, int)
     */
    public void handleBluetoothA2dpActiveDeviceChange(
            BluetoothDevice device, int state, int profile, boolean suppressNoisyIntent,
            int a2dpVolume) {
        if (device == null) {
                throw new IllegalArgumentException(""Illegal null device"");
        }
        if (profile != BluetoothProfile.A2DP && profile != BluetoothProfile.A2DP_SINK) {
            throw new IllegalArgumentException(""invalid profile "" + profile);
        }
        if (state != BluetoothProfile.STATE_CONNECTED
                && state != BluetoothProfile.STATE_DISCONNECTED) {
            throw new IllegalArgumentException(""Invalid state "" + state);
        }
        mDeviceBroker.postBluetoothA2dpDeviceConfigChangeExt(device, state, profile,
                suppressNoisyIntent, a2dpVolume);
    }

    private static final int DEVICE_MEDIA_UNMUTED_ON_PLUG =
            AudioSystem.DEVICE_OUT_WIRED_HEADSET | AudioSystem.DEVICE_OUT_WIRED_HEADPHONE |
            AudioSystem.DEVICE_OUT_LINE |
            AudioSystem.DEVICE_OUT_ALL_A2DP |
            AudioSystem.DEVICE_OUT_ALL_USB |
            AudioSystem.DEVICE_OUT_HDMI;
","    /**
     * @see AudioManager#handleBluetoothA2dpActiveDeviceChange(BluetoothDevice, int, int,
     *                                                        boolean, int)
     */
    public void handleBluetoothA2dpActiveDeviceChange(
            BluetoothDevice device, int state, int profile, boolean suppressNoisyIntent,
            int a2dpVolume) {
        if (device == null) {
                throw new IllegalArgumentException(""Illegal null device"");
        }
        if (profile != BluetoothProfile.A2DP && profile != BluetoothProfile.A2DP_SINK) {
            throw new IllegalArgumentException(""invalid profile "" + profile);
        }
        if (state != BluetoothProfile.STATE_CONNECTED
                && state != BluetoothProfile.STATE_DISCONNECTED) {
            throw new IllegalArgumentException(""Invalid state "" + state);
        }
        mDeviceBroker.postBluetoothA2dpDeviceConfigChangeExt(device, state, profile,
                suppressNoisyIntent, a2dpVolume);
    }

    private static final int DEVICE_MEDIA_UNMUTED_ON_PLUG =
            AudioSystem.DEVICE_OUT_WIRED_HEADSET | AudioSystem.DEVICE_OUT_WIRED_HEADPHONE |
            AudioSystem.DEVICE_OUT_LINE |
            AudioSystem.DEVICE_OUT_ALL_A2DP |
            AudioSystem.DEVICE_OUT_ALL_USB |
            AudioSystem.DEVICE_OUT_HDMI;
","[1.0, 1.0]"
865,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(578, 582, 5), (578, 582, 5)]","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
    public static boolean mForceStopKill = false;
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
    public static boolean mForceStopKill = false;
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
    public static boolean mForceStopKill = false;
","[1.0, 1.0]"
866,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(3800, 3807, 8), (3800, 3807, 8)]","
            if (mUxPerf != null && !mForceStopKill) {
                mUxPerf.perfUXEngine_events(BoostFramework.UXE_EVENT_KILL, 0, app.processName, 0);
                mUxPerf.perfHint(BoostFramework.VENDOR_HINT_KILL, app.processName, pid, 0);
            }

            EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName,
                    app.setAdj, app.setProcState);
","
            if (mUxPerf != null && !mForceStopKill) {
                mUxPerf.perfUXEngine_events(BoostFramework.UXE_EVENT_KILL, 0, app.processName, 0);
                mUxPerf.perfHint(BoostFramework.VENDOR_HINT_KILL, app.processName, pid, 0);
            }

            EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName,
                    app.setAdj, app.setProcState);
","
            if (mUxPerf != null && !mForceStopKill) {
                mUxPerf.perfUXEngine_events(BoostFramework.UXE_EVENT_KILL, 0, app.processName, 0);
                mUxPerf.perfHint(BoostFramework.VENDOR_HINT_KILL, app.processName, pid, 0);
            }

            EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName,
                    app.setAdj, app.setProcState);
","[1.0, 1.0]"
867,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/WifiUtils.java,"[(110, 112, 3), (110, 112, 3)]","        int maxRssi5 = WifiConfiguration.INVALID_RSSI;
        int maxRssi24 = WifiConfiguration.INVALID_RSSI;
        int maxRssi60 = WifiConfiguration.INVALID_RSSI;
","        int maxRssi5 = WifiConfiguration.INVALID_RSSI;
        int maxRssi24 = WifiConfiguration.INVALID_RSSI;
        int maxRssi60 = WifiConfiguration.INVALID_RSSI;
","        int maxRssi5 = WifiConfiguration.INVALID_RSSI;
        int maxRssi24 = WifiConfiguration.INVALID_RSSI;
        int maxRssi60 = WifiConfiguration.INVALID_RSSI;
","[1.0, 1.0]"
868,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiInfo.java,"[(698, 730, 33), (698, 730, 33)]","    /** @hide */
    public void setWifiGeneration(int generation) {
        mWifiGeneration = generation;
    }

    /** @hide */
    public int getWifiGeneration() {
        return mWifiGeneration;
    }

    /** @hide */
    public void setVhtMax8SpatialStreamsSupport(boolean vhtMax8SpatialStreamsSupport) {
        mVhtMax8SpatialStreamsSupport = vhtMax8SpatialStreamsSupport;
    }

    /** @hide */
    public boolean isVhtMax8SpatialStreamsSupported() {
        return mVhtMax8SpatialStreamsSupport;
    }

    /** @hide */
    public void setTwtSupport(boolean twtSupport) {
        mTwtSupport = twtSupport;
    }

    /** @hide */
    public boolean isTwtSupported() {
        return mTwtSupport;
    }

    /** {@hide} */
    @UnsupportedAppUsage
    public static String removeDoubleQuotes(String string) {
","    /** @hide */
    public void setWifiGeneration(int generation) {
        mWifiGeneration = generation;
    }

    /** @hide */
    public int getWifiGeneration() {
        return mWifiGeneration;
    }

    /** @hide */
    public void setVhtMax8SpatialStreamsSupport(boolean vhtMax8SpatialStreamsSupport) {
        mVhtMax8SpatialStreamsSupport = vhtMax8SpatialStreamsSupport;
    }

    /** @hide */
    public boolean isVhtMax8SpatialStreamsSupported() {
        return mVhtMax8SpatialStreamsSupport;
    }

    /** @hide */
    public void setTwtSupport(boolean twtSupport) {
        mTwtSupport = twtSupport;
    }

    /** @hide */
    public boolean isTwtSupported() {
        return mTwtSupport;
    }

    /** {@hide} */
    @UnsupportedAppUsage
    public static String removeDoubleQuotes(String string) {
","    /** @hide */
    public void setWifiGeneration(int generation) {
        mWifiGeneration = generation;
    }

    /** @hide */
    public int getWifiGeneration() {
        return mWifiGeneration;
    }

    /** @hide */
    public void setVhtMax8SpatialStreamsSupport(boolean vhtMax8SpatialStreamsSupport) {
        mVhtMax8SpatialStreamsSupport = vhtMax8SpatialStreamsSupport;
    }

    /** @hide */
    public boolean isVhtMax8SpatialStreamsSupported() {
        return mVhtMax8SpatialStreamsSupport;
    }

    /** @hide */
    public void setTwtSupport(boolean twtSupport) {
        mTwtSupport = twtSupport;
    }

    /** @hide */
    public boolean isTwtSupported() {
        return mTwtSupport;
    }

    /** {@hide} */
    @UnsupportedAppUsage
    public static String removeDoubleQuotes(String string) {
","[1.0, 1.0]"
869,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(1892, 1897, 6), (1892, 1897, 6)]","        clonedNetworkConfigKey = null;
        dppConnector = null;
        dppNetAccessKey = null;
        dppNetAccessKeyExpiry = -1;
        dppCsign = null;
        oweTransIfaceName = null;
","        clonedNetworkConfigKey = null;
        dppConnector = null;
        dppNetAccessKey = null;
        dppNetAccessKeyExpiry = -1;
        dppCsign = null;
        oweTransIfaceName = null;
","        clonedNetworkConfigKey = null;
        dppConnector = null;
        dppNetAccessKey = null;
        dppNetAccessKeyExpiry = -1;
        dppCsign = null;
        oweTransIfaceName = null;
","[1.0, 1.0]"
870,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2574, 2575, 2), (2574, 2575, 2)]","            clonedNetworkConfigKey = source.clonedNetworkConfigKey;
            oweTransIfaceName = source.oweTransIfaceName;
","            clonedNetworkConfigKey = source.clonedNetworkConfigKey;
            oweTransIfaceName = source.oweTransIfaceName;
","            clonedNetworkConfigKey = source.clonedNetworkConfigKey;
            oweTransIfaceName = source.oweTransIfaceName;
","[1.0, 1.0]"
871,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2656, 2657, 2), (2656, 2657, 2)]","        dest.writeString(clonedNetworkConfigKey);
        dest.writeString(oweTransIfaceName);
","        dest.writeString(clonedNetworkConfigKey);
        dest.writeString(oweTransIfaceName);
","        dest.writeString(clonedNetworkConfigKey);
        dest.writeString(oweTransIfaceName);
","[1.0, 1.0]"
872,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2740, 2741, 2), (2740, 2741, 2)]","                config.clonedNetworkConfigKey = in.readString();
                config.oweTransIfaceName = in.readString();
","                config.clonedNetworkConfigKey = in.readString();
                config.oweTransIfaceName = in.readString();
","                config.clonedNetworkConfigKey = in.readString();
                config.oweTransIfaceName = in.readString();
","[1.0, 1.0]"
873,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/CellInfoNr.java,"[(51, 53, 3), (51, 53, 3)]","        final android.hardware.radio.V1_4.CellInfoNr cin = ci.info.nr();
        mCellIdentity = new CellIdentityNr(cin.cellidentity);
        mCellSignalStrength = new CellSignalStrengthNr(cin.signalStrength);
","        final android.hardware.radio.V1_4.CellInfoNr cin = ci.info.nr();
        mCellIdentity = new CellIdentityNr(cin.cellidentity);
        mCellSignalStrength = new CellSignalStrengthNr(cin.signalStrength);
","        final android.hardware.radio.V1_4.CellInfoNr cin = ci.info.nr();
        mCellIdentity = new CellIdentityNr(cin.cellidentity);
        mCellSignalStrength = new CellSignalStrengthNr(cin.signalStrength);
","[1.0, 1.0]"
874,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java,"[(170, 171, 2), (170, 171, 2)]","    @VisibleForTesting
    FiveGServiceClient mFiveGServiceClient;
","    @VisibleForTesting
    FiveGServiceClient mFiveGServiceClient;
","    @VisibleForTesting
    FiveGServiceClient mFiveGServiceClient;
","[1.0, 1.0]"
875,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(357, 450, 94), (357, 450, 94)]","    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 80;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 81;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 82;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 85;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 86;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 87;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 88;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 89;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 90;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 91;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 94;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 95;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 96;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 97;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 98;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 99;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 100;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 101;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 102;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 103;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 106;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 107;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 108;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 109;
    /** @hide */
    public static final int CALL_REJECTED = 110;
    /** @hide */
    public static final int NUMBER_CHANGED = 111;
    /** @hide */
    public static final int PREEMPTION = 112;
    /** @hide */
    public static final int FACILITY_REJECTED = 113;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 114;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 115;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 116;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 117;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 118;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 119;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 120;
    /** @hide */
    public static final int QOS_UNAVAILABLE = 121;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 122;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 123;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 124;
","    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 80;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 81;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 82;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 85;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 86;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 87;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 88;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 89;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 90;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 91;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 94;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 95;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 96;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 97;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 98;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 99;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 100;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 101;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 102;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 103;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 106;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 107;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 108;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 109;
    /** @hide */
    public static final int CALL_REJECTED = 110;
    /** @hide */
    public static final int NUMBER_CHANGED = 111;
    /** @hide */
    public static final int PREEMPTION = 112;
    /** @hide */
    public static final int FACILITY_REJECTED = 113;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 114;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 115;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 116;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 117;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 118;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 119;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 120;
    /** @hide */
    public static final int QOS_UNAVAILABLE = 121;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 122;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 123;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 124;
","    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 80;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 81;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 82;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 85;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 86;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 87;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 88;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 89;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 90;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 91;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 94;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 95;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 96;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 97;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 98;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 99;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 100;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 101;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 102;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 103;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 106;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 107;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 108;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 109;
    /** @hide */
    public static final int CALL_REJECTED = 110;
    /** @hide */
    public static final int NUMBER_CHANGED = 111;
    /** @hide */
    public static final int PREEMPTION = 112;
    /** @hide */
    public static final int FACILITY_REJECTED = 113;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 114;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 115;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 116;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 117;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 118;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 119;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 120;
    /** @hide */
    public static final int QOS_UNAVAILABLE = 121;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 122;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 123;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 124;
","[1.0, 1.0]"
876,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(669, 732, 64), (669, 732, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
877,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '6fc85c43e31aad55eecd51d3b0de34715ae03810']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,"[(62, 63, 2), (62, 63, 2)]","
        mDefaultWifiIconGroup = new IconGroup(
","
        mDefaultWifiIconGroup = new IconGroup(
","
        mDefaultWifiIconGroup = new IconGroup(
","[1.0, 1.0]"
878,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(669, 732, 64), (677, 740, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
879,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '7fe8671fd7b5388dd9be6295dbea6d31209468f9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(669, 732, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
880,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(578, 582, 5), (545, 548, 4)]","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
    public static boolean mForceStopKill = false;
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
","[0.794, 1.0]"
881,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(578, 582, 5), (578, 588, 11)]","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
    public static boolean mForceStopKill = false;
","    /**
     * How long between a process kill and we actually receive its death recipient
     */
    private static final long PROC_KILL_TIMEOUT = 5000; // 5 seconds;

    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
    public static boolean mForceStopKill = false;

","    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
    public static boolean mForceStopKill = false;
","[1.0, 0.587]"
882,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(669, 732, 64), (593, 656, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
883,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(669, 732, 64), (570, 633, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
884,"['6fc85c43e31aad55eecd51d3b0de34715ae03810', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(669, 732, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
888,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']","['aospa-ruby-SAP-block_text', 'omnirom-10-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(677, 740, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
889,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '4a30c150e58ec67edb92a7bec5ea48cebd6b90d4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(2806, 2806, 1), (2663, 2664, 2)]","            clearUserKeyAuth(userId, null, auth.deriveDiskEncryptionKey());
","            // during boot.
            clearUserKeyAuth(userId, null, auth.deriveDiskEncryptionKey());
","            clearUserKeyAuth(userId, null, auth.deriveDiskEncryptionKey());
","[1.0, 0.731]"
890,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '4a30c150e58ec67edb92a7bec5ea48cebd6b90d4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(225, 242, 18), (190, 199, 10)]","    private static final int LEGACY_CAPABLE_BSSID = 0;
    private static final int HT_CAPABLE_BSSID = 1;
    private static final int VHT_CAPABLE_BSSID = 2;
    private static final int HE_CAPABLE_BSSID = 3;
    private static final int MAX_CAPABLE_BSSID = Integer.MAX_VALUE;

    private static final int WIFI_GENERATION_LEGACY = 0;
    private static final int WIFI_GENERATION_4 = 4;
    private static final int WIFI_GENERATION_5 = 5;
    private static final int WIFI_GENERATION_6 = 6;

    /**
     * The number of distinct wifi levels.
     *
     * <p>Must keep in sync with {@link R.array.wifi_signal} and {@link WifiManager#RSSI_LEVELS}.
     */
    public static final int SIGNAL_LEVELS = 5;

","    private static final int LEGACY_CAPABLE_BSSID = 0;
    private static final int HT_CAPABLE_BSSID = 1;
    private static final int VHT_CAPABLE_BSSID = 2;
    private static final int HE_CAPABLE_BSSID = 3;
    private static final int MAX_CAPABLE_BSSID = Integer.MAX_VALUE;

    private static final int WIFI_GENERATION_LEGACY = 0;
    private static final int WIFI_GENERATION_4 = 4;
    private static final int WIFI_GENERATION_5 = 5;
    private static final int WIFI_GENERATION_6 = 6;
","    private static final int LEGACY_CAPABLE_BSSID = 0;
    private static final int HT_CAPABLE_BSSID = 1;
    private static final int VHT_CAPABLE_BSSID = 2;
    private static final int HE_CAPABLE_BSSID = 3;
    private static final int MAX_CAPABLE_BSSID = Integer.MAX_VALUE;

    private static final int WIFI_GENERATION_LEGACY = 0;
    private static final int WIFI_GENERATION_4 = 4;
    private static final int WIFI_GENERATION_5 = 5;
    private static final int WIFI_GENERATION_6 = 6;
","[0.697, 1.0]"
891,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '6e44ad255823e1b7f2b23386d61af655c19adb49']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(688, 688, 1), (599, 599, 1)]","                                    subject, null, finalStack, null);
","                                subject, null, finalStack, null);
","                                subject, null, finalStack, null);
","[0.943, 1.0]"
892,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(766, 779, 14), (766, 779, 14)]","        if (bondState == BluetoothDevice.BOND_BONDED) {
            boolean mIsBondingInitiatedLocally = mDevice.isBondingInitiatedLocally();
            Log.w(TAG, ""mIsBondingInitiatedLocally"" + mIsBondingInitiatedLocally);
            if (mIsBondingInitiatedLocally) {
                mDevice.setBondingInitiatedLocally(false);
            }
            if (mIsTwsConnectEnabled) {
                Log.d(TAG, ""Initiating connection to"" + mDevice);
                if (mIsBondingInitiatedLocally || mDevice.isTwsPlusDevice()) {
                    connect(false);
                }
            } else if (mIsBondingInitiatedLocally) {
                 connect(false);
            }
","        if (bondState == BluetoothDevice.BOND_BONDED) {
            boolean mIsBondingInitiatedLocally = mDevice.isBondingInitiatedLocally();
            Log.w(TAG, ""mIsBondingInitiatedLocally"" + mIsBondingInitiatedLocally);
            if (mIsBondingInitiatedLocally) {
                mDevice.setBondingInitiatedLocally(false);
            }
            if (mIsTwsConnectEnabled) {
                Log.d(TAG, ""Initiating connection to"" + mDevice);
                if (mIsBondingInitiatedLocally || mDevice.isTwsPlusDevice()) {
                    connect(false);
                }
            } else if (mIsBondingInitiatedLocally) {
                 connect(false);
            }
","        if (bondState == BluetoothDevice.BOND_BONDED) {
            boolean mIsBondingInitiatedLocally = mDevice.isBondingInitiatedLocally();
            Log.w(TAG, ""mIsBondingInitiatedLocally"" + mIsBondingInitiatedLocally);
            if (mIsBondingInitiatedLocally) {
                mDevice.setBondingInitiatedLocally(false);
            }
            if (mIsTwsConnectEnabled) {
                Log.d(TAG, ""Initiating connection to"" + mDevice);
                if (mIsBondingInitiatedLocally || mDevice.isTwsPlusDevice()) {
                    connect(false);
                }
            } else if (mIsBondingInitiatedLocally) {
                 connect(false);
            }
","[1.0, 1.0]"
893,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/hardware/camera2/CameraDevice.java,"[(491, 530, 40), (491, 530, 40)]","     * @param outputs The new set of Surfaces that should be made available as
     *                targets for captured image data.
     * @param callback The callback to notify about the status of the new capture session.
     * @param handler The handler on which the callback should be invoked, or {@code null} to use
     *                the current thread's {@link android.os.Looper looper}.
     *
     * @throws IllegalArgumentException if the set of output Surfaces do not meet the requirements,
     *                                  the callback is null, or the handler is null but the current
     *                                  thread has no looper.
     * @throws CameraAccessException if the camera device is no longer connected or has
     *                               encountered a fatal error
     * @throws IllegalStateException if the camera device has been closed
     *
     * @see CameraCaptureSession
     * @see StreamConfigurationMap#getOutputFormats()
     * @see StreamConfigurationMap#getOutputSizes(int)
     * @see StreamConfigurationMap#getOutputSizes(Class)
     */
    public abstract void createCaptureSession(@NonNull List<Surface> outputs,
            @NonNull CameraCaptureSession.StateCallback callback, @Nullable Handler handler)
            throws CameraAccessException;

    /** @hide */
    public abstract void setVendorStreamConfigMode(int index)
            throws CameraAccessException;

    /**
     * <p>Create a new camera capture session by providing the target output set of Surfaces and
     * its corresponding surface configuration to the camera device.</p>
     *
     * @see #createCaptureSession
     * @see OutputConfiguration
     */
    public abstract void createCaptureSessionByOutputConfigurations(
            List<OutputConfiguration> outputConfigurations,
            CameraCaptureSession.StateCallback callback, @Nullable Handler handler)
            throws CameraAccessException;
    /**
     * Create a new reprocessable camera capture session by providing the desired reprocessing
     * input Surface configuration and the target output set of Surfaces to the camera device.
","     * @param outputs The new set of Surfaces that should be made available as
     *                targets for captured image data.
     * @param callback The callback to notify about the status of the new capture session.
     * @param handler The handler on which the callback should be invoked, or {@code null} to use
     *                the current thread's {@link android.os.Looper looper}.
     *
     * @throws IllegalArgumentException if the set of output Surfaces do not meet the requirements,
     *                                  the callback is null, or the handler is null but the current
     *                                  thread has no looper.
     * @throws CameraAccessException if the camera device is no longer connected or has
     *                               encountered a fatal error
     * @throws IllegalStateException if the camera device has been closed
     *
     * @see CameraCaptureSession
     * @see StreamConfigurationMap#getOutputFormats()
     * @see StreamConfigurationMap#getOutputSizes(int)
     * @see StreamConfigurationMap#getOutputSizes(Class)
     */
    public abstract void createCaptureSession(@NonNull List<Surface> outputs,
            @NonNull CameraCaptureSession.StateCallback callback, @Nullable Handler handler)
            throws CameraAccessException;

    /** @hide */
    public abstract void setVendorStreamConfigMode(int index)
            throws CameraAccessException;

    /**
     * <p>Create a new camera capture session by providing the target output set of Surfaces and
     * its corresponding surface configuration to the camera device.</p>
     *
     * @see #createCaptureSession
     * @see OutputConfiguration
     */
    public abstract void createCaptureSessionByOutputConfigurations(
            List<OutputConfiguration> outputConfigurations,
            CameraCaptureSession.StateCallback callback, @Nullable Handler handler)
            throws CameraAccessException;
    /**
     * Create a new reprocessable camera capture session by providing the desired reprocessing
     * input Surface configuration and the target output set of Surfaces to the camera device.
","     * @param outputs The new set of Surfaces that should be made available as
     *                targets for captured image data.
     * @param callback The callback to notify about the status of the new capture session.
     * @param handler The handler on which the callback should be invoked, or {@code null} to use
     *                the current thread's {@link android.os.Looper looper}.
     *
     * @throws IllegalArgumentException if the set of output Surfaces do not meet the requirements,
     *                                  the callback is null, or the handler is null but the current
     *                                  thread has no looper.
     * @throws CameraAccessException if the camera device is no longer connected or has
     *                               encountered a fatal error
     * @throws IllegalStateException if the camera device has been closed
     *
     * @see CameraCaptureSession
     * @see StreamConfigurationMap#getOutputFormats()
     * @see StreamConfigurationMap#getOutputSizes(int)
     * @see StreamConfigurationMap#getOutputSizes(Class)
     */
    public abstract void createCaptureSession(@NonNull List<Surface> outputs,
            @NonNull CameraCaptureSession.StateCallback callback, @Nullable Handler handler)
            throws CameraAccessException;

    /** @hide */
    public abstract void setVendorStreamConfigMode(int index)
            throws CameraAccessException;

    /**
     * <p>Create a new camera capture session by providing the target output set of Surfaces and
     * its corresponding surface configuration to the camera device.</p>
     *
     * @see #createCaptureSession
     * @see OutputConfiguration
     */
    public abstract void createCaptureSessionByOutputConfigurations(
            List<OutputConfiguration> outputConfigurations,
            CameraCaptureSession.StateCallback callback, @Nullable Handler handler)
            throws CameraAccessException;
    /**
     * Create a new reprocessable camera capture session by providing the desired reprocessing
     * input Surface configuration and the target output set of Surfaces to the camera device.
","[1.0, 1.0]"
894,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/accounts/AccountManager.java,"[(1196, 1211, 16), (1196, 1211, 16)]","        android.util.SeempLog.record(25);
        if (account == null) throw new IllegalArgumentException(""account is null"");
        return new Future2Task<Boolean>(handler, callback) {
            @Override
            public void doWork() throws RemoteException {
                android.util.SeempLog.record(31);
                mService.removeAccount(mResponse, account, false);
            }
            @Override
            public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
                if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                    throw new AuthenticatorException(""no result in response"");
                }
                return bundle.getBoolean(KEY_BOOLEAN_RESULT);
            }
        }.start();
","        android.util.SeempLog.record(25);
        if (account == null) throw new IllegalArgumentException(""account is null"");
        return new Future2Task<Boolean>(handler, callback) {
            @Override
            public void doWork() throws RemoteException {
                android.util.SeempLog.record(31);
                mService.removeAccount(mResponse, account, false);
            }
            @Override
            public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
                if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                    throw new AuthenticatorException(""no result in response"");
                }
                return bundle.getBoolean(KEY_BOOLEAN_RESULT);
            }
        }.start();
","        android.util.SeempLog.record(25);
        if (account == null) throw new IllegalArgumentException(""account is null"");
        return new Future2Task<Boolean>(handler, callback) {
            @Override
            public void doWork() throws RemoteException {
                android.util.SeempLog.record(31);
                mService.removeAccount(mResponse, account, false);
            }
            @Override
            public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
                if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                    throw new AuthenticatorException(""no result in response"");
                }
                return bundle.getBoolean(KEY_BOOLEAN_RESULT);
            }
        }.start();
","[1.0, 1.0]"
895,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/accounts/AccountManager.java,"[(1257, 1265, 9), (1257, 1265, 9)]","        android.util.SeempLog.record(28);
        if (account == null) throw new IllegalArgumentException(""account is null"");
        return new AmsTask(activity, handler, callback) {
            @Override
            public void doWork() throws RemoteException {
                android.util.SeempLog.record(34);
                mService.removeAccount(mResponse, account, activity != null);
            }
        }.start();
","        android.util.SeempLog.record(28);
        if (account == null) throw new IllegalArgumentException(""account is null"");
        return new AmsTask(activity, handler, callback) {
            @Override
            public void doWork() throws RemoteException {
                android.util.SeempLog.record(34);
                mService.removeAccount(mResponse, account, activity != null);
            }
        }.start();
","        android.util.SeempLog.record(28);
        if (account == null) throw new IllegalArgumentException(""account is null"");
        return new AmsTask(activity, handler, callback) {
            @Override
            public void doWork() throws RemoteException {
                android.util.SeempLog.record(34);
                mService.removeAccount(mResponse, account, activity != null);
            }
        }.start();
","[1.0, 1.0]"
896,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/accounts/AccountManager.java,"[(1866, 1879, 14), (1866, 1879, 14)]","        android.util.SeempLog.record(29);
        if (accountType == null) throw new IllegalArgumentException(""accountType is null"");
        final Bundle optionsIn = new Bundle();
        if (addAccountOptions != null) {
            optionsIn.putAll(addAccountOptions);
        }
        optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());

        return new AmsTask(activity, handler, callback) {
            @Override
            public void doWork() throws RemoteException {
                android.util.SeempLog.record(31);
                mService.addAccount(mResponse, accountType, authTokenType,
                        requiredFeatures, activity != null, optionsIn);
","        android.util.SeempLog.record(29);
        if (accountType == null) throw new IllegalArgumentException(""accountType is null"");
        final Bundle optionsIn = new Bundle();
        if (addAccountOptions != null) {
            optionsIn.putAll(addAccountOptions);
        }
        optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());

        return new AmsTask(activity, handler, callback) {
            @Override
            public void doWork() throws RemoteException {
                android.util.SeempLog.record(31);
                mService.addAccount(mResponse, accountType, authTokenType,
                        requiredFeatures, activity != null, optionsIn);
","        android.util.SeempLog.record(29);
        if (accountType == null) throw new IllegalArgumentException(""accountType is null"");
        final Bundle optionsIn = new Bundle();
        if (addAccountOptions != null) {
            optionsIn.putAll(addAccountOptions);
        }
        optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());

        return new AmsTask(activity, handler, callback) {
            @Override
            public void doWork() throws RemoteException {
                android.util.SeempLog.record(31);
                mService.addAccount(mResponse, accountType, authTokenType,
                        requiredFeatures, activity != null, optionsIn);
","[1.0, 1.0]"
897,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/com/android/ims/internal/uce/common/CapInfo.java,"[(82, 85, 4), (82, 85, 4)]","     /** Standalone Chatbot communication support. */
    private boolean mSmChatbotSupported = false;
     /** MMtel based call composer support. */
    private boolean mMmtelCallComposerSupported = false;
","     /** Standalone Chatbot communication support. */
    private boolean mSmChatbotSupported = false;
     /** MMtel based call composer support. */
    private boolean mMmtelCallComposerSupported = false;
","     /** Standalone Chatbot communication support. */
    private boolean mSmChatbotSupported = false;
     /** MMtel based call composer support. */
    private boolean mMmtelCallComposerSupported = false;
","[1.0, 1.0]"
898,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/com/android/ims/internal/uce/common/CapInfo.java,"[(95, 95, 1), (95, 95, 1)]","    @UnsupportedAppUsage
","    @UnsupportedAppUsage
","    @UnsupportedAppUsage
","[1.0, 1.0]"
899,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/com/android/ims/internal/uce/common/CapInfo.java,"[(520, 551, 32), (520, 551, 32)]","    /**
     * Checks whether standalone chatbot communication is supported.
     */
    @UnsupportedAppUsage
    public boolean isSmChatbotSupported() {
        return mSmChatbotSupported;
    }

    /**
     * Sets standalone chatbot communication as supported or not supported.
     */
    @UnsupportedAppUsage
    public void setSmChatbotSupported(boolean smChatbotSupported) {
        this.mSmChatbotSupported = smChatbotSupported;
    }

    /**
     * Checks whether Mmtel based call composer is supported.
     */
    @UnsupportedAppUsage
    public boolean isMmtelCallComposerSupported() {
        return mMmtelCallComposerSupported;
    }

    /**
     * Sets Mmtel based call composer as supported or not supported.
     */
    @UnsupportedAppUsage
    public void setMmtelCallComposerSupported(boolean mmtelCallComposerSupported) {
        this.mMmtelCallComposerSupported = mmtelCallComposerSupported;
    }

","    /**
     * Checks whether standalone chatbot communication is supported.
     */
    @UnsupportedAppUsage
    public boolean isSmChatbotSupported() {
        return mSmChatbotSupported;
    }

    /**
     * Sets standalone chatbot communication as supported or not supported.
     */
    @UnsupportedAppUsage
    public void setSmChatbotSupported(boolean smChatbotSupported) {
        this.mSmChatbotSupported = smChatbotSupported;
    }

    /**
     * Checks whether Mmtel based call composer is supported.
     */
    @UnsupportedAppUsage
    public boolean isMmtelCallComposerSupported() {
        return mMmtelCallComposerSupported;
    }

    /**
     * Sets Mmtel based call composer as supported or not supported.
     */
    @UnsupportedAppUsage
    public void setMmtelCallComposerSupported(boolean mmtelCallComposerSupported) {
        this.mMmtelCallComposerSupported = mmtelCallComposerSupported;
    }

","    /**
     * Checks whether standalone chatbot communication is supported.
     */
    @UnsupportedAppUsage
    public boolean isSmChatbotSupported() {
        return mSmChatbotSupported;
    }

    /**
     * Sets standalone chatbot communication as supported or not supported.
     */
    @UnsupportedAppUsage
    public void setSmChatbotSupported(boolean smChatbotSupported) {
        this.mSmChatbotSupported = smChatbotSupported;
    }

    /**
     * Checks whether Mmtel based call composer is supported.
     */
    @UnsupportedAppUsage
    public boolean isMmtelCallComposerSupported() {
        return mMmtelCallComposerSupported;
    }

    /**
     * Sets Mmtel based call composer as supported or not supported.
     */
    @UnsupportedAppUsage
    public void setMmtelCallComposerSupported(boolean mmtelCallComposerSupported) {
        this.mMmtelCallComposerSupported = mmtelCallComposerSupported;
    }

","[1.0, 1.0]"
900,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/com/android/ims/internal/uce/common/CapInfo.java,"[(607, 608, 2), (607, 608, 2)]","        dest.writeInt(mSmChatbotSupported ? 1 : 0);
        dest.writeInt(mMmtelCallComposerSupported ? 1 : 0);
","        dest.writeInt(mSmChatbotSupported ? 1 : 0);
        dest.writeInt(mMmtelCallComposerSupported ? 1 : 0);
","        dest.writeInt(mSmChatbotSupported ? 1 : 0);
        dest.writeInt(mMmtelCallComposerSupported ? 1 : 0);
","[1.0, 1.0]"
901,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/com/android/ims/internal/uce/common/CapInfo.java,"[(658, 659, 2), (658, 659, 2)]","        mSmChatbotSupported = (source.readInt() == 0) ? false : true;
        mMmtelCallComposerSupported = (source.readInt() == 0) ? false : true;
","        mSmChatbotSupported = (source.readInt() == 0) ? false : true;
        mMmtelCallComposerSupported = (source.readInt() == 0) ? false : true;
","        mSmChatbotSupported = (source.readInt() == 0) ? false : true;
        mMmtelCallComposerSupported = (source.readInt() == 0) ? false : true;
","[1.0, 1.0]"
902,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(194, 194, 1), (194, 194, 1)]","public class ActivityStack extends WindowContainer<WindowContainer> implements BoundsAnimationTarget {
","public class ActivityStack extends WindowContainer<WindowContainer> implements BoundsAnimationTarget {
","public class ActivityStack extends WindowContainer<WindowContainer> implements BoundsAnimationTarget {
","[1.0, 1.0]"
903,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(255, 283, 29), (255, 283, 29)]","    final ActivityTaskManagerService mAtmService;

    public BoostFramework mPerf = null;

    /**
     * When we are in the process of pausing an activity, before starting the
     * next one, this variable holds the activity that is currently being paused.
     */
    ActivityRecord mPausingActivity = null;

    /**
     * This is the last activity that we put into the paused state.  This is
     * used to determine if we need to do an activity transition while sleeping,
     * when we normally hold the top activity paused.
     */
    ActivityRecord mLastPausedActivity = null;

    /**
     * Activities that specify No History must be removed once the user navigates away from them.
     * If the device goes to sleep with such an activity in the paused state then we save it here
     * and finish it later if another activity replaces it on wakeup.
     */
    ActivityRecord mLastNoHistoryActivity = null;

    /**
     * Current activity that is resumed, or null if there is none.
     */
    ActivityRecord mResumedActivity = null;

","    final ActivityTaskManagerService mAtmService;

    public BoostFramework mPerf = null;

    /**
     * When we are in the process of pausing an activity, before starting the
     * next one, this variable holds the activity that is currently being paused.
     */
    ActivityRecord mPausingActivity = null;

    /**
     * This is the last activity that we put into the paused state.  This is
     * used to determine if we need to do an activity transition while sleeping,
     * when we normally hold the top activity paused.
     */
    ActivityRecord mLastPausedActivity = null;

    /**
     * Activities that specify No History must be removed once the user navigates away from them.
     * If the device goes to sleep with such an activity in the paused state then we save it here
     * and finish it later if another activity replaces it on wakeup.
     */
    ActivityRecord mLastNoHistoryActivity = null;

    /**
     * Current activity that is resumed, or null if there is none.
     */
    ActivityRecord mResumedActivity = null;

","    final ActivityTaskManagerService mAtmService;

    public BoostFramework mPerf = null;

    /**
     * When we are in the process of pausing an activity, before starting the
     * next one, this variable holds the activity that is currently being paused.
     */
    ActivityRecord mPausingActivity = null;

    /**
     * This is the last activity that we put into the paused state.  This is
     * used to determine if we need to do an activity transition while sleeping,
     * when we normally hold the top activity paused.
     */
    ActivityRecord mLastPausedActivity = null;

    /**
     * Activities that specify No History must be removed once the user navigates away from them.
     * If the device goes to sleep with such an activity in the paused state then we save it here
     * and finish it later if another activity replaces it on wakeup.
     */
    ActivityRecord mLastNoHistoryActivity = null;

    /**
     * Current activity that is resumed, or null if there is none.
     */
    ActivityRecord mResumedActivity = null;

","[1.0, 1.0]"
904,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(5135, 5170, 36), (5135, 5170, 36)]","    @Override
    void getAnimationFrames(Rect outFrame, Rect outInsets, Rect outStableInsets,
            Rect outSurfaceInsets) {
        final Task task = getTopMostTask();
        if (task != null) {
            task.getAnimationFrames(outFrame, outInsets, outStableInsets, outSurfaceInsets);
        } else {
            super.getAnimationFrames(outFrame, outInsets, outStableInsets, outSurfaceInsets);
        }
    }

    @Override
    RemoteAnimationTarget createRemoteAnimationTarget(
            RemoteAnimationController.RemoteAnimationRecord record) {
        final Task task = getTopMostTask();
        return task != null ? task.createRemoteAnimationTarget(record) : null;
    }

    public void onARStopTriggered(ActivityRecord r) {
        if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
                            mActivityPluginDelegate.activitySuspendNotification
                                (r.info.applicationInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
                        }
    }

    @Override
    public String toString() {
        return ""ActivityStack{"" + Integer.toHexString(System.identityHashCode(this))
                + "" stackId="" + mStackId + "" type="" + activityTypeToString(getActivityType())
                + "" mode="" + windowingModeToString(getWindowingMode())
                + "" visible="" + shouldBeVisible(null /* starting */)
                + "" translucent="" + isStackTranslucent(null /* starting */)
                + "", ""
                + getChildCount() + "" tasks}"";
    }

","    @Override
    void getAnimationFrames(Rect outFrame, Rect outInsets, Rect outStableInsets,
            Rect outSurfaceInsets) {
        final Task task = getTopMostTask();
        if (task != null) {
            task.getAnimationFrames(outFrame, outInsets, outStableInsets, outSurfaceInsets);
        } else {
            super.getAnimationFrames(outFrame, outInsets, outStableInsets, outSurfaceInsets);
        }
    }

    @Override
    RemoteAnimationTarget createRemoteAnimationTarget(
            RemoteAnimationController.RemoteAnimationRecord record) {
        final Task task = getTopMostTask();
        return task != null ? task.createRemoteAnimationTarget(record) : null;
    }

    public void onARStopTriggered(ActivityRecord r) {
        if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
                            mActivityPluginDelegate.activitySuspendNotification
                                (r.info.applicationInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
                        }
    }

    @Override
    public String toString() {
        return ""ActivityStack{"" + Integer.toHexString(System.identityHashCode(this))
                + "" stackId="" + mStackId + "" type="" + activityTypeToString(getActivityType())
                + "" mode="" + windowingModeToString(getWindowingMode())
                + "" visible="" + shouldBeVisible(null /* starting */)
                + "" translucent="" + isStackTranslucent(null /* starting */)
                + "", ""
                + getChildCount() + "" tasks}"";
    }

","    @Override
    void getAnimationFrames(Rect outFrame, Rect outInsets, Rect outStableInsets,
            Rect outSurfaceInsets) {
        final Task task = getTopMostTask();
        if (task != null) {
            task.getAnimationFrames(outFrame, outInsets, outStableInsets, outSurfaceInsets);
        } else {
            super.getAnimationFrames(outFrame, outInsets, outStableInsets, outSurfaceInsets);
        }
    }

    @Override
    RemoteAnimationTarget createRemoteAnimationTarget(
            RemoteAnimationController.RemoteAnimationRecord record) {
        final Task task = getTopMostTask();
        return task != null ? task.createRemoteAnimationTarget(record) : null;
    }

    public void onARStopTriggered(ActivityRecord r) {
        if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
                            mActivityPluginDelegate.activitySuspendNotification
                                (r.info.applicationInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
                        }
    }

    @Override
    public String toString() {
        return ""ActivityStack{"" + Integer.toHexString(System.identityHashCode(this))
                + "" stackId="" + mStackId + "" type="" + activityTypeToString(getActivityType())
                + "" mode="" + windowingModeToString(getWindowingMode())
                + "" visible="" + shouldBeVisible(null /* starting */)
                + "" translucent="" + isStackTranslucent(null /* starting */)
                + "", ""
                + getChildCount() + "" tasks}"";
    }

","[1.0, 1.0]"
905,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java,"[(2557, 2557, 1), (2557, 2557, 1)]","                        ? RILConstants.NETWORK_MODE_WCDMA_PREF : defaultNetworks.get(phoneId);
","                        ? RILConstants.NETWORK_MODE_WCDMA_PREF : defaultNetworks.get(phoneId);
","                        ? RILConstants.NETWORK_MODE_WCDMA_PREF : defaultNetworks.get(phoneId);
","[1.0, 1.0]"
906,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java,"[(184, 185, 2), (184, 185, 2)]","        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        broadcastDispatcher.registerReceiver(mIntentReceiver, filter, mHandler);
","        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        broadcastDispatcher.registerReceiver(mIntentReceiver, filter, mHandler);
","        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        broadcastDispatcher.registerReceiver(mIntentReceiver, filter, mHandler);
","[1.0, 1.0]"
907,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/accounts/AccountManagerService.java,"[(2134, 2144, 11), (2134, 2144, 11)]","    public void removeAccount(IAccountManagerResponse response, Account account,
            boolean expectActivityLaunch) {
        android.util.SeempLog.record(17);
        removeAccountAsUser(
                response,
                account,
                expectActivityLaunch,
                UserHandle.getCallingUserId());
    }

    @Override
","    public void removeAccount(IAccountManagerResponse response, Account account,
            boolean expectActivityLaunch) {
        android.util.SeempLog.record(17);
        removeAccountAsUser(
                response,
                account,
                expectActivityLaunch,
                UserHandle.getCallingUserId());
    }

    @Override
","    public void removeAccount(IAccountManagerResponse response, Account account,
            boolean expectActivityLaunch) {
        android.util.SeempLog.record(17);
        removeAccountAsUser(
                response,
                account,
                expectActivityLaunch,
                UserHandle.getCallingUserId());
    }

    @Override
","[1.0, 1.0]"
908,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(2806, 2806, 1), (2806, 2806, 1)]","            clearUserKeyAuth(userId, null, auth.deriveDiskEncryptionKey());
","            clearUserKeyAuth(userId, null, auth.deriveDiskEncryptionKey());
","            clearUserKeyAuth(userId, null, auth.deriveDiskEncryptionKey());
","[1.0, 1.0]"
909,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(363, 456, 94), (363, 456, 94)]","    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 81;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 82;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 83;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 85;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 86;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 87;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 88;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 89;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 90;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 91;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 92;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 94;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 95;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 96;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 97;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 98;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 99;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 100;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 101;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 102;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 103;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 104;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 106;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 107;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 108;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 109;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 110;
    /** @hide */
    public static final int CALL_REJECTED = 111;
    /** @hide */
    public static final int NUMBER_CHANGED = 112;
    /** @hide */
    public static final int PREEMPTION = 113;
    /** @hide */
    public static final int FACILITY_REJECTED = 114;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 115;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 116;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 117;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 118;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 119;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 120;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 121;
    /** @hide */
    public static final int QOS_UNAVAILABLE = 122;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 123;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 124;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 125;
","    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 81;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 82;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 83;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 85;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 86;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 87;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 88;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 89;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 90;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 91;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 92;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 94;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 95;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 96;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 97;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 98;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 99;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 100;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 101;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 102;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 103;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 104;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 106;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 107;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 108;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 109;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 110;
    /** @hide */
    public static final int CALL_REJECTED = 111;
    /** @hide */
    public static final int NUMBER_CHANGED = 112;
    /** @hide */
    public static final int PREEMPTION = 113;
    /** @hide */
    public static final int FACILITY_REJECTED = 114;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 115;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 116;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 117;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 118;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 119;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 120;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 121;
    /** @hide */
    public static final int QOS_UNAVAILABLE = 122;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 123;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 124;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 125;
","    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 81;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 82;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 83;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 84;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 85;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 86;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 87;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 88;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 89;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 90;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 91;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 92;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 93;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 94;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 95;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 96;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 97;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 98;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 99;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 100;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 101;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 102;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 103;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 104;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 105;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 106;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 107;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 108;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 109;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 110;
    /** @hide */
    public static final int CALL_REJECTED = 111;
    /** @hide */
    public static final int NUMBER_CHANGED = 112;
    /** @hide */
    public static final int PREEMPTION = 113;
    /** @hide */
    public static final int FACILITY_REJECTED = 114;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 115;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 116;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 117;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 118;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 119;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 120;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 121;
    /** @hide */
    public static final int QOS_UNAVAILABLE = 122;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 123;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 124;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 125;
","[1.0, 1.0]"
910,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(677, 740, 64), (677, 740, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
911,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(201, 202, 2), (201, 202, 2)]","        SECURITY_TYPE_OWE,
        SECURITY_TYPE_SAE,
","        SECURITY_TYPE_OWE,
        SECURITY_TYPE_SAE,
","        SECURITY_TYPE_OWE,
        SECURITY_TYPE_SAE,
","[1.0, 1.0]"
912,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(213, 214, 2), (213, 214, 2)]","            @Nullable String wpa2Passphrase, boolean hiddenSsid, @BandType int band, int channel,
            @SecurityType int securityType, int maxNumberOfClients, @Nullable String oweTransIfaceName) {
","            @Nullable String wpa2Passphrase, boolean hiddenSsid, @BandType int band, int channel,
            @SecurityType int securityType, int maxNumberOfClients, @Nullable String oweTransIfaceName) {
","            @Nullable String wpa2Passphrase, boolean hiddenSsid, @BandType int band, int channel,
            @SecurityType int securityType, int maxNumberOfClients, @Nullable String oweTransIfaceName) {
","[1.0, 1.0]"
913,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(223, 223, 1), (223, 223, 1)]","        mOweTransIfaceName = oweTransIfaceName;
","        mOweTransIfaceName = oweTransIfaceName;
","        mOweTransIfaceName = oweTransIfaceName;
","[1.0, 1.0]"
914,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(223, 223, 1), (423, 423, 1)]","        mOweTransIfaceName = oweTransIfaceName;
","            mOweTransIfaceName = null;
",        mOweTransIfaceName = ,"[0.604, 0.744]"
915,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(223, 223, 1), (439, 439, 1)]","        mOweTransIfaceName = oweTransIfaceName;
","            mOweTransIfaceName = other.mOweTransIfaceName;
",        mOweTransIfaceName = o,"[0.625, 0.508]"
916,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(243, 243, 1), (243, 243, 1)]","                && mOweTransIfaceName == other.mOweTransIfaceName;
","                && mOweTransIfaceName == other.mOweTransIfaceName;
","                && mOweTransIfaceName == other.mOweTransIfaceName;
","[1.0, 1.0]"
917,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(248, 249, 2), (248, 249, 2)]","        return Objects.hash(mSsid, mBssid, mWpa2Passphrase, mHiddenSsid,
                mBand, mChannel, mSecurityType, mMaxNumberOfClients, mOweTransIfaceName);
","        return Objects.hash(mSsid, mBssid, mWpa2Passphrase, mHiddenSsid,
                mBand, mChannel, mSecurityType, mMaxNumberOfClients, mOweTransIfaceName);
","        return Objects.hash(mSsid, mBssid, mWpa2Passphrase, mHiddenSsid,
                mBand, mChannel, mSecurityType, mMaxNumberOfClients, mOweTransIfaceName);
","[1.0, 1.0]"
918,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(264, 264, 1), (264, 264, 1)]","        sbuf.append("" \n OWE Transition mode Iface ="").append(mOweTransIfaceName);
","        sbuf.append("" \n OWE Transition mode Iface ="").append(mOweTransIfaceName);
","        sbuf.append("" \n OWE Transition mode Iface ="").append(mOweTransIfaceName);
","[1.0, 1.0]"
919,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(278, 278, 1), (278, 278, 1)]","        dest.writeString(mOweTransIfaceName);
","        dest.writeString(mOweTransIfaceName);
","        dest.writeString(mOweTransIfaceName);
","[1.0, 1.0]"
920,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(294, 294, 1), (294, 294, 1)]","                    in.readInt(), in.readString());
","                    in.readInt(), in.readString());
","                    in.readInt(), in.readString());
","[1.0, 1.0]"
921,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(373, 380, 8), (373, 380, 8)]","     * Return the iface name for OWE transition mode for the AP.
     * {@link #setOweTransIfaceName(String)}.
     *
     * @hide
     */
    @Nullable
    public String getOweTransIfaceName() {
      return mOweTransIfaceName;
","     * Return the iface name for OWE transition mode for the AP.
     * {@link #setOweTransIfaceName(String)}.
     *
     * @hide
     */
    @Nullable
    public String getOweTransIfaceName() {
      return mOweTransIfaceName;
","     * Return the iface name for OWE transition mode for the AP.
     * {@link #setOweTransIfaceName(String)}.
     *
     * @hide
     */
    @Nullable
    public String getOweTransIfaceName() {
      return mOweTransIfaceName;
","[1.0, 1.0]"
922,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(398, 410, 13), (398, 410, 13)]","        private String mOweTransIfaceName;

        private int setSecurityType() {
            int securityType = SECURITY_TYPE_OPEN;
            if (!TextUtils.isEmpty(mWpa2Passphrase)) { // WPA2-PSK network.
                securityType = SECURITY_TYPE_WPA2_PSK;
            }
            return securityType;
        }

        private void clearAllPassphrase() {
            mWpa2Passphrase = null;
        }
","        private String mOweTransIfaceName;

        private int setSecurityType() {
            int securityType = SECURITY_TYPE_OPEN;
            if (!TextUtils.isEmpty(mWpa2Passphrase)) { // WPA2-PSK network.
                securityType = SECURITY_TYPE_WPA2_PSK;
            }
            return securityType;
        }

        private void clearAllPassphrase() {
            mWpa2Passphrase = null;
        }
","        private String mOweTransIfaceName;

        private int setSecurityType() {
            int securityType = SECURITY_TYPE_OPEN;
            if (!TextUtils.isEmpty(mWpa2Passphrase)) { // WPA2-PSK network.
                securityType = SECURITY_TYPE_WPA2_PSK;
            }
            return securityType;
        }

        private void clearAllPassphrase() {
            mWpa2Passphrase = null;
        }
","[1.0, 1.0]"
923,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(423, 423, 1), (423, 423, 1)]","            mOweTransIfaceName = null;
","            mOweTransIfaceName = null;
","            mOweTransIfaceName = null;
","[1.0, 1.0]"
924,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(423, 423, 1), (439, 439, 1)]","            mOweTransIfaceName = null;
","            mOweTransIfaceName = other.mOweTransIfaceName;
",            mOweTransIfaceName = ,"[0.846, 0.559]"
925,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(439, 439, 1), (439, 439, 1)]","            mOweTransIfaceName = other.mOweTransIfaceName;
","            mOweTransIfaceName = other.mOweTransIfaceName;
","            mOweTransIfaceName = other.mOweTransIfaceName;
","[1.0, 1.0]"
926,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(449, 450, 2), (449, 450, 2)]","            return new SoftApConfiguration(mSsid, mBssid, mWpa2Passphrase,
                mHiddenSsid, mBand, mChannel, setSecurityType(), mMaxNumberOfClients, mOweTransIfaceName);
","            return new SoftApConfiguration(mSsid, mBssid, mWpa2Passphrase,
                mHiddenSsid, mBand, mChannel, setSecurityType(), mMaxNumberOfClients, mOweTransIfaceName);
","            return new SoftApConfiguration(mSsid, mBssid, mWpa2Passphrase,
                mHiddenSsid, mBand, mChannel, setSecurityType(), mMaxNumberOfClients, mOweTransIfaceName);
","[1.0, 1.0]"
927,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(627, 638, 12), (627, 638, 12)]","         * Specifies an iface name for OWE transition mode for the AP.
         * <p>
         * <li>If not set, defaults to null.</li>
         *
         * @param oweTransIfaceName iface name for OWE transition mode.
         * @return Builder for chaining.
         *
         * @hide
         */
        @NonNull
        public Builder setOweTransIfaceName(@Nullable String oweTransIfaceName) {
            mOweTransIfaceName = oweTransIfaceName;
","         * Specifies an iface name for OWE transition mode for the AP.
         * <p>
         * <li>If not set, defaults to null.</li>
         *
         * @param oweTransIfaceName iface name for OWE transition mode.
         * @return Builder for chaining.
         *
         * @hide
         */
        @NonNull
        public Builder setOweTransIfaceName(@Nullable String oweTransIfaceName) {
            mOweTransIfaceName = oweTransIfaceName;
","         * Specifies an iface name for OWE transition mode for the AP.
         * <p>
         * <li>If not set, defaults to null.</li>
         *
         * @param oweTransIfaceName iface name for OWE transition mode.
         * @return Builder for chaining.
         *
         * @hide
         */
        @NonNull
        public Builder setOweTransIfaceName(@Nullable String oweTransIfaceName) {
            mOweTransIfaceName = oweTransIfaceName;
","[1.0, 1.0]"
928,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,"[(128, 128, 1), (128, 128, 1)]","                && (mCurrentState.connected || !mHasMobileData);
","                && (mCurrentState.connected || !mHasMobileData);
","                && (mCurrentState.connected || !mHasMobileData);
","[1.0, 1.0]"
929,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(617, 618, 2), (617, 618, 2)]","            final File finalStack = ActivityManagerService.dumpStackTraces(
                    pids, null, null, getInterestingNativePids());
","            final File finalStack = ActivityManagerService.dumpStackTraces(
                    pids, null, null, getInterestingNativePids());
","            final File finalStack = ActivityManagerService.dumpStackTraces(
                    pids, null, null, getInterestingNativePids());
","[1.0, 1.0]"
930,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(629, 676, 48), (629, 676, 48)]","            File watchdogTraces;
            String newTracesPath = ""traces_SystemServer_WDT""
                    + mTraceDateFormat.format(new Date()) + ""_pid""
                    + String.valueOf(Process.myPid());
            File tracesDir = new File(ActivityManagerService.ANR_TRACE_DIR);
            watchdogTraces = new File(tracesDir, newTracesPath);
            try {
                if (watchdogTraces.createNewFile()) {
                    FileUtils.setPermissions(watchdogTraces.getAbsolutePath(),
                            0600, -1, -1); // -rw------- permissions

                    // Append both traces from the first and second half
                    // to a new file, making it easier to debug Watchdog timeouts
                    // dumpStackTraces() can return a null instance, so check the same
                    if (initialStack != null) {
                        // check the last-modified time of this file.
                        // we are interested in this only it was written to in the
                        // last 5 minutes or so
                        final long age = System.currentTimeMillis()
                                - initialStack.lastModified();
                        final long FIVE_MINUTES_IN_MILLIS = 1000 * 60 * 5;
                        if (age < FIVE_MINUTES_IN_MILLIS) {
                            Slog.e(TAG, ""First set of traces taken from ""
                                    + initialStack.getAbsolutePath());
                            appendFile(watchdogTraces, initialStack);
                        } else {
                            Slog.e(TAG, ""First set of traces were collected more than ""
                                    + ""5 minutes ago, ignoring ..."");
                        }
                    } else {
                        Slog.e(TAG, ""First set of traces are empty!"");
                    }

                    if (finalStack != null) {
                        Slog.e(TAG, ""Second set of traces taken from ""
                                + finalStack.getAbsolutePath());
                        appendFile(watchdogTraces, finalStack);
                    } else {
                        Slog.e(TAG, ""Second set of traces are empty!"");
                    }
                } else {
                    Slog.w(TAG, ""Unable to create Watchdog dump file: createNewFile failed"");
                }
            } catch (Exception e) {
                // catch any exception that happens here;
                // why kill the system when it is going to die anyways?
                Slog.e(TAG, ""Exception creating Watchdog dump file:"", e);
            }
","            File watchdogTraces;
            String newTracesPath = ""traces_SystemServer_WDT""
                    + mTraceDateFormat.format(new Date()) + ""_pid""
                    + String.valueOf(Process.myPid());
            File tracesDir = new File(ActivityManagerService.ANR_TRACE_DIR);
            watchdogTraces = new File(tracesDir, newTracesPath);
            try {
                if (watchdogTraces.createNewFile()) {
                    FileUtils.setPermissions(watchdogTraces.getAbsolutePath(),
                            0600, -1, -1); // -rw------- permissions

                    // Append both traces from the first and second half
                    // to a new file, making it easier to debug Watchdog timeouts
                    // dumpStackTraces() can return a null instance, so check the same
                    if (initialStack != null) {
                        // check the last-modified time of this file.
                        // we are interested in this only it was written to in the
                        // last 5 minutes or so
                        final long age = System.currentTimeMillis()
                                - initialStack.lastModified();
                        final long FIVE_MINUTES_IN_MILLIS = 1000 * 60 * 5;
                        if (age < FIVE_MINUTES_IN_MILLIS) {
                            Slog.e(TAG, ""First set of traces taken from ""
                                    + initialStack.getAbsolutePath());
                            appendFile(watchdogTraces, initialStack);
                        } else {
                            Slog.e(TAG, ""First set of traces were collected more than ""
                                    + ""5 minutes ago, ignoring ..."");
                        }
                    } else {
                        Slog.e(TAG, ""First set of traces are empty!"");
                    }

                    if (finalStack != null) {
                        Slog.e(TAG, ""Second set of traces taken from ""
                                + finalStack.getAbsolutePath());
                        appendFile(watchdogTraces, finalStack);
                    } else {
                        Slog.e(TAG, ""Second set of traces are empty!"");
                    }
                } else {
                    Slog.w(TAG, ""Unable to create Watchdog dump file: createNewFile failed"");
                }
            } catch (Exception e) {
                // catch any exception that happens here;
                // why kill the system when it is going to die anyways?
                Slog.e(TAG, ""Exception creating Watchdog dump file:"", e);
            }
","            File watchdogTraces;
            String newTracesPath = ""traces_SystemServer_WDT""
                    + mTraceDateFormat.format(new Date()) + ""_pid""
                    + String.valueOf(Process.myPid());
            File tracesDir = new File(ActivityManagerService.ANR_TRACE_DIR);
            watchdogTraces = new File(tracesDir, newTracesPath);
            try {
                if (watchdogTraces.createNewFile()) {
                    FileUtils.setPermissions(watchdogTraces.getAbsolutePath(),
                            0600, -1, -1); // -rw------- permissions

                    // Append both traces from the first and second half
                    // to a new file, making it easier to debug Watchdog timeouts
                    // dumpStackTraces() can return a null instance, so check the same
                    if (initialStack != null) {
                        // check the last-modified time of this file.
                        // we are interested in this only it was written to in the
                        // last 5 minutes or so
                        final long age = System.currentTimeMillis()
                                - initialStack.lastModified();
                        final long FIVE_MINUTES_IN_MILLIS = 1000 * 60 * 5;
                        if (age < FIVE_MINUTES_IN_MILLIS) {
                            Slog.e(TAG, ""First set of traces taken from ""
                                    + initialStack.getAbsolutePath());
                            appendFile(watchdogTraces, initialStack);
                        } else {
                            Slog.e(TAG, ""First set of traces were collected more than ""
                                    + ""5 minutes ago, ignoring ..."");
                        }
                    } else {
                        Slog.e(TAG, ""First set of traces are empty!"");
                    }

                    if (finalStack != null) {
                        Slog.e(TAG, ""Second set of traces taken from ""
                                + finalStack.getAbsolutePath());
                        appendFile(watchdogTraces, finalStack);
                    } else {
                        Slog.e(TAG, ""Second set of traces are empty!"");
                    }
                } else {
                    Slog.w(TAG, ""Unable to create Watchdog dump file: createNewFile failed"");
                }
            } catch (Exception e) {
                // catch any exception that happens here;
                // why kill the system when it is going to die anyways?
                Slog.e(TAG, ""Exception creating Watchdog dump file:"", e);
            }
","[1.0, 1.0]"
931,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(688, 688, 1), (688, 688, 1)]","                                    subject, null, finalStack, null);
","                                    subject, null, finalStack, null);
","                                    subject, null, finalStack, null);
","[1.0, 1.0]"
932,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(1662, 1664, 3), (1662, 1664, 3)]","
        if (mPerf == null)
            mPerf = new BoostFramework();
","
        if (mPerf == null)
            mPerf = new BoostFramework();
","
        if (mPerf == null)
            mPerf = new BoostFramework();
","[1.0, 1.0]"
933,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(4887, 4890, 4), (4887, 4890, 4)]","        launching = false;
        final ActivityStack stack = getActivityStack();
        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0
                || (info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0) {
","        launching = false;
        final ActivityStack stack = getActivityStack();
        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0
                || (info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0) {
","        launching = false;
        final ActivityStack stack = getActivityStack();
        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0
                || (info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0) {
","[1.0, 1.0]"
934,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(300, 314, 15), (300, 314, 15)]","                    // If state is BLE_ON make sure we trigger disableBLE
                    if (st == BluetoothAdapter.STATE_BLE_ON) {
                        try {
                            mBluetoothLock.readLock().lock();
                            if (mBluetooth != null) {
                                addActiveLog(
                                        BluetoothProtoEnums.ENABLE_DISABLE_REASON_AIRPLANE_MODE,
                                        mContext.getPackageName(), false);
                                mBluetooth.onBrEdrDown();
                                mEnable = false;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to call onBrEdrDown"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
","                    // If state is BLE_ON make sure we trigger disableBLE
                    if (st == BluetoothAdapter.STATE_BLE_ON) {
                        try {
                            mBluetoothLock.readLock().lock();
                            if (mBluetooth != null) {
                                addActiveLog(
                                        BluetoothProtoEnums.ENABLE_DISABLE_REASON_AIRPLANE_MODE,
                                        mContext.getPackageName(), false);
                                mBluetooth.onBrEdrDown();
                                mEnable = false;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to call onBrEdrDown"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
","                    // If state is BLE_ON make sure we trigger disableBLE
                    if (st == BluetoothAdapter.STATE_BLE_ON) {
                        try {
                            mBluetoothLock.readLock().lock();
                            if (mBluetooth != null) {
                                addActiveLog(
                                        BluetoothProtoEnums.ENABLE_DISABLE_REASON_AIRPLANE_MODE,
                                        mContext.getPackageName(), false);
                                mBluetooth.onBrEdrDown();
                                mEnable = false;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to call onBrEdrDown"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
","[1.0, 1.0]"
935,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(320, 323, 4), (320, 323, 4)]","                } else if (mEnableExternal) {
                    if (st!= BluetoothAdapter.STATE_ON && isBluetoothPersistedStateOn()) {
                    sendEnableMsg(mQuietEnableExternal,
                            BluetoothProtoEnums.ENABLE_DISABLE_REASON_AIRPLANE_MODE,
","                } else if (mEnableExternal) {
                    if (st!= BluetoothAdapter.STATE_ON && isBluetoothPersistedStateOn()) {
                    sendEnableMsg(mQuietEnableExternal,
                            BluetoothProtoEnums.ENABLE_DISABLE_REASON_AIRPLANE_MODE,
","                } else if (mEnableExternal) {
                    if (st!= BluetoothAdapter.STATE_ON && isBluetoothPersistedStateOn()) {
                    sendEnableMsg(mQuietEnableExternal,
                            BluetoothProtoEnums.ENABLE_DISABLE_REASON_AIRPLANE_MODE,
","[1.0, 1.0]"
936,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1049, 1052, 4), (1049, 1052, 4)]","            if (persist) {
                persistBluetoothSetting(BLUETOOTH_OFF);
                mEnableExternal = false;
                sendDisableMsg(BluetoothProtoEnums.ENABLE_DISABLE_REASON_APPLICATION_REQUEST,
","            if (persist) {
                persistBluetoothSetting(BLUETOOTH_OFF);
                mEnableExternal = false;
                sendDisableMsg(BluetoothProtoEnums.ENABLE_DISABLE_REASON_APPLICATION_REQUEST,
","            if (persist) {
                persistBluetoothSetting(BLUETOOTH_OFF);
                mEnableExternal = false;
                sendDisableMsg(BluetoothProtoEnums.ENABLE_DISABLE_REASON_APPLICATION_REQUEST,
","[1.0, 1.0]"
937,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(3040, 3040, 1), (3040, 3040, 1)]","            android.util.SeempLog.record(android.util.SeempLog.getSeempPutApiIdFromValue(name));
","            android.util.SeempLog.record(android.util.SeempLog.getSeempPutApiIdFromValue(name));
","            android.util.SeempLog.record(android.util.SeempLog.getSeempPutApiIdFromValue(name));
","[1.0, 1.0]"
938,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(5097, 5098, 2), (5097, 5098, 2)]","            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED);
            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_COVERAGE_EXTEND_FEATURE_ENABLED);
","            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED);
            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_COVERAGE_EXTEND_FEATURE_ENABLED);
","            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED);
            MOVED_TO_GLOBAL.add(Settings.Global.WIFI_COVERAGE_EXTEND_FEATURE_ENABLED);
","[1.0, 1.0]"
939,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(16973, 16976, 4), (16973, 16976, 4)]","                                + "" dur="" + checkDur + "" limit="" + cpuLimit, true);
                        if (app.baseProcessTracker != null) {
                            app.baseProcessTracker.reportExcessiveCpu(app.pkgList.mPkgList);
                        }
","                                + "" dur="" + checkDur + "" limit="" + cpuLimit, true);
                        if (app.baseProcessTracker != null) {
                            app.baseProcessTracker.reportExcessiveCpu(app.pkgList.mPkgList);
                        }
","                                + "" dur="" + checkDur + "" limit="" + cpuLimit, true);
                        if (app.baseProcessTracker != null) {
                            app.baseProcessTracker.reportExcessiveCpu(app.pkgList.mPkgList);
                        }
","[1.0, 1.0]"
940,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(18, 18, 1), (18, 18, 1)]","import android.content.BroadcastReceiver;
","import android.content.BroadcastReceiver;
","import android.content.BroadcastReceiver;
","[1.0, 1.0]"
941,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(51, 53, 3), (51, 53, 3)]","import com.android.internal.telephony.cdma.EriInfo;
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","import com.android.internal.telephony.cdma.EriInfo;
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","import com.android.internal.telephony.cdma.EriInfo;
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","[1.0, 1.0]"
942,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(279, 285, 7), (279, 285, 7)]","        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_0, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_A, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_B, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EHRPD, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UMTS, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_TD_SCDMA, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_NR, TelephonyIcons.FIVE_G_SA);
","        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_0, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_A, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_B, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EHRPD, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UMTS, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_TD_SCDMA, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_NR, TelephonyIcons.FIVE_G_SA);
","        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_0, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_A, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_B, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EHRPD, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UMTS, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_TD_SCDMA, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_NR, TelephonyIcons.FIVE_G_SA);
","[1.0, 1.0]"
943,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(3604, 3617, 14), (3604, 3617, 14)]","         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(@NonNull String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(@NonNull String Macaddr, int numClients);
","         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(@NonNull String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(@NonNull String Macaddr, int numClients);
","         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(@NonNull String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(@NonNull String Macaddr, int numClients);
","[1.0, 1.0]"
944,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(3686, 3699, 14), (3686, 3699, 14)]","        public void onStaConnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaConnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaConnected(Macaddr, numClients);
            });
        }

        @Override
        public void onStaDisconnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaDisconnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaDisconnected(Macaddr, numClients);
","        public void onStaConnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaConnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaConnected(Macaddr, numClients);
            });
        }

        @Override
        public void onStaDisconnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaDisconnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaDisconnected(Macaddr, numClients);
","        public void onStaConnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaConnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaConnected(Macaddr, numClients);
            });
        }

        @Override
        public void onStaDisconnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaDisconnected Macaddr ="" + Macaddr);
            Binder.clearCallingIdentity();
            mExecutor.execute(() -> {
                mCallback.onStaDisconnected(Macaddr, numClients);
","[1.0, 1.0]"
945,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/SmsManager.java,"[(1605, 1607, 3), (1605, 1607, 3)]","    @UnsupportedAppUsage
    public boolean copyMessageToIcc(byte[] smsc, byte[] pdu,int status) {
        android.util.SeempLog.record(79);
","    @UnsupportedAppUsage
    public boolean copyMessageToIcc(byte[] smsc, byte[] pdu,int status) {
        android.util.SeempLog.record(79);
","    @UnsupportedAppUsage
    public boolean copyMessageToIcc(byte[] smsc, byte[] pdu,int status) {
        android.util.SeempLog.record(79);
","[1.0, 1.0]"
946,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/BluetoothAdapter.java,"[(2683, 2684, 2), (2683, 2684, 2)]","        } else if (profile == BluetoothProfile.DUN) {
            BluetoothDun dun = new BluetoothDun(context, listener);
","        } else if (profile == BluetoothProfile.DUN) {
            BluetoothDun dun = new BluetoothDun(context, listener);
","        } else if (profile == BluetoothProfile.DUN) {
            BluetoothDun dun = new BluetoothDun(context, listener);
","[1.0, 1.0]"
947,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/BluetoothAdapter.java,"[(2758, 2760, 3), (2758, 2760, 3)]","            case BluetoothProfile.DUN:
                BluetoothDun dun = (BluetoothDun)proxy;
                dun.close();
","            case BluetoothProfile.DUN:
                BluetoothDun dun = (BluetoothDun)proxy;
                dun.close();
","            case BluetoothProfile.DUN:
                BluetoothDun dun = (BluetoothDun)proxy;
                dun.close();
","[1.0, 1.0]"
948,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/util/NtpTrustedTime.java,"[(55, 64, 10), (55, 64, 10)]","    private boolean mBackupmode = false;
    private static String mBackupServer = """";
    private static int mNtpRetries = 0;
    private static int mNtpRetriesMax = 0;
    private static final String BACKUP_SERVER = ""persist.backup.ntpServer"";

    private NtpTrustedTime(String server, long timeout) {
        if (LOGD) Log.d(TAG, ""creating NtpTrustedTime using "" + server);
        mServer = server;
        mTimeout = timeout;
","    private boolean mBackupmode = false;
    private static String mBackupServer = """";
    private static int mNtpRetries = 0;
    private static int mNtpRetriesMax = 0;
    private static final String BACKUP_SERVER = ""persist.backup.ntpServer"";

    private NtpTrustedTime(String server, long timeout) {
        if (LOGD) Log.d(TAG, ""creating NtpTrustedTime using "" + server);
        mServer = server;
        mTimeout = timeout;
","    private boolean mBackupmode = false;
    private static String mBackupServer = """";
    private static int mNtpRetries = 0;
    private static int mNtpRetriesMax = 0;
    private static final String BACKUP_SERVER = ""persist.backup.ntpServer"";

    private NtpTrustedTime(String server, long timeout) {
        if (LOGD) Log.d(TAG, ""creating NtpTrustedTime using "" + server);
        mServer = server;
        mTimeout = timeout;
","[1.0, 1.0]"
949,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/util/NtpTrustedTime.java,"[(70, 102, 33), (70, 102, 33)]","            final Resources res = context.getResources();
            final ContentResolver resolver = context.getContentResolver();

            final String defaultServer = res.getString(
                    com.android.internal.R.string.config_ntpServer);
            final long defaultTimeout = res.getInteger(
                    com.android.internal.R.integer.config_ntpTimeout);

            final String secureServer = Settings.Global.getString(
                    resolver, Settings.Global.NTP_SERVER);
            final long timeout = Settings.Global.getLong(
                    resolver, Settings.Global.NTP_TIMEOUT, defaultTimeout);

            final String server = secureServer != null ? secureServer : defaultServer;
            sSingleton = new NtpTrustedTime(server, timeout);
            sContext = context;

            final String sserver_prop = Settings.Global.getString(
                    resolver, Settings.Global.NTP_SERVER_2);

            final String secondServer_prop = ((null != sserver_prop)
                                               && (0 < sserver_prop.length()))
                                               ? sserver_prop : BACKUP_SERVER;

            final String backupServer = SystemProperties.get(secondServer_prop);

            if ((null != backupServer) && (0 < backupServer.length())) {
                int retryMax = res.getInteger(com.android.internal.R.integer.config_ntpRetry);
                if (0 < retryMax) {
                    sSingleton.mNtpRetriesMax = retryMax;
                    sSingleton.mBackupServer = (backupServer.trim()).replace(""\"""", """");
                }
            }
","            final Resources res = context.getResources();
            final ContentResolver resolver = context.getContentResolver();

            final String defaultServer = res.getString(
                    com.android.internal.R.string.config_ntpServer);
            final long defaultTimeout = res.getInteger(
                    com.android.internal.R.integer.config_ntpTimeout);

            final String secureServer = Settings.Global.getString(
                    resolver, Settings.Global.NTP_SERVER);
            final long timeout = Settings.Global.getLong(
                    resolver, Settings.Global.NTP_TIMEOUT, defaultTimeout);

            final String server = secureServer != null ? secureServer : defaultServer;
            sSingleton = new NtpTrustedTime(server, timeout);
            sContext = context;

            final String sserver_prop = Settings.Global.getString(
                    resolver, Settings.Global.NTP_SERVER_2);

            final String secondServer_prop = ((null != sserver_prop)
                                               && (0 < sserver_prop.length()))
                                               ? sserver_prop : BACKUP_SERVER;

            final String backupServer = SystemProperties.get(secondServer_prop);

            if ((null != backupServer) && (0 < backupServer.length())) {
                int retryMax = res.getInteger(com.android.internal.R.integer.config_ntpRetry);
                if (0 < retryMax) {
                    sSingleton.mNtpRetriesMax = retryMax;
                    sSingleton.mBackupServer = (backupServer.trim()).replace(""\"""", """");
                }
            }
","            final Resources res = context.getResources();
            final ContentResolver resolver = context.getContentResolver();

            final String defaultServer = res.getString(
                    com.android.internal.R.string.config_ntpServer);
            final long defaultTimeout = res.getInteger(
                    com.android.internal.R.integer.config_ntpTimeout);

            final String secureServer = Settings.Global.getString(
                    resolver, Settings.Global.NTP_SERVER);
            final long timeout = Settings.Global.getLong(
                    resolver, Settings.Global.NTP_TIMEOUT, defaultTimeout);

            final String server = secureServer != null ? secureServer : defaultServer;
            sSingleton = new NtpTrustedTime(server, timeout);
            sContext = context;

            final String sserver_prop = Settings.Global.getString(
                    resolver, Settings.Global.NTP_SERVER_2);

            final String secondServer_prop = ((null != sserver_prop)
                                               && (0 < sserver_prop.length()))
                                               ? sserver_prop : BACKUP_SERVER;

            final String backupServer = SystemProperties.get(secondServer_prop);

            if ((null != backupServer) && (0 < backupServer.length())) {
                int retryMax = res.getInteger(com.android.internal.R.integer.config_ntpRetry);
                if (0 < retryMax) {
                    sSingleton.mNtpRetriesMax = retryMax;
                    sSingleton.mBackupServer = (backupServer.trim()).replace(""\"""", """");
                }
            }
","[1.0, 1.0]"
950,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/util/NtpTrustedTime.java,"[(111, 116, 6), (111, 116, 6)]","        return hasCache() ? forceSync() : false;
    }

    @Override
    public boolean forceSync() {
        // We can't do this at initialization time: ConnectivityService might not be running yet.
","        return hasCache() ? forceSync() : false;
    }

    @Override
    public boolean forceSync() {
        // We can't do this at initialization time: ConnectivityService might not be running yet.
","        return hasCache() ? forceSync() : false;
    }

    @Override
    public boolean forceSync() {
        // We can't do this at initialization time: ConnectivityService might not be running yet.
","[1.0, 1.0]"
951,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/util/NtpTrustedTime.java,"[(147, 164, 18), (147, 164, 18)]","        if (LOGD) Log.d(TAG, ""forceRefresh() from cache miss"");
        final SntpClient client = new SntpClient();

        String targetServer = mServer;
        if (getBackupmode()) {
            setBackupmode(false);
            targetServer = mBackupServer;
        }
        if (LOGD) Log.d(TAG, ""Ntp Server to access at:"" + targetServer);
        if (client.requestTime(targetServer, (int) mTimeout, network)) {
            mHasCache = true;
            mCachedNtpTime = client.getNtpTime();
            mCachedNtpElapsedRealtime = client.getNtpTimeReference();
            mCachedNtpCertainty = client.getRoundTripTime() / 2;
            return true;
        } else {
            countInBackupmode();
            return false;
","        if (LOGD) Log.d(TAG, ""forceRefresh() from cache miss"");
        final SntpClient client = new SntpClient();

        String targetServer = mServer;
        if (getBackupmode()) {
            setBackupmode(false);
            targetServer = mBackupServer;
        }
        if (LOGD) Log.d(TAG, ""Ntp Server to access at:"" + targetServer);
        if (client.requestTime(targetServer, (int) mTimeout, network)) {
            mHasCache = true;
            mCachedNtpTime = client.getNtpTime();
            mCachedNtpElapsedRealtime = client.getNtpTimeReference();
            mCachedNtpCertainty = client.getRoundTripTime() / 2;
            return true;
        } else {
            countInBackupmode();
            return false;
","        if (LOGD) Log.d(TAG, ""forceRefresh() from cache miss"");
        final SntpClient client = new SntpClient();

        String targetServer = mServer;
        if (getBackupmode()) {
            setBackupmode(false);
            targetServer = mBackupServer;
        }
        if (LOGD) Log.d(TAG, ""Ntp Server to access at:"" + targetServer);
        if (client.requestTime(targetServer, (int) mTimeout, network)) {
            mHasCache = true;
            mCachedNtpTime = client.getNtpTime();
            mCachedNtpElapsedRealtime = client.getNtpTimeReference();
            mCachedNtpCertainty = client.getRoundTripTime() / 2;
            return true;
        } else {
            countInBackupmode();
            return false;
","[1.0, 1.0]"
952,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(225, 242, 18), (225, 242, 18)]","    private static final int LEGACY_CAPABLE_BSSID = 0;
    private static final int HT_CAPABLE_BSSID = 1;
    private static final int VHT_CAPABLE_BSSID = 2;
    private static final int HE_CAPABLE_BSSID = 3;
    private static final int MAX_CAPABLE_BSSID = Integer.MAX_VALUE;

    private static final int WIFI_GENERATION_LEGACY = 0;
    private static final int WIFI_GENERATION_4 = 4;
    private static final int WIFI_GENERATION_5 = 5;
    private static final int WIFI_GENERATION_6 = 6;

    /**
     * The number of distinct wifi levels.
     *
     * <p>Must keep in sync with {@link R.array.wifi_signal} and {@link WifiManager#RSSI_LEVELS}.
     */
    public static final int SIGNAL_LEVELS = 5;

","    private static final int LEGACY_CAPABLE_BSSID = 0;
    private static final int HT_CAPABLE_BSSID = 1;
    private static final int VHT_CAPABLE_BSSID = 2;
    private static final int HE_CAPABLE_BSSID = 3;
    private static final int MAX_CAPABLE_BSSID = Integer.MAX_VALUE;

    private static final int WIFI_GENERATION_LEGACY = 0;
    private static final int WIFI_GENERATION_4 = 4;
    private static final int WIFI_GENERATION_5 = 5;
    private static final int WIFI_GENERATION_6 = 6;

    /**
     * The number of distinct wifi levels.
     *
     * <p>Must keep in sync with {@link R.array.wifi_signal} and {@link WifiManager#RSSI_LEVELS}.
     */
    public static final int SIGNAL_LEVELS = 5;

","    private static final int LEGACY_CAPABLE_BSSID = 0;
    private static final int HT_CAPABLE_BSSID = 1;
    private static final int VHT_CAPABLE_BSSID = 2;
    private static final int HE_CAPABLE_BSSID = 3;
    private static final int MAX_CAPABLE_BSSID = Integer.MAX_VALUE;

    private static final int WIFI_GENERATION_LEGACY = 0;
    private static final int WIFI_GENERATION_4 = 4;
    private static final int WIFI_GENERATION_5 = 5;
    private static final int WIFI_GENERATION_6 = 6;

    /**
     * The number of distinct wifi levels.
     *
     * <p>Must keep in sync with {@link R.array.wifi_signal} and {@link WifiManager#RSSI_LEVELS}.
     */
    public static final int SIGNAL_LEVELS = 5;

","[1.0, 1.0]"
953,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ProcessRecord.java,"[(66, 68, 3), (66, 68, 3)]","import com.android.server.LocalServices;
import com.android.server.Watchdog;
import com.android.server.wm.WindowManagerInternal;
","import com.android.server.LocalServices;
import com.android.server.Watchdog;
import com.android.server.wm.WindowManagerInternal;
","import com.android.server.LocalServices;
import com.android.server.Watchdog;
import com.android.server.wm.WindowManagerInternal;
","[1.0, 1.0]"
954,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java,"[(333, 334, 2), (333, 334, 2)]","        filter.addAction(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
        mBroadcastDispatcher.registerReceiver(this, filter, mReceiverHandler);
","        filter.addAction(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
        mBroadcastDispatcher.registerReceiver(this, filter, mReceiverHandler);
","        filter.addAction(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
        mBroadcastDispatcher.registerReceiver(this, filter, mReceiverHandler);
","[1.0, 1.0]"
955,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/view/InputEventReceiver.java,"[(217, 232, 16), (217, 232, 16)]","    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
    public static interface Factory {
        public InputEventReceiver createInputEventReceiver(
                InputChannel inputChannel, Looper looper);
","    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
    public static interface Factory {
        public InputEventReceiver createInputEventReceiver(
                InputChannel inputChannel, Looper looper);
","    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
    public static interface Factory {
        public InputEventReceiver createInputEventReceiver(
                InputChannel inputChannel, Looper looper);
","[1.0, 1.0]"
956,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerConstants.java,"[(35, 35, 1), (35, 35, 1)]","import android.util.BoostFramework;
","import android.util.BoostFramework;
","import android.util.BoostFramework;
","[1.0, 1.0]"
957,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerConstants.java,"[(365, 377, 13), (365, 377, 13)]","
        if (mPerf != null) {
          // Maximum number of cached processes we will allow.
            DEFAULT_MAX_CACHED_PROCESSES = MAX_CACHED_PROCESSES = Integer.valueOf(
                                                 mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bg_apps_limit"", ""32""));

           //Trim Settings
            USE_TRIM_SETTINGS = Boolean.parseBoolean(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.use_trim_settings"", ""true""));
            EMPTY_APP_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.empty_app_percent"", ""50""));
            TRIM_EMPTY_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_empty_percent"", ""100""));
            TRIM_CACHE_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_cache_percent"", ""100""));
            TRIM_ENABLE_MEMORY = Long.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_enable_memory"", ""1073741824""));
        }
","
        if (mPerf != null) {
          // Maximum number of cached processes we will allow.
            DEFAULT_MAX_CACHED_PROCESSES = MAX_CACHED_PROCESSES = Integer.valueOf(
                                                 mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bg_apps_limit"", ""32""));

           //Trim Settings
            USE_TRIM_SETTINGS = Boolean.parseBoolean(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.use_trim_settings"", ""true""));
            EMPTY_APP_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.empty_app_percent"", ""50""));
            TRIM_EMPTY_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_empty_percent"", ""100""));
            TRIM_CACHE_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_cache_percent"", ""100""));
            TRIM_ENABLE_MEMORY = Long.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_enable_memory"", ""1073741824""));
        }
","
        if (mPerf != null) {
          // Maximum number of cached processes we will allow.
            DEFAULT_MAX_CACHED_PROCESSES = MAX_CACHED_PROCESSES = Integer.valueOf(
                                                 mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bg_apps_limit"", ""32""));

           //Trim Settings
            USE_TRIM_SETTINGS = Boolean.parseBoolean(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.use_trim_settings"", ""true""));
            EMPTY_APP_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.empty_app_percent"", ""50""));
            TRIM_EMPTY_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_empty_percent"", ""100""));
            TRIM_CACHE_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_cache_percent"", ""100""));
            TRIM_ENABLE_MEMORY = Long.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_enable_memory"", ""1073741824""));
        }
","[1.0, 1.0]"
958,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '7fe8671fd7b5388dd9be6295dbea6d31209468f9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(677, 740, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
959,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java,"[(184, 185, 2), (190, 191, 2)]","        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        broadcastDispatcher.registerReceiver(mIntentReceiver, filter, mHandler);
","        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        broadcastDispatcher.registerReceiverWithHandler(mIntentReceiver, filter, mHandler);
","        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        broadcastDispatcher.registerReceiver","[0.73, 0.676]"
960,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(617, 618, 2), (621, 622, 2)]","            final File finalStack = ActivityManagerService.dumpStackTraces(
                    pids, null, null, getInterestingNativePids());
","            final File finalStack = ActivityManagerService.dumpStackTraces(
                    pids, processCpuTracker, new SparseArray<>(), getInterestingNativePids());
","            final File finalStack = ActivityManagerService.dumpStackTraces(
                    pids, ","[0.713, 0.596]"
961,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(688, 688, 1), (695, 695, 1)]","                                    subject, null, finalStack, null);
","                                    subject, cpuInfo, finalStack, null);
","                                    subject, ","[0.643, 0.616]"
962,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/com/android/ims/internal/uce/common/CapInfo.java,"[(82, 85, 4), (81, 83, 3)]","     /** Standalone Chatbot communication support. */
    private boolean mSmChatbotSupported = false;
     /** MMtel based call composer support. */
    private boolean mMmtelCallComposerSupported = false;
","     /** Standalone Chatbot communication support. */
    private boolean mSmChatbotSupported = false;
     /** MMtel based call composer support. */
","     /** Standalone Chatbot communication support. */
    private boolean mSmChatbotSupported = false;
     /** MMtel based call composer support. */
","[0.725, 1.0]"
963,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/com/android/ims/internal/uce/common/CapInfo.java,"[(95, 95, 1), (94, 94, 1)]","    @UnsupportedAppUsage
","    @UnsupportedAppUsage
","    @UnsupportedAppUsage
","[1.0, 1.0]"
964,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(1662, 1664, 3), (1658, 1660, 3)]","
        if (mPerf == null)
            mPerf = new BoostFramework();
","
        if (mPerf == null)
            mPerf = new BoostFramework();
","
        if (mPerf == null)
            mPerf = new BoostFramework();
","[1.0, 1.0]"
965,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerConstants.java,"[(365, 377, 13), (434, 446, 13)]","
        if (mPerf != null) {
          // Maximum number of cached processes we will allow.
            DEFAULT_MAX_CACHED_PROCESSES = MAX_CACHED_PROCESSES = Integer.valueOf(
                                                 mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bg_apps_limit"", ""32""));

           //Trim Settings
            USE_TRIM_SETTINGS = Boolean.parseBoolean(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.use_trim_settings"", ""true""));
            EMPTY_APP_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.empty_app_percent"", ""50""));
            TRIM_EMPTY_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_empty_percent"", ""100""));
            TRIM_CACHE_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_cache_percent"", ""100""));
            TRIM_ENABLE_MEMORY = Long.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_enable_memory"", ""1073741824""));
        }
","
        if (mPerf != null) {
          // Maximum number of cached processes we will allow.
            DEFAULT_MAX_CACHED_PROCESSES = MAX_CACHED_PROCESSES = Integer.valueOf(
                                                 mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bg_apps_limit"", ""32""));

           //Trim Settings
            USE_TRIM_SETTINGS = Boolean.parseBoolean(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.use_trim_settings"", ""true""));
            EMPTY_APP_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.empty_app_percent"", ""50""));
            TRIM_EMPTY_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_empty_percent"", ""100""));
            TRIM_CACHE_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_cache_percent"", ""100""));
            TRIM_ENABLE_MEMORY = Long.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_enable_memory"", ""1073741824""));
        }
","
        if (mPerf != null) {
          // Maximum number of cached processes we will allow.
            DEFAULT_MAX_CACHED_PROCESSES = MAX_CACHED_PROCESSES = Integer.valueOf(
                                                 mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bg_apps_limit"", ""32""));

           //Trim Settings
            USE_TRIM_SETTINGS = Boolean.parseBoolean(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.use_trim_settings"", ""true""));
            EMPTY_APP_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.empty_app_percent"", ""50""));
            TRIM_EMPTY_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_empty_percent"", ""100""));
            TRIM_CACHE_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_cache_percent"", ""100""));
            TRIM_ENABLE_MEMORY = Long.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_enable_memory"", ""1073741824""));
        }
","[1.0, 1.0]"
966,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(677, 740, 64), (593, 656, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
967,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(51, 53, 3), (46, 48, 3)]","import com.android.internal.telephony.cdma.EriInfo;
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
import com.android.settingslib.graph.SignalDrawable;
","import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","[0.694, 0.69]"
968,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'c77ad764fad2451538f140b31601e7b8c6c59fa2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/view/InputEventReceiver.java,"[(217, 232, 16), (225, 244, 20)]","    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
    public static interface Factory {
        public InputEventReceiver createInputEventReceiver(
                InputChannel inputChannel, Looper looper);
","    @UnsupportedAppUsage
    private void dispatchBatchedInputEventPending() {
        onBatchedInputEventPending();
    }

    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
    /**
     * Factory for InputEventReceiver
","    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
    ","[0.765, 0.75]"
969,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(51, 53, 3), (54, 56, 3)]","import com.android.internal.telephony.cdma.EriInfo;
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","import com.android.internal.telephony.TelephonyIntents;
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
",";
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","[0.706, 0.69]"
970,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(677, 740, 64), (570, 633, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
971,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java,"[(333, 334, 2), (321, 322, 2)]","        filter.addAction(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
        mBroadcastDispatcher.registerReceiver(this, filter, mReceiverHandler);
","        filter.addAction(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
        mContext.registerReceiver(this, filter, null, mReceiverHandler);
","        filter.addAction(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
        m","[0.573, 0.595]"
972,"['71998c3d8b36220df1be12fe6e1ba7eda81cde41', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(677, 740, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
973,"['784ecc8e9194775f58ad5a45422ed16570bcbee6', '784ecc8e9194775f58ad5a45422ed16570bcbee6']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(271, 271, 1), (271, 271, 1)]","import android.util.BoostFramework;
","import android.util.BoostFramework;
","import android.util.BoostFramework;
","[1.0, 1.0]"
982,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '8943bbe92bfbc3ead44f63a6a3c145a135548b7c']","['aospa-ruby-SAP-block_text', 'lineage-17.1-SAP-block_text']",telephony/java/android/telephony/ServiceState.java,"[(991, 991, 1), (990, 990, 1)]","                rtString = ""NR"";
","                rtString = ""NR"";
","                rtString = ""NR"";
","[1.0, 1.0]"
983,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']","['aospa-ruby-SAP-block_text', 'omnirom-10-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1875, 1883, 9), (1799, 1807, 9)]","        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        CHALLENGE_NONE, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        false, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
",", 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","[0.768, 0.78]"
984,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'b7ff81acc796b2957f68c9412cef71b9b47e67de']","['aospa-ruby-SAP-block_text', 'omnirom-10-SAP-block_text']",telephony/java/android/telephony/ServiceState.java,"[(991, 991, 1), (990, 990, 1)]","                rtString = ""NR"";
","                rtString = ""NR"";
","                rtString = ""NR"";
","[1.0, 1.0]"
985,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '3a5272699e3e16fbfdc397480898bb27abeb2caa']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1749, 1763, 15), (1577, 1589, 13)]","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } catch (RemoteException e) {
            throw new IllegalStateException(""clearUserKeyAuth failed user="" + userId);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(byte[] credential) {
","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) throws RemoteException {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(String credential) throws RemoteException {
"," {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } ","[0.534, 0.597]"
986,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '4a30c150e58ec67edb92a7bec5ea48cebd6b90d4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,"[(137, 138, 2), (120, 121, 2)]","
        updateResources();
","
        updateResources();
","
        updateResources();
","[1.0, 1.0]"
987,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3272, 3272, 1), (3024, 3025, 2)]","            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
","            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
            disconnectBluetoothSco(newModeOwnerPid);
","            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
","[1.0, 0.583]"
988,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '6445e9361550e1306d29713dd600481e125f88a8']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/com/android/internal/os/ZygoteInit.java,"[(187, 190, 4), (191, 194, 4)]","        try {
            System.loadLibrary(""qti_performance"");
        } catch (UnsatisfiedLinkError e) {
            Log.e(TAG, ""Couldn't load qti_performance"");
","        try {
            System.loadLibrary(""qti_performance"");
        } catch (UnsatisfiedLinkError e) {
            Log.e(TAG, ""Couldn't load qti_performance"");
","        try {
            System.loadLibrary(""qti_performance"");
        } catch (UnsatisfiedLinkError e) {
            Log.e(TAG, ""Couldn't load qti_performance"");
","[1.0, 1.0]"
989,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '799030b703da27e7117eba75c2ca753b0e976a8d']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/ServiceState.java,"[(991, 991, 1), (990, 990, 1)]","                rtString = ""NR"";
","                rtString = ""NR"";
","                rtString = ""NR"";
","[1.0, 1.0]"
990,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3214, 3214, 1), (3214, 3214, 1)]","                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
","                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
","                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
","[1.0, 1.0]"
991,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3238, 3239, 2), (3238, 3239, 2)]","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
","[1.0, 1.0]"
992,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3272, 3272, 1), (3272, 3272, 1)]","            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
","            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
","            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
","[1.0, 1.0]"
993,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/com/android/internal/widget/LockPatternUtils.java,"[(834, 842, 9), (834, 842, 9)]","    /**
     * clears stored password.
     */
    public void sanitizePassword() {
        try {
            getLockSettings().sanitizePassword();
        } catch (RemoteException re) {
            Log.e(TAG, ""Couldn't sanitize password"" + re);
        }
","    /**
     * clears stored password.
     */
    public void sanitizePassword() {
        try {
            getLockSettings().sanitizePassword();
        } catch (RemoteException re) {
            Log.e(TAG, ""Couldn't sanitize password"" + re);
        }
","    /**
     * clears stored password.
     */
    public void sanitizePassword() {
        try {
            getLockSettings().sanitizePassword();
        } catch (RemoteException re) {
            Log.e(TAG, ""Couldn't sanitize password"" + re);
        }
","[1.0, 1.0]"
994,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/com/android/internal/telephony/uicc/IccUtils.java,"[(25, 25, 1), (25, 25, 1)]","import com.android.internal.telephony.EncodeException;
","import com.android.internal.telephony.EncodeException;
","import com.android.internal.telephony.EncodeException;
","[1.0, 1.0]"
995,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/com/android/internal/telephony/uicc/IccUtils.java,"[(31, 31, 1), (31, 31, 1)]","import java.nio.charset.Charset;
","import java.nio.charset.Charset;
","import java.nio.charset.Charset;
","[1.0, 1.0]"
996,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/com/android/internal/telephony/uicc/IccUtils.java,"[(902, 925, 24), (902, 925, 24)]","    static byte[]
    stringToAdnStringField(String alphaTag) {
        boolean isUcs2 = false;
        try {
           for(int i = 0; i < alphaTag.length(); i++) {
               GsmAlphabet.countGsmSeptets(alphaTag.charAt(i), true);
           }
        } catch (EncodeException e) {
            isUcs2 = true;
        }
        return stringToAdnStringField(alphaTag, isUcs2);
    }

    static byte[]
    stringToAdnStringField(String alphaTag, boolean isUcs2) {
        if (!isUcs2) {
            return GsmAlphabet.stringToGsm8BitPacked(alphaTag);
        }
        byte[] alphaTagBytes = alphaTag.getBytes(Charset.forName(""UTF-16BE""));
        byte[] ret = new byte[1 + alphaTagBytes.length];
        ret[0] = (byte)0x80;
        System.arraycopy(alphaTagBytes, 0, ret, 1, alphaTagBytes.length);

        return ret;
","    static byte[]
    stringToAdnStringField(String alphaTag) {
        boolean isUcs2 = false;
        try {
           for(int i = 0; i < alphaTag.length(); i++) {
               GsmAlphabet.countGsmSeptets(alphaTag.charAt(i), true);
           }
        } catch (EncodeException e) {
            isUcs2 = true;
        }
        return stringToAdnStringField(alphaTag, isUcs2);
    }

    static byte[]
    stringToAdnStringField(String alphaTag, boolean isUcs2) {
        if (!isUcs2) {
            return GsmAlphabet.stringToGsm8BitPacked(alphaTag);
        }
        byte[] alphaTagBytes = alphaTag.getBytes(Charset.forName(""UTF-16BE""));
        byte[] ret = new byte[1 + alphaTagBytes.length];
        ret[0] = (byte)0x80;
        System.arraycopy(alphaTagBytes, 0, ret, 1, alphaTagBytes.length);

        return ret;
","    static byte[]
    stringToAdnStringField(String alphaTag) {
        boolean isUcs2 = false;
        try {
           for(int i = 0; i < alphaTag.length(); i++) {
               GsmAlphabet.countGsmSeptets(alphaTag.charAt(i), true);
           }
        } catch (EncodeException e) {
            isUcs2 = true;
        }
        return stringToAdnStringField(alphaTag, isUcs2);
    }

    static byte[]
    stringToAdnStringField(String alphaTag, boolean isUcs2) {
        if (!isUcs2) {
            return GsmAlphabet.stringToGsm8BitPacked(alphaTag);
        }
        byte[] alphaTagBytes = alphaTag.getBytes(Charset.forName(""UTF-16BE""));
        byte[] ret = new byte[1 + alphaTagBytes.length];
        ret[0] = (byte)0x80;
        System.arraycopy(alphaTagBytes, 0, ret, 1, alphaTagBytes.length);

        return ret;
","[1.0, 1.0]"
997,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/BtHelper.java,"[(268, 336, 69), (268, 336, 69)]","    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

","    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

","    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

","[1.0, 1.0]"
998,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(519, 528, 10), (519, 528, 10)]","    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(@NonNull String provider, long minTime, float minDistance,
            @NonNull LocationListener listener) {
        android.util.SeempLog.record(47);
        checkProvider(provider);
        checkListener(listener);

        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, minTime, minDistance, false);
        requestLocationUpdates(request, listener, null, null);
","    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(@NonNull String provider, long minTime, float minDistance,
            @NonNull LocationListener listener) {
        android.util.SeempLog.record(47);
        checkProvider(provider);
        checkListener(listener);

        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, minTime, minDistance, false);
        requestLocationUpdates(request, listener, null, null);
","    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(@NonNull String provider, long minTime, float minDistance,
            @NonNull LocationListener listener) {
        android.util.SeempLog.record(47);
        checkProvider(provider);
        checkListener(listener);

        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, minTime, minDistance, false);
        requestLocationUpdates(request, listener, null, null);
","[1.0, 1.0]"
999,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(552, 561, 10), (552, 561, 10)]","    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(@NonNull String provider, long minTime, float minDistance,
            @NonNull LocationListener listener, @Nullable Looper looper) {
        android.util.SeempLog.record(47);
        checkProvider(provider);
        checkListener(listener);

        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, minTime, minDistance, false);
        requestLocationUpdates(request, listener, looper, null);
","    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(@NonNull String provider, long minTime, float minDistance,
            @NonNull LocationListener listener, @Nullable Looper looper) {
        android.util.SeempLog.record(47);
        checkProvider(provider);
        checkListener(listener);

        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, minTime, minDistance, false);
        requestLocationUpdates(request, listener, looper, null);
","    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(@NonNull String provider, long minTime, float minDistance,
            @NonNull LocationListener listener, @Nullable Looper looper) {
        android.util.SeempLog.record(47);
        checkProvider(provider);
        checkListener(listener);

        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, minTime, minDistance, false);
        requestLocationUpdates(request, listener, looper, null);
","[1.0, 1.0]"
1000,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(586, 591, 6), (586, 591, 6)]","    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(long minTime, float minDistance, @NonNull Criteria criteria,
            @NonNull LocationListener listener, @Nullable Looper looper) {
        android.util.SeempLog.record(47);
        checkCriteria(criteria);
        checkListener(listener);
","    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(long minTime, float minDistance, @NonNull Criteria criteria,
            @NonNull LocationListener listener, @Nullable Looper looper) {
        android.util.SeempLog.record(47);
        checkCriteria(criteria);
        checkListener(listener);
","    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(long minTime, float minDistance, @NonNull Criteria criteria,
            @NonNull LocationListener listener, @Nullable Looper looper) {
        android.util.SeempLog.record(47);
        checkCriteria(criteria);
        checkListener(listener);
","[1.0, 1.0]"
1001,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(615, 720, 106), (615, 720, 106)]","    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(@NonNull String provider, long minTime, float minDistance,
            @NonNull PendingIntent intent) {
        android.util.SeempLog.record(47);
        checkProvider(provider);
        checkPendingIntent(intent);

        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, minTime, minDistance, false);
        requestLocationUpdates(request, null, null, intent);
    }

    /**
     * Register for location updates using a Criteria and pending intent.
     *
     * <p>The <code>requestLocationUpdates()</code> and
     * <code>requestSingleUpdate()</code> register the current activity to be
     * updated periodically by the named provider, or by the provider matching
     * the specified {@link Criteria}, with location and status updates.
     *
     * <p> It may take a while to receive the first location update. If
     * an immediate location is required, applications may use the
     * {@link #getLastKnownLocation(String)} method.
     *
     * <p> Location updates are received either by {@link LocationListener}
     * callbacks, or by broadcast intents to a supplied {@link PendingIntent}.
     *
     * <p> If the caller supplied a pending intent, then location updates
     * are sent with a key of {@link #KEY_LOCATION_CHANGED} and a
     * {@link android.location.Location} value.
     *
     * <p> The location update interval can be controlled using the minTime parameter.
     * The elapsed time between location updates will never be less than
     * minTime, although it can be more depending on the Location Provider
     * implementation and the update interval requested by other applications.
     *
     * <p> Choosing a sensible value for minTime is important to conserve
     * battery life. Each location update requires power from
     * GPS, WIFI, Cell and other radios. Select a minTime value as high as
     * possible while still providing a reasonable user experience.
     * If your application is not in the foreground and showing
     * location to the user then your application should avoid using an active
     * provider (such as {@link #NETWORK_PROVIDER} or {@link #GPS_PROVIDER}),
     * but if you insist then select a minTime of 5 * 60 * 1000 (5 minutes)
     * or greater. If your application is in the foreground and showing
     * location to the user then it is appropriate to select a faster
     * update interval.
     *
     * <p> The minDistance parameter can also be used to control the
     * frequency of location updates. If it is greater than 0 then the
     * location provider will only send your application an update when
     * the location has changed by at least minDistance meters, AND
     * at least minTime milliseconds have passed. However it is more
     * difficult for location providers to save power using the minDistance
     * parameter, so minTime should be the primary tool to conserving battery
     * life.
     *
     * <p> If your application wants to passively observe location
     * updates triggered by other applications, but not consume
     * any additional power otherwise, then use the {@link #PASSIVE_PROVIDER}
     * This provider does not actively turn on or modify active location
     * providers, so you do not need to be as careful about minTime and
     * minDistance. However if your application performs heavy work
     * on a location update (such as network activity) then you should
     * select non-zero values for minTime and/or minDistance to rate-limit
     * your update frequency in the case another application enables a
     * location provider with extremely fast updates.
     *
     * <p>In case the provider is disabled by the user, updates will stop,
     * and a provider availability update will be sent.
     * As soon as the provider is enabled again,
     * location updates will immediately resume and a provider availability
     * update sent. Providers can also send status updates, at any time,
     * with extra's specific to the provider. If a callback was supplied
     * then status and availability updates are via
     * {@link LocationListener#onProviderDisabled},
     * {@link LocationListener#onProviderEnabled} or
     * {@link LocationListener#onStatusChanged}. Alternately, if a
     * pending intent was supplied then status and availability updates
     * are broadcast intents with extra keys of
     * {@link #KEY_PROVIDER_ENABLED} or {@link #KEY_STATUS_CHANGED}.
     *
     * <p> If a {@link LocationListener} is used but with no Looper specified
     * then the calling thread must already
     * be a {@link android.os.Looper} thread such as the main thread of the
     * calling Activity. If a Looper is specified with a {@link LocationListener}
     * then callbacks are made on the supplied Looper thread.
     *
     * <p> When location callbacks are invoked, the system will hold a wakelock
     * on your application's behalf for some period of time, but not
     * indefinitely. If your application requires a long running wakelock
     * within the location callback, you should acquire it yourself.
     *
     * <p class=""note""> Prior to Jellybean, the minTime parameter was
     * only a hint, and some location provider implementations ignored it.
     * From Jellybean and onwards it is mandatory for Android compatible
     * devices to observe both the minTime and minDistance parameters.
     *
     * @param minTime minimum time interval between location updates, in milliseconds
     * @param minDistance minimum distance between location updates, in meters
     * @param criteria contains parameters for the location manager to choose the
     * appropriate provider and parameters to compute the location
     * @param intent a {@link PendingIntent} to be sent for each location update
     *
     * @throws IllegalArgumentException if criteria is null
     * @throws IllegalArgumentException if intent is null
","    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(@NonNull String provider, long minTime, float minDistance,
            @NonNull PendingIntent intent) {
        android.util.SeempLog.record(47);
        checkProvider(provider);
        checkPendingIntent(intent);

        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, minTime, minDistance, false);
        requestLocationUpdates(request, null, null, intent);
    }

    /**
     * Register for location updates using a Criteria and pending intent.
     *
     * <p>The <code>requestLocationUpdates()</code> and
     * <code>requestSingleUpdate()</code> register the current activity to be
     * updated periodically by the named provider, or by the provider matching
     * the specified {@link Criteria}, with location and status updates.
     *
     * <p> It may take a while to receive the first location update. If
     * an immediate location is required, applications may use the
     * {@link #getLastKnownLocation(String)} method.
     *
     * <p> Location updates are received either by {@link LocationListener}
     * callbacks, or by broadcast intents to a supplied {@link PendingIntent}.
     *
     * <p> If the caller supplied a pending intent, then location updates
     * are sent with a key of {@link #KEY_LOCATION_CHANGED} and a
     * {@link android.location.Location} value.
     *
     * <p> The location update interval can be controlled using the minTime parameter.
     * The elapsed time between location updates will never be less than
     * minTime, although it can be more depending on the Location Provider
     * implementation and the update interval requested by other applications.
     *
     * <p> Choosing a sensible value for minTime is important to conserve
     * battery life. Each location update requires power from
     * GPS, WIFI, Cell and other radios. Select a minTime value as high as
     * possible while still providing a reasonable user experience.
     * If your application is not in the foreground and showing
     * location to the user then your application should avoid using an active
     * provider (such as {@link #NETWORK_PROVIDER} or {@link #GPS_PROVIDER}),
     * but if you insist then select a minTime of 5 * 60 * 1000 (5 minutes)
     * or greater. If your application is in the foreground and showing
     * location to the user then it is appropriate to select a faster
     * update interval.
     *
     * <p> The minDistance parameter can also be used to control the
     * frequency of location updates. If it is greater than 0 then the
     * location provider will only send your application an update when
     * the location has changed by at least minDistance meters, AND
     * at least minTime milliseconds have passed. However it is more
     * difficult for location providers to save power using the minDistance
     * parameter, so minTime should be the primary tool to conserving battery
     * life.
     *
     * <p> If your application wants to passively observe location
     * updates triggered by other applications, but not consume
     * any additional power otherwise, then use the {@link #PASSIVE_PROVIDER}
     * This provider does not actively turn on or modify active location
     * providers, so you do not need to be as careful about minTime and
     * minDistance. However if your application performs heavy work
     * on a location update (such as network activity) then you should
     * select non-zero values for minTime and/or minDistance to rate-limit
     * your update frequency in the case another application enables a
     * location provider with extremely fast updates.
     *
     * <p>In case the provider is disabled by the user, updates will stop,
     * and a provider availability update will be sent.
     * As soon as the provider is enabled again,
     * location updates will immediately resume and a provider availability
     * update sent. Providers can also send status updates, at any time,
     * with extra's specific to the provider. If a callback was supplied
     * then status and availability updates are via
     * {@link LocationListener#onProviderDisabled},
     * {@link LocationListener#onProviderEnabled} or
     * {@link LocationListener#onStatusChanged}. Alternately, if a
     * pending intent was supplied then status and availability updates
     * are broadcast intents with extra keys of
     * {@link #KEY_PROVIDER_ENABLED} or {@link #KEY_STATUS_CHANGED}.
     *
     * <p> If a {@link LocationListener} is used but with no Looper specified
     * then the calling thread must already
     * be a {@link android.os.Looper} thread such as the main thread of the
     * calling Activity. If a Looper is specified with a {@link LocationListener}
     * then callbacks are made on the supplied Looper thread.
     *
     * <p> When location callbacks are invoked, the system will hold a wakelock
     * on your application's behalf for some period of time, but not
     * indefinitely. If your application requires a long running wakelock
     * within the location callback, you should acquire it yourself.
     *
     * <p class=""note""> Prior to Jellybean, the minTime parameter was
     * only a hint, and some location provider implementations ignored it.
     * From Jellybean and onwards it is mandatory for Android compatible
     * devices to observe both the minTime and minDistance parameters.
     *
     * @param minTime minimum time interval between location updates, in milliseconds
     * @param minDistance minimum distance between location updates, in meters
     * @param criteria contains parameters for the location manager to choose the
     * appropriate provider and parameters to compute the location
     * @param intent a {@link PendingIntent} to be sent for each location update
     *
     * @throws IllegalArgumentException if criteria is null
     * @throws IllegalArgumentException if intent is null
","    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void requestLocationUpdates(@NonNull String provider, long minTime, float minDistance,
            @NonNull PendingIntent intent) {
        android.util.SeempLog.record(47);
        checkProvider(provider);
        checkPendingIntent(intent);

        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, minTime, minDistance, false);
        requestLocationUpdates(request, null, null, intent);
    }

    /**
     * Register for location updates using a Criteria and pending intent.
     *
     * <p>The <code>requestLocationUpdates()</code> and
     * <code>requestSingleUpdate()</code> register the current activity to be
     * updated periodically by the named provider, or by the provider matching
     * the specified {@link Criteria}, with location and status updates.
     *
     * <p> It may take a while to receive the first location update. If
     * an immediate location is required, applications may use the
     * {@link #getLastKnownLocation(String)} method.
     *
     * <p> Location updates are received either by {@link LocationListener}
     * callbacks, or by broadcast intents to a supplied {@link PendingIntent}.
     *
     * <p> If the caller supplied a pending intent, then location updates
     * are sent with a key of {@link #KEY_LOCATION_CHANGED} and a
     * {@link android.location.Location} value.
     *
     * <p> The location update interval can be controlled using the minTime parameter.
     * The elapsed time between location updates will never be less than
     * minTime, although it can be more depending on the Location Provider
     * implementation and the update interval requested by other applications.
     *
     * <p> Choosing a sensible value for minTime is important to conserve
     * battery life. Each location update requires power from
     * GPS, WIFI, Cell and other radios. Select a minTime value as high as
     * possible while still providing a reasonable user experience.
     * If your application is not in the foreground and showing
     * location to the user then your application should avoid using an active
     * provider (such as {@link #NETWORK_PROVIDER} or {@link #GPS_PROVIDER}),
     * but if you insist then select a minTime of 5 * 60 * 1000 (5 minutes)
     * or greater. If your application is in the foreground and showing
     * location to the user then it is appropriate to select a faster
     * update interval.
     *
     * <p> The minDistance parameter can also be used to control the
     * frequency of location updates. If it is greater than 0 then the
     * location provider will only send your application an update when
     * the location has changed by at least minDistance meters, AND
     * at least minTime milliseconds have passed. However it is more
     * difficult for location providers to save power using the minDistance
     * parameter, so minTime should be the primary tool to conserving battery
     * life.
     *
     * <p> If your application wants to passively observe location
     * updates triggered by other applications, but not consume
     * any additional power otherwise, then use the {@link #PASSIVE_PROVIDER}
     * This provider does not actively turn on or modify active location
     * providers, so you do not need to be as careful about minTime and
     * minDistance. However if your application performs heavy work
     * on a location update (such as network activity) then you should
     * select non-zero values for minTime and/or minDistance to rate-limit
     * your update frequency in the case another application enables a
     * location provider with extremely fast updates.
     *
     * <p>In case the provider is disabled by the user, updates will stop,
     * and a provider availability update will be sent.
     * As soon as the provider is enabled again,
     * location updates will immediately resume and a provider availability
     * update sent. Providers can also send status updates, at any time,
     * with extra's specific to the provider. If a callback was supplied
     * then status and availability updates are via
     * {@link LocationListener#onProviderDisabled},
     * {@link LocationListener#onProviderEnabled} or
     * {@link LocationListener#onStatusChanged}. Alternately, if a
     * pending intent was supplied then status and availability updates
     * are broadcast intents with extra keys of
     * {@link #KEY_PROVIDER_ENABLED} or {@link #KEY_STATUS_CHANGED}.
     *
     * <p> If a {@link LocationListener} is used but with no Looper specified
     * then the calling thread must already
     * be a {@link android.os.Looper} thread such as the main thread of the
     * calling Activity. If a Looper is specified with a {@link LocationListener}
     * then callbacks are made on the supplied Looper thread.
     *
     * <p> When location callbacks are invoked, the system will hold a wakelock
     * on your application's behalf for some period of time, but not
     * indefinitely. If your application requires a long running wakelock
     * within the location callback, you should acquire it yourself.
     *
     * <p class=""note""> Prior to Jellybean, the minTime parameter was
     * only a hint, and some location provider implementations ignored it.
     * From Jellybean and onwards it is mandatory for Android compatible
     * devices to observe both the minTime and minDistance parameters.
     *
     * @param minTime minimum time interval between location updates, in milliseconds
     * @param minDistance minimum distance between location updates, in meters
     * @param criteria contains parameters for the location manager to choose the
     * appropriate provider and parameters to compute the location
     * @param intent a {@link PendingIntent} to be sent for each location update
     *
     * @throws IllegalArgumentException if criteria is null
     * @throws IllegalArgumentException if intent is null
","[1.0, 1.0]"
1002,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(724, 728, 5), (724, 728, 5)]","    public void requestLocationUpdates(long minTime, float minDistance, @NonNull Criteria criteria,
            @NonNull PendingIntent intent) {
        android.util.SeempLog.record(47);
        checkCriteria(criteria);
        checkPendingIntent(intent);
","    public void requestLocationUpdates(long minTime, float minDistance, @NonNull Criteria criteria,
            @NonNull PendingIntent intent) {
        android.util.SeempLog.record(47);
        checkCriteria(criteria);
        checkPendingIntent(intent);
","    public void requestLocationUpdates(long minTime, float minDistance, @NonNull Criteria criteria,
            @NonNull PendingIntent intent) {
        android.util.SeempLog.record(47);
        checkCriteria(criteria);
        checkPendingIntent(intent);
","[1.0, 1.0]"
1003,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(757, 759, 3), (757, 759, 3)]","        android.util.SeempLog.record(64);
        checkProvider(provider);
        checkListener(listener);
","        android.util.SeempLog.record(64);
        checkProvider(provider);
        checkListener(listener);
","        android.util.SeempLog.record(64);
        checkProvider(provider);
        checkListener(listener);
","[1.0, 1.0]"
1004,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(757, 759, 3), (791, 793, 3)]","        android.util.SeempLog.record(64);
        checkProvider(provider);
        checkListener(listener);
","        android.util.SeempLog.record(64);
        checkCriteria(criteria);
        checkListener(listener);
","        android.util.SeempLog.record(64);
        check","[0.509, 0.509]"
1005,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(791, 793, 3), (791, 793, 3)]","        android.util.SeempLog.record(64);
        checkCriteria(criteria);
        checkListener(listener);
","        android.util.SeempLog.record(64);
        checkCriteria(criteria);
        checkListener(listener);
","        android.util.SeempLog.record(64);
        checkCriteria(criteria);
        checkListener(listener);
","[1.0, 1.0]"
1006,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(814, 817, 4), (814, 817, 4)]","    public void requestSingleUpdate(@NonNull String provider, @NonNull PendingIntent intent) {
        android.util.SeempLog.record(64);
        checkProvider(provider);
        checkPendingIntent(intent);
","    public void requestSingleUpdate(@NonNull String provider, @NonNull PendingIntent intent) {
        android.util.SeempLog.record(64);
        checkProvider(provider);
        checkPendingIntent(intent);
","    public void requestSingleUpdate(@NonNull String provider, @NonNull PendingIntent intent) {
        android.util.SeempLog.record(64);
        checkProvider(provider);
        checkPendingIntent(intent);
","[1.0, 1.0]"
1007,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(839, 842, 4), (839, 842, 4)]","    public void requestSingleUpdate(@NonNull Criteria criteria, @NonNull PendingIntent intent) {
        android.util.SeempLog.record(64);
        checkCriteria(criteria);
        checkPendingIntent(intent);
","    public void requestSingleUpdate(@NonNull Criteria criteria, @NonNull PendingIntent intent) {
        android.util.SeempLog.record(64);
        checkCriteria(criteria);
        checkPendingIntent(intent);
","    public void requestSingleUpdate(@NonNull Criteria criteria, @NonNull PendingIntent intent) {
        android.util.SeempLog.record(64);
        checkCriteria(criteria);
        checkPendingIntent(intent);
","[1.0, 1.0]"
1008,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(910, 915, 6), (910, 915, 6)]","            @NonNull LocationRequest request,
            @NonNull LocationListener listener,
            @Nullable Looper looper) {
        android.util.SeempLog.record(47);
        checkListener(listener);
        requestLocationUpdates(request, listener, looper, null);
","            @NonNull LocationRequest request,
            @NonNull LocationListener listener,
            @Nullable Looper looper) {
        android.util.SeempLog.record(47);
        checkListener(listener);
        requestLocationUpdates(request, listener, looper, null);
","            @NonNull LocationRequest request,
            @NonNull LocationListener listener,
            @Nullable Looper looper) {
        android.util.SeempLog.record(47);
        checkListener(listener);
        requestLocationUpdates(request, listener, looper, null);
","[1.0, 1.0]"
1009,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(943, 946, 4), (943, 946, 4)]","            @NonNull LocationRequest request, @NonNull PendingIntent intent) {
        android.util.SeempLog.record(47);
        checkPendingIntent(intent);
        requestLocationUpdates(request, null, null, intent);
","            @NonNull LocationRequest request, @NonNull PendingIntent intent) {
        android.util.SeempLog.record(47);
        checkPendingIntent(intent);
        requestLocationUpdates(request, null, null, intent);
","            @NonNull LocationRequest request, @NonNull PendingIntent intent) {
        android.util.SeempLog.record(47);
        checkPendingIntent(intent);
        requestLocationUpdates(request, null, null, intent);
","[1.0, 1.0]"
1010,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(989, 997, 9), (989, 997, 9)]","    @UnsupportedAppUsage
    private void requestLocationUpdates(LocationRequest request, LocationListener listener,
            Looper looper, PendingIntent intent) {
        android.util.SeempLog.record(47);

        String packageName = mContext.getPackageName();

        // wrap the listener class
        ListenerTransport transport = wrapListener(listener, looper);
","    @UnsupportedAppUsage
    private void requestLocationUpdates(LocationRequest request, LocationListener listener,
            Looper looper, PendingIntent intent) {
        android.util.SeempLog.record(47);

        String packageName = mContext.getPackageName();

        // wrap the listener class
        ListenerTransport transport = wrapListener(listener, looper);
","    @UnsupportedAppUsage
    private void requestLocationUpdates(LocationRequest request, LocationListener listener,
            Looper looper, PendingIntent intent) {
        android.util.SeempLog.record(47);

        String packageName = mContext.getPackageName();

        // wrap the listener class
        ListenerTransport transport = wrapListener(listener, looper);
","[1.0, 1.0]"
1011,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1098, 1103, 6), (1098, 1103, 6)]","    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void addProximityAlert(double latitude, double longitude, float radius, long expiration,
            @NonNull PendingIntent intent) {
        android.util.SeempLog.record(45);
        checkPendingIntent(intent);
        if (expiration < 0) expiration = Long.MAX_VALUE;
","    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void addProximityAlert(double latitude, double longitude, float radius, long expiration,
            @NonNull PendingIntent intent) {
        android.util.SeempLog.record(45);
        checkPendingIntent(intent);
        if (expiration < 0) expiration = Long.MAX_VALUE;
","    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    public void addProximityAlert(double latitude, double longitude, float radius, long expiration,
            @NonNull PendingIntent intent) {
        android.util.SeempLog.record(45);
        checkPendingIntent(intent);
        if (expiration < 0) expiration = Long.MAX_VALUE;
","[1.0, 1.0]"
1012,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1346, 1426, 81), (1346, 1426, 81)]","     * @deprecated Do not manipulate providers individually, use
     * {@link #setLocationEnabledForUser(boolean, UserHandle)} instead.
     * @hide
     */
    @Deprecated
    @SystemApi
    @RequiresPermission(WRITE_SECURE_SETTINGS)
    public boolean setProviderEnabledForUser(
            @NonNull String provider, boolean enabled, @NonNull UserHandle userHandle) {
        checkProvider(provider);

        return Settings.Secure.putStringForUser(
                mContext.getContentResolver(),
                Settings.Secure.LOCATION_PROVIDERS_ALLOWED,
                (enabled ? ""+"" : ""-"") + provider,
                userHandle.getIdentifier());
    }

    /**
     * Get the last known location.
     *
     * <p>This location could be very old so use
     * {@link Location#getElapsedRealtimeNanos} to calculate its age. It can
     * also return null if no previous location is available.
     *
     * <p>Always returns immediately.
     *
     * @return The last known location, or null if not available
     * @throws SecurityException if no suitable permission is present
     *
     * @hide
     */
    @Nullable
    public Location getLastLocation() {
        String packageName = mContext.getPackageName();

        try {
            return mService.getLastLocation(null, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Returns a Location indicating the data from the last known
     * location fix obtained from the given provider.
     *
     * <p> This can be done
     * without starting the provider.  Note that this location could
     * be out-of-date, for example if the device was turned off and
     * moved to another location.
     *
     * <p> If the provider is currently disabled, null is returned.
     *
     * @param provider the name of the provider
     * @return the last known location for the provider, or null
     *
     * @throws SecurityException if no suitable permission is present
     * @throws IllegalArgumentException if provider is null or doesn't exist
     */
    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    @Nullable
    public Location getLastKnownLocation(@NonNull String provider) {
        android.util.SeempLog.record(46);
        checkProvider(provider);
        String packageName = mContext.getPackageName();
        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, 0, 0, true);

        try {
            return mService.getLastLocation(request, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Creates a mock location provider and adds it to the set of active providers.
     *
     * @param name the provider name
     *
","     * @deprecated Do not manipulate providers individually, use
     * {@link #setLocationEnabledForUser(boolean, UserHandle)} instead.
     * @hide
     */
    @Deprecated
    @SystemApi
    @RequiresPermission(WRITE_SECURE_SETTINGS)
    public boolean setProviderEnabledForUser(
            @NonNull String provider, boolean enabled, @NonNull UserHandle userHandle) {
        checkProvider(provider);

        return Settings.Secure.putStringForUser(
                mContext.getContentResolver(),
                Settings.Secure.LOCATION_PROVIDERS_ALLOWED,
                (enabled ? ""+"" : ""-"") + provider,
                userHandle.getIdentifier());
    }

    /**
     * Get the last known location.
     *
     * <p>This location could be very old so use
     * {@link Location#getElapsedRealtimeNanos} to calculate its age. It can
     * also return null if no previous location is available.
     *
     * <p>Always returns immediately.
     *
     * @return The last known location, or null if not available
     * @throws SecurityException if no suitable permission is present
     *
     * @hide
     */
    @Nullable
    public Location getLastLocation() {
        String packageName = mContext.getPackageName();

        try {
            return mService.getLastLocation(null, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Returns a Location indicating the data from the last known
     * location fix obtained from the given provider.
     *
     * <p> This can be done
     * without starting the provider.  Note that this location could
     * be out-of-date, for example if the device was turned off and
     * moved to another location.
     *
     * <p> If the provider is currently disabled, null is returned.
     *
     * @param provider the name of the provider
     * @return the last known location for the provider, or null
     *
     * @throws SecurityException if no suitable permission is present
     * @throws IllegalArgumentException if provider is null or doesn't exist
     */
    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    @Nullable
    public Location getLastKnownLocation(@NonNull String provider) {
        android.util.SeempLog.record(46);
        checkProvider(provider);
        String packageName = mContext.getPackageName();
        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, 0, 0, true);

        try {
            return mService.getLastLocation(request, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Creates a mock location provider and adds it to the set of active providers.
     *
     * @param name the provider name
     *
","     * @deprecated Do not manipulate providers individually, use
     * {@link #setLocationEnabledForUser(boolean, UserHandle)} instead.
     * @hide
     */
    @Deprecated
    @SystemApi
    @RequiresPermission(WRITE_SECURE_SETTINGS)
    public boolean setProviderEnabledForUser(
            @NonNull String provider, boolean enabled, @NonNull UserHandle userHandle) {
        checkProvider(provider);

        return Settings.Secure.putStringForUser(
                mContext.getContentResolver(),
                Settings.Secure.LOCATION_PROVIDERS_ALLOWED,
                (enabled ? ""+"" : ""-"") + provider,
                userHandle.getIdentifier());
    }

    /**
     * Get the last known location.
     *
     * <p>This location could be very old so use
     * {@link Location#getElapsedRealtimeNanos} to calculate its age. It can
     * also return null if no previous location is available.
     *
     * <p>Always returns immediately.
     *
     * @return The last known location, or null if not available
     * @throws SecurityException if no suitable permission is present
     *
     * @hide
     */
    @Nullable
    public Location getLastLocation() {
        String packageName = mContext.getPackageName();

        try {
            return mService.getLastLocation(null, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Returns a Location indicating the data from the last known
     * location fix obtained from the given provider.
     *
     * <p> This can be done
     * without starting the provider.  Note that this location could
     * be out-of-date, for example if the device was turned off and
     * moved to another location.
     *
     * <p> If the provider is currently disabled, null is returned.
     *
     * @param provider the name of the provider
     * @return the last known location for the provider, or null
     *
     * @throws SecurityException if no suitable permission is present
     * @throws IllegalArgumentException if provider is null or doesn't exist
     */
    @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
    @Nullable
    public Location getLastKnownLocation(@NonNull String provider) {
        android.util.SeempLog.record(46);
        checkProvider(provider);
        String packageName = mContext.getPackageName();
        LocationRequest request = LocationRequest.createFromDeprecatedProvider(
                provider, 0, 0, true);

        try {
            return mService.getLastLocation(request, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
     * Creates a mock location provider and adds it to the set of active providers.
     *
     * @param name the provider name
     *
","[1.0, 1.0]"
1013,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1750, 1754, 5), (1750, 1754, 5)]","    @Deprecated
    @RequiresPermission(ACCESS_FINE_LOCATION)
    public boolean addGpsStatusListener(GpsStatus.Listener listener) {
        android.util.SeempLog.record(43);
        boolean result;
","    @Deprecated
    @RequiresPermission(ACCESS_FINE_LOCATION)
    public boolean addGpsStatusListener(GpsStatus.Listener listener) {
        android.util.SeempLog.record(43);
        boolean result;
","    @Deprecated
    @RequiresPermission(ACCESS_FINE_LOCATION)
    public boolean addGpsStatusListener(GpsStatus.Listener listener) {
        android.util.SeempLog.record(43);
        boolean result;
","[1.0, 1.0]"
1014,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1868, 1870, 3), (1868, 1870, 3)]","    public boolean addNmeaListener(GpsStatus.NmeaListener listener) {
        android.util.SeempLog.record(44);
        return false;
","    public boolean addNmeaListener(GpsStatus.NmeaListener listener) {
        android.util.SeempLog.record(44);
        return false;
","    public boolean addNmeaListener(GpsStatus.NmeaListener listener) {
        android.util.SeempLog.record(44);
        return false;
","[1.0, 1.0]"
1015,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(2261, 2282, 22), (2261, 2282, 22)]","     * Sends additional commands to a location provider. Can be used to support provider specific
     * extensions to the Location Manager API.
     *
     * @param provider name of the location provider.
     * @param command  name of the command to send to the provider.
     * @param extras   optional arguments for the command (or null).
     * @return true always
     */
    public boolean sendExtraCommand(
            @NonNull String provider, @NonNull String command, @Nullable Bundle extras) {
        android.util.SeempLog.record(48);
        Preconditions.checkArgument(provider != null, ""invalid null provider"");
        Preconditions.checkArgument(command != null, ""invalid null command"");

        try {
            return mService.sendExtraCommand(provider, command, extras);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
","     * Sends additional commands to a location provider. Can be used to support provider specific
     * extensions to the Location Manager API.
     *
     * @param provider name of the location provider.
     * @param command  name of the command to send to the provider.
     * @param extras   optional arguments for the command (or null).
     * @return true always
     */
    public boolean sendExtraCommand(
            @NonNull String provider, @NonNull String command, @Nullable Bundle extras) {
        android.util.SeempLog.record(48);
        Preconditions.checkArgument(provider != null, ""invalid null provider"");
        Preconditions.checkArgument(command != null, ""invalid null command"");

        try {
            return mService.sendExtraCommand(provider, command, extras);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
","     * Sends additional commands to a location provider. Can be used to support provider specific
     * extensions to the Location Manager API.
     *
     * @param provider name of the location provider.
     * @param command  name of the command to send to the provider.
     * @param extras   optional arguments for the command (or null).
     * @return true always
     */
    public boolean sendExtraCommand(
            @NonNull String provider, @NonNull String command, @Nullable Bundle extras) {
        android.util.SeempLog.record(48);
        Preconditions.checkArgument(provider != null, ""invalid null provider"");
        Preconditions.checkArgument(command != null, ""invalid null command"");

        try {
            return mService.sendExtraCommand(provider, command, extras);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

    /**
","[1.0, 1.0]"
1016,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(221, 223, 3), (221, 223, 3)]","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
","[1.0, 1.0]"
1017,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(289, 297, 9), (289, 297, 9)]","    }

    /*package*/ void postBluetoothA2dpDeviceConfigChangeExt(
            @NonNull BluetoothDevice device,
            @AudioService.BtProfileConnectionState int state, int profile,
            boolean suppressNoisyIntent, int a2dpVolume) {
         final BtDeviceConnectionInfo info = new BtDeviceConnectionInfo(device, state, profile,
                 suppressNoisyIntent, a2dpVolume);
         sendLMsgNoDelay(MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT, SENDMSG_QUEUE, info);
","    }

    /*package*/ void postBluetoothA2dpDeviceConfigChangeExt(
            @NonNull BluetoothDevice device,
            @AudioService.BtProfileConnectionState int state, int profile,
            boolean suppressNoisyIntent, int a2dpVolume) {
         final BtDeviceConnectionInfo info = new BtDeviceConnectionInfo(device, state, profile,
                 suppressNoisyIntent, a2dpVolume);
         sendLMsgNoDelay(MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT, SENDMSG_QUEUE, info);
","    }

    /*package*/ void postBluetoothA2dpDeviceConfigChangeExt(
            @NonNull BluetoothDevice device,
            @AudioService.BtProfileConnectionState int state, int profile,
            boolean suppressNoisyIntent, int a2dpVolume) {
         final BtDeviceConnectionInfo info = new BtDeviceConnectionInfo(device, state, profile,
                 suppressNoisyIntent, a2dpVolume);
         sendLMsgNoDelay(MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT, SENDMSG_QUEUE, info);
","[1.0, 1.0]"
1018,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(329, 332, 4), (329, 332, 4)]","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In setBluetoothScoOnByApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In setBluetoothScoOnByApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In setBluetoothScoOnByApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","[1.0, 1.0]"
1019,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(329, 332, 4), (339, 342, 4)]","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In setBluetoothScoOnByApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isBluetoothScoOnForApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","App(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","[0.5, 0.5]"
1020,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(339, 342, 4), (339, 342, 4)]","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isBluetoothScoOnForApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isBluetoothScoOnForApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isBluetoothScoOnForApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","[1.0, 1.0]"
1021,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(348, 350, 3), (348, 350, 3)]","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
","[1.0, 1.0]"
1022,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(929, 944, 16), (929, 944, 16)]","                } break;
                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
","                } break;
                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
","                } break;
                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
","[1.0, 1.0]"
1023,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/OomAdjuster.java,"[(167, 174, 8), (167, 174, 8)]","    // Min aging threshold in milliseconds to consider a B-service
    int mMinBServiceAgingTime = 5000;
    // Threshold for B-services when in memory pressure
    int mBServiceAppThreshold = 5;
    // Enable B-service aging propagation on memory pressure.
    boolean mEnableBServicePropagation = false;

    public static BoostFramework mPerf = new BoostFramework();
","    // Min aging threshold in milliseconds to consider a B-service
    int mMinBServiceAgingTime = 5000;
    // Threshold for B-services when in memory pressure
    int mBServiceAppThreshold = 5;
    // Enable B-service aging propagation on memory pressure.
    boolean mEnableBServicePropagation = false;

    public static BoostFramework mPerf = new BoostFramework();
","    // Min aging threshold in milliseconds to consider a B-service
    int mMinBServiceAgingTime = 5000;
    // Threshold for B-services when in memory pressure
    int mBServiceAppThreshold = 5;
    // Enable B-service aging propagation on memory pressure.
    boolean mEnableBServicePropagation = false;

    public static BoostFramework mPerf = new BoostFramework();
","[1.0, 1.0]"
1024,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/OomAdjuster.java,"[(337, 422, 86), (337, 422, 86)]","        mNumNonCachedProcs = 0;
        mNumCachedHiddenProcs = 0;

        // First update the OOM adjustment for each of the
        // application processes based on their current state.
        int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;
        int nextCachedAdj = curCachedAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        int curCachedImpAdj = 0;
        int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ + ProcessList.CACHED_APP_IMPORTANCE_LEVELS;
        int nextEmptyAdj = curEmptyAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        ProcessRecord selectedAppRecord = null;
        long serviceLastActivity = 0;
        int numBServices = 0;

        boolean retryCycles = false;

        // need to reset cycle state before calling computeOomAdjLocked because of service conns
        for (int i = N - 1; i >= 0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            app.containsCycle = false;
            app.setCurRawProcState(PROCESS_STATE_CACHED_EMPTY);
            app.setCurRawAdj(ProcessList.UNKNOWN_ADJ);
        }
        for (int i = N - 1; i >= 0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            if (mEnableBServicePropagation && app.serviceb
                    && (app.curAdj == ProcessList.SERVICE_B_ADJ)) {
                numBServices++;
                for (int s = app.services.size() - 1; s >= 0; s--) {
                    ServiceRecord sr = app.services.valueAt(s);
                    if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + app.processName
                            + "" serviceb = "" + app.serviceb + "" s = "" + s + "" sr.lastActivity = ""
                            + sr.lastActivity + "" packageName = "" + sr.packageName
                            + "" processName = "" + sr.processName);
                    if (SystemClock.uptimeMillis() - sr.lastActivity
                            < mMinBServiceAgingTime) {
                        if (DEBUG_OOM_ADJ) {
                            Slog.d(TAG,""Not aged enough!!!"");
                        }
                        continue;
                    }
                    if (serviceLastActivity == 0) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    } else if (sr.lastActivity < serviceLastActivity) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    }
                }
            }
            if (DEBUG_OOM_ADJ && selectedAppRecord != null) Slog.d(TAG,
                    ""Identified app.processName = "" + selectedAppRecord.processName
                    + "" app.pid = "" + selectedAppRecord.pid);

            if (!app.killedByAm && app.thread != null) {
                app.procStateChanged = false;
                computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now, false);

                // if any app encountered a cycle, we need to perform an additional loop later
                retryCycles |= app.containsCycle;

                // If we haven't yet assigned the final cached adj
                // to the process, do that now.
                if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
                    switch (app.getCurProcState()) {
                        case PROCESS_STATE_CACHED_ACTIVITY:
                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                        case ActivityManager.PROCESS_STATE_CACHED_RECENT:
                            // Figure out the next cached level, taking into account groups.
                            boolean inGroup = false;
                            if (app.connectionGroup != 0) {
                                if (lastCachedGroupUid == app.uid
                                        && lastCachedGroup == app.connectionGroup) {
                                    // This is in the same group as the last process, just tweak
                                    // adjustment by importance.
                                    if (app.connectionImportance > lastCachedGroupImportance) {
                                        lastCachedGroupImportance = app.connectionImportance;
                                        if (curCachedAdj < nextCachedAdj
                                                && curCachedAdj < ProcessList.CACHED_APP_MAX_ADJ) {
                                            curCachedImpAdj++;
                                        }
                                    }
                                    inGroup = true;
                                } else {
                                    lastCachedGroupUid = app.uid;
                                    lastCachedGroup = app.connectionGroup;
","        mNumNonCachedProcs = 0;
        mNumCachedHiddenProcs = 0;

        // First update the OOM adjustment for each of the
        // application processes based on their current state.
        int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;
        int nextCachedAdj = curCachedAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        int curCachedImpAdj = 0;
        int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ + ProcessList.CACHED_APP_IMPORTANCE_LEVELS;
        int nextEmptyAdj = curEmptyAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        ProcessRecord selectedAppRecord = null;
        long serviceLastActivity = 0;
        int numBServices = 0;

        boolean retryCycles = false;

        // need to reset cycle state before calling computeOomAdjLocked because of service conns
        for (int i = N - 1; i >= 0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            app.containsCycle = false;
            app.setCurRawProcState(PROCESS_STATE_CACHED_EMPTY);
            app.setCurRawAdj(ProcessList.UNKNOWN_ADJ);
        }
        for (int i = N - 1; i >= 0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            if (mEnableBServicePropagation && app.serviceb
                    && (app.curAdj == ProcessList.SERVICE_B_ADJ)) {
                numBServices++;
                for (int s = app.services.size() - 1; s >= 0; s--) {
                    ServiceRecord sr = app.services.valueAt(s);
                    if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + app.processName
                            + "" serviceb = "" + app.serviceb + "" s = "" + s + "" sr.lastActivity = ""
                            + sr.lastActivity + "" packageName = "" + sr.packageName
                            + "" processName = "" + sr.processName);
                    if (SystemClock.uptimeMillis() - sr.lastActivity
                            < mMinBServiceAgingTime) {
                        if (DEBUG_OOM_ADJ) {
                            Slog.d(TAG,""Not aged enough!!!"");
                        }
                        continue;
                    }
                    if (serviceLastActivity == 0) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    } else if (sr.lastActivity < serviceLastActivity) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    }
                }
            }
            if (DEBUG_OOM_ADJ && selectedAppRecord != null) Slog.d(TAG,
                    ""Identified app.processName = "" + selectedAppRecord.processName
                    + "" app.pid = "" + selectedAppRecord.pid);

            if (!app.killedByAm && app.thread != null) {
                app.procStateChanged = false;
                computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now, false);

                // if any app encountered a cycle, we need to perform an additional loop later
                retryCycles |= app.containsCycle;

                // If we haven't yet assigned the final cached adj
                // to the process, do that now.
                if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
                    switch (app.getCurProcState()) {
                        case PROCESS_STATE_CACHED_ACTIVITY:
                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                        case ActivityManager.PROCESS_STATE_CACHED_RECENT:
                            // Figure out the next cached level, taking into account groups.
                            boolean inGroup = false;
                            if (app.connectionGroup != 0) {
                                if (lastCachedGroupUid == app.uid
                                        && lastCachedGroup == app.connectionGroup) {
                                    // This is in the same group as the last process, just tweak
                                    // adjustment by importance.
                                    if (app.connectionImportance > lastCachedGroupImportance) {
                                        lastCachedGroupImportance = app.connectionImportance;
                                        if (curCachedAdj < nextCachedAdj
                                                && curCachedAdj < ProcessList.CACHED_APP_MAX_ADJ) {
                                            curCachedImpAdj++;
                                        }
                                    }
                                    inGroup = true;
                                } else {
                                    lastCachedGroupUid = app.uid;
                                    lastCachedGroup = app.connectionGroup;
","        mNumNonCachedProcs = 0;
        mNumCachedHiddenProcs = 0;

        // First update the OOM adjustment for each of the
        // application processes based on their current state.
        int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;
        int nextCachedAdj = curCachedAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        int curCachedImpAdj = 0;
        int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ + ProcessList.CACHED_APP_IMPORTANCE_LEVELS;
        int nextEmptyAdj = curEmptyAdj + (ProcessList.CACHED_APP_IMPORTANCE_LEVELS * 2);
        ProcessRecord selectedAppRecord = null;
        long serviceLastActivity = 0;
        int numBServices = 0;

        boolean retryCycles = false;

        // need to reset cycle state before calling computeOomAdjLocked because of service conns
        for (int i = N - 1; i >= 0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            app.containsCycle = false;
            app.setCurRawProcState(PROCESS_STATE_CACHED_EMPTY);
            app.setCurRawAdj(ProcessList.UNKNOWN_ADJ);
        }
        for (int i = N - 1; i >= 0; i--) {
            ProcessRecord app = mProcessList.mLruProcesses.get(i);
            if (mEnableBServicePropagation && app.serviceb
                    && (app.curAdj == ProcessList.SERVICE_B_ADJ)) {
                numBServices++;
                for (int s = app.services.size() - 1; s >= 0; s--) {
                    ServiceRecord sr = app.services.valueAt(s);
                    if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + app.processName
                            + "" serviceb = "" + app.serviceb + "" s = "" + s + "" sr.lastActivity = ""
                            + sr.lastActivity + "" packageName = "" + sr.packageName
                            + "" processName = "" + sr.processName);
                    if (SystemClock.uptimeMillis() - sr.lastActivity
                            < mMinBServiceAgingTime) {
                        if (DEBUG_OOM_ADJ) {
                            Slog.d(TAG,""Not aged enough!!!"");
                        }
                        continue;
                    }
                    if (serviceLastActivity == 0) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    } else if (sr.lastActivity < serviceLastActivity) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    }
                }
            }
            if (DEBUG_OOM_ADJ && selectedAppRecord != null) Slog.d(TAG,
                    ""Identified app.processName = "" + selectedAppRecord.processName
                    + "" app.pid = "" + selectedAppRecord.pid);

            if (!app.killedByAm && app.thread != null) {
                app.procStateChanged = false;
                computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now, false);

                // if any app encountered a cycle, we need to perform an additional loop later
                retryCycles |= app.containsCycle;

                // If we haven't yet assigned the final cached adj
                // to the process, do that now.
                if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
                    switch (app.getCurProcState()) {
                        case PROCESS_STATE_CACHED_ACTIVITY:
                        case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                        case ActivityManager.PROCESS_STATE_CACHED_RECENT:
                            // Figure out the next cached level, taking into account groups.
                            boolean inGroup = false;
                            if (app.connectionGroup != 0) {
                                if (lastCachedGroupUid == app.uid
                                        && lastCachedGroup == app.connectionGroup) {
                                    // This is in the same group as the last process, just tweak
                                    // adjustment by importance.
                                    if (app.connectionImportance > lastCachedGroupImportance) {
                                        lastCachedGroupImportance = app.connectionImportance;
                                        if (curCachedAdj < nextCachedAdj
                                                && curCachedAdj < ProcessList.CACHED_APP_MAX_ADJ) {
                                            curCachedImpAdj++;
                                        }
                                    }
                                    inGroup = true;
                                } else {
                                    lastCachedGroupUid = app.uid;
                                    lastCachedGroup = app.connectionGroup;
","[1.0, 1.0]"
1025,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/OomAdjuster.java,"[(583, 596, 14), (583, 596, 14)]","        if ((numBServices > mBServiceAppThreshold) && (true == mService.mAllowLowerMemLevel)
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }

        mService.incrementProcStateSeqAndNotifyAppsLocked();

        mNumServiceProcs = mNewNumServiceProcs;

        boolean allChanged = mService.updateLowMemStateLocked(numCached, numEmpty, numTrimming);
","        if ((numBServices > mBServiceAppThreshold) && (true == mService.mAllowLowerMemLevel)
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }

        mService.incrementProcStateSeqAndNotifyAppsLocked();

        mNumServiceProcs = mNewNumServiceProcs;

        boolean allChanged = mService.updateLowMemStateLocked(numCached, numEmpty, numTrimming);
","        if ((numBServices > mBServiceAppThreshold) && (true == mService.mAllowLowerMemLevel)
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }

        mService.incrementProcStateSeqAndNotifyAppsLocked();

        mNumServiceProcs = mNewNumServiceProcs;

        boolean allChanged = mService.updateLowMemStateLocked(numCached, numEmpty, numTrimming);
","[1.0, 1.0]"
1026,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/util/sensors/AsyncSensorManager.java,"[(100, 102, 3), (100, 102, 3)]","        if ( sensor == null ) {
            Log.e(TAG, ""sensor cannot be null \n"" + Log.getStackTraceString(new Throwable()));
            return false;
","        if ( sensor == null ) {
            Log.e(TAG, ""sensor cannot be null \n"" + Log.getStackTraceString(new Throwable()));
            return false;
","        if ( sensor == null ) {
            Log.e(TAG, ""sensor cannot be null \n"" + Log.getStackTraceString(new Throwable()));
            return false;
","[1.0, 1.0]"
1027,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1749, 1763, 15), (1749, 1763, 15)]","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } catch (RemoteException e) {
            throw new IllegalStateException(""clearUserKeyAuth failed user="" + userId);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(byte[] credential) {
","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } catch (RemoteException e) {
            throw new IllegalStateException(""clearUserKeyAuth failed user="" + userId);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(byte[] credential) {
","    private void clearUserKeyAuth(int userId, byte[] token, byte[] secret) {
        if (DEBUG) Slog.d(TAG, ""clearUserKeyProtection user="" + userId);
        final UserInfo userInfo = mUserManager.getUserInfo(userId);
        final IStorageManager storageManager = mInjector.getStorageManager();
        final long callingId = Binder.clearCallingIdentity();
        try {
            storageManager.clearUserKeyAuth(userId, userInfo.serialNumber, token, secret);
        } catch (RemoteException e) {
            throw new IllegalStateException(""clearUserKeyAuth failed user="" + userId);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private static byte[] secretFromCredential(byte[] credential) {
","[1.0, 1.0]"
1028,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1875, 1883, 9), (1875, 1883, 9)]","        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        CHALLENGE_NONE, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        CHALLENGE_NONE, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        CHALLENGE_NONE, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","[1.0, 1.0]"
1029,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/DisplayPolicy.java,"[(21, 21, 1), (21, 21, 1)]","import static android.app.WindowConfiguration.ACTIVITY_TYPE_RECENTS;
","import static android.app.WindowConfiguration.ACTIVITY_TYPE_RECENTS;
","import static android.app.WindowConfiguration.ACTIVITY_TYPE_RECENTS;
","[1.0, 1.0]"
1030,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/com/android/internal/os/ZygoteInit.java,"[(187, 190, 4), (187, 190, 4)]","        try {
            System.loadLibrary(""qti_performance"");
        } catch (UnsatisfiedLinkError e) {
            Log.e(TAG, ""Couldn't load qti_performance"");
","        try {
            System.loadLibrary(""qti_performance"");
        } catch (UnsatisfiedLinkError e) {
            Log.e(TAG, ""Couldn't load qti_performance"");
","        try {
            System.loadLibrary(""qti_performance"");
        } catch (UnsatisfiedLinkError e) {
            Log.e(TAG, ""Couldn't load qti_performance"");
","[1.0, 1.0]"
1031,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(266, 266, 1), (266, 266, 1)]","public final class ActivityRecord extends ConfigurationContainer {
","public final class ActivityRecord extends ConfigurationContainer {
","public final class ActivityRecord extends ConfigurationContainer {
","[1.0, 1.0]"
1032,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(309, 309, 1), (309, 309, 1)]","    public final String packageName; // the package implementing intent's component
","    public final String packageName; // the package implementing intent's component
","    public final String packageName; // the package implementing intent's component
","[1.0, 1.0]"
1033,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(436, 444, 9), (436, 444, 9)]","    public BoostFramework mPerf = null;
    public BoostFramework mPerf_iop = null;

    // A hint to override the window specified rotation animation, or -1
    // to use the window specified value. We use this so that
    // we can select the right animation in the cases of starting
    // windows, where the app hasn't had time to set a value
    // on the window.
    int mRotationAnimationHint = -1;
","    public BoostFramework mPerf = null;
    public BoostFramework mPerf_iop = null;

    // A hint to override the window specified rotation animation, or -1
    // to use the window specified value. We use this so that
    // we can select the right animation in the cases of starting
    // windows, where the app hasn't had time to set a value
    // on the window.
    int mRotationAnimationHint = -1;
","    public BoostFramework mPerf = null;
    public BoostFramework mPerf_iop = null;

    // A hint to override the window specified rotation animation, or -1
    // to use the window specified value. We use this so that
    // we can select the right animation in the cases of starting
    // windows, where the app hasn't had time to set a value
    // on the window.
    int mRotationAnimationHint = -1;
","[1.0, 1.0]"
1034,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(2987, 3008, 22), (2987, 3008, 22)]","    void completeResumeLocked() {
        final boolean wasVisible = visible;
        setVisible(true);
        if (!wasVisible) {
            // Visibility has changed, so take a note of it so we call the TaskStackChangedListener
            mStackSupervisor.mAppVisibilitiesChangedSinceLastPause = true;
        }
        idle = false;
        results = null;
        newIntents = null;
        stopped = false;

        if (isActivityTypeHome()) {
            mStackSupervisor.updateHomeProcess(task.mActivities.get(0).app);
            try {
                mStackSupervisor.new PreferredAppsTask().execute();
            } catch (Exception e) {
                Slog.v (TAG, ""Exception: "" + e);
            }
        }
        if (nowVisible) {
            mStackSupervisor.stopWaitingForActivityVisible(this);
","    void completeResumeLocked() {
        final boolean wasVisible = visible;
        setVisible(true);
        if (!wasVisible) {
            // Visibility has changed, so take a note of it so we call the TaskStackChangedListener
            mStackSupervisor.mAppVisibilitiesChangedSinceLastPause = true;
        }
        idle = false;
        results = null;
        newIntents = null;
        stopped = false;

        if (isActivityTypeHome()) {
            mStackSupervisor.updateHomeProcess(task.mActivities.get(0).app);
            try {
                mStackSupervisor.new PreferredAppsTask().execute();
            } catch (Exception e) {
                Slog.v (TAG, ""Exception: "" + e);
            }
        }
        if (nowVisible) {
            mStackSupervisor.stopWaitingForActivityVisible(this);
","    void completeResumeLocked() {
        final boolean wasVisible = visible;
        setVisible(true);
        if (!wasVisible) {
            // Visibility has changed, so take a note of it so we call the TaskStackChangedListener
            mStackSupervisor.mAppVisibilitiesChangedSinceLastPause = true;
        }
        idle = false;
        results = null;
        newIntents = null;
        stopped = false;

        if (isActivityTypeHome()) {
            mStackSupervisor.updateHomeProcess(task.mActivities.get(0).app);
            try {
                mStackSupervisor.new PreferredAppsTask().execute();
            } catch (Exception e) {
                Slog.v (TAG, ""Exception: "" + e);
            }
        }
        if (nowVisible) {
            mStackSupervisor.stopWaitingForActivityVisible(this);
","[1.0, 1.0]"
1035,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(3041, 3062, 22), (3041, 3062, 22)]","    void stopIfPossible() {
        if (DEBUG_SWITCH) Slog.d(TAG_SWITCH, ""Stopping: "" + this);
        launching = false;
        final ActivityStack stack = getActivityStack();
        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0
                || (info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0) {
            if (!finishing) {
                if (!stack.shouldSleepActivities()) {
                    if (DEBUG_STATES) Slog.d(TAG_STATES, ""no-history finish of "" + this);
                    if (finishIfPossible(""stop-no-history"", false /* oomAdj */)
                            != FINISH_RESULT_CANCELLED) {
                        resumeKeyDispatchingLocked();
                        return;
                    }
                } else {
                    if (DEBUG_STATES) {
                        Slog.d(TAG_STATES, ""Not finishing noHistory "" + this
                                + "" on stop because we're just sleeping"");
                    }
                }
            }
        }
","    void stopIfPossible() {
        if (DEBUG_SWITCH) Slog.d(TAG_SWITCH, ""Stopping: "" + this);
        launching = false;
        final ActivityStack stack = getActivityStack();
        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0
                || (info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0) {
            if (!finishing) {
                if (!stack.shouldSleepActivities()) {
                    if (DEBUG_STATES) Slog.d(TAG_STATES, ""no-history finish of "" + this);
                    if (finishIfPossible(""stop-no-history"", false /* oomAdj */)
                            != FINISH_RESULT_CANCELLED) {
                        resumeKeyDispatchingLocked();
                        return;
                    }
                } else {
                    if (DEBUG_STATES) {
                        Slog.d(TAG_STATES, ""Not finishing noHistory "" + this
                                + "" on stop because we're just sleeping"");
                    }
                }
            }
        }
","    void stopIfPossible() {
        if (DEBUG_SWITCH) Slog.d(TAG_SWITCH, ""Stopping: "" + this);
        launching = false;
        final ActivityStack stack = getActivityStack();
        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0
                || (info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0) {
            if (!finishing) {
                if (!stack.shouldSleepActivities()) {
                    if (DEBUG_STATES) Slog.d(TAG_STATES, ""no-history finish of "" + this);
                    if (finishIfPossible(""stop-no-history"", false /* oomAdj */)
                            != FINISH_RESULT_CANCELLED) {
                        resumeKeyDispatchingLocked();
                        return;
                    }
                } else {
                    if (DEBUG_STATES) {
                        Slog.d(TAG_STATES, ""Not finishing noHistory "" + this
                                + "" on stop because we're just sleeping"");
                    }
                }
            }
        }
","[1.0, 1.0]"
1036,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(3304, 3323, 20), (3304, 3323, 20)]","    /** Called when the windows associated app window container are visible. */
    public void onWindowsVisible() {
        synchronized (mAtmService.mGlobalLock) {
            mStackSupervisor.stopWaitingForActivityVisible(this);
            if (DEBUG_SWITCH) Log.v(TAG_SWITCH, ""windowsVisibleLocked(): "" + this);
            if (!nowVisible) {
                nowVisible = true;
                launching = false;
                lastVisibleTime = SystemClock.uptimeMillis();
                mAtmService.scheduleAppGcsLocked();
            }
        }
    }

    /** Called when the windows associated app window container are no longer visible. */
    public void onWindowsGone() {
        synchronized (mAtmService.mGlobalLock) {
            if (DEBUG_SWITCH) Log.v(TAG_SWITCH, ""windowsGone(): "" + this);
            nowVisible = false;
            launching = false;
","    /** Called when the windows associated app window container are visible. */
    public void onWindowsVisible() {
        synchronized (mAtmService.mGlobalLock) {
            mStackSupervisor.stopWaitingForActivityVisible(this);
            if (DEBUG_SWITCH) Log.v(TAG_SWITCH, ""windowsVisibleLocked(): "" + this);
            if (!nowVisible) {
                nowVisible = true;
                launching = false;
                lastVisibleTime = SystemClock.uptimeMillis();
                mAtmService.scheduleAppGcsLocked();
            }
        }
    }

    /** Called when the windows associated app window container are no longer visible. */
    public void onWindowsGone() {
        synchronized (mAtmService.mGlobalLock) {
            if (DEBUG_SWITCH) Log.v(TAG_SWITCH, ""windowsGone(): "" + this);
            nowVisible = false;
            launching = false;
","    /** Called when the windows associated app window container are visible. */
    public void onWindowsVisible() {
        synchronized (mAtmService.mGlobalLock) {
            mStackSupervisor.stopWaitingForActivityVisible(this);
            if (DEBUG_SWITCH) Log.v(TAG_SWITCH, ""windowsVisibleLocked(): "" + this);
            if (!nowVisible) {
                nowVisible = true;
                launching = false;
                lastVisibleTime = SystemClock.uptimeMillis();
                mAtmService.scheduleAppGcsLocked();
            }
        }
    }

    /** Called when the windows associated app window container are no longer visible. */
    public void onWindowsGone() {
        synchronized (mAtmService.mGlobalLock) {
            if (DEBUG_SWITCH) Log.v(TAG_SWITCH, ""windowsGone(): "" + this);
            nowVisible = false;
            launching = false;
","[1.0, 1.0]"
1037,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/hardware/camera2/CameraManager.java,"[(24, 24, 1), (24, 24, 1)]","import android.app.ActivityThread;
","import android.app.ActivityThread;
","import android.app.ActivityThread;
","[1.0, 1.0]"
1038,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/hardware/camera2/CameraManager.java,"[(1008, 1042, 35), (1008, 1042, 35)]","            synchronized(mLock) {
                // Try to make sure we have an up-to-date list of camera devices.
                connectCameraServiceLocked();

                boolean exposeAuxCamera = false;
                String packageName = ActivityThread.currentOpPackageName();
                String packageList = SystemProperties.get(""vendor.camera.aux.packagelist"");
                if (packageList.length() > 0) {
                    TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(',');
                    splitter.setString(packageList);
                    for (String str : splitter) {
                        if (packageName.equals(str)) {
                            exposeAuxCamera = true;
                            break;
                        }
                    }
                }
                int idCount = 0;
                for (int i = 0; i < mDeviceStatus.size(); i++) {
                    if(!exposeAuxCamera && (i == 2)) break;
                    int status = mDeviceStatus.valueAt(i);
                    if (status == ICameraServiceListener.STATUS_NOT_PRESENT ||
                            status == ICameraServiceListener.STATUS_ENUMERATING) continue;
                    idCount++;
                }
                cameraIds = new String[idCount];
                idCount = 0;
                for (int i = 0; i < mDeviceStatus.size(); i++) {
                    if(!exposeAuxCamera && (i == 2)) break;
                    int status = mDeviceStatus.valueAt(i);
                    if (status == ICameraServiceListener.STATUS_NOT_PRESENT ||
                            status == ICameraServiceListener.STATUS_ENUMERATING) continue;
                    cameraIds[idCount] = mDeviceStatus.keyAt(i);
                    idCount++;
                }
","            synchronized(mLock) {
                // Try to make sure we have an up-to-date list of camera devices.
                connectCameraServiceLocked();

                boolean exposeAuxCamera = false;
                String packageName = ActivityThread.currentOpPackageName();
                String packageList = SystemProperties.get(""vendor.camera.aux.packagelist"");
                if (packageList.length() > 0) {
                    TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(',');
                    splitter.setString(packageList);
                    for (String str : splitter) {
                        if (packageName.equals(str)) {
                            exposeAuxCamera = true;
                            break;
                        }
                    }
                }
                int idCount = 0;
                for (int i = 0; i < mDeviceStatus.size(); i++) {
                    if(!exposeAuxCamera && (i == 2)) break;
                    int status = mDeviceStatus.valueAt(i);
                    if (status == ICameraServiceListener.STATUS_NOT_PRESENT ||
                            status == ICameraServiceListener.STATUS_ENUMERATING) continue;
                    idCount++;
                }
                cameraIds = new String[idCount];
                idCount = 0;
                for (int i = 0; i < mDeviceStatus.size(); i++) {
                    if(!exposeAuxCamera && (i == 2)) break;
                    int status = mDeviceStatus.valueAt(i);
                    if (status == ICameraServiceListener.STATUS_NOT_PRESENT ||
                            status == ICameraServiceListener.STATUS_ENUMERATING) continue;
                    cameraIds[idCount] = mDeviceStatus.keyAt(i);
                    idCount++;
                }
","            synchronized(mLock) {
                // Try to make sure we have an up-to-date list of camera devices.
                connectCameraServiceLocked();

                boolean exposeAuxCamera = false;
                String packageName = ActivityThread.currentOpPackageName();
                String packageList = SystemProperties.get(""vendor.camera.aux.packagelist"");
                if (packageList.length() > 0) {
                    TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(',');
                    splitter.setString(packageList);
                    for (String str : splitter) {
                        if (packageName.equals(str)) {
                            exposeAuxCamera = true;
                            break;
                        }
                    }
                }
                int idCount = 0;
                for (int i = 0; i < mDeviceStatus.size(); i++) {
                    if(!exposeAuxCamera && (i == 2)) break;
                    int status = mDeviceStatus.valueAt(i);
                    if (status == ICameraServiceListener.STATUS_NOT_PRESENT ||
                            status == ICameraServiceListener.STATUS_ENUMERATING) continue;
                    idCount++;
                }
                cameraIds = new String[idCount];
                idCount = 0;
                for (int i = 0; i < mDeviceStatus.size(); i++) {
                    if(!exposeAuxCamera && (i == 2)) break;
                    int status = mDeviceStatus.valueAt(i);
                    if (status == ICameraServiceListener.STATUS_NOT_PRESENT ||
                            status == ICameraServiceListener.STATUS_ENUMERATING) continue;
                    cameraIds[idCount] = mDeviceStatus.keyAt(i);
                    idCount++;
                }
","[1.0, 1.0]"
1039,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/ServiceState.java,"[(991, 991, 1), (991, 991, 1)]","                rtString = ""NR"";
","                rtString = ""NR"";
","                rtString = ""NR"";
","[1.0, 1.0]"
1040,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/SmsManager.java,"[(459, 562, 104), (459, 562, 104)]","    /**
     * A variant of {@link SmsManager#sendTextMessage} that allows self to be the caller. This is
     * for internal use only.
     *
     * <p class=""note""><strong>Note:</strong> This method is intended for internal use by carrier
     * applications or the Telephony framework and will never trigger an SMS disambiguation
     * dialog. If this method is called on a device that has multiple active subscriptions, this
     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined
     * default subscription is defined, the subscription ID associated with this message will be
     * INVALID, which will result in the SMS being sent on the subscription associated with logical
     * slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is sent on the
     * correct subscription.
     * </p>
     *
     * @param persistMessage whether to persist the sent message in the SMS app. the caller must be
     * the Phone process if set to false.
     *
     * @hide
     */
    public void sendTextMessageWithSelfPermissions(
            String destinationAddress, String scAddress, String text,
            PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage) {
        android.util.SeempLog.record_str(75, destinationAddress);
        if (TextUtils.isEmpty(destinationAddress)) {
            throw new IllegalArgumentException(""Invalid destinationAddress"");
        }

        if (TextUtils.isEmpty(text)) {
            throw new IllegalArgumentException(""Invalid message body"");
        }

        try {
            ISms iSms = getISmsServiceOrThrow();
            iSms.sendTextForSubscriberWithSelfPermissions(getSubscriptionId(),
                    ActivityThread.currentPackageName(),
                    destinationAddress,
                    scAddress, text, sentIntent, deliveryIntent, persistMessage);
        } catch (RemoteException ex) {
            notifySmsGenericError(sentIntent);
        }
    }

    /**
     * Send a text based SMS with messaging options.
     *
     * <p class=""note""><strong>Note:</strong> If {@link #getDefault()} is used to instantiate this
     * manager on a multi-SIM device, this operation may fail sending the SMS message because no
     * suitable default subscription could be found. In this case, if {@code sentIntent} is
     * non-null, then the {@link PendingIntent} will be sent with an error code
     * {@code RESULT_ERROR_GENERIC_FAILURE} and an extra string {@code ""noDefault""} containing the
     * boolean value {@code true}. See {@link #getDefault()} for more information on the conditions
     * where this operation may fail.
     * </p>
     *
     * @param destinationAddress the address to send the message to
     * @param scAddress is the service center address or null to use
     *  the current default SMSC
     * @param text the body of the message to send
     * @param sentIntent if not NULL this <code>PendingIntent</code> is
     *  broadcast when the message is successfully sent, or failed.
     *  The result code will be <code>Activity.RESULT_OK</code> for success,
     *  or one of these errors:<br>
     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
     *  <code>RESULT_ERROR_RADIO_OFF</code><br>
     *  <code>RESULT_ERROR_NULL_PDU</code><br>
     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
     *  the extra ""errorCode"" containing a radio technology specific value,
     *  generally only useful for troubleshooting.<br>
     *  The per-application based SMS control checks sentIntent. If sentIntent
     *  is NULL the caller will be checked against all unknown applications,
     *  which cause smaller number of SMS to be sent in checking period.
     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
     *  broadcast when the message is delivered to the recipient.  The
     *  raw pdu of the status report is in the extended data (""pdu"").
     * @param priority Priority level of the message
     *  Refer specification See 3GPP2 C.S0015-B, v2.0, table 4.5.9-1
     *  ---------------------------------
     *  PRIORITY      | Level of Priority
     *  ---------------------------------
     *      '00'      |     Normal
     *      '01'      |     Interactive
     *      '10'      |     Urgent
     *      '11'      |     Emergency
     *  ----------------------------------
     *  Any Other values included Negative considered as Invalid Priority Indicator of the message.
     * @param expectMore is a boolean to indicate the sending messages through same link or not.
     * @param validityPeriod Validity Period of the message in mins.
     *  Refer specification 3GPP TS 23.040 V6.8.1 section 9.2.3.12.1.
     *  Validity Period(Minimum) -> 5 mins
     *  Validity Period(Maximum) -> 635040 mins(i.e.63 weeks).
     *  Any Other values included Negative considered as Invalid Validity Period of the message.
     *
     * @throws IllegalArgumentException if destinationAddress or text are empty
     * {@hide}
     */
    @UnsupportedAppUsage
    public void sendTextMessage(
            String destinationAddress, String scAddress, String text,
            PendingIntent sentIntent, PendingIntent deliveryIntent,
            int priority, boolean expectMore, int validityPeriod) {
        sendTextMessageInternal(destinationAddress, scAddress, text, sentIntent, deliveryIntent,
                true /* persistMessage*/, priority, expectMore, validityPeriod);
    }

","    /**
     * A variant of {@link SmsManager#sendTextMessage} that allows self to be the caller. This is
     * for internal use only.
     *
     * <p class=""note""><strong>Note:</strong> This method is intended for internal use by carrier
     * applications or the Telephony framework and will never trigger an SMS disambiguation
     * dialog. If this method is called on a device that has multiple active subscriptions, this
     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined
     * default subscription is defined, the subscription ID associated with this message will be
     * INVALID, which will result in the SMS being sent on the subscription associated with logical
     * slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is sent on the
     * correct subscription.
     * </p>
     *
     * @param persistMessage whether to persist the sent message in the SMS app. the caller must be
     * the Phone process if set to false.
     *
     * @hide
     */
    public void sendTextMessageWithSelfPermissions(
            String destinationAddress, String scAddress, String text,
            PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage) {
        android.util.SeempLog.record_str(75, destinationAddress);
        if (TextUtils.isEmpty(destinationAddress)) {
            throw new IllegalArgumentException(""Invalid destinationAddress"");
        }

        if (TextUtils.isEmpty(text)) {
            throw new IllegalArgumentException(""Invalid message body"");
        }

        try {
            ISms iSms = getISmsServiceOrThrow();
            iSms.sendTextForSubscriberWithSelfPermissions(getSubscriptionId(),
                    ActivityThread.currentPackageName(),
                    destinationAddress,
                    scAddress, text, sentIntent, deliveryIntent, persistMessage);
        } catch (RemoteException ex) {
            notifySmsGenericError(sentIntent);
        }
    }

    /**
     * Send a text based SMS with messaging options.
     *
     * <p class=""note""><strong>Note:</strong> If {@link #getDefault()} is used to instantiate this
     * manager on a multi-SIM device, this operation may fail sending the SMS message because no
     * suitable default subscription could be found. In this case, if {@code sentIntent} is
     * non-null, then the {@link PendingIntent} will be sent with an error code
     * {@code RESULT_ERROR_GENERIC_FAILURE} and an extra string {@code ""noDefault""} containing the
     * boolean value {@code true}. See {@link #getDefault()} for more information on the conditions
     * where this operation may fail.
     * </p>
     *
     * @param destinationAddress the address to send the message to
     * @param scAddress is the service center address or null to use
     *  the current default SMSC
     * @param text the body of the message to send
     * @param sentIntent if not NULL this <code>PendingIntent</code> is
     *  broadcast when the message is successfully sent, or failed.
     *  The result code will be <code>Activity.RESULT_OK</code> for success,
     *  or one of these errors:<br>
     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
     *  <code>RESULT_ERROR_RADIO_OFF</code><br>
     *  <code>RESULT_ERROR_NULL_PDU</code><br>
     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
     *  the extra ""errorCode"" containing a radio technology specific value,
     *  generally only useful for troubleshooting.<br>
     *  The per-application based SMS control checks sentIntent. If sentIntent
     *  is NULL the caller will be checked against all unknown applications,
     *  which cause smaller number of SMS to be sent in checking period.
     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
     *  broadcast when the message is delivered to the recipient.  The
     *  raw pdu of the status report is in the extended data (""pdu"").
     * @param priority Priority level of the message
     *  Refer specification See 3GPP2 C.S0015-B, v2.0, table 4.5.9-1
     *  ---------------------------------
     *  PRIORITY      | Level of Priority
     *  ---------------------------------
     *      '00'      |     Normal
     *      '01'      |     Interactive
     *      '10'      |     Urgent
     *      '11'      |     Emergency
     *  ----------------------------------
     *  Any Other values included Negative considered as Invalid Priority Indicator of the message.
     * @param expectMore is a boolean to indicate the sending messages through same link or not.
     * @param validityPeriod Validity Period of the message in mins.
     *  Refer specification 3GPP TS 23.040 V6.8.1 section 9.2.3.12.1.
     *  Validity Period(Minimum) -> 5 mins
     *  Validity Period(Maximum) -> 635040 mins(i.e.63 weeks).
     *  Any Other values included Negative considered as Invalid Validity Period of the message.
     *
     * @throws IllegalArgumentException if destinationAddress or text are empty
     * {@hide}
     */
    @UnsupportedAppUsage
    public void sendTextMessage(
            String destinationAddress, String scAddress, String text,
            PendingIntent sentIntent, PendingIntent deliveryIntent,
            int priority, boolean expectMore, int validityPeriod) {
        sendTextMessageInternal(destinationAddress, scAddress, text, sentIntent, deliveryIntent,
                true /* persistMessage*/, priority, expectMore, validityPeriod);
    }

","    /**
     * A variant of {@link SmsManager#sendTextMessage} that allows self to be the caller. This is
     * for internal use only.
     *
     * <p class=""note""><strong>Note:</strong> This method is intended for internal use by carrier
     * applications or the Telephony framework and will never trigger an SMS disambiguation
     * dialog. If this method is called on a device that has multiple active subscriptions, this
     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined
     * default subscription is defined, the subscription ID associated with this message will be
     * INVALID, which will result in the SMS being sent on the subscription associated with logical
     * slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is sent on the
     * correct subscription.
     * </p>
     *
     * @param persistMessage whether to persist the sent message in the SMS app. the caller must be
     * the Phone process if set to false.
     *
     * @hide
     */
    public void sendTextMessageWithSelfPermissions(
            String destinationAddress, String scAddress, String text,
            PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage) {
        android.util.SeempLog.record_str(75, destinationAddress);
        if (TextUtils.isEmpty(destinationAddress)) {
            throw new IllegalArgumentException(""Invalid destinationAddress"");
        }

        if (TextUtils.isEmpty(text)) {
            throw new IllegalArgumentException(""Invalid message body"");
        }

        try {
            ISms iSms = getISmsServiceOrThrow();
            iSms.sendTextForSubscriberWithSelfPermissions(getSubscriptionId(),
                    ActivityThread.currentPackageName(),
                    destinationAddress,
                    scAddress, text, sentIntent, deliveryIntent, persistMessage);
        } catch (RemoteException ex) {
            notifySmsGenericError(sentIntent);
        }
    }

    /**
     * Send a text based SMS with messaging options.
     *
     * <p class=""note""><strong>Note:</strong> If {@link #getDefault()} is used to instantiate this
     * manager on a multi-SIM device, this operation may fail sending the SMS message because no
     * suitable default subscription could be found. In this case, if {@code sentIntent} is
     * non-null, then the {@link PendingIntent} will be sent with an error code
     * {@code RESULT_ERROR_GENERIC_FAILURE} and an extra string {@code ""noDefault""} containing the
     * boolean value {@code true}. See {@link #getDefault()} for more information on the conditions
     * where this operation may fail.
     * </p>
     *
     * @param destinationAddress the address to send the message to
     * @param scAddress is the service center address or null to use
     *  the current default SMSC
     * @param text the body of the message to send
     * @param sentIntent if not NULL this <code>PendingIntent</code> is
     *  broadcast when the message is successfully sent, or failed.
     *  The result code will be <code>Activity.RESULT_OK</code> for success,
     *  or one of these errors:<br>
     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
     *  <code>RESULT_ERROR_RADIO_OFF</code><br>
     *  <code>RESULT_ERROR_NULL_PDU</code><br>
     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
     *  the extra ""errorCode"" containing a radio technology specific value,
     *  generally only useful for troubleshooting.<br>
     *  The per-application based SMS control checks sentIntent. If sentIntent
     *  is NULL the caller will be checked against all unknown applications,
     *  which cause smaller number of SMS to be sent in checking period.
     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
     *  broadcast when the message is delivered to the recipient.  The
     *  raw pdu of the status report is in the extended data (""pdu"").
     * @param priority Priority level of the message
     *  Refer specification See 3GPP2 C.S0015-B, v2.0, table 4.5.9-1
     *  ---------------------------------
     *  PRIORITY      | Level of Priority
     *  ---------------------------------
     *      '00'      |     Normal
     *      '01'      |     Interactive
     *      '10'      |     Urgent
     *      '11'      |     Emergency
     *  ----------------------------------
     *  Any Other values included Negative considered as Invalid Priority Indicator of the message.
     * @param expectMore is a boolean to indicate the sending messages through same link or not.
     * @param validityPeriod Validity Period of the message in mins.
     *  Refer specification 3GPP TS 23.040 V6.8.1 section 9.2.3.12.1.
     *  Validity Period(Minimum) -> 5 mins
     *  Validity Period(Maximum) -> 635040 mins(i.e.63 weeks).
     *  Any Other values included Negative considered as Invalid Validity Period of the message.
     *
     * @throws IllegalArgumentException if destinationAddress or text are empty
     * {@hide}
     */
    @UnsupportedAppUsage
    public void sendTextMessage(
            String destinationAddress, String scAddress, String text,
            PendingIntent sentIntent, PendingIntent deliveryIntent,
            int priority, boolean expectMore, int validityPeriod) {
        sendTextMessageInternal(destinationAddress, scAddress, text, sentIntent, deliveryIntent,
                true /* persistMessage*/, priority, expectMore, validityPeriod);
    }

","[1.0, 1.0]"
1041,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/SmsManager.java,"[(1186, 1225, 40), (1186, 1225, 40)]","     * A variant of {@link SmsManager#sendDataMessage} that allows self to be the caller. This is
     * for internal use only.
     *
     * <p class=""note""><strong>Note:</strong> This method is intended for internal use by carrier
     * applications or the Telephony framework and will never trigger an SMS disambiguation
     * dialog. If this method is called on a device that has multiple active subscriptions, this
     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined
     * default subscription is defined, the subscription ID associated with this message will be
     * INVALID, which will result in the SMS being sent on the subscription associated with logical
     * slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is sent on the
     * correct subscription.
     * </p>
     *
     * @hide
     */
    public void sendDataMessageWithSelfPermissions(
            String destinationAddress, String scAddress, short destinationPort,
            byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
        android.util.SeempLog.record_str(73, destinationAddress);
        if (TextUtils.isEmpty(destinationAddress)) {
            throw new IllegalArgumentException(""Invalid destinationAddress"");
        }

        if (data == null || data.length == 0) {
            throw new IllegalArgumentException(""Invalid message data"");
        }

        try {
            ISms iSms = getISmsServiceOrThrow();
            iSms.sendDataForSubscriberWithSelfPermissions(getSubscriptionId(),
                    ActivityThread.currentPackageName(), destinationAddress, scAddress,
                    destinationPort & 0xFFFF, data, sentIntent, deliveryIntent);
        } catch (RemoteException e) {
            Log.e(TAG, ""sendDataMessageWithSelfPermissions: Couldn't send SMS - Exception: ""
                    + e.getMessage());
            notifySmsGenericError(sentIntent);
        }
    }

    /**
","     * A variant of {@link SmsManager#sendDataMessage} that allows self to be the caller. This is
     * for internal use only.
     *
     * <p class=""note""><strong>Note:</strong> This method is intended for internal use by carrier
     * applications or the Telephony framework and will never trigger an SMS disambiguation
     * dialog. If this method is called on a device that has multiple active subscriptions, this
     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined
     * default subscription is defined, the subscription ID associated with this message will be
     * INVALID, which will result in the SMS being sent on the subscription associated with logical
     * slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is sent on the
     * correct subscription.
     * </p>
     *
     * @hide
     */
    public void sendDataMessageWithSelfPermissions(
            String destinationAddress, String scAddress, short destinationPort,
            byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
        android.util.SeempLog.record_str(73, destinationAddress);
        if (TextUtils.isEmpty(destinationAddress)) {
            throw new IllegalArgumentException(""Invalid destinationAddress"");
        }

        if (data == null || data.length == 0) {
            throw new IllegalArgumentException(""Invalid message data"");
        }

        try {
            ISms iSms = getISmsServiceOrThrow();
            iSms.sendDataForSubscriberWithSelfPermissions(getSubscriptionId(),
                    ActivityThread.currentPackageName(), destinationAddress, scAddress,
                    destinationPort & 0xFFFF, data, sentIntent, deliveryIntent);
        } catch (RemoteException e) {
            Log.e(TAG, ""sendDataMessageWithSelfPermissions: Couldn't send SMS - Exception: ""
                    + e.getMessage());
            notifySmsGenericError(sentIntent);
        }
    }

    /**
","     * A variant of {@link SmsManager#sendDataMessage} that allows self to be the caller. This is
     * for internal use only.
     *
     * <p class=""note""><strong>Note:</strong> This method is intended for internal use by carrier
     * applications or the Telephony framework and will never trigger an SMS disambiguation
     * dialog. If this method is called on a device that has multiple active subscriptions, this
     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined
     * default subscription is defined, the subscription ID associated with this message will be
     * INVALID, which will result in the SMS being sent on the subscription associated with logical
     * slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is sent on the
     * correct subscription.
     * </p>
     *
     * @hide
     */
    public void sendDataMessageWithSelfPermissions(
            String destinationAddress, String scAddress, short destinationPort,
            byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
        android.util.SeempLog.record_str(73, destinationAddress);
        if (TextUtils.isEmpty(destinationAddress)) {
            throw new IllegalArgumentException(""Invalid destinationAddress"");
        }

        if (data == null || data.length == 0) {
            throw new IllegalArgumentException(""Invalid message data"");
        }

        try {
            ISms iSms = getISmsServiceOrThrow();
            iSms.sendDataForSubscriberWithSelfPermissions(getSubscriptionId(),
                    ActivityThread.currentPackageName(), destinationAddress, scAddress,
                    destinationPort & 0xFFFF, data, sentIntent, deliveryIntent);
        } catch (RemoteException e) {
            Log.e(TAG, ""sendDataMessageWithSelfPermissions: Couldn't send SMS - Exception: ""
                    + e.getMessage());
            notifySmsGenericError(sentIntent);
        }
    }

    /**
","[1.0, 1.0]"
1042,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java,"[(120, 121, 2), (120, 121, 2)]","    private EmergencyCarrierArea mEmergencyCarrierArea;
    private final UnlockMethodCache mUnlockMethodCache;
","    private EmergencyCarrierArea mEmergencyCarrierArea;
    private final UnlockMethodCache mUnlockMethodCache;
","    private EmergencyCarrierArea mEmergencyCarrierArea;
    private final UnlockMethodCache mUnlockMethodCache;
","[1.0, 1.0]"
1043,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java,"[(3958, 4212, 255), (3958, 4212, 255)]","    @VisibleForTesting
    final class DozeServiceHost implements DozeHost {
        private final ArrayList<Callback> mCallbacks = new ArrayList<>();
        private boolean mAnimateWakeup;
        private boolean mAnimateScreenOff;
        private boolean mIgnoreTouchWhilePulsing;
        @VisibleForTesting
        boolean mWakeLockScreenPerformsAuth = SystemProperties.getBoolean(
                ""persist.sysui.wake_performs_auth"", true);

        @Override
        public String toString() {
            return ""PSB.DozeServiceHost[mCallbacks="" + mCallbacks.size() + ""]"";
        }

        public void firePowerSaveChanged(boolean active) {
            for (Callback callback : mCallbacks) {
                callback.onPowerSaveChanged(active);
            }
        }

        public void fireNotificationPulse(NotificationEntry entry) {
            Runnable pulseSupressedListener = () -> {
                entry.setPulseSuppressed(true);
                mNotificationIconAreaController.updateAodNotificationIcons();
            };
            for (Callback callback : mCallbacks) {
                callback.onNotificationAlerted(pulseSupressedListener);
            }
        }

        @Override
        public void addCallback(@NonNull Callback callback) {
            mCallbacks.add(callback);
        }

        @Override
        public void removeCallback(@NonNull Callback callback) {
            mCallbacks.remove(callback);
        }

        @Override
        public void startDozing() {
            if (!mDozingRequested) {
                mDozingRequested = true;
                DozeLog.traceDozing(mContext, mDozing);
                updateDozing();
                updateIsKeyguard();
            }else{
                mDozingRequested = true;
            }
        }

        @Override
        public void pulseWhileDozing(@NonNull PulseCallback callback, int reason) {
            if (reason == DozeLog.PULSE_REASON_SENSOR_LONG_PRESS) {
                mPowerManager.wakeUp(SystemClock.uptimeMillis(), PowerManager.WAKE_REASON_GESTURE,
                        ""com.android.systemui:LONG_PRESS"");
                startAssist(new Bundle());
                return;
            }

            if (reason == DozeLog.PULSE_REASON_SENSOR_WAKE_LOCK_SCREEN) {
                mScrimController.setWakeLockScreenSensorActive(true);
            }

            if (reason == DozeLog.PULSE_REASON_DOCKING && mStatusBarWindow != null) {
                mStatusBarWindow.suppressWakeUpGesture(true);
            }

            boolean passiveAuthInterrupt = reason == DozeLog.PULSE_REASON_SENSOR_WAKE_LOCK_SCREEN
                            && mWakeLockScreenPerformsAuth;
            // Set the state to pulsing, so ScrimController will know what to do once we ask it to
            // execute the transition. The pulse callback will then be invoked when the scrims
            // are black, indicating that StatusBar is ready to present the rest of the UI.
            mPulsing = true;
            mDozeScrimController.pulse(new PulseCallback() {
                @Override
                public void onPulseStarted() {
                    callback.onPulseStarted();
                    updateNotificationPanelTouchState();
                    setPulsing(true);
                }

                @Override
                public void onPulseFinished() {
                    mPulsing = false;
                    callback.onPulseFinished();
                    updateNotificationPanelTouchState();
                    mScrimController.setWakeLockScreenSensorActive(false);
                    if (mStatusBarWindow != null) {
                        mStatusBarWindow.suppressWakeUpGesture(false);
                    }
                    setPulsing(false);
                }

                private void setPulsing(boolean pulsing) {
                    mStatusBarStateController.setPulsing(pulsing);
                    mStatusBarKeyguardViewManager.setPulsing(pulsing);
                    mKeyguardViewMediator.setPulsing(pulsing);
                    mNotificationPanel.setPulsing(pulsing);
                    mVisualStabilityManager.setPulsing(pulsing);
                    mStatusBarWindow.setPulsing(pulsing);
                    mIgnoreTouchWhilePulsing = false;
                    if (mKeyguardUpdateMonitor != null && passiveAuthInterrupt) {
                        mKeyguardUpdateMonitor.onAuthInterruptDetected(pulsing /* active */);
                    }
                    updateScrimController();
                    mPulseExpansionHandler.setPulsing(pulsing);
                    mWakeUpCoordinator.setPulsing(pulsing);
                }
            }, reason);
            // DozeScrimController is in pulse state, now let's ask ScrimController to start
            // pulsing and draw the black frame, if necessary.
            updateScrimController();
        }

        @Override
        public void stopDozing() {
            if (mDozingRequested) {
                mDozingRequested = false;
                DozeLog.traceDozing(mContext, mDozing);
                updateDozing();
            }
        }

        @Override
        public void onIgnoreTouchWhilePulsing(boolean ignore) {
            if (ignore != mIgnoreTouchWhilePulsing) {
                DozeLog.tracePulseTouchDisabledByProx(mContext, ignore);
            }
            mIgnoreTouchWhilePulsing = ignore;
            if (isDozing() && ignore) {
                mStatusBarWindow.cancelCurrentTouch();
            }
        }

        @Override
        public void dozeTimeTick() {
            mNotificationPanel.dozeTimeTick();
            if (mAmbientIndicationContainer instanceof DozeReceiver) {
                ((DozeReceiver) mAmbientIndicationContainer).dozeTimeTick();
            }
        }

        @Override
        public boolean isPowerSaveActive() {
            return mBatteryController.isAodPowerSave();
        }

        @Override
        public boolean isPulsingBlocked() {
            return mBiometricUnlockController.getMode()
                    == BiometricUnlockController.MODE_WAKE_AND_UNLOCK;
        }

        @Override
        public boolean isProvisioned() {
            return mDeviceProvisionedController.isDeviceProvisioned()
                    && mDeviceProvisionedController.isCurrentUserSetup();
        }

        @Override
        public boolean isBlockingDoze() {
            if (mBiometricUnlockController.hasPendingAuthentication()) {
                Log.i(TAG, ""Blocking AOD because fingerprint has authenticated"");
                return true;
            }
            return false;
        }

        @Override
        public void extendPulse(int reason) {
            if (reason == DozeLog.PULSE_REASON_SENSOR_WAKE_LOCK_SCREEN) {
                mScrimController.setWakeLockScreenSensorActive(true);
            }
            if (mDozeScrimController.isPulsing() && mHeadsUpManager.hasNotifications()) {
                mHeadsUpManager.extendHeadsUp();
            } else {
                mDozeScrimController.extendPulse();
            }
        }

        @Override
        public void stopPulsing() {
            if (mDozeScrimController.isPulsing()) {
                mDozeScrimController.pulseOutNow();
            }
        }

        @Override
        public void setAnimateWakeup(boolean animateWakeup) {
            if (mWakefulnessLifecycle.getWakefulness() == WAKEFULNESS_AWAKE
                    || mWakefulnessLifecycle.getWakefulness() == WAKEFULNESS_WAKING) {
                // Too late to change the wakeup animation.
                return;
            }
            mAnimateWakeup = animateWakeup;
        }

        @Override
        public void setAnimateScreenOff(boolean animateScreenOff) {
            mAnimateScreenOff = animateScreenOff;
        }

        @Override
        public void onSlpiTap(float screenX, float screenY) {
            if (screenX > 0 && screenY > 0 && mAmbientIndicationContainer != null
                && mAmbientIndicationContainer.getVisibility() == View.VISIBLE) {
                mAmbientIndicationContainer.getLocationOnScreen(mTmpInt2);
                float viewX = screenX - mTmpInt2[0];
                float viewY = screenY - mTmpInt2[1];
                if (0 <= viewX && viewX <= mAmbientIndicationContainer.getWidth()
                        && 0 <= viewY && viewY <= mAmbientIndicationContainer.getHeight()) {
                    dispatchTap(mAmbientIndicationContainer, viewX, viewY);
                }
            }
        }

        @Override
        public void setDozeScreenBrightness(int value) {
            mStatusBarWindowController.setDozeScreenBrightness(value);
        }

        @Override
        public void setAodDimmingScrim(float scrimOpacity) {
            mScrimController.setAodFrontScrimAlpha(scrimOpacity);
        }

        @Override
        public void prepareForGentleWakeUp() {
            mScrimController.prepareForGentleWakeUp();
        }

        private void dispatchTap(View view, float x, float y) {
            long now = SystemClock.elapsedRealtime();
            dispatchTouchEvent(view, x, y, now, MotionEvent.ACTION_DOWN);
            dispatchTouchEvent(view, x, y, now, MotionEvent.ACTION_UP);
        }

        private void dispatchTouchEvent(View view, float x, float y, long now, int action) {
            MotionEvent ev = MotionEvent.obtain(now, now, action, x, y, 0 /* meta */);
            view.dispatchTouchEvent(ev);
            ev.recycle();
        }

        private boolean shouldAnimateWakeup() {
            return mAnimateWakeup;
        }

        public boolean shouldAnimateScreenOff() {
            return mAnimateScreenOff;
        }
    }

","    @VisibleForTesting
    final class DozeServiceHost implements DozeHost {
        private final ArrayList<Callback> mCallbacks = new ArrayList<>();
        private boolean mAnimateWakeup;
        private boolean mAnimateScreenOff;
        private boolean mIgnoreTouchWhilePulsing;
        @VisibleForTesting
        boolean mWakeLockScreenPerformsAuth = SystemProperties.getBoolean(
                ""persist.sysui.wake_performs_auth"", true);

        @Override
        public String toString() {
            return ""PSB.DozeServiceHost[mCallbacks="" + mCallbacks.size() + ""]"";
        }

        public void firePowerSaveChanged(boolean active) {
            for (Callback callback : mCallbacks) {
                callback.onPowerSaveChanged(active);
            }
        }

        public void fireNotificationPulse(NotificationEntry entry) {
            Runnable pulseSupressedListener = () -> {
                entry.setPulseSuppressed(true);
                mNotificationIconAreaController.updateAodNotificationIcons();
            };
            for (Callback callback : mCallbacks) {
                callback.onNotificationAlerted(pulseSupressedListener);
            }
        }

        @Override
        public void addCallback(@NonNull Callback callback) {
            mCallbacks.add(callback);
        }

        @Override
        public void removeCallback(@NonNull Callback callback) {
            mCallbacks.remove(callback);
        }

        @Override
        public void startDozing() {
            if (!mDozingRequested) {
                mDozingRequested = true;
                DozeLog.traceDozing(mContext, mDozing);
                updateDozing();
                updateIsKeyguard();
            }else{
                mDozingRequested = true;
            }
        }

        @Override
        public void pulseWhileDozing(@NonNull PulseCallback callback, int reason) {
            if (reason == DozeLog.PULSE_REASON_SENSOR_LONG_PRESS) {
                mPowerManager.wakeUp(SystemClock.uptimeMillis(), PowerManager.WAKE_REASON_GESTURE,
                        ""com.android.systemui:LONG_PRESS"");
                startAssist(new Bundle());
                return;
            }

            if (reason == DozeLog.PULSE_REASON_SENSOR_WAKE_LOCK_SCREEN) {
                mScrimController.setWakeLockScreenSensorActive(true);
            }

            if (reason == DozeLog.PULSE_REASON_DOCKING && mStatusBarWindow != null) {
                mStatusBarWindow.suppressWakeUpGesture(true);
            }

            boolean passiveAuthInterrupt = reason == DozeLog.PULSE_REASON_SENSOR_WAKE_LOCK_SCREEN
                            && mWakeLockScreenPerformsAuth;
            // Set the state to pulsing, so ScrimController will know what to do once we ask it to
            // execute the transition. The pulse callback will then be invoked when the scrims
            // are black, indicating that StatusBar is ready to present the rest of the UI.
            mPulsing = true;
            mDozeScrimController.pulse(new PulseCallback() {
                @Override
                public void onPulseStarted() {
                    callback.onPulseStarted();
                    updateNotificationPanelTouchState();
                    setPulsing(true);
                }

                @Override
                public void onPulseFinished() {
                    mPulsing = false;
                    callback.onPulseFinished();
                    updateNotificationPanelTouchState();
                    mScrimController.setWakeLockScreenSensorActive(false);
                    if (mStatusBarWindow != null) {
                        mStatusBarWindow.suppressWakeUpGesture(false);
                    }
                    setPulsing(false);
                }

                private void setPulsing(boolean pulsing) {
                    mStatusBarStateController.setPulsing(pulsing);
                    mStatusBarKeyguardViewManager.setPulsing(pulsing);
                    mKeyguardViewMediator.setPulsing(pulsing);
                    mNotificationPanel.setPulsing(pulsing);
                    mVisualStabilityManager.setPulsing(pulsing);
                    mStatusBarWindow.setPulsing(pulsing);
                    mIgnoreTouchWhilePulsing = false;
                    if (mKeyguardUpdateMonitor != null && passiveAuthInterrupt) {
                        mKeyguardUpdateMonitor.onAuthInterruptDetected(pulsing /* active */);
                    }
                    updateScrimController();
                    mPulseExpansionHandler.setPulsing(pulsing);
                    mWakeUpCoordinator.setPulsing(pulsing);
                }
            }, reason);
            // DozeScrimController is in pulse state, now let's ask ScrimController to start
            // pulsing and draw the black frame, if necessary.
            updateScrimController();
        }

        @Override
        public void stopDozing() {
            if (mDozingRequested) {
                mDozingRequested = false;
                DozeLog.traceDozing(mContext, mDozing);
                updateDozing();
            }
        }

        @Override
        public void onIgnoreTouchWhilePulsing(boolean ignore) {
            if (ignore != mIgnoreTouchWhilePulsing) {
                DozeLog.tracePulseTouchDisabledByProx(mContext, ignore);
            }
            mIgnoreTouchWhilePulsing = ignore;
            if (isDozing() && ignore) {
                mStatusBarWindow.cancelCurrentTouch();
            }
        }

        @Override
        public void dozeTimeTick() {
            mNotificationPanel.dozeTimeTick();
            if (mAmbientIndicationContainer instanceof DozeReceiver) {
                ((DozeReceiver) mAmbientIndicationContainer).dozeTimeTick();
            }
        }

        @Override
        public boolean isPowerSaveActive() {
            return mBatteryController.isAodPowerSave();
        }

        @Override
        public boolean isPulsingBlocked() {
            return mBiometricUnlockController.getMode()
                    == BiometricUnlockController.MODE_WAKE_AND_UNLOCK;
        }

        @Override
        public boolean isProvisioned() {
            return mDeviceProvisionedController.isDeviceProvisioned()
                    && mDeviceProvisionedController.isCurrentUserSetup();
        }

        @Override
        public boolean isBlockingDoze() {
            if (mBiometricUnlockController.hasPendingAuthentication()) {
                Log.i(TAG, ""Blocking AOD because fingerprint has authenticated"");
                return true;
            }
            return false;
        }

        @Override
        public void extendPulse(int reason) {
            if (reason == DozeLog.PULSE_REASON_SENSOR_WAKE_LOCK_SCREEN) {
                mScrimController.setWakeLockScreenSensorActive(true);
            }
            if (mDozeScrimController.isPulsing() && mHeadsUpManager.hasNotifications()) {
                mHeadsUpManager.extendHeadsUp();
            } else {
                mDozeScrimController.extendPulse();
            }
        }

        @Override
        public void stopPulsing() {
            if (mDozeScrimController.isPulsing()) {
                mDozeScrimController.pulseOutNow();
            }
        }

        @Override
        public void setAnimateWakeup(boolean animateWakeup) {
            if (mWakefulnessLifecycle.getWakefulness() == WAKEFULNESS_AWAKE
                    || mWakefulnessLifecycle.getWakefulness() == WAKEFULNESS_WAKING) {
                // Too late to change the wakeup animation.
                return;
            }
            mAnimateWakeup = animateWakeup;
        }

        @Override
        public void setAnimateScreenOff(boolean animateScreenOff) {
            mAnimateScreenOff = animateScreenOff;
        }

        @Override
        public void onSlpiTap(float screenX, float screenY) {
            if (screenX > 0 && screenY > 0 && mAmbientIndicationContainer != null
                && mAmbientIndicationContainer.getVisibility() == View.VISIBLE) {
                mAmbientIndicationContainer.getLocationOnScreen(mTmpInt2);
                float viewX = screenX - mTmpInt2[0];
                float viewY = screenY - mTmpInt2[1];
                if (0 <= viewX && viewX <= mAmbientIndicationContainer.getWidth()
                        && 0 <= viewY && viewY <= mAmbientIndicationContainer.getHeight()) {
                    dispatchTap(mAmbientIndicationContainer, viewX, viewY);
                }
            }
        }

        @Override
        public void setDozeScreenBrightness(int value) {
            mStatusBarWindowController.setDozeScreenBrightness(value);
        }

        @Override
        public void setAodDimmingScrim(float scrimOpacity) {
            mScrimController.setAodFrontScrimAlpha(scrimOpacity);
        }

        @Override
        public void prepareForGentleWakeUp() {
            mScrimController.prepareForGentleWakeUp();
        }

        private void dispatchTap(View view, float x, float y) {
            long now = SystemClock.elapsedRealtime();
            dispatchTouchEvent(view, x, y, now, MotionEvent.ACTION_DOWN);
            dispatchTouchEvent(view, x, y, now, MotionEvent.ACTION_UP);
        }

        private void dispatchTouchEvent(View view, float x, float y, long now, int action) {
            MotionEvent ev = MotionEvent.obtain(now, now, action, x, y, 0 /* meta */);
            view.dispatchTouchEvent(ev);
            ev.recycle();
        }

        private boolean shouldAnimateWakeup() {
            return mAnimateWakeup;
        }

        public boolean shouldAnimateScreenOff() {
            return mAnimateScreenOff;
        }
    }

","    @VisibleForTesting
    final class DozeServiceHost implements DozeHost {
        private final ArrayList<Callback> mCallbacks = new ArrayList<>();
        private boolean mAnimateWakeup;
        private boolean mAnimateScreenOff;
        private boolean mIgnoreTouchWhilePulsing;
        @VisibleForTesting
        boolean mWakeLockScreenPerformsAuth = SystemProperties.getBoolean(
                ""persist.sysui.wake_performs_auth"", true);

        @Override
        public String toString() {
            return ""PSB.DozeServiceHost[mCallbacks="" + mCallbacks.size() + ""]"";
        }

        public void firePowerSaveChanged(boolean active) {
            for (Callback callback : mCallbacks) {
                callback.onPowerSaveChanged(active);
            }
        }

        public void fireNotificationPulse(NotificationEntry entry) {
            Runnable pulseSupressedListener = () -> {
                entry.setPulseSuppressed(true);
                mNotificationIconAreaController.updateAodNotificationIcons();
            };
            for (Callback callback : mCallbacks) {
                callback.onNotificationAlerted(pulseSupressedListener);
            }
        }

        @Override
        public void addCallback(@NonNull Callback callback) {
            mCallbacks.add(callback);
        }

        @Override
        public void removeCallback(@NonNull Callback callback) {
            mCallbacks.remove(callback);
        }

        @Override
        public void startDozing() {
            if (!mDozingRequested) {
                mDozingRequested = true;
                DozeLog.traceDozing(mContext, mDozing);
                updateDozing();
                updateIsKeyguard();
            }else{
                mDozingRequested = true;
            }
        }

        @Override
        public void pulseWhileDozing(@NonNull PulseCallback callback, int reason) {
            if (reason == DozeLog.PULSE_REASON_SENSOR_LONG_PRESS) {
                mPowerManager.wakeUp(SystemClock.uptimeMillis(), PowerManager.WAKE_REASON_GESTURE,
                        ""com.android.systemui:LONG_PRESS"");
                startAssist(new Bundle());
                return;
            }

            if (reason == DozeLog.PULSE_REASON_SENSOR_WAKE_LOCK_SCREEN) {
                mScrimController.setWakeLockScreenSensorActive(true);
            }

            if (reason == DozeLog.PULSE_REASON_DOCKING && mStatusBarWindow != null) {
                mStatusBarWindow.suppressWakeUpGesture(true);
            }

            boolean passiveAuthInterrupt = reason == DozeLog.PULSE_REASON_SENSOR_WAKE_LOCK_SCREEN
                            && mWakeLockScreenPerformsAuth;
            // Set the state to pulsing, so ScrimController will know what to do once we ask it to
            // execute the transition. The pulse callback will then be invoked when the scrims
            // are black, indicating that StatusBar is ready to present the rest of the UI.
            mPulsing = true;
            mDozeScrimController.pulse(new PulseCallback() {
                @Override
                public void onPulseStarted() {
                    callback.onPulseStarted();
                    updateNotificationPanelTouchState();
                    setPulsing(true);
                }

                @Override
                public void onPulseFinished() {
                    mPulsing = false;
                    callback.onPulseFinished();
                    updateNotificationPanelTouchState();
                    mScrimController.setWakeLockScreenSensorActive(false);
                    if (mStatusBarWindow != null) {
                        mStatusBarWindow.suppressWakeUpGesture(false);
                    }
                    setPulsing(false);
                }

                private void setPulsing(boolean pulsing) {
                    mStatusBarStateController.setPulsing(pulsing);
                    mStatusBarKeyguardViewManager.setPulsing(pulsing);
                    mKeyguardViewMediator.setPulsing(pulsing);
                    mNotificationPanel.setPulsing(pulsing);
                    mVisualStabilityManager.setPulsing(pulsing);
                    mStatusBarWindow.setPulsing(pulsing);
                    mIgnoreTouchWhilePulsing = false;
                    if (mKeyguardUpdateMonitor != null && passiveAuthInterrupt) {
                        mKeyguardUpdateMonitor.onAuthInterruptDetected(pulsing /* active */);
                    }
                    updateScrimController();
                    mPulseExpansionHandler.setPulsing(pulsing);
                    mWakeUpCoordinator.setPulsing(pulsing);
                }
            }, reason);
            // DozeScrimController is in pulse state, now let's ask ScrimController to start
            // pulsing and draw the black frame, if necessary.
            updateScrimController();
        }

        @Override
        public void stopDozing() {
            if (mDozingRequested) {
                mDozingRequested = false;
                DozeLog.traceDozing(mContext, mDozing);
                updateDozing();
            }
        }

        @Override
        public void onIgnoreTouchWhilePulsing(boolean ignore) {
            if (ignore != mIgnoreTouchWhilePulsing) {
                DozeLog.tracePulseTouchDisabledByProx(mContext, ignore);
            }
            mIgnoreTouchWhilePulsing = ignore;
            if (isDozing() && ignore) {
                mStatusBarWindow.cancelCurrentTouch();
            }
        }

        @Override
        public void dozeTimeTick() {
            mNotificationPanel.dozeTimeTick();
            if (mAmbientIndicationContainer instanceof DozeReceiver) {
                ((DozeReceiver) mAmbientIndicationContainer).dozeTimeTick();
            }
        }

        @Override
        public boolean isPowerSaveActive() {
            return mBatteryController.isAodPowerSave();
        }

        @Override
        public boolean isPulsingBlocked() {
            return mBiometricUnlockController.getMode()
                    == BiometricUnlockController.MODE_WAKE_AND_UNLOCK;
        }

        @Override
        public boolean isProvisioned() {
            return mDeviceProvisionedController.isDeviceProvisioned()
                    && mDeviceProvisionedController.isCurrentUserSetup();
        }

        @Override
        public boolean isBlockingDoze() {
            if (mBiometricUnlockController.hasPendingAuthentication()) {
                Log.i(TAG, ""Blocking AOD because fingerprint has authenticated"");
                return true;
            }
            return false;
        }

        @Override
        public void extendPulse(int reason) {
            if (reason == DozeLog.PULSE_REASON_SENSOR_WAKE_LOCK_SCREEN) {
                mScrimController.setWakeLockScreenSensorActive(true);
            }
            if (mDozeScrimController.isPulsing() && mHeadsUpManager.hasNotifications()) {
                mHeadsUpManager.extendHeadsUp();
            } else {
                mDozeScrimController.extendPulse();
            }
        }

        @Override
        public void stopPulsing() {
            if (mDozeScrimController.isPulsing()) {
                mDozeScrimController.pulseOutNow();
            }
        }

        @Override
        public void setAnimateWakeup(boolean animateWakeup) {
            if (mWakefulnessLifecycle.getWakefulness() == WAKEFULNESS_AWAKE
                    || mWakefulnessLifecycle.getWakefulness() == WAKEFULNESS_WAKING) {
                // Too late to change the wakeup animation.
                return;
            }
            mAnimateWakeup = animateWakeup;
        }

        @Override
        public void setAnimateScreenOff(boolean animateScreenOff) {
            mAnimateScreenOff = animateScreenOff;
        }

        @Override
        public void onSlpiTap(float screenX, float screenY) {
            if (screenX > 0 && screenY > 0 && mAmbientIndicationContainer != null
                && mAmbientIndicationContainer.getVisibility() == View.VISIBLE) {
                mAmbientIndicationContainer.getLocationOnScreen(mTmpInt2);
                float viewX = screenX - mTmpInt2[0];
                float viewY = screenY - mTmpInt2[1];
                if (0 <= viewX && viewX <= mAmbientIndicationContainer.getWidth()
                        && 0 <= viewY && viewY <= mAmbientIndicationContainer.getHeight()) {
                    dispatchTap(mAmbientIndicationContainer, viewX, viewY);
                }
            }
        }

        @Override
        public void setDozeScreenBrightness(int value) {
            mStatusBarWindowController.setDozeScreenBrightness(value);
        }

        @Override
        public void setAodDimmingScrim(float scrimOpacity) {
            mScrimController.setAodFrontScrimAlpha(scrimOpacity);
        }

        @Override
        public void prepareForGentleWakeUp() {
            mScrimController.prepareForGentleWakeUp();
        }

        private void dispatchTap(View view, float x, float y) {
            long now = SystemClock.elapsedRealtime();
            dispatchTouchEvent(view, x, y, now, MotionEvent.ACTION_DOWN);
            dispatchTouchEvent(view, x, y, now, MotionEvent.ACTION_UP);
        }

        private void dispatchTouchEvent(View view, float x, float y, long now, int action) {
            MotionEvent ev = MotionEvent.obtain(now, now, action, x, y, 0 /* meta */);
            view.dispatchTouchEvent(ev);
            ev.recycle();
        }

        private boolean shouldAnimateWakeup() {
            return mAnimateWakeup;
        }

        public boolean shouldAnimateScreenOff() {
            return mAnimateScreenOff;
        }
    }

","[1.0, 1.0]"
1044,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,"[(137, 138, 2), (137, 138, 2)]","
        updateResources();
","
        updateResources();
","
        updateResources();
","[1.0, 1.0]"
1045,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ScreenRotationAnimation.java,"[(455, 457, 3), (455, 457, 3)]","        if (mPerf != null && mIsPerfLockAcquired) {
            mPerf.perfLockRelease();
            mIsPerfLockAcquired = false;
","        if (mPerf != null && mIsPerfLockAcquired) {
            mPerf.perfLockRelease();
            mIsPerfLockAcquired = false;
","        if (mPerf != null && mIsPerfLockAcquired) {
            mPerf.perfLockRelease();
            mIsPerfLockAcquired = false;
","[1.0, 1.0]"
1046,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ScreenRotationAnimation.java,"[(499, 509, 11), (499, 509, 11)]","            if (mPerf != null && mIsPerfLockAcquired) {
                mPerf.perfLockRelease();
                mIsPerfLockAcquired = false;
            }
        }

        if (!mMoreRotateEnter) {
            if (mRotateEnterAnimation != null) {
                mRotateEnterAnimation.cancel();
                mRotateEnterAnimation = null;
                mRotateEnterTransformation.clear();
","            if (mPerf != null && mIsPerfLockAcquired) {
                mPerf.perfLockRelease();
                mIsPerfLockAcquired = false;
            }
        }

        if (!mMoreRotateEnter) {
            if (mRotateEnterAnimation != null) {
                mRotateEnterAnimation.cancel();
                mRotateEnterAnimation = null;
                mRotateEnterTransformation.clear();
","            if (mPerf != null && mIsPerfLockAcquired) {
                mPerf.perfLockRelease();
                mIsPerfLockAcquired = false;
            }
        }

        if (!mMoreRotateEnter) {
            if (mRotateEnterAnimation != null) {
                mRotateEnterAnimation.cancel();
                mRotateEnterAnimation = null;
                mRotateEnterTransformation.clear();
","[1.0, 1.0]"
1047,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ScreenRotationAnimation.java,"[(577, 582, 6), (577, 582, 6)]","            mAnimRunning = true;
            mHalfwayPoint = now + mRotateEnterAnimation.getDuration() / 2;
            if (mPerf != null && !mIsPerfLockAcquired) {
                mPerf.perfHint(BoostFramework.VENDOR_HINT_ROTATION_ANIM_BOOST, null);
                mIsPerfLockAcquired = true;
            }
","            mAnimRunning = true;
            mHalfwayPoint = now + mRotateEnterAnimation.getDuration() / 2;
            if (mPerf != null && !mIsPerfLockAcquired) {
                mPerf.perfHint(BoostFramework.VENDOR_HINT_ROTATION_ANIM_BOOST, null);
                mIsPerfLockAcquired = true;
            }
","            mAnimRunning = true;
            mHalfwayPoint = now + mRotateEnterAnimation.getDuration() / 2;
            if (mPerf != null && !mIsPerfLockAcquired) {
                mPerf.perfHint(BoostFramework.VENDOR_HINT_ROTATION_ANIM_BOOST, null);
                mIsPerfLockAcquired = true;
            }
","[1.0, 1.0]"
1048,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/net/ConnectivityManager.java,"[(476, 480, 5), (476, 480, 5)]","     * WIGIG tethering type. Use a separate type to prevent
     * conflicts with TETHERING_WIFI
     * @hide
     */
    public static final int TETHERING_WIGIG = 3;
","     * WIGIG tethering type. Use a separate type to prevent
     * conflicts with TETHERING_WIFI
     * @hide
     */
    public static final int TETHERING_WIGIG = 3;
","     * WIGIG tethering type. Use a separate type to prevent
     * conflicts with TETHERING_WIFI
     * @hide
     */
    public static final int TETHERING_WIGIG = 3;
","[1.0, 1.0]"
1049,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiInfo.java,"[(727, 729, 3), (727, 729, 3)]","                .append("", Wifi Generation: "").append(mWifiGeneration)
                .append("", TWT support: "").append(mTwtSupport)
                .append("", Eight Max VHT Spatial streams support: "").append(mVhtMax8SpatialStreamsSupport)
","                .append("", Wifi Generation: "").append(mWifiGeneration)
                .append("", TWT support: "").append(mTwtSupport)
                .append("", Eight Max VHT Spatial streams support: "").append(mVhtMax8SpatialStreamsSupport)
","                .append("", Wifi Generation: "").append(mWifiGeneration)
                .append("", TWT support: "").append(mTwtSupport)
                .append("", Eight Max VHT Spatial streams support: "").append(mVhtMax8SpatialStreamsSupport)
","[1.0, 1.0]"
1050,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiInfo.java,"[(785, 787, 3), (785, 787, 3)]","        dest.writeInt(mWifiGeneration);
        dest.writeInt(mVhtMax8SpatialStreamsSupport ? 1 : 0);
        dest.writeInt(mTwtSupport ? 1 : 0);
","        dest.writeInt(mWifiGeneration);
        dest.writeInt(mVhtMax8SpatialStreamsSupport ? 1 : 0);
        dest.writeInt(mTwtSupport ? 1 : 0);
","        dest.writeInt(mWifiGeneration);
        dest.writeInt(mVhtMax8SpatialStreamsSupport ? 1 : 0);
        dest.writeInt(mTwtSupport ? 1 : 0);
","[1.0, 1.0]"
1051,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiInfo.java,"[(829, 831, 3), (829, 831, 3)]","                info.mWifiGeneration = in.readInt();
                info.mVhtMax8SpatialStreamsSupport = in.readInt() != 0;
                info.mTwtSupport = in.readInt() != 0;
","                info.mWifiGeneration = in.readInt();
                info.mVhtMax8SpatialStreamsSupport = in.readInt() != 0;
                info.mTwtSupport = in.readInt() != 0;
","                info.mWifiGeneration = in.readInt();
                info.mVhtMax8SpatialStreamsSupport = in.readInt() != 0;
                info.mTwtSupport = in.readInt() != 0;
","[1.0, 1.0]"
1052,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', '8d21ad0d966c1e9f96e5a65144efad2582391957']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(266, 266, 1), (209, 209, 1)]","public final class ActivityRecord extends ConfigurationContainer {
","public final class ActivityRecord extends ConfigurationContainer implements AppWindowContainerListener {
",public final class ActivityRecord extends ConfigurationContainer ,"[0.97, 0.619]"
1053,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(929, 944, 16), (931, 945, 15)]","                } break;
                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
","                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
","                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
","[0.976, 1.0]"
1054,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3238, 3239, 2), (3473, 3475, 3)]","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
        if (DEBUG_MODE) { Log.v(TAG, ""setMode(mode="" + mode + "", callingPackage="" + callingPackage + "")""); }
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
","[1.0, 0.578]"
1055,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'b576b28ececdf87e488eaf196c28e48371784746']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/BtHelper.java,"[(268, 336, 69), (239, 307, 69)]","    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

","    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

","    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

","[1.0, 1.0]"
1056,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1868, 1870, 3), (1978, 1979, 2)]","    public boolean addNmeaListener(GpsStatus.NmeaListener listener) {
        android.util.SeempLog.record(44);
        return false;
","    public boolean addNmeaListener(GpsStatus.NmeaListener listener) {
        android.util.SeempLog.record(44);
","    public boolean addNmeaListener(GpsStatus.NmeaListener listener) {
        android.util.SeempLog.record(44);
","[0.836, 1.0]"
1057,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiInfo.java,"[(727, 729, 3), (788, 791, 4)]","                .append("", Wifi Generation: "").append(mWifiGeneration)
                .append("", TWT support: "").append(mTwtSupport)
                .append("", Eight Max VHT Spatial streams support: "").append(mVhtMax8SpatialStreamsSupport)
","                .append("", Wifi Generation: "").append(mWifiGeneration)
                .append("", TWT support: "").append(mTwtSupport)
                .append("", Eight Max VHT Spatial streams support: "").append(mVhtMax8SpatialStreamsSupport)
                .append("", Wi-Fi technology: "").append(mWifiTechnology)
","                .append("", Wifi Generation: "").append(mWifiGeneration)
                .append("", TWT support: "").append(mTwtSupport)
                .append("", Eight Max VHT Spatial streams support: "").append(mVhtMax8SpatialStreamsSupport)
","[1.0, 0.77]"
1058,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiInfo.java,"[(785, 787, 3), (847, 850, 4)]","        dest.writeInt(mWifiGeneration);
        dest.writeInt(mVhtMax8SpatialStreamsSupport ? 1 : 0);
        dest.writeInt(mTwtSupport ? 1 : 0);
","        dest.writeInt(mWifiGeneration);
        dest.writeInt(mVhtMax8SpatialStreamsSupport ? 1 : 0);
        dest.writeInt(mTwtSupport ? 1 : 0);
        dest.writeInt(mWifiTechnology);
","        dest.writeInt(mWifiGeneration);
        dest.writeInt(mVhtMax8SpatialStreamsSupport ? 1 : 0);
        dest.writeInt(mTwtSupport ? 1 : 0);
","[1.0, 0.785]"
1059,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiInfo.java,"[(829, 831, 3), (892, 895, 4)]","                info.mWifiGeneration = in.readInt();
                info.mVhtMax8SpatialStreamsSupport = in.readInt() != 0;
                info.mTwtSupport = in.readInt() != 0;
","                info.mWifiGeneration = in.readInt();
                info.mVhtMax8SpatialStreamsSupport = in.readInt() != 0;
                info.mTwtSupport = in.readInt() != 0;
                info.mWifiTechnology = in.readInt();
","                info.mWifiGeneration = in.readInt();
                info.mVhtMax8SpatialStreamsSupport = in.readInt() != 0;
                info.mTwtSupport = in.readInt() != 0;
","[1.0, 0.772]"
1060,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1875, 1883, 9), (1799, 1807, 9)]","        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        CHALLENGE_NONE, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","        VerifyCredentialResponse response = doVerifyCredential(credential, type,
                                        false, 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
",", 0, userId, progressCallback);
        if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&
                                           (userId == UserHandle.USER_OWNER)) {
                //TODO(b/127810705): Update to credentials to use byte[]
                String credentialString = credential == null ? null : new String(credential);
                retainPassword(credentialString);
        }
        return response;
","[0.768, 0.78]"
1061,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3238, 3239, 2), (3226, 3228, 3)]","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
        if (DEBUG_MODE) { Log.v(TAG, ""setMode(mode="" + mode + "", callingPackage="" + callingPackage + "")""); }
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
","[1.0, 0.578]"
1062,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/BtHelper.java,"[(268, 336, 69), (268, 338, 71)]","    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

","    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

    // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
    @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
","    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

","[1.0, 0.962]"
1063,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(221, 223, 3), (220, 223, 4)]","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
","        synchronized (mDeviceStateLock) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
","[1.0, 0.787]"
1064,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(339, 342, 4), (341, 345, 5)]","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isBluetoothScoOnForApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","        synchronized (mDeviceStateLock) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isBluetoothScoOnForApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isBluetoothScoOnForApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","[1.0, 0.814]"
1065,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(348, 350, 3), (351, 354, 4)]","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
        synchronized (mDeviceStateLock) {
","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
","[1.0, 0.741]"
1066,"['7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java,"[(120, 121, 2), (121, 121, 1)]","    private EmergencyCarrierArea mEmergencyCarrierArea;
    private final UnlockMethodCache mUnlockMethodCache;
","    private EmergencyCarrierArea mEmergencyCarrierArea;
","    private EmergencyCarrierArea mEmergencyCarrierArea;
","[0.5, 1.0]"
1067,"['7fe8671fd7b5388dd9be6295dbea6d31209468f9', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']","['aospa-ruby-SAP-block_text', 'omnirom-10-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(336, 429, 94), (336, 429, 94)]","    /** @hide */
    public static final int QOS_UNAVAILABLE = 77;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 78;
    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 79;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 80;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 81;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 82;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 84;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 85;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 86;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 87;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 88;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 89;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 90;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 91;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 93;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 94;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 95;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 96;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 97;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 98;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 99;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 100;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 101;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 102;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 103;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 105;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 106;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 107;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 108;
    /** @hide */
    public static final int CALL_REJECTED = 109;
    /** @hide */
    public static final int NUMBER_CHANGED = 110;
    /** @hide */
    public static final int PREEMPTION = 111;
    /** @hide */
    public static final int FACILITY_REJECTED = 112;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 113;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 114;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 115;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 116;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 117;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 118;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 119;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 120;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 121;
","    /** @hide */
    public static final int QOS_UNAVAILABLE = 77;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 78;
    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 79;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 80;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 81;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 82;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 84;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 85;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 86;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 87;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 88;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 89;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 90;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 91;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 93;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 94;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 95;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 96;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 97;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 98;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 99;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 100;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 101;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 102;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 103;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 105;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 106;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 107;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 108;
    /** @hide */
    public static final int CALL_REJECTED = 109;
    /** @hide */
    public static final int NUMBER_CHANGED = 110;
    /** @hide */
    public static final int PREEMPTION = 111;
    /** @hide */
    public static final int FACILITY_REJECTED = 112;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 113;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 114;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 115;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 116;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 117;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 118;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 119;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 120;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 121;
","    /** @hide */
    public static final int QOS_UNAVAILABLE = 77;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 78;
    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 79;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 80;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 81;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 82;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 84;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 85;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 86;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 87;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 88;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 89;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 90;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 91;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 93;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 94;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 95;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 96;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 97;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 98;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 99;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 100;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 101;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 102;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 103;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 105;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 106;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 107;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 108;
    /** @hide */
    public static final int CALL_REJECTED = 109;
    /** @hide */
    public static final int NUMBER_CHANGED = 110;
    /** @hide */
    public static final int PREEMPTION = 111;
    /** @hide */
    public static final int FACILITY_REJECTED = 112;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 113;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 114;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 115;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 116;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 117;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 118;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 119;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 120;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 121;
","[1.0, 1.0]"
1068,"['7fe8671fd7b5388dd9be6295dbea6d31209468f9', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']","['aospa-ruby-SAP-block_text', 'omnirom-10-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(642, 705, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
1069,"['7fe8671fd7b5388dd9be6295dbea6d31209468f9', '7fe8671fd7b5388dd9be6295dbea6d31209468f9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(336, 429, 94), (336, 429, 94)]","    /** @hide */
    public static final int QOS_UNAVAILABLE = 77;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 78;
    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 79;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 80;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 81;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 82;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 84;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 85;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 86;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 87;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 88;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 89;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 90;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 91;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 93;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 94;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 95;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 96;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 97;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 98;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 99;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 100;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 101;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 102;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 103;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 105;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 106;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 107;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 108;
    /** @hide */
    public static final int CALL_REJECTED = 109;
    /** @hide */
    public static final int NUMBER_CHANGED = 110;
    /** @hide */
    public static final int PREEMPTION = 111;
    /** @hide */
    public static final int FACILITY_REJECTED = 112;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 113;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 114;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 115;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 116;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 117;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 118;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 119;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 120;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 121;
","    /** @hide */
    public static final int QOS_UNAVAILABLE = 77;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 78;
    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 79;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 80;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 81;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 82;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 84;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 85;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 86;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 87;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 88;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 89;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 90;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 91;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 93;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 94;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 95;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 96;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 97;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 98;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 99;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 100;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 101;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 102;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 103;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 105;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 106;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 107;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 108;
    /** @hide */
    public static final int CALL_REJECTED = 109;
    /** @hide */
    public static final int NUMBER_CHANGED = 110;
    /** @hide */
    public static final int PREEMPTION = 111;
    /** @hide */
    public static final int FACILITY_REJECTED = 112;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 113;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 114;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 115;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 116;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 117;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 118;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 119;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 120;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 121;
","    /** @hide */
    public static final int QOS_UNAVAILABLE = 77;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 78;
    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 79;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 80;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 81;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 82;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 84;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 85;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 86;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 87;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 88;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 89;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 90;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 91;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 93;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 94;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 95;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 96;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 97;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 98;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 99;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 100;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 101;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 102;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 103;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 105;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 106;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 107;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 108;
    /** @hide */
    public static final int CALL_REJECTED = 109;
    /** @hide */
    public static final int NUMBER_CHANGED = 110;
    /** @hide */
    public static final int PREEMPTION = 111;
    /** @hide */
    public static final int FACILITY_REJECTED = 112;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 113;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 114;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 115;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 116;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 117;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 118;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 119;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 120;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 121;
","[1.0, 1.0]"
1070,"['7fe8671fd7b5388dd9be6295dbea6d31209468f9', '7fe8671fd7b5388dd9be6295dbea6d31209468f9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(642, 705, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
1071,"['7fe8671fd7b5388dd9be6295dbea6d31209468f9', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(642, 705, 64), (593, 656, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
1072,"['7fe8671fd7b5388dd9be6295dbea6d31209468f9', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(642, 705, 64), (570, 633, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
1073,"['7fe8671fd7b5388dd9be6295dbea6d31209468f9', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(336, 429, 94), (336, 429, 94)]","    /** @hide */
    public static final int QOS_UNAVAILABLE = 77;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 78;
    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 79;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 80;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 81;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 82;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 84;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 85;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 86;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 87;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 88;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 89;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 90;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 91;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 93;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 94;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 95;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 96;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 97;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 98;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 99;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 100;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 101;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 102;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 103;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 105;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 106;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 107;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 108;
    /** @hide */
    public static final int CALL_REJECTED = 109;
    /** @hide */
    public static final int NUMBER_CHANGED = 110;
    /** @hide */
    public static final int PREEMPTION = 111;
    /** @hide */
    public static final int FACILITY_REJECTED = 112;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 113;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 114;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 115;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 116;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 117;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 118;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 119;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 120;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 121;
","    /** @hide */
    public static final int QOS_UNAVAILABLE = 77;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 78;
    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 79;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 80;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 81;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 82;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 84;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 85;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 86;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 87;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 88;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 89;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 90;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 91;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 93;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 94;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 95;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 96;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 97;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 98;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 99;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 100;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 101;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 102;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 103;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 105;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 106;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 107;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 108;
    /** @hide */
    public static final int CALL_REJECTED = 109;
    /** @hide */
    public static final int NUMBER_CHANGED = 110;
    /** @hide */
    public static final int PREEMPTION = 111;
    /** @hide */
    public static final int FACILITY_REJECTED = 112;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 113;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 114;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 115;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 116;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 117;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 118;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 119;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 120;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 121;
","    /** @hide */
    public static final int QOS_UNAVAILABLE = 77;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = 78;
    /** @hide */
    public static final int INCOMING_CALLS_BARRED_WITHIN_CUG = 79;
    /** @hide */
    public static final int BEARER_CAPABILITY_UNAVAILABLE = 80;
    /** @hide */
    public static final int SERVICE_OPTION_NOT_AVAILABLE = 81;
    /** @hide */
    public static final int BEARER_SERVICE_NOT_IMPLEMENTED = 82;
    /** @hide */
    public static final int REQUESTED_FACILITY_NOT_IMPLEMENTED = 83;
    /** @hide */
    public static final int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 84;
    /** @hide */
    public static final int SERVICE_OR_OPTION_NOT_IMPLEMENTED = 85;
    /** @hide */
    public static final int INVALID_TRANSACTION_IDENTIFIER = 86;
    /** @hide */
    public static final int USER_NOT_MEMBER_OF_CUG = 87;
    /** @hide */
    public static final int INCOMPATIBLE_DESTINATION = 88;
    /** @hide */
    public static final int INVALID_TRANSIT_NW_SELECTION = 89;
    /** @hide */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = 90;
    /** @hide */
    public static final int INVALID_MANDATORY_INFORMATION = 91;
    /** @hide */
    public static final int MESSAGE_TYPE_NON_IMPLEMENTED = 92;
    /** @hide */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 93;
    /** @hide */
    public static final int INFORMATION_ELEMENT_NON_EXISTENT = 94;
    /** @hide */
    public static final int CONDITIONAL_IE_ERROR = 95;
    /** @hide */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 96;
    /** @hide */
    public static final int RECOVERY_ON_TIMER_EXPIRED = 97;
    /** @hide */
    public static final int PROTOCOL_ERROR_UNSPECIFIED = 98;
    /** @hide */
    public static final int INTERWORKING_UNSPECIFIED = 99;
    /** @hide */
    public static final int LOCAL_LOW_BATTERY = 100;
    /** @hide */
    public static final int NO_CIRCUIT_AVAIL = 101;
    /** @hide */
    public static final int NO_ROUTE_TO_DESTINATION = 102;
    /** @hide */
    public static final int OPERATOR_DETERMINED_BARRING = 103;
    /** @hide */
    public static final int CALL_FAIL_NO_USER_RESPONDING = 104;
    /** @hide */
    public static final int CALL_FAIL_NO_ANSWER_FROM_USER = 105;
    /** @hide */
    public static final int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 106;
    /** @hide */
    public static final int BEARER_CAPABILITY_NOT_AUTHORIZED = 107;
    /** @hide */
    public static final int CHANNEL_UNACCEPTABLE = 108;
    /** @hide */
    public static final int CALL_REJECTED = 109;
    /** @hide */
    public static final int NUMBER_CHANGED = 110;
    /** @hide */
    public static final int PREEMPTION = 111;
    /** @hide */
    public static final int FACILITY_REJECTED = 112;
    /** @hide */
    public static final int RESP_TO_STATUS_ENQUIRY = 113;
    /** @hide */
    public static final int NETWORK_OUT_OF_ORDER = 114;
    /** @hide */
    public static final int TEMPORARY_FAILURE = 115;
    /** @hide */
    public static final int SWITCHING_EQUIPMENT_CONGESTION = 116;
    /** @hide */
    public static final int ACCESS_INFORMATION_DISCARDED = 117;
    /** @hide */
    public static final int REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 118;
    /** @hide */
    public static final int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 119;

    /**
     * call failed due to LTE to 3G/2G handover not feasible
     * @hide
     */
    public static final int HO_NOT_FEASIBLE = 120;
    /** @hide */
    public static final int NON_SELECTED_USER_CLEARING = 121;
","[1.0, 1.0]"
1074,"['7fe8671fd7b5388dd9be6295dbea6d31209468f9', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/DisconnectCause.java,"[(642, 705, 64), (642, 705, 64)]","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","        case NETWORK_OUT_OF_ORDER:
            return ""NETWORK_OUT_OF_ORDER"";
        case TEMPORARY_FAILURE:
            return ""TEMPORARY_FAILURE"";
        case SWITCHING_EQUIPMENT_CONGESTION:
            return ""SWITCHING_EQUIPMENT_CONGESTION"";
        case ACCESS_INFORMATION_DISCARDED:
            return ""ACCESS_INFORMATION_DISCARDED"";
        case REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE:
            return ""REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE"";
        case RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
            return ""RESOURCES_UNAVAILABLE_OR_UNSPECIFIED"";
        case QOS_UNAVAILABLE:
            return ""QOS_UNAVAILABLE"";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return ""REQUESTED_FACILITY_NOT_SUBSCRIBED"";
        case INCOMING_CALLS_BARRED_WITHIN_CUG:
            return ""INCOMING_CALLS_BARRED_WITHIN_CUG"";
        case BEARER_CAPABILITY_UNAVAILABLE:
            return ""BEARER_CAPABILITY_UNAVAILABLE"";
        case SERVICE_OPTION_NOT_AVAILABLE:
            return ""SERVICE_OPTION_NOT_AVAILABLE"";
        case BEARER_SERVICE_NOT_IMPLEMENTED:
            return ""BEARER_SERVICE_NOT_IMPLEMENTED"";
        case REQUESTED_FACILITY_NOT_IMPLEMENTED:
            return ""REQUESTED_FACILITY_NOT_IMPLEMENTED"";
        case ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
            return ""ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE"";
        case SERVICE_OR_OPTION_NOT_IMPLEMENTED:
            return ""SERVICE_OR_OPTION_NOT_IMPLEMENTED"";
        case INVALID_TRANSACTION_IDENTIFIER:
            return ""INVALID_TRANSACTION_IDENTIFIER"";
        case USER_NOT_MEMBER_OF_CUG:
            return ""USER_NOT_MEMBER_OF_CUG"";
        case INCOMPATIBLE_DESTINATION:
            return ""INCOMPATIBLE_DESTINATION"";
        case INVALID_TRANSIT_NW_SELECTION:
            return ""INVALID_TRANSIT_NW_SELECTION"";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return ""SEMANTICALLY_INCORRECT_MESSAGE"";
        case INVALID_MANDATORY_INFORMATION:
            return ""INVALID_MANDATORY_INFORMATION"";
        case MESSAGE_TYPE_NON_IMPLEMENTED:
            return ""MESSAGE_TYPE_NON_IMPLEMENTED"";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case INFORMATION_ELEMENT_NON_EXISTENT:
            return ""INFORMATION_ELEMENT_NON_EXISTENT"";
        case CONDITIONAL_IE_ERROR:
            return ""CONDITIONAL_IE_ERROR"";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return ""MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE"";
        case RECOVERY_ON_TIMER_EXPIRED:
            return ""RECOVERY_ON_TIMER_EXPIRED"";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return ""PROTOCOL_ERROR_UNSPECIFIED"";
        case INTERWORKING_UNSPECIFIED:
            return ""INTERWORKING_UNSPECIFIED"";
        case LOCAL_LOW_BATTERY:
            return ""LOCAL_LOW_BATTERY"";
        case HO_NOT_FEASIBLE:
            return ""HO_NOT_FEASIBLE"";
        case NON_SELECTED_USER_CLEARING:
            return ""NON_SELECTED_USER_CLEARING"";
","[1.0, 1.0]"
1076,"['82ca638edd627c1b70aae1505f06c8ddaef731d2', '82ca638edd627c1b70aae1505f06c8ddaef731d2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1308, 1310, 3), (1308, 1310, 3)]","        if (isBluetoothAvailableForBinding() == false) {
            Slog.w(TAG, ""bindBluetoothProfileService:Trying to bind to profile: ""
                       + bluetoothProfile + "", while Bluetooth is disabled"");
","        if (isBluetoothAvailableForBinding() == false) {
            Slog.w(TAG, ""bindBluetoothProfileService:Trying to bind to profile: ""
                       + bluetoothProfile + "", while Bluetooth is disabled"");
","        if (isBluetoothAvailableForBinding() == false) {
            Slog.w(TAG, ""bindBluetoothProfileService:Trying to bind to profile: ""
                       + bluetoothProfile + "", while Bluetooth is disabled"");
","[1.0, 1.0]"
1077,"['82ca638edd627c1b70aae1505f06c8ddaef731d2', 'd1ffad806502fc4ff57f88b4eb543cc81fc601a1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1308, 1310, 3), (1308, 1310, 3)]","        if (isBluetoothAvailableForBinding() == false) {
            Slog.w(TAG, ""bindBluetoothProfileService:Trying to bind to profile: ""
                       + bluetoothProfile + "", while Bluetooth is disabled"");
","        if (isBluetoothAvailableForBinding() == false) {
            Slog.w(TAG, ""bindBluetoothProfileService:Trying to bind to profile: ""
                       + bluetoothProfile + "", while Bluetooth is disabled"");
","        if (isBluetoothAvailableForBinding() == false) {
            Slog.w(TAG, ""bindBluetoothProfileService:Trying to bind to profile: ""
                       + bluetoothProfile + "", while Bluetooth is disabled"");
","[1.0, 1.0]"
1078,"['89ca8eb6845aeb5da5c69c25c3fb5c31e0d827d7', '89ca8eb6845aeb5da5c69c25c3fb5c31e0d827d7']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/TelephonyManager.java,"[(13107, 13112, 6), (13107, 13112, 6)]","            // This is a temporary change awaiting a proper rework from Google (b/156203930).
            // Just log the exception instead of rethrowing as a DeadSystemException, which causes
            // framework reboot. Keeping the original code around since we do not know the actual
            // motive of putting this here in the first place.
            Log.e(TAG, ""notifyUserActivity RemoteException"", e);
            // throw e.rethrowFromSystemServer();
","            // This is a temporary change awaiting a proper rework from Google (b/156203930).
            // Just log the exception instead of rethrowing as a DeadSystemException, which causes
            // framework reboot. Keeping the original code around since we do not know the actual
            // motive of putting this here in the first place.
            Log.e(TAG, ""notifyUserActivity RemoteException"", e);
            // throw e.rethrowFromSystemServer();
","            // This is a temporary change awaiting a proper rework from Google (b/156203930).
            // Just log the exception instead of rethrowing as a DeadSystemException, which causes
            // framework reboot. Keeping the original code around since we do not know the actual
            // motive of putting this here in the first place.
            Log.e(TAG, ""notifyUserActivity RemoteException"", e);
            // throw e.rethrowFromSystemServer();
","[1.0, 1.0]"
1080,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(56, 56, 1), (52, 52, 1)]","import java.io.BufferedReader;
","import java.io.BufferedReader;
","import java.io.BufferedReader;
","[1.0, 1.0]"
1081,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '6e44ad255823e1b7f2b23386d61af655c19adb49']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(695, 695, 1), (599, 599, 1)]","                                    subject, cpuInfo, finalStack, null);
","                                subject, null, finalStack, null);
","                                subject, ","[0.562, 0.621]"
1082,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 22, 4), (19, 22, 4)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_","[0.7, 0.943]"
1083,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiEnterpriseConfig.java,"[(96, 97, 2), (96, 97, 2)]","    /** @hide */
    public static final String KEY_SIMNUM          = ""sim_num"";
","    /** @hide */
    public static final String KEY_SIMNUM          = ""sim_num"";
","    /** @hide */
    public static final String KEY_SIMNUM          = ""sim_num"";
","[1.0, 1.0]"
1084,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(3502, 3513, 12), (3502, 3513, 12)]","                    satisfiesMobileMultiNetworkDataCheck(nai.networkCapabilities,
                       nri.request.networkCapabilities) &&
                    (nai.isSatisfyingRequest(nri.request.requestId)
                    // Note that canPossiblyBeat catches two important cases:
                    // 1. Unvalidated slow networks will not be reaped when an unvalidated fast
                    // network is currently satisfying the request. This is desirable for example
                    // when cellular ends up validating but WiFi/Ethernet does not.
                    // 2. Fast networks will not be reaped when a validated slow network is
                    // currently satisfying the request. This is desirable for example when
                    // Ethernet ends up validating and out scoring WiFi, or WiFi/Ethernet ends
                    // up validating and out scoring cellular.
                            || nai.canPossiblyBeat(nri.mSatisfier))) {
","                    satisfiesMobileMultiNetworkDataCheck(nai.networkCapabilities,
                       nri.request.networkCapabilities) &&
                    (nai.isSatisfyingRequest(nri.request.requestId)
                    // Note that canPossiblyBeat catches two important cases:
                    // 1. Unvalidated slow networks will not be reaped when an unvalidated fast
                    // network is currently satisfying the request. This is desirable for example
                    // when cellular ends up validating but WiFi/Ethernet does not.
                    // 2. Fast networks will not be reaped when a validated slow network is
                    // currently satisfying the request. This is desirable for example when
                    // Ethernet ends up validating and out scoring WiFi, or WiFi/Ethernet ends
                    // up validating and out scoring cellular.
                            || nai.canPossiblyBeat(nri.mSatisfier))) {
","                    satisfiesMobileMultiNetworkDataCheck(nai.networkCapabilities,
                       nri.request.networkCapabilities) &&
                    (nai.isSatisfyingRequest(nri.request.requestId)
                    // Note that canPossiblyBeat catches two important cases:
                    // 1. Unvalidated slow networks will not be reaped when an unvalidated fast
                    // network is currently satisfying the request. This is desirable for example
                    // when cellular ends up validating but WiFi/Ethernet does not.
                    // 2. Fast networks will not be reaped when a validated slow network is
                    // currently satisfying the request. This is desirable for example when
                    // Ethernet ends up validating and out scoring WiFi, or WiFi/Ethernet ends
                    // up validating and out scoring cellular.
                            || nai.canPossiblyBeat(nri.mSatisfier))) {
","[1.0, 1.0]"
1085,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(56, 56, 1), (56, 56, 1)]","import java.io.BufferedReader;
","import java.io.BufferedReader;
","import java.io.BufferedReader;
","[1.0, 1.0]"
1086,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(593, 594, 2), (593, 594, 2)]","                            initialStack = ActivityManagerService.dumpStackTraces(pids,
                                    null, null, getInterestingNativePids());
","                            initialStack = ActivityManagerService.dumpStackTraces(pids,
                                    null, null, getInterestingNativePids());
","                            initialStack = ActivityManagerService.dumpStackTraces(pids,
                                    null, null, getInterestingNativePids());
","[1.0, 1.0]"
1087,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(621, 622, 2), (621, 622, 2)]","            final File finalStack = ActivityManagerService.dumpStackTraces(
                    pids, processCpuTracker, new SparseArray<>(), getInterestingNativePids());
","            final File finalStack = ActivityManagerService.dumpStackTraces(
                    pids, processCpuTracker, new SparseArray<>(), getInterestingNativePids());
","            final File finalStack = ActivityManagerService.dumpStackTraces(
                    pids, processCpuTracker, new SparseArray<>(), getInterestingNativePids());
","[1.0, 1.0]"
1088,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(695, 695, 1), (695, 695, 1)]","                                    subject, cpuInfo, finalStack, null);
","                                    subject, cpuInfo, finalStack, null);
","                                    subject, cpuInfo, finalStack, null);
","[1.0, 1.0]"
1089,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(208, 208, 1), (208, 208, 1)]","public class ActivityStack extends Task implements BoundsAnimationTarget {
","public class ActivityStack extends Task implements BoundsAnimationTarget {
","public class ActivityStack extends Task implements BoundsAnimationTarget {
","[1.0, 1.0]"
1090,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(5830, 5843, 14), (5830, 5843, 14)]","    public int isAppInfoGame() {
        int isGame = 0;
        if (info.applicationInfo != null) {
            isGame = (info.applicationInfo.category == ApplicationInfo.CATEGORY_GAME ||
                      (info.applicationInfo.flags & ApplicationInfo.FLAG_IS_GAME) == ApplicationInfo.FLAG_IS_GAME) ? 1 : 0;
        }
        return isGame;
    }

    @Override
    boolean isChangingAppTransition() {
        return task != null ? task.isChangingAppTransition() : super.isChangingAppTransition();
    }

","    public int isAppInfoGame() {
        int isGame = 0;
        if (info.applicationInfo != null) {
            isGame = (info.applicationInfo.category == ApplicationInfo.CATEGORY_GAME ||
                      (info.applicationInfo.flags & ApplicationInfo.FLAG_IS_GAME) == ApplicationInfo.FLAG_IS_GAME) ? 1 : 0;
        }
        return isGame;
    }

    @Override
    boolean isChangingAppTransition() {
        return task != null ? task.isChangingAppTransition() : super.isChangingAppTransition();
    }

","    public int isAppInfoGame() {
        int isGame = 0;
        if (info.applicationInfo != null) {
            isGame = (info.applicationInfo.category == ApplicationInfo.CATEGORY_GAME ||
                      (info.applicationInfo.flags & ApplicationInfo.FLAG_IS_GAME) == ApplicationInfo.FLAG_IS_GAME) ? 1 : 0;
        }
        return isGame;
    }

    @Override
    boolean isChangingAppTransition() {
        return task != null ? task.isChangingAppTransition() : super.isChangingAppTransition();
    }

","[1.0, 1.0]"
1091,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ProcessRecord.java,"[(70, 70, 1), (70, 70, 1)]","import com.android.server.Watchdog;
","import com.android.server.Watchdog;
","import com.android.server.Watchdog;
","[1.0, 1.0]"
1092,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,"[(191, 193, 3), (191, 193, 3)]","        mDumpController = dumpController;

        updateResources();
","        mDumpController = dumpController;

        updateResources();
","        mDumpController = dumpController;

        updateResources();
","[1.0, 1.0]"
1093,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java,"[(84, 85, 2), (84, 85, 2)]","import com.android.systemui.Dependency;
import com.android.systemui.DumpController;
","import com.android.systemui.Dependency;
import com.android.systemui.DumpController;
","import com.android.systemui.Dependency;
import com.android.systemui.DumpController;
","[1.0, 1.0]"
1094,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/view/SurfaceControl.java,"[(873, 874, 2), (873, 874, 2)]","        // TODO(b/150410543) Re-enable CloseGuard.
        //mCloseGuard.open(""release"");
","        // TODO(b/150410543) Re-enable CloseGuard.
        //mCloseGuard.open(""release"");
","        // TODO(b/150410543) Re-enable CloseGuard.
        //mCloseGuard.open(""release"");
","[1.0, 1.0]"
1095,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 22, 4), (19, 22, 4)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","[1.0, 1.0]"
1096,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java,"[(190, 191, 2), (190, 191, 2)]","        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        broadcastDispatcher.registerReceiverWithHandler(mIntentReceiver, filter, mHandler);
","        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        broadcastDispatcher.registerReceiverWithHandler(mIntentReceiver, filter, mHandler);
","        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        broadcastDispatcher.registerReceiverWithHandler(mIntentReceiver, filter, mHandler);
","[1.0, 1.0]"
1097,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(93, 93, 1), (93, 93, 1)]","    @SystemApi
","    @SystemApi
","    @SystemApi
","[1.0, 1.0]"
1098,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(220, 227, 8), (220, 227, 8)]","        @SystemApi
        public static final int FILS_SHA384 = 16;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        @SystemApi
        public static final int DPP = 17;
","        @SystemApi
        public static final int FILS_SHA384 = 16;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        @SystemApi
        public static final int DPP = 17;
","        @SystemApi
        public static final int FILS_SHA384 = 16;
        /**
         * Device Provisioning Protocol
         * @hide
         */
        @SystemApi
        public static final int DPP = 17;
","[1.0, 1.0]"
1099,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(234, 234, 1), (234, 234, 1)]","                ""WAPI_PSK"", ""WAPI_CERT"", ""FILS_SHA256"", ""FILS_SHA384"", ""DPP"", };
","                ""WAPI_PSK"", ""WAPI_CERT"", ""FILS_SHA256"", ""FILS_SHA384"", ""DPP"", };
","                ""WAPI_PSK"", ""WAPI_CERT"", ""FILS_SHA256"", ""FILS_SHA384"", ""DPP"", };
","[1.0, 1.0]"
1100,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2637, 2638, 2), (2637, 2638, 2)]","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","[1.0, 1.0]"
1101,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/ScanResult.java,"[(214, 221, 8), (214, 221, 8)]","     * Security key management scheme: DPP.
     */
    public static final int KEY_MGMT_DPP = 15;
    /**
     * @hide
     * Security key management scheme: FILS_SHA256.
     */
    public static final int KEY_MGMT_FILS_SHA256 = 16;
","     * Security key management scheme: DPP.
     */
    public static final int KEY_MGMT_DPP = 15;
    /**
     * @hide
     * Security key management scheme: FILS_SHA256.
     */
    public static final int KEY_MGMT_FILS_SHA256 = 16;
","     * Security key management scheme: DPP.
     */
    public static final int KEY_MGMT_DPP = 15;
    /**
     * @hide
     * Security key management scheme: FILS_SHA256.
     */
    public static final int KEY_MGMT_FILS_SHA256 = 16;
","[1.0, 1.0]"
1102,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/ScanResult.java,"[(226, 226, 1), (226, 226, 1)]","    public static final int KEY_MGMT_FILS_SHA384 = 17;
","    public static final int KEY_MGMT_FILS_SHA384 = 17;
","    public static final int KEY_MGMT_FILS_SHA384 = 17;
","[1.0, 1.0]"
1103,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,"[(130, 131, 2), (130, 131, 2)]","                    || !mHasMobileData);
        String wifiDesc = wifiVisible ? mCurrentState.ssid : null;
","                    || !mHasMobileData);
        String wifiDesc = wifiVisible ? mCurrentState.ssid : null;
","                    || !mHasMobileData);
        String wifiDesc = wifiVisible ? mCurrentState.ssid : null;
","[1.0, 1.0]"
1104,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 22, 4), (19, 21, 3)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_","[0.7, 0.947]"
1105,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', 'b6292e3e1ba3616eac1032737a91925391d94b92']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(593, 594, 2), (592, 595, 4)]","                            initialStack = ActivityManagerService.dumpStackTraces(pids,
                                    null, null, getInterestingNativePids());
","                            ArrayList<Integer> pids = new ArrayList<Integer>();
                            pids.add(Process.myPid());
                            initialStack = ActivityManagerService.dumpStackTraces(pids,
                                    null, null, getInterestingNativePids(), null);
","                            initialStack = ActivityManagerService.dumpStackTraces(pids,
                                    null, null, getInterestingNativePids()","[0.982, 0.529]"
1106,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2637, 2638, 2), (2059, 2060, 2)]","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            return KeyMgmt.DPP;
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            ","[0.626, 0.783]"
1107,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2637, 2638, 2), (2098, 2099, 2)]","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","            } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
                key = SSID + KeyMgmt.strings[KeyMgmt.DPP];
","        } else if (allowedKeyManagement.get(KeyMgmt.DPP)) {
            ","[0.626, 0.585]"
1108,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/ScanResult.java,"[(226, 226, 1), (198, 198, 1)]","    public static final int KEY_MGMT_FILS_SHA384 = 17;
","    public static final int CIPHER_GCMP = 4;
",    public static final int ,"[0.509, 0.622]"
1109,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ProcessRecord.java,"[(70, 70, 1), (69, 69, 1)]","import com.android.server.Watchdog;
","import com.android.server.Watchdog;
","import com.android.server.Watchdog;
","[1.0, 1.0]"
1110,"['8faa0d981413f18b2468dde1b1fe71e248df0df1', 'f6f595c8a4c17ed2347482c43e2cccc89531224e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiEnterpriseConfig.java,"[(96, 97, 2), (97, 97, 1)]","    /** @hide */
    public static final String KEY_SIMNUM          = ""sim_num"";
","    public static final String KEY_SIMNUM          = ""sim_num"";
","    public static final String KEY_SIMNUM          = ""sim_num"";
","[0.79, 1.0]"
1113,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/BluetoothAdapter.java,"[(1238, 1242, 5), (1204, 1207, 4)]","            if (mManagerService != null) {
                SystemProperties.set(""persist.bluetooth.factoryreset"", ""true"");
                return mManagerService.factoryReset();
            }
            Log.e(TAG, ""factoryReset(): IBluetooth Service is null"");
","            if (mManagerService != null) {
                SystemProperties.set(""persist.bluetooth.factoryreset"", ""true"");
                return mManagerService.factoryReset();
            }
","            if (mManagerService != null) {
                SystemProperties.set(""persist.bluetooth.factoryreset"", ""true"");
                return mManagerService.factoryReset();
            }
","[0.733, 1.0]"
1114,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1833, 1833, 1), (1799, 1799, 1)]","                        //     is accomplished by ""waitForMonitoredOnOff(false, true)"".
","                        //     is accomplished by ""waitForMonitoredOnOff(false, true)"".
","                        //     is accomplished by ""waitForMonitoredOnOff(false, true)"".
","[1.0, 1.0]"
1115,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1843, 1853, 11), (1809, 1819, 11)]","                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitForMonitoredOnOff(false, true);
","                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitForMonitoredOnOff(false, true);
","                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitForMonitoredOnOff(false, true);
","[1.0, 1.0]"
1116,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1866, 1885, 20), (1832, 1851, 20)]","                        waitForMonitoredOnOff(true, false);

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
                        mEnable = false;
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
","                        waitForMonitoredOnOff(true, false);

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
                        mEnable = false;
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
","                        waitForMonitoredOnOff(true, false);

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
                        mEnable = false;
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
","[1.0, 1.0]"
1117,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(2017, 2019, 3), (1990, 1992, 3)]","                        waitForMonitoredOnOff(true, false);
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
","                        waitForMonitoredOnOff(true, false);
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
","                        waitForMonitoredOnOff(true, false);
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
","[1.0, 1.0]"
1118,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(2057, 2058, 2), (2030, 2031, 2)]","                            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                            waitForMonitoredOnOff(false, true);
","                            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                            waitForMonitoredOnOff(false, true);
","                            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                            waitForMonitoredOnOff(false, true);
","[1.0, 1.0]"
1119,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1866, 1866, 1), (1832, 1832, 1)]","                        waitForMonitoredOnOff(true, false);
","                        waitForMonitoredOnOff(true, false);
","                        waitForMonitoredOnOff(true, false);
","[1.0, 1.0]"
1120,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1866, 1866, 1), (1819, 1819, 1)]","                        waitForMonitoredOnOff(true, false);
","                            waitForMonitoredOnOff(false, true);
",                        waitForMonitoredOnOff(,"[0.767, 0.719]"
1121,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(2205, 2205, 1), (2181, 2181, 1)]","                        boolean didDisableTimeout = !waitForMonitoredOnOff(false, true);
","                        boolean didDisableTimeout = !waitForMonitoredOnOff(false, true);
","                        boolean didDisableTimeout = !waitForMonitoredOnOff(false, true);
","[1.0, 1.0]"
1122,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(2490, 2550, 61), (2473, 2533, 61)]","            if (on || off) {
                SystemClock.sleep(500);
            } else {
                SystemClock.sleep(30);
            }
            i++;
        }
        Slog.e(TAG,""waitForOnOff time out"");
        return false;
    }

    /**
     *  if on is true, wait for state become ON
     *  if off is true, wait for state become OFF
     *  if both on and off are false, wait for state not ON
     */
    private boolean waitForMonitoredOnOff(boolean on, boolean off) {
        int i = 0;
        while (i < 10) {
            synchronized(mConnection) {
                try {
                    if (mBluetooth == null) break;
                    if (on) {
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_ON) return true;
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_BLE_TURNING_ON,
                                                        BluetoothAdapter.STATE_BLE_ON);
                            if (mBluetoothGatt != null) {
                                Slog.d(TAG,""GattService is connected, execute waitForOnOff"");
                                boolean ret = waitForOnOff(on, off);
                                return ret;
                            } else {
                                Slog.d(TAG,
                                    ""GattService connect in progress, return to avoid timeout"");
                                return true;
                            }
                        }
                    } else if (off) {
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_OFF) return true;
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF,
                                                        BluetoothAdapter.STATE_BLE_ON);
                            boolean ret = waitForOnOff(on, off);
                            return ret;
                        }
                    } else {
                        if (mBluetooth.getState() != BluetoothAdapter.STATE_ON) return true;
                    }
                } catch (RemoteException e) {
                    Slog.e(TAG, ""getState()"", e);
                    break;
                }
            }
            if (on || off) {
                SystemClock.sleep(300);
            } else {
                SystemClock.sleep(50);
            }
            i++;
        }
        Slog.e(TAG,""waitForMonitoredOnOff time out"");
","            if (on || off) {
                SystemClock.sleep(500);
            } else {
                SystemClock.sleep(30);
            }
            i++;
        }
        Slog.e(TAG,""waitForOnOff time out"");
        return false;
    }

    /**
     *  if on is true, wait for state become ON
     *  if off is true, wait for state become OFF
     *  if both on and off are false, wait for state not ON
     */
    private boolean waitForMonitoredOnOff(boolean on, boolean off) {
        int i = 0;
        while (i < 10) {
            synchronized(mConnection) {
                try {
                    if (mBluetooth == null) break;
                    if (on) {
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_ON) return true;
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_BLE_TURNING_ON,
                                                        BluetoothAdapter.STATE_BLE_ON);
                            if (mBluetoothGatt != null) {
                                Slog.d(TAG,""GattService is connected, execute waitForOnOff"");
                                boolean ret = waitForOnOff(on, off);
                                return ret;
                            } else {
                                Slog.d(TAG,
                                    ""GattService connect in progress, return to avoid timeout"");
                                return true;
                            }
                        }
                    } else if (off) {
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_OFF) return true;
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF,
                                                        BluetoothAdapter.STATE_BLE_ON);
                            boolean ret = waitForOnOff(on, off);
                            return ret;
                        }
                    } else {
                        if (mBluetooth.getState() != BluetoothAdapter.STATE_ON) return true;
                    }
                } catch (RemoteException e) {
                    Slog.e(TAG, ""getState()"", e);
                    break;
                }
            }
            if (on || off) {
                SystemClock.sleep(300);
            } else {
                SystemClock.sleep(50);
            }
            i++;
        }
        Slog.e(TAG,""waitForMonitoredOnOff time out"");
","            if (on || off) {
                SystemClock.sleep(500);
            } else {
                SystemClock.sleep(30);
            }
            i++;
        }
        Slog.e(TAG,""waitForOnOff time out"");
        return false;
    }

    /**
     *  if on is true, wait for state become ON
     *  if off is true, wait for state become OFF
     *  if both on and off are false, wait for state not ON
     */
    private boolean waitForMonitoredOnOff(boolean on, boolean off) {
        int i = 0;
        while (i < 10) {
            synchronized(mConnection) {
                try {
                    if (mBluetooth == null) break;
                    if (on) {
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_ON) return true;
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_BLE_TURNING_ON,
                                                        BluetoothAdapter.STATE_BLE_ON);
                            if (mBluetoothGatt != null) {
                                Slog.d(TAG,""GattService is connected, execute waitForOnOff"");
                                boolean ret = waitForOnOff(on, off);
                                return ret;
                            } else {
                                Slog.d(TAG,
                                    ""GattService connect in progress, return to avoid timeout"");
                                return true;
                            }
                        }
                    } else if (off) {
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_OFF) return true;
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF,
                                                        BluetoothAdapter.STATE_BLE_ON);
                            boolean ret = waitForOnOff(on, off);
                            return ret;
                        }
                    } else {
                        if (mBluetooth.getState() != BluetoothAdapter.STATE_ON) return true;
                    }
                } catch (RemoteException e) {
                    Slog.e(TAG, ""getState()"", e);
                    break;
                }
            }
            if (on || off) {
                SystemClock.sleep(300);
            } else {
                SystemClock.sleep(50);
            }
            i++;
        }
        Slog.e(TAG,""waitForMonitoredOnOff time out"");
","[1.0, 1.0]"
1123,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1853, 1853, 1), (1832, 1832, 1)]","                            waitForMonitoredOnOff(false, true);
","                        waitForMonitoredOnOff(true, false);
",                        waitForMonitoredOnOff(,"[0.719, 0.767]"
1124,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1853, 1853, 1), (1819, 1819, 1)]","                            waitForMonitoredOnOff(false, true);
","                            waitForMonitoredOnOff(false, true);
","                            waitForMonitoredOnOff(false, true);
","[1.0, 1.0]"
1125,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/BluetoothAdapter.java,"[(1238, 1242, 5), (1238, 1242, 5)]","            if (mManagerService != null) {
                SystemProperties.set(""persist.bluetooth.factoryreset"", ""true"");
                return mManagerService.factoryReset();
            }
            Log.e(TAG, ""factoryReset(): IBluetooth Service is null"");
","            if (mManagerService != null) {
                SystemProperties.set(""persist.bluetooth.factoryreset"", ""true"");
                return mManagerService.factoryReset();
            }
            Log.e(TAG, ""factoryReset(): IBluetooth Service is null"");
","            if (mManagerService != null) {
                SystemProperties.set(""persist.bluetooth.factoryreset"", ""true"");
                return mManagerService.factoryReset();
            }
            Log.e(TAG, ""factoryReset(): IBluetooth Service is null"");
","[1.0, 1.0]"
1126,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(4190, 4198, 9), (4190, 4198, 9)]","                case EVENT_TIMEOUT_NOTIFICATION:
                    mNotifier.clearNotification(msg.arg1, NotificationType.LOGGED_IN);
                    break;
                case EVENT_UPDATE_TCP_BUFFER_FOR_5G:
                    handleUpdateTCPBuffersfor5G();
                    break;
                case EVENT_UPDATE_ACTIVE_DATA_SUBID:
                    handleUpdateActiveDataSubId(msg.arg1);
                    break;
","                case EVENT_TIMEOUT_NOTIFICATION:
                    mNotifier.clearNotification(msg.arg1, NotificationType.LOGGED_IN);
                    break;
                case EVENT_UPDATE_TCP_BUFFER_FOR_5G:
                    handleUpdateTCPBuffersfor5G();
                    break;
                case EVENT_UPDATE_ACTIVE_DATA_SUBID:
                    handleUpdateActiveDataSubId(msg.arg1);
                    break;
","                case EVENT_TIMEOUT_NOTIFICATION:
                    mNotifier.clearNotification(msg.arg1, NotificationType.LOGGED_IN);
                    break;
                case EVENT_UPDATE_TCP_BUFFER_FOR_5G:
                    handleUpdateTCPBuffersfor5G();
                    break;
                case EVENT_UPDATE_ACTIVE_DATA_SUBID:
                    handleUpdateActiveDataSubId(msg.arg1);
                    break;
","[1.0, 1.0]"
1127,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/content/pm/ApplicationInfo.java,"[(2190, 2190, 1), (2190, 2190, 1)]","    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
","    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
","    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
","[1.0, 1.0]"
1128,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/content/pm/ApplicationInfo.java,"[(2202, 2202, 1), (2202, 2202, 1)]","    /** {@hide} */ public int canOverrideRes() { return overrideRes; }
","    /** {@hide} */ public int canOverrideRes() { return overrideRes; }
","    /** {@hide} */ public int canOverrideRes() { return overrideRes; }
","[1.0, 1.0]"
1129,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1833, 1833, 1), (1833, 1833, 1)]","                        //     is accomplished by ""waitForMonitoredOnOff(false, true)"".
","                        //     is accomplished by ""waitForMonitoredOnOff(false, true)"".
","                        //     is accomplished by ""waitForMonitoredOnOff(false, true)"".
","[1.0, 1.0]"
1130,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1843, 1853, 11), (1843, 1853, 11)]","                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitForMonitoredOnOff(false, true);
","                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitForMonitoredOnOff(false, true);
","                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitForMonitoredOnOff(false, true);
","[1.0, 1.0]"
1131,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1866, 1885, 20), (1866, 1885, 20)]","                        waitForMonitoredOnOff(true, false);

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
                        mEnable = false;
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
","                        waitForMonitoredOnOff(true, false);

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
                        mEnable = false;
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
","                        waitForMonitoredOnOff(true, false);

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
                        mEnable = false;
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
","[1.0, 1.0]"
1132,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(2017, 2019, 3), (2017, 2019, 3)]","                        waitForMonitoredOnOff(true, false);
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
","                        waitForMonitoredOnOff(true, false);
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
","                        waitForMonitoredOnOff(true, false);
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
","[1.0, 1.0]"
1133,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(2057, 2058, 2), (2057, 2058, 2)]","                            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                            waitForMonitoredOnOff(false, true);
","                            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                            waitForMonitoredOnOff(false, true);
","                            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                            waitForMonitoredOnOff(false, true);
","[1.0, 1.0]"
1134,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1866, 1866, 1), (1866, 1866, 1)]","                        waitForMonitoredOnOff(true, false);
","                        waitForMonitoredOnOff(true, false);
","                        waitForMonitoredOnOff(true, false);
","[1.0, 1.0]"
1135,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1866, 1866, 1), (1853, 1853, 1)]","                        waitForMonitoredOnOff(true, false);
","                            waitForMonitoredOnOff(false, true);
",                        waitForMonitoredOnOff(,"[0.767, 0.719]"
1136,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(2205, 2205, 1), (2205, 2205, 1)]","                        boolean didDisableTimeout = !waitForMonitoredOnOff(false, true);
","                        boolean didDisableTimeout = !waitForMonitoredOnOff(false, true);
","                        boolean didDisableTimeout = !waitForMonitoredOnOff(false, true);
","[1.0, 1.0]"
1137,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(2490, 2550, 61), (2490, 2550, 61)]","            if (on || off) {
                SystemClock.sleep(500);
            } else {
                SystemClock.sleep(30);
            }
            i++;
        }
        Slog.e(TAG,""waitForOnOff time out"");
        return false;
    }

    /**
     *  if on is true, wait for state become ON
     *  if off is true, wait for state become OFF
     *  if both on and off are false, wait for state not ON
     */
    private boolean waitForMonitoredOnOff(boolean on, boolean off) {
        int i = 0;
        while (i < 10) {
            synchronized(mConnection) {
                try {
                    if (mBluetooth == null) break;
                    if (on) {
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_ON) return true;
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_BLE_TURNING_ON,
                                                        BluetoothAdapter.STATE_BLE_ON);
                            if (mBluetoothGatt != null) {
                                Slog.d(TAG,""GattService is connected, execute waitForOnOff"");
                                boolean ret = waitForOnOff(on, off);
                                return ret;
                            } else {
                                Slog.d(TAG,
                                    ""GattService connect in progress, return to avoid timeout"");
                                return true;
                            }
                        }
                    } else if (off) {
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_OFF) return true;
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF,
                                                        BluetoothAdapter.STATE_BLE_ON);
                            boolean ret = waitForOnOff(on, off);
                            return ret;
                        }
                    } else {
                        if (mBluetooth.getState() != BluetoothAdapter.STATE_ON) return true;
                    }
                } catch (RemoteException e) {
                    Slog.e(TAG, ""getState()"", e);
                    break;
                }
            }
            if (on || off) {
                SystemClock.sleep(300);
            } else {
                SystemClock.sleep(50);
            }
            i++;
        }
        Slog.e(TAG,""waitForMonitoredOnOff time out"");
","            if (on || off) {
                SystemClock.sleep(500);
            } else {
                SystemClock.sleep(30);
            }
            i++;
        }
        Slog.e(TAG,""waitForOnOff time out"");
        return false;
    }

    /**
     *  if on is true, wait for state become ON
     *  if off is true, wait for state become OFF
     *  if both on and off are false, wait for state not ON
     */
    private boolean waitForMonitoredOnOff(boolean on, boolean off) {
        int i = 0;
        while (i < 10) {
            synchronized(mConnection) {
                try {
                    if (mBluetooth == null) break;
                    if (on) {
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_ON) return true;
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_BLE_TURNING_ON,
                                                        BluetoothAdapter.STATE_BLE_ON);
                            if (mBluetoothGatt != null) {
                                Slog.d(TAG,""GattService is connected, execute waitForOnOff"");
                                boolean ret = waitForOnOff(on, off);
                                return ret;
                            } else {
                                Slog.d(TAG,
                                    ""GattService connect in progress, return to avoid timeout"");
                                return true;
                            }
                        }
                    } else if (off) {
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_OFF) return true;
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF,
                                                        BluetoothAdapter.STATE_BLE_ON);
                            boolean ret = waitForOnOff(on, off);
                            return ret;
                        }
                    } else {
                        if (mBluetooth.getState() != BluetoothAdapter.STATE_ON) return true;
                    }
                } catch (RemoteException e) {
                    Slog.e(TAG, ""getState()"", e);
                    break;
                }
            }
            if (on || off) {
                SystemClock.sleep(300);
            } else {
                SystemClock.sleep(50);
            }
            i++;
        }
        Slog.e(TAG,""waitForMonitoredOnOff time out"");
","            if (on || off) {
                SystemClock.sleep(500);
            } else {
                SystemClock.sleep(30);
            }
            i++;
        }
        Slog.e(TAG,""waitForOnOff time out"");
        return false;
    }

    /**
     *  if on is true, wait for state become ON
     *  if off is true, wait for state become OFF
     *  if both on and off are false, wait for state not ON
     */
    private boolean waitForMonitoredOnOff(boolean on, boolean off) {
        int i = 0;
        while (i < 10) {
            synchronized(mConnection) {
                try {
                    if (mBluetooth == null) break;
                    if (on) {
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_ON) return true;
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_BLE_TURNING_ON,
                                                        BluetoothAdapter.STATE_BLE_ON);
                            if (mBluetoothGatt != null) {
                                Slog.d(TAG,""GattService is connected, execute waitForOnOff"");
                                boolean ret = waitForOnOff(on, off);
                                return ret;
                            } else {
                                Slog.d(TAG,
                                    ""GattService connect in progress, return to avoid timeout"");
                                return true;
                            }
                        }
                    } else if (off) {
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_OFF) return true;
                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF,
                                                        BluetoothAdapter.STATE_BLE_ON);
                            boolean ret = waitForOnOff(on, off);
                            return ret;
                        }
                    } else {
                        if (mBluetooth.getState() != BluetoothAdapter.STATE_ON) return true;
                    }
                } catch (RemoteException e) {
                    Slog.e(TAG, ""getState()"", e);
                    break;
                }
            }
            if (on || off) {
                SystemClock.sleep(300);
            } else {
                SystemClock.sleep(50);
            }
            i++;
        }
        Slog.e(TAG,""waitForMonitoredOnOff time out"");
","[1.0, 1.0]"
1138,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1853, 1853, 1), (1853, 1853, 1)]","                            waitForMonitoredOnOff(false, true);
","                            waitForMonitoredOnOff(false, true);
","                            waitForMonitoredOnOff(false, true);
","[1.0, 1.0]"
1139,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/SoftApConfiguration.java,"[(265, 267, 3), (265, 267, 3)]","            int shutdownTimeoutMillis, boolean clientControlByUser,
            @NonNull List<MacAddress> blockedList, @NonNull List<MacAddress> allowedList,
            @Nullable String oweTransIfaceName) {
","            int shutdownTimeoutMillis, boolean clientControlByUser,
            @NonNull List<MacAddress> blockedList, @NonNull List<MacAddress> allowedList,
            @Nullable String oweTransIfaceName) {
","            int shutdownTimeoutMillis, boolean clientControlByUser,
            @NonNull List<MacAddress> blockedList, @NonNull List<MacAddress> allowedList,
            @Nullable String oweTransIfaceName) {
","[1.0, 1.0]"
1140,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1843, 1853, 11), (1888, 1901, 14)]","                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitForMonitoredOnOff(false, true);
","                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitForState(Set.of(BluetoothAdapter.STATE_OFF));
                        Message restartMsg =
                                mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mHandler.sendMessageDelayed(restartMsg, getServiceRestartMs());
","                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitFor","[0.952, 0.683]"
1141,"['a33382db0bb0bc29bab84f1e5ee36d682bea593e', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1866, 1885, 20), (1911, 1927, 17)]","                        waitForMonitoredOnOff(true, false);

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
                        mEnable = false;
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
","                        waitForState(Set.of(BluetoothAdapter.STATE_ON));

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
",");

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
","[0.812, 0.925]"
1149,"['a9736185db896fe2edde0281d71102b35327b7f8', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(431, 432, 2), (349, 350, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1150,"['a9736185db896fe2edde0281d71102b35327b7f8', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(431, 432, 2), (444, 445, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1151,"['a9736185db896fe2edde0281d71102b35327b7f8', 'a9736185db896fe2edde0281d71102b35327b7f8']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java,"[(706, 719, 14), (706, 719, 14)]","    private void updateHotspotIcon(int standard) {
        if (standard == ScanResult.WIFI_STANDARD_11AX) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_6_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11AC) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_5_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11N) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_4_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        }
","    private void updateHotspotIcon(int standard) {
        if (standard == ScanResult.WIFI_STANDARD_11AX) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_6_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11AC) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_5_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11N) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_4_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        }
","    private void updateHotspotIcon(int standard) {
        if (standard == ScanResult.WIFI_STANDARD_11AX) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_6_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11AC) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_5_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11N) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_4_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        }
","[1.0, 1.0]"
1152,"['a9736185db896fe2edde0281d71102b35327b7f8', 'a9736185db896fe2edde0281d71102b35327b7f8']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(1961, 1971, 11), (1961, 1971, 11)]","            String callingPackage, String caller, int uid) {
        if (DEBUG_VOL) Log.d(TAG, ""adjustStreamVolume() stream="" + streamType + "", dir="" + direction
                + "", flags="" + flags + "", caller="" + caller);

        /* If MirrorLink audio is playing, then disable volume changes */
        String value = SystemProperties.get(""vendor.mls.audio.session.status"", ""default"");
        if (true == value.equals(""started"")){
            Log.e(TAG, ""adjustStreamVolume() Ignore volume change during MirrorLink session"");
            return;
        }

","            String callingPackage, String caller, int uid) {
        if (DEBUG_VOL) Log.d(TAG, ""adjustStreamVolume() stream="" + streamType + "", dir="" + direction
                + "", flags="" + flags + "", caller="" + caller);

        /* If MirrorLink audio is playing, then disable volume changes */
        String value = SystemProperties.get(""vendor.mls.audio.session.status"", ""default"");
        if (true == value.equals(""started"")){
            Log.e(TAG, ""adjustStreamVolume() Ignore volume change during MirrorLink session"");
            return;
        }

","            String callingPackage, String caller, int uid) {
        if (DEBUG_VOL) Log.d(TAG, ""adjustStreamVolume() stream="" + streamType + "", dir="" + direction
                + "", flags="" + flags + "", caller="" + caller);

        /* If MirrorLink audio is playing, then disable volume changes */
        String value = SystemProperties.get(""vendor.mls.audio.session.status"", ""default"");
        if (true == value.equals(""started"")){
            Log.e(TAG, ""adjustStreamVolume() Ignore volume change during MirrorLink session"");
            return;
        }

","[1.0, 1.0]"
1153,"['a9736185db896fe2edde0281d71102b35327b7f8', 'a9736185db896fe2edde0281d71102b35327b7f8']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/CachedAppOptimizer.java,"[(240, 250, 11), (240, 250, 11)]","    public static BoostFramework mPerf = new BoostFramework();

    public CachedAppOptimizer(ActivityManagerService am) {
        mAm = am;
        mCachedAppOptimizerThread = new ServiceThread(""CachedAppOptimizerThread"",
                THREAD_PRIORITY_FOREGROUND, true);
        mProcStateThrottle = new HashSet<>();
        isLowRAM = SystemProperties.getBoolean(""ro.config.low_ram"", false);

        if (isLowRAM == true)
            DEFAULT_USE_COMPACTION = true;
","    public static BoostFramework mPerf = new BoostFramework();

    public CachedAppOptimizer(ActivityManagerService am) {
        mAm = am;
        mCachedAppOptimizerThread = new ServiceThread(""CachedAppOptimizerThread"",
                THREAD_PRIORITY_FOREGROUND, true);
        mProcStateThrottle = new HashSet<>();
        isLowRAM = SystemProperties.getBoolean(""ro.config.low_ram"", false);

        if (isLowRAM == true)
            DEFAULT_USE_COMPACTION = true;
","    public static BoostFramework mPerf = new BoostFramework();

    public CachedAppOptimizer(ActivityManagerService am) {
        mAm = am;
        mCachedAppOptimizerThread = new ServiceThread(""CachedAppOptimizerThread"",
                THREAD_PRIORITY_FOREGROUND, true);
        mProcStateThrottle = new HashSet<>();
        isLowRAM = SystemProperties.getBoolean(""ro.config.low_ram"", false);

        if (isLowRAM == true)
            DEFAULT_USE_COMPACTION = true;
","[1.0, 1.0]"
1154,"['a9736185db896fe2edde0281d71102b35327b7f8', 'a9736185db896fe2edde0281d71102b35327b7f8']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(431, 432, 2), (431, 432, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1155,"['a9736185db896fe2edde0281d71102b35327b7f8', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(431, 432, 2), (371, 372, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1156,"['a9736185db896fe2edde0281d71102b35327b7f8', 'ddc3dc79034f4570388245270b50ddad964c11f0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java,"[(706, 719, 14), (718, 747, 30)]","    private void updateHotspotIcon(int standard) {
        if (standard == ScanResult.WIFI_STANDARD_11AX) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_6_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11AC) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_5_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11N) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_4_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        }
","
    @Override
    public void onMediaDataLoaded(String key, MediaData data) {
        updateMediaIcon();
    }

    @Override
    public void onMediaDataRemoved(String key) {
        updateMediaIcon();
    }

    private void updateMediaIcon() {
        mIconController.setIconVisibility(mSlotMedia, mMediaDataManager.hasActiveMedia());
    }

    private void updateHotspotIcon(int standard) {
        if (standard == ScanResult.WIFI_STANDARD_11AX) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_6_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11AC) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_5_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11N) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_4_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        }
    }
","    private void updateHotspotIcon(int standard) {
        if (standard == ScanResult.WIFI_STANDARD_11AX) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_6_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11AC) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_5_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11N) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_4_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        }
","[1.0, 0.725]"
1157,"['a9736185db896fe2edde0281d71102b35327b7f8', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(431, 432, 2), (398, 399, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1161,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', '799030b703da27e7117eba75c2ca753b0e976a8d']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(1843, 1851, 9), (1851, 1862, 12)]","    private static int getSecurity(ScanResult result) {
        if (result.capabilities.contains(""DPP"")) {
            return SECURITY_DPP;
        } else if (result.capabilities.contains(""WEP"")) {
            return SECURITY_WEP;
        } else if (result.capabilities.contains(""PSK"")
                   && result.capabilities.contains(""SAE"")) {
            return SECURITY_PSK_SAE_TRANSITION;
        } else if (result.capabilities.contains(""SAE"")) {
","    private static int getSecurity(ScanResult result) {
        if (result.capabilities.contains(""DPP"")) {
            return SECURITY_DPP;
        } else if (result.capabilities.contains(""WEP"")) {
            return SECURITY_WEP;
        } else if (checkForSaeTransitionMode(result)) {
            if (isWpa3SaeSupported()) {
                return SECURITY_SAE;
            } else {
                return SECURITY_PSK;
            }
        } else if (result.capabilities.contains(""SAE"")) {
","    private static int getSecurity(ScanResult result) {
        if (result.capabilities.contains(""DPP"")) {
            return SECURITY_DPP;
        } else if (result.capabilities.contains(""WEP"")) {
            return SECURITY_WEP;
        } else if (","[0.552, 0.506]"
1162,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityMetricsLogger.java,"[(81, 81, 1), (81, 81, 1)]","import android.util.BoostFramework;
","import android.util.BoostFramework;
","import android.util.BoostFramework;
","[1.0, 1.0]"
1163,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityMetricsLogger.java,"[(426, 431, 6), (426, 431, 6)]","        final boolean otherWindowModesLaunching =
                mWindowingModeTransitionInfo.size() > 0 && info == null;
        if ((!isLoggableResultCode(resultCode) || launchedActivity == null
                || windowingMode == WINDOWING_MODE_UNDEFINED) && !otherWindowModesLaunching) {
            // Failed to launch or it was not a process switch, so we don't care about the timing.
            abort(info, ""failed to launch or not a process switch"");
","        final boolean otherWindowModesLaunching =
                mWindowingModeTransitionInfo.size() > 0 && info == null;
        if ((!isLoggableResultCode(resultCode) || launchedActivity == null
                || windowingMode == WINDOWING_MODE_UNDEFINED) && !otherWindowModesLaunching) {
            // Failed to launch or it was not a process switch, so we don't care about the timing.
            abort(info, ""failed to launch or not a process switch"");
","        final boolean otherWindowModesLaunching =
                mWindowingModeTransitionInfo.size() > 0 && info == null;
        if ((!isLoggableResultCode(resultCode) || launchedActivity == null
                || windowingMode == WINDOWING_MODE_UNDEFINED) && !otherWindowModesLaunching) {
            // Failed to launch or it was not a process switch, so we don't care about the timing.
            abort(info, ""failed to launch or not a process switch"");
","[1.0, 1.0]"
1164,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityMetricsLogger.java,"[(703, 732, 30), (703, 732, 30)]","    private void logAppTransitionMultiEvents() {
        if (DEBUG_METRICS) Slog.i(TAG, ""logging transition events"");
        for (int index = mWindowingModeTransitionInfo.size() - 1; index >= 0; index--) {
            final WindowingModeTransitionInfo info = mWindowingModeTransitionInfo.valueAt(index);
            final int type = getTransitionType(info);
            if (type == INVALID_TRANSITION_TYPE) {
                if (DEBUG_METRICS) {
                    Slog.i(TAG, ""invalid transition type""
                            + "" processRunning="" + info.currentTransitionProcessRunning
                            + "" startResult="" + info.startResult);
                }
                return;
            }

            mLaunchedActivity = info.launchedActivity;

            // Take a snapshot of the transition info before sending it to the handler for logging.
            // This will avoid any races with other operations that modify the ActivityRecord.
            final WindowingModeTransitionInfoSnapshot infoSnapshot =
                     new WindowingModeTransitionInfoSnapshot(info);
            final int currentTransitionDeviceUptime = mCurrentTransitionDeviceUptime;
            final int currentTransitionDelayMs = mCurrentTransitionDelayMs;
            BackgroundThread.getHandler().post(() -> logAppTransition(
                    currentTransitionDeviceUptime, currentTransitionDelayMs, infoSnapshot));
            BackgroundThread.getHandler().post(() -> logAppDisplayed(infoSnapshot));
            if (info.pendingFullyDrawn != null) {
                info.pendingFullyDrawn.run();
            }

            info.launchedActivity.info.launchToken = null;
","    private void logAppTransitionMultiEvents() {
        if (DEBUG_METRICS) Slog.i(TAG, ""logging transition events"");
        for (int index = mWindowingModeTransitionInfo.size() - 1; index >= 0; index--) {
            final WindowingModeTransitionInfo info = mWindowingModeTransitionInfo.valueAt(index);
            final int type = getTransitionType(info);
            if (type == INVALID_TRANSITION_TYPE) {
                if (DEBUG_METRICS) {
                    Slog.i(TAG, ""invalid transition type""
                            + "" processRunning="" + info.currentTransitionProcessRunning
                            + "" startResult="" + info.startResult);
                }
                return;
            }

            mLaunchedActivity = info.launchedActivity;

            // Take a snapshot of the transition info before sending it to the handler for logging.
            // This will avoid any races with other operations that modify the ActivityRecord.
            final WindowingModeTransitionInfoSnapshot infoSnapshot =
                     new WindowingModeTransitionInfoSnapshot(info);
            final int currentTransitionDeviceUptime = mCurrentTransitionDeviceUptime;
            final int currentTransitionDelayMs = mCurrentTransitionDelayMs;
            BackgroundThread.getHandler().post(() -> logAppTransition(
                    currentTransitionDeviceUptime, currentTransitionDelayMs, infoSnapshot));
            BackgroundThread.getHandler().post(() -> logAppDisplayed(infoSnapshot));
            if (info.pendingFullyDrawn != null) {
                info.pendingFullyDrawn.run();
            }

            info.launchedActivity.info.launchToken = null;
","    private void logAppTransitionMultiEvents() {
        if (DEBUG_METRICS) Slog.i(TAG, ""logging transition events"");
        for (int index = mWindowingModeTransitionInfo.size() - 1; index >= 0; index--) {
            final WindowingModeTransitionInfo info = mWindowingModeTransitionInfo.valueAt(index);
            final int type = getTransitionType(info);
            if (type == INVALID_TRANSITION_TYPE) {
                if (DEBUG_METRICS) {
                    Slog.i(TAG, ""invalid transition type""
                            + "" processRunning="" + info.currentTransitionProcessRunning
                            + "" startResult="" + info.startResult);
                }
                return;
            }

            mLaunchedActivity = info.launchedActivity;

            // Take a snapshot of the transition info before sending it to the handler for logging.
            // This will avoid any races with other operations that modify the ActivityRecord.
            final WindowingModeTransitionInfoSnapshot infoSnapshot =
                     new WindowingModeTransitionInfoSnapshot(info);
            final int currentTransitionDeviceUptime = mCurrentTransitionDeviceUptime;
            final int currentTransitionDelayMs = mCurrentTransitionDelayMs;
            BackgroundThread.getHandler().post(() -> logAppTransition(
                    currentTransitionDeviceUptime, currentTransitionDelayMs, infoSnapshot));
            BackgroundThread.getHandler().post(() -> logAppDisplayed(infoSnapshot));
            if (info.pendingFullyDrawn != null) {
                info.pendingFullyDrawn.run();
            }

            info.launchedActivity.info.launchToken = null;
","[1.0, 1.0]"
1165,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(6524, 6545, 22), (6524, 6545, 22)]","        // Second pass: process all listens.
        if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
            // If the network went from background to foreground or vice versa, we need to update
            // its foreground state. It is safe to do this after rematching the requests because
            // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
            // capability and does not affect the network's score (see the Slog.wtf call above).
            updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
        } else {
            processListenRequests(newNetwork, false);
        }

        if ((satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities) == false) &&
             !newNetwork.isVPN()) {
            // Force trigger permission change on non-DDS network to close all live connections
            try {
                mNMS.setNetworkPermission(newNetwork.network.netId,
                                           INetd.PERMISSION_NETWORK);
            } catch (RemoteException e) {
                loge(""Exception in setNetworkPermission: "" + e);
            }
        }
        // do this after the default net is switched, but
","        // Second pass: process all listens.
        if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
            // If the network went from background to foreground or vice versa, we need to update
            // its foreground state. It is safe to do this after rematching the requests because
            // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
            // capability and does not affect the network's score (see the Slog.wtf call above).
            updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
        } else {
            processListenRequests(newNetwork, false);
        }

        if ((satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities) == false) &&
             !newNetwork.isVPN()) {
            // Force trigger permission change on non-DDS network to close all live connections
            try {
                mNMS.setNetworkPermission(newNetwork.network.netId,
                                           INetd.PERMISSION_NETWORK);
            } catch (RemoteException e) {
                loge(""Exception in setNetworkPermission: "" + e);
            }
        }
        // do this after the default net is switched, but
","        // Second pass: process all listens.
        if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
            // If the network went from background to foreground or vice versa, we need to update
            // its foreground state. It is safe to do this after rematching the requests because
            // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
            // capability and does not affect the network's score (see the Slog.wtf call above).
            updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
        } else {
            processListenRequests(newNetwork, false);
        }

        if ((satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities) == false) &&
             !newNetwork.isVPN()) {
            // Force trigger permission change on non-DDS network to close all live connections
            try {
                mNMS.setNetworkPermission(newNetwork.network.netId,
                                           INetd.PERMISSION_NETWORK);
            } catch (RemoteException e) {
                loge(""Exception in setNetworkPermission: "" + e);
            }
        }
        // do this after the default net is switched, but
","[1.0, 1.0]"
1166,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(931, 945, 15), (931, 945, 15)]","                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
","                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
","                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
","[1.0, 1.0]"
1167,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(999, 999, 1), (999, 999, 1)]","    private static final int MSG_L_SCOCLIENT_DIED = 33;
","    private static final int MSG_L_SCOCLIENT_DIED = 33;
","    private static final int MSG_L_SCOCLIENT_DIED = 33;
","[1.0, 1.0]"
1168,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(15147, 15149, 3), (15147, 15149, 3)]","        if (DEBUG_INSTALL) Slog.d(TAG, ""New package installed in "" + pkg.codePath);
        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
","        if (DEBUG_INSTALL) Slog.d(TAG, ""New package installed in "" + pkg.codePath);
        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
","        if (DEBUG_INSTALL) Slog.d(TAG, ""New package installed in "" + pkg.codePath);
        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
","[1.0, 1.0]"
1169,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStackSupervisor.java,"[(181, 200, 20), (181, 200, 20)]","    static final int TOP_RESUMED_STATE_LOSS_TIMEOUT = 500;

    static final int IDLE_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG;
    static final int IDLE_NOW_MSG = FIRST_SUPERVISOR_STACK_MSG + 1;
    static final int RESUME_TOP_ACTIVITY_MSG = FIRST_SUPERVISOR_STACK_MSG + 2;
    static final int SLEEP_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 3;
    static final int LAUNCH_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 4;

    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = new BoostFramework();
    public BoostFramework mUxPerf = new BoostFramework();

    static final int LAUNCH_TASK_BEHIND_COMPLETE = FIRST_SUPERVISOR_STACK_MSG + 12;
    static final int RESTART_ACTIVITY_PROCESS_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 13;
    static final int REPORT_MULTI_WINDOW_MODE_CHANGED_MSG = FIRST_SUPERVISOR_STACK_MSG + 14;
    static final int REPORT_PIP_MODE_CHANGED_MSG = FIRST_SUPERVISOR_STACK_MSG + 15;
    static final int REPORT_HOME_CHANGED_MSG = FIRST_SUPERVISOR_STACK_MSG + 16;
    static final int TOP_RESUMED_STATE_LOSS_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 17;
","    static final int TOP_RESUMED_STATE_LOSS_TIMEOUT = 500;

    static final int IDLE_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG;
    static final int IDLE_NOW_MSG = FIRST_SUPERVISOR_STACK_MSG + 1;
    static final int RESUME_TOP_ACTIVITY_MSG = FIRST_SUPERVISOR_STACK_MSG + 2;
    static final int SLEEP_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 3;
    static final int LAUNCH_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 4;

    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = new BoostFramework();
    public BoostFramework mUxPerf = new BoostFramework();

    static final int LAUNCH_TASK_BEHIND_COMPLETE = FIRST_SUPERVISOR_STACK_MSG + 12;
    static final int RESTART_ACTIVITY_PROCESS_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 13;
    static final int REPORT_MULTI_WINDOW_MODE_CHANGED_MSG = FIRST_SUPERVISOR_STACK_MSG + 14;
    static final int REPORT_PIP_MODE_CHANGED_MSG = FIRST_SUPERVISOR_STACK_MSG + 15;
    static final int REPORT_HOME_CHANGED_MSG = FIRST_SUPERVISOR_STACK_MSG + 16;
    static final int TOP_RESUMED_STATE_LOSS_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 17;
","    static final int TOP_RESUMED_STATE_LOSS_TIMEOUT = 500;

    static final int IDLE_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG;
    static final int IDLE_NOW_MSG = FIRST_SUPERVISOR_STACK_MSG + 1;
    static final int RESUME_TOP_ACTIVITY_MSG = FIRST_SUPERVISOR_STACK_MSG + 2;
    static final int SLEEP_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 3;
    static final int LAUNCH_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 4;

    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = new BoostFramework();
    public BoostFramework mUxPerf = new BoostFramework();

    static final int LAUNCH_TASK_BEHIND_COMPLETE = FIRST_SUPERVISOR_STACK_MSG + 12;
    static final int RESTART_ACTIVITY_PROCESS_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 13;
    static final int REPORT_MULTI_WINDOW_MODE_CHANGED_MSG = FIRST_SUPERVISOR_STACK_MSG + 14;
    static final int REPORT_PIP_MODE_CHANGED_MSG = FIRST_SUPERVISOR_STACK_MSG + 15;
    static final int REPORT_HOME_CHANGED_MSG = FIRST_SUPERVISOR_STACK_MSG + 16;
    static final int TOP_RESUMED_STATE_LOSS_TIMEOUT_MSG = FIRST_SUPERVISOR_STACK_MSG + 17;
","[1.0, 1.0]"
1170,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(201, 202, 2), (201, 202, 2)]","public class ActivityStack extends WindowContainer<Task> implements BoundsAnimationTarget,
        ConfigurationContainerListener {
","public class ActivityStack extends WindowContainer<Task> implements BoundsAnimationTarget,
        ConfigurationContainerListener {
","public class ActivityStack extends WindowContainer<Task> implements BoundsAnimationTarget,
        ConfigurationContainerListener {
","[1.0, 1.0]"
1171,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(978, 979, 2), (978, 979, 2)]","    public ActivityRecord topRunningActivityLocked() {
        return topRunningActivityLocked(false /* focusableOnly */);
","    public ActivityRecord topRunningActivityLocked() {
        return topRunningActivityLocked(false /* focusableOnly */);
","    public ActivityRecord topRunningActivityLocked() {
        return topRunningActivityLocked(false /* focusableOnly */);
","[1.0, 1.0]"
1172,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(4679, 4684, 6), (4679, 4684, 6)]","            mStackSupervisor.updateHomeProcess(task.getChildAt(0).app);
            try {
                mStackSupervisor.new PreferredAppsTask().execute();
            } catch (Exception e) {
                Slog.v (TAG, ""Exception: "" + e);
            }
","            mStackSupervisor.updateHomeProcess(task.getChildAt(0).app);
            try {
                mStackSupervisor.new PreferredAppsTask().execute();
            } catch (Exception e) {
                Slog.v (TAG, ""Exception: "" + e);
            }
","            mStackSupervisor.updateHomeProcess(task.getChildAt(0).app);
            try {
                mStackSupervisor.new PreferredAppsTask().execute();
            } catch (Exception e) {
                Slog.v (TAG, ""Exception: "" + e);
            }
","[1.0, 1.0]"
1173,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(578, 588, 11), (578, 588, 11)]","    /**
     * How long between a process kill and we actually receive its death recipient
     */
    private static final long PROC_KILL_TIMEOUT = 5000; // 5 seconds;

    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
    public static boolean mForceStopKill = false;

","    /**
     * How long between a process kill and we actually receive its death recipient
     */
    private static final long PROC_KILL_TIMEOUT = 5000; // 5 seconds;

    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
    public static boolean mForceStopKill = false;

","    /**
     * How long between a process kill and we actually receive its death recipient
     */
    private static final long PROC_KILL_TIMEOUT = 5000; // 5 seconds;

    /* Freq Aggr boost objects */
    public static BoostFramework mPerfServiceStartHint = null;
    /* UX perf event object */
    public static BoostFramework mUxPerf = new BoostFramework();
    public static boolean mForceStopKill = false;

","[1.0, 1.0]"
1174,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(215, 218, 4), (215, 218, 4)]","    public static final int SECURITY_PSK_SAE_TRANSITION = 7;
    public static final int SECURITY_OWE_TRANSITION = 8;
    public static final int SECURITY_DPP = 9;
    public static final int SECURITY_MAX_VAL = 10; // Has to be the last
","    public static final int SECURITY_PSK_SAE_TRANSITION = 7;
    public static final int SECURITY_OWE_TRANSITION = 8;
    public static final int SECURITY_DPP = 9;
    public static final int SECURITY_MAX_VAL = 10; // Has to be the last
","    public static final int SECURITY_PSK_SAE_TRANSITION = 7;
    public static final int SECURITY_OWE_TRANSITION = 8;
    public static final int SECURITY_DPP = 9;
    public static final int SECURITY_MAX_VAL = 10; // Has to be the last
","[1.0, 1.0]"
1175,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(1811, 1812, 2), (1811, 1812, 2)]","        boolean wpa3TransitionMode = result.capabilities.contains(""PSK"")
                                         && result.capabilities.contains(""SAE"");
","        boolean wpa3TransitionMode = result.capabilities.contains(""PSK"")
                                         && result.capabilities.contains(""SAE"");
","        boolean wpa3TransitionMode = result.capabilities.contains(""PSK"")
                                         && result.capabilities.contains(""SAE"");
","[1.0, 1.0]"
1176,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(1843, 1851, 9), (1843, 1851, 9)]","    private static int getSecurity(ScanResult result) {
        if (result.capabilities.contains(""DPP"")) {
            return SECURITY_DPP;
        } else if (result.capabilities.contains(""WEP"")) {
            return SECURITY_WEP;
        } else if (result.capabilities.contains(""PSK"")
                   && result.capabilities.contains(""SAE"")) {
            return SECURITY_PSK_SAE_TRANSITION;
        } else if (result.capabilities.contains(""SAE"")) {
","    private static int getSecurity(ScanResult result) {
        if (result.capabilities.contains(""DPP"")) {
            return SECURITY_DPP;
        } else if (result.capabilities.contains(""WEP"")) {
            return SECURITY_WEP;
        } else if (result.capabilities.contains(""PSK"")
                   && result.capabilities.contains(""SAE"")) {
            return SECURITY_PSK_SAE_TRANSITION;
        } else if (result.capabilities.contains(""SAE"")) {
","    private static int getSecurity(ScanResult result) {
        if (result.capabilities.contains(""DPP"")) {
            return SECURITY_DPP;
        } else if (result.capabilities.contains(""WEP"")) {
            return SECURITY_WEP;
        } else if (result.capabilities.contains(""PSK"")
                   && result.capabilities.contains(""SAE"")) {
            return SECURITY_PSK_SAE_TRANSITION;
        } else if (result.capabilities.contains(""SAE"")) {
","[1.0, 1.0]"
1177,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"[(33, 34, 2), (33, 34, 2)]","import android.bluetooth.BluetoothDun;
import android.bluetooth.BluetoothSap;
","import android.bluetooth.BluetoothDun;
import android.bluetooth.BluetoothSap;
","import android.bluetooth.BluetoothDun;
import android.bluetooth.BluetoothSap;
","[1.0, 1.0]"
1178,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"[(488, 492, 5), (488, 492, 5)]","            if ((BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.HSP_AG) &&
                    BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP)) ||
                    (BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.Handsfree_AG) &&
                            BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree)) ||
                    (mHeadsetProfile.getConnectionStatus(device) == BluetoothProfile.STATE_CONNECTED)) {
","            if ((BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.HSP_AG) &&
                    BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP)) ||
                    (BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.Handsfree_AG) &&
                            BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree)) ||
                    (mHeadsetProfile.getConnectionStatus(device) == BluetoothProfile.STATE_CONNECTED)) {
","            if ((BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.HSP_AG) &&
                    BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP)) ||
                    (BluetoothUuid.isUuidPresent(localUuids, BluetoothUuid.Handsfree_AG) &&
                            BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree)) ||
                    (mHeadsetProfile.getConnectionStatus(device) == BluetoothProfile.STATE_CONNECTED)) {
","[1.0, 1.0]"
1179,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"[(505, 510, 6), (505, 510, 6)]","        if (mA2dpProfile != null) {
            if (BluetoothUuid.containsAnyUuid(uuids, A2dpProfile.SINK_UUIDS) ||
                (mA2dpProfile.getConnectionStatus(device) == BluetoothProfile.STATE_CONNECTED)) {
                profiles.add(mA2dpProfile);
                removedProfiles.remove(mA2dpProfile);
            }
","        if (mA2dpProfile != null) {
            if (BluetoothUuid.containsAnyUuid(uuids, A2dpProfile.SINK_UUIDS) ||
                (mA2dpProfile.getConnectionStatus(device) == BluetoothProfile.STATE_CONNECTED)) {
                profiles.add(mA2dpProfile);
                removedProfiles.remove(mA2dpProfile);
            }
","        if (mA2dpProfile != null) {
            if (BluetoothUuid.containsAnyUuid(uuids, A2dpProfile.SINK_UUIDS) ||
                (mA2dpProfile.getConnectionStatus(device) == BluetoothProfile.STATE_CONNECTED)) {
                profiles.add(mA2dpProfile);
                removedProfiles.remove(mA2dpProfile);
            }
","[1.0, 1.0]"
1180,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/BluetoothCodecConfig.java,"[(44, 56, 13), (44, 56, 13)]","    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 4;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_LDAC = 5;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_APTX_TWSP = 6;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_MAX = 7;
    /* CELT is not an A2DP Codec and only used to fetch encoder
    ** format for BA usecase, moving out of a2dp codec value list
    */
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_CELT = 8;
","    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 4;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_LDAC = 5;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_APTX_TWSP = 6;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_MAX = 7;
    /* CELT is not an A2DP Codec and only used to fetch encoder
    ** format for BA usecase, moving out of a2dp codec value list
    */
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_CELT = 8;
","    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 4;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_LDAC = 5;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_APTX_TWSP = 6;
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_MAX = 7;
    /* CELT is not an A2DP Codec and only used to fetch encoder
    ** format for BA usecase, moving out of a2dp codec value list
    */
    @UnsupportedAppUsage
    public static final int SOURCE_CODEC_TYPE_CELT = 8;
","[1.0, 1.0]"
1181,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/ScanResult.java,"[(526, 535, 10), (526, 535, 10)]","    public boolean is60GHz() {
        return ScanResult.is60GHz(frequency);
    }

    /**
     * @hide
     * TODO: makes real freq boundaries
     */
    public static boolean is60GHz(int freq) {
        return freq >= 58320 && freq <= 70200;
","    public boolean is60GHz() {
        return ScanResult.is60GHz(frequency);
    }

    /**
     * @hide
     * TODO: makes real freq boundaries
     */
    public static boolean is60GHz(int freq) {
        return freq >= 58320 && freq <= 70200;
","    public boolean is60GHz() {
        return ScanResult.is60GHz(frequency);
    }

    /**
     * @hide
     * TODO: makes real freq boundaries
     */
    public static boolean is60GHz(int freq) {
        return freq >= 58320 && freq <= 70200;
","[1.0, 1.0]"
1182,"['ae1b3a8f3221dbe692fd90d414cfe5040538c264', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"[(33, 34, 2), (33, 33, 1)]","import android.bluetooth.BluetoothDun;
import android.bluetooth.BluetoothSap;
","import android.bluetooth.BluetoothDun;
","import android.bluetooth.BluetoothDun;
","[0.5, 1.0]"
1187,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1648, 1649, 2), (1148, 1149, 2)]","        android.util.SeempLog.record(45);
        checkPendingIntent(intent);
","            PendingIntent intent) {
        android.util.SeempLog.record(45);
","        android.util.SeempLog.record(45);
","[0.538, 0.538]"
1188,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/NetworkControllerBaseTest.java,"[(416, 417, 2), (343, 344, 2)]","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","[1.0, 1.0]"
1189,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/NetworkControllerBaseTest.java,"[(450, 452, 3), (343, 344, 2)]","                ArgumentCaptor.forClass(Integer.class).capture(),
                anyString(), anyString(), anyBoolean(),
                anyInt(), eq(roaming));
","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                ArgumentCaptor.forClass(Integer.class).capture(),
                ","[0.506, 0.529]"
1190,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(198, 199, 2), (184, 185, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
1191,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', '88b45c586d461df38b866d529bc98d1dfa3e8838']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 21, 3), (19, 22, 4)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;

","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","[1.0, 0.995]"
1192,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(623, 624, 2), (623, 624, 2)]","    private TelephonyManager mTelephonyManager;
    private SubscriptionManager mSubscriptionManager;
","    private TelephonyManager mTelephonyManager;
    private SubscriptionManager mSubscriptionManager;
","    private TelephonyManager mTelephonyManager;
    private SubscriptionManager mSubscriptionManager;
","[1.0, 1.0]"
1193,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(1022, 1023, 2), (1022, 1023, 2)]","        mSubscriptionManager = SubscriptionManager.from(mContext);
        mTelephonyManager.listen(mPhoneStateListener, LISTEN_ACTIVE_DATA_SUBSCRIPTION_ID_CHANGE);
","        mSubscriptionManager = SubscriptionManager.from(mContext);
        mTelephonyManager.listen(mPhoneStateListener, LISTEN_ACTIVE_DATA_SUBSCRIPTION_ID_CHANGE);
","        mSubscriptionManager = SubscriptionManager.from(mContext);
        mTelephonyManager.listen(mPhoneStateListener, LISTEN_ACTIVE_DATA_SUBSCRIPTION_ID_CHANGE);
","[1.0, 1.0]"
1194,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(6620, 6654, 35), (6620, 6654, 35)]","                // If ""newNetwork"" is listed as satisfying ""nri"" but no longer satisfies ""nri"",
                // mark it as no longer satisfying ""nri"".  Because networks are processed by
                // rematchAllNetworksAndRequests() in descending score order, ""currentNetwork"" will
                // match ""newNetwork"" before this loop will encounter a ""currentNetwork"" with higher
                // score than ""newNetwork"" and where ""currentNetwork"" no longer satisfies ""nri"".
                // This means this code doesn't have to handle the case where ""currentNetwork"" no
                // longer satisfies ""nri"" when ""currentNetwork"" does not equal ""newNetwork"".
                if (DBG) {
                    log(""Network "" + newNetwork.name() + "" stopped satisfying"" +
                            "" request "" + nri.request.requestId);
                }
                newNetwork.removeRequest(nri.request.requestId);
                if (previousSatisfier == newNetwork) {
                    nri.mSatisfier = null;
                    if (isDefaultRequest(nri)) mDefaultNetworkNai = null;
                    sendUpdatedScoreToFactories(nri.request, null);
                } else {
                    Slog.wtf(TAG, ""BUG: Removing request "" + nri.request.requestId + "" from "" +
                            newNetwork.name() +
                            "" without updating mSatisfier or providers!"");
                }
                // TODO: Technically, sending CALLBACK_LOST here is
                // incorrect if there is a replacement network currently
                // connected that can satisfy nri, which is a request
                // (not a listen). However, the only capability that can both
                // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
                // so this code is only incorrect for a network that loses
                // the TRUSTED capability, which is a rare case.
                // Linger the non-DDS network requests and do not send LOST
                // callback, since ideally callback LOSING is sent if lingering
                if (satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities)) {
                    callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
                } else {
                    newNetwork.lingerRequest(nri.request, now, mNonDefaultSubscriptionLingerDelayMs);
                }
","                // If ""newNetwork"" is listed as satisfying ""nri"" but no longer satisfies ""nri"",
                // mark it as no longer satisfying ""nri"".  Because networks are processed by
                // rematchAllNetworksAndRequests() in descending score order, ""currentNetwork"" will
                // match ""newNetwork"" before this loop will encounter a ""currentNetwork"" with higher
                // score than ""newNetwork"" and where ""currentNetwork"" no longer satisfies ""nri"".
                // This means this code doesn't have to handle the case where ""currentNetwork"" no
                // longer satisfies ""nri"" when ""currentNetwork"" does not equal ""newNetwork"".
                if (DBG) {
                    log(""Network "" + newNetwork.name() + "" stopped satisfying"" +
                            "" request "" + nri.request.requestId);
                }
                newNetwork.removeRequest(nri.request.requestId);
                if (previousSatisfier == newNetwork) {
                    nri.mSatisfier = null;
                    if (isDefaultRequest(nri)) mDefaultNetworkNai = null;
                    sendUpdatedScoreToFactories(nri.request, null);
                } else {
                    Slog.wtf(TAG, ""BUG: Removing request "" + nri.request.requestId + "" from "" +
                            newNetwork.name() +
                            "" without updating mSatisfier or providers!"");
                }
                // TODO: Technically, sending CALLBACK_LOST here is
                // incorrect if there is a replacement network currently
                // connected that can satisfy nri, which is a request
                // (not a listen). However, the only capability that can both
                // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
                // so this code is only incorrect for a network that loses
                // the TRUSTED capability, which is a rare case.
                // Linger the non-DDS network requests and do not send LOST
                // callback, since ideally callback LOSING is sent if lingering
                if (satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities)) {
                    callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
                } else {
                    newNetwork.lingerRequest(nri.request, now, mNonDefaultSubscriptionLingerDelayMs);
                }
","                // If ""newNetwork"" is listed as satisfying ""nri"" but no longer satisfies ""nri"",
                // mark it as no longer satisfying ""nri"".  Because networks are processed by
                // rematchAllNetworksAndRequests() in descending score order, ""currentNetwork"" will
                // match ""newNetwork"" before this loop will encounter a ""currentNetwork"" with higher
                // score than ""newNetwork"" and where ""currentNetwork"" no longer satisfies ""nri"".
                // This means this code doesn't have to handle the case where ""currentNetwork"" no
                // longer satisfies ""nri"" when ""currentNetwork"" does not equal ""newNetwork"".
                if (DBG) {
                    log(""Network "" + newNetwork.name() + "" stopped satisfying"" +
                            "" request "" + nri.request.requestId);
                }
                newNetwork.removeRequest(nri.request.requestId);
                if (previousSatisfier == newNetwork) {
                    nri.mSatisfier = null;
                    if (isDefaultRequest(nri)) mDefaultNetworkNai = null;
                    sendUpdatedScoreToFactories(nri.request, null);
                } else {
                    Slog.wtf(TAG, ""BUG: Removing request "" + nri.request.requestId + "" from "" +
                            newNetwork.name() +
                            "" without updating mSatisfier or providers!"");
                }
                // TODO: Technically, sending CALLBACK_LOST here is
                // incorrect if there is a replacement network currently
                // connected that can satisfy nri, which is a request
                // (not a listen). However, the only capability that can both
                // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
                // so this code is only incorrect for a network that loses
                // the TRUSTED capability, which is a rare case.
                // Linger the non-DDS network requests and do not send LOST
                // callback, since ideally callback LOSING is sent if lingering
                if (satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities)) {
                    callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
                } else {
                    newNetwork.lingerRequest(nri.request, now, mNonDefaultSubscriptionLingerDelayMs);
                }
","[1.0, 1.0]"
1195,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(6658, 6687, 30), (6658, 6687, 30)]","        if (isNewDefault) {
            // restore permission to actual value if it becomes the default network again..
            if (!newNetwork.isVPN()) {
                try {
                    mNMS.setNetworkPermission(newNetwork.network.netId,
                                           getNetworkPermission(newNetwork.networkCapabilities));
                } catch (RemoteException e) {
                    loge(""Exception in setNetworkPermission: "" + e);
                }
            }
            updateDataActivityTracking(newNetwork, oldDefaultNetwork);
            // Notify system services that this network is up.
            makeDefault(newNetwork);
            // Log 0 -> X and Y -> X default network transitions, where X is the new default.
            mDeps.getMetricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(
                    now, newNetwork, oldDefaultNetwork);
            // Have a new default network, release the transition wakelock in
            scheduleReleaseNetworkTransitionWakelock();
        }

        if ((satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities) == false) &&
             !newNetwork.isVPN()) {
            // Force trigger permission change on non-DDS network to close all live connections
            try {
                mNMS.setNetworkPermission(newNetwork.network.netId,
                                           INetd.PERMISSION_NETWORK);
            } catch (RemoteException e) {
                loge(""Exception in setNetworkPermission: "" + e);
            }
        }
","        if (isNewDefault) {
            // restore permission to actual value if it becomes the default network again..
            if (!newNetwork.isVPN()) {
                try {
                    mNMS.setNetworkPermission(newNetwork.network.netId,
                                           getNetworkPermission(newNetwork.networkCapabilities));
                } catch (RemoteException e) {
                    loge(""Exception in setNetworkPermission: "" + e);
                }
            }
            updateDataActivityTracking(newNetwork, oldDefaultNetwork);
            // Notify system services that this network is up.
            makeDefault(newNetwork);
            // Log 0 -> X and Y -> X default network transitions, where X is the new default.
            mDeps.getMetricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(
                    now, newNetwork, oldDefaultNetwork);
            // Have a new default network, release the transition wakelock in
            scheduleReleaseNetworkTransitionWakelock();
        }

        if ((satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities) == false) &&
             !newNetwork.isVPN()) {
            // Force trigger permission change on non-DDS network to close all live connections
            try {
                mNMS.setNetworkPermission(newNetwork.network.netId,
                                           INetd.PERMISSION_NETWORK);
            } catch (RemoteException e) {
                loge(""Exception in setNetworkPermission: "" + e);
            }
        }
","        if (isNewDefault) {
            // restore permission to actual value if it becomes the default network again..
            if (!newNetwork.isVPN()) {
                try {
                    mNMS.setNetworkPermission(newNetwork.network.netId,
                                           getNetworkPermission(newNetwork.networkCapabilities));
                } catch (RemoteException e) {
                    loge(""Exception in setNetworkPermission: "" + e);
                }
            }
            updateDataActivityTracking(newNetwork, oldDefaultNetwork);
            // Notify system services that this network is up.
            makeDefault(newNetwork);
            // Log 0 -> X and Y -> X default network transitions, where X is the new default.
            mDeps.getMetricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(
                    now, newNetwork, oldDefaultNetwork);
            // Have a new default network, release the transition wakelock in
            scheduleReleaseNetworkTransitionWakelock();
        }

        if ((satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities) == false) &&
             !newNetwork.isVPN()) {
            // Force trigger permission change on non-DDS network to close all live connections
            try {
                mNMS.setNetworkPermission(newNetwork.network.netId,
                                           INetd.PERMISSION_NETWORK);
            } catch (RemoteException e) {
                loge(""Exception in setNetworkPermission: "" + e);
            }
        }
","[1.0, 1.0]"
1196,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3473, 3475, 3), (3473, 3475, 3)]","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
        if (DEBUG_MODE) { Log.v(TAG, ""setMode(mode="" + mode + "", callingPackage="" + callingPackage + "")""); }
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
        if (DEBUG_MODE) { Log.v(TAG, ""setMode(mode="" + mode + "", callingPackage="" + callingPackage + "")""); }
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
        if (DEBUG_MODE) { Log.v(TAG, ""setMode(mode="" + mode + "", callingPackage="" + callingPackage + "")""); }
","[1.0, 1.0]"
1197,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/WifiDisplayController.java,"[(374, 375, 2), (374, 375, 2)]","                wfdInfo.setWfdEnabled(false);
                mWifiP2pManager.setWfdInfo(getWifiP2pChannel(), wfdInfo, new ActionListener() {
","                wfdInfo.setWfdEnabled(false);
                mWifiP2pManager.setWfdInfo(getWifiP2pChannel(), wfdInfo, new ActionListener() {
","                wfdInfo.setWfdEnabled(false);
                mWifiP2pManager.setWfdInfo(getWifiP2pChannel(), wfdInfo, new ActionListener() {
","[1.0, 1.0]"
1198,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarSignalPolicy.java,"[(179, 181, 3), (179, 181, 3)]","            int qsType, boolean activityIn, boolean activityOut, int volteIcon,
            String typeContentDescription, String description, boolean isWide,
            int subId, boolean roaming) {
","            int qsType, boolean activityIn, boolean activityOut, int volteIcon,
            String typeContentDescription, String description, boolean isWide,
            int subId, boolean roaming) {
","            int qsType, boolean activityIn, boolean activityOut, int volteIcon,
            String typeContentDescription, String description, boolean isWide,
            int subId, boolean roaming) {
","[1.0, 1.0]"
1199,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarSignalPolicy.java,"[(391, 392, 2), (391, 392, 2)]","        public String typeContentDescription;
        public int volteId;
","        public String typeContentDescription;
        public int volteId;
","        public String typeContentDescription;
        public int volteId;
","[1.0, 1.0]"
1200,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/CallbackHandlerTest.java,"[(125, 126, 2), (125, 126, 2)]","        mHandler.setMobileDataIndicators(status, qs, type, qsType, in, out, 0,
                typeDescription, description, wide, subId, roaming);
","        mHandler.setMobileDataIndicators(status, qs, type, qsType, in, out, 0,
                typeDescription, description, wide, subId, roaming);
","        mHandler.setMobileDataIndicators(status, qs, type, qsType, in, out, 0,
                typeDescription, description, wide, subId, roaming);
","[1.0, 1.0]"
1201,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/CallbackHandlerTest.java,"[(141, 144, 4), (141, 144, 4)]","                outArg.capture(),
                ArgumentCaptor.forClass(Integer.class).capture(),
                typeContentArg.capture(), descArg.capture(), wideArg.capture(),
                subIdArg.capture(), eq(roaming));
","                outArg.capture(),
                ArgumentCaptor.forClass(Integer.class).capture(),
                typeContentArg.capture(), descArg.capture(), wideArg.capture(),
                subIdArg.capture(), eq(roaming));
","                outArg.capture(),
                ArgumentCaptor.forClass(Integer.class).capture(),
                typeContentArg.capture(), descArg.capture(), wideArg.capture(),
                subIdArg.capture(), eq(roaming));
","[1.0, 1.0]"
1202,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Call.java,"[(468, 475, 8), (468, 475, 8)]","         * Remote device supports RTT.
         * @hide
         */

        public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x04000000;

        //******************************************************************************************
        // Next CAPABILITY value: 0x08000000
","         * Remote device supports RTT.
         * @hide
         */

        public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x04000000;

        //******************************************************************************************
        // Next CAPABILITY value: 0x08000000
","         * Remote device supports RTT.
         * @hide
         */

        public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x04000000;

        //******************************************************************************************
        // Next CAPABILITY value: 0x08000000
","[1.0, 1.0]"
1203,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Call.java,"[(707, 708, 2), (707, 708, 2)]","            if (can(capabilities, CAPABILITY_SUPPORTS_RTT_REMOTE)) {
                builder.append("" CAPABILITY_SUPPORTS_RTT_REMOTE"");
","            if (can(capabilities, CAPABILITY_SUPPORTS_RTT_REMOTE)) {
                builder.append("" CAPABILITY_SUPPORTS_RTT_REMOTE"");
","            if (can(capabilities, CAPABILITY_SUPPORTS_RTT_REMOTE)) {
                builder.append("" CAPABILITY_SUPPORTS_RTT_REMOTE"");
","[1.0, 1.0]"
1204,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1648, 1649, 2), (1648, 1649, 2)]","        android.util.SeempLog.record(45);
        checkPendingIntent(intent);
","        android.util.SeempLog.record(45);
        checkPendingIntent(intent);
","        android.util.SeempLog.record(45);
        checkPendingIntent(intent);
","[1.0, 1.0]"
1205,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1888, 1894, 7), (1888, 1894, 7)]","        android.util.SeempLog.record(43);
        UnsupportedOperationException ex = new UnsupportedOperationException(
                ""GpsStatus APIs not supported in S and above, use GnssStatus APIs instead"");
        if (mContext.getApplicationInfo().targetSdkVersion > Build.VERSION_CODES.R) {
            throw ex;
        } else {
            Log.w(TAG, ex);
","        android.util.SeempLog.record(43);
        UnsupportedOperationException ex = new UnsupportedOperationException(
                ""GpsStatus APIs not supported in S and above, use GnssStatus APIs instead"");
        if (mContext.getApplicationInfo().targetSdkVersion > Build.VERSION_CODES.R) {
            throw ex;
        } else {
            Log.w(TAG, ex);
","        android.util.SeempLog.record(43);
        UnsupportedOperationException ex = new UnsupportedOperationException(
                ""GpsStatus APIs not supported in S and above, use GnssStatus APIs instead"");
        if (mContext.getApplicationInfo().targetSdkVersion > Build.VERSION_CODES.R) {
            throw ex;
        } else {
            Log.w(TAG, ex);
","[1.0, 1.0]"
1206,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/com/android/ims/internal/uce/common/CapInfo.java,"[(81, 83, 3), (81, 83, 3)]","     /** Standalone Chatbot communication support. */
    private boolean mSmChatbotSupported = false;
     /** MMtel based call composer support. */
","     /** Standalone Chatbot communication support. */
    private boolean mSmChatbotSupported = false;
     /** MMtel based call composer support. */
","     /** Standalone Chatbot communication support. */
    private boolean mSmChatbotSupported = false;
     /** MMtel based call composer support. */
","[1.0, 1.0]"
1207,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/com/android/ims/internal/uce/common/CapInfo.java,"[(94, 94, 1), (94, 94, 1)]","    @UnsupportedAppUsage
","    @UnsupportedAppUsage
","    @UnsupportedAppUsage
","[1.0, 1.0]"
1208,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTile.java,"[(258, 260, 3), (258, 260, 3)]","                int qsType, boolean activityIn, boolean activityOut, int volteIcon,
                String typeContentDescription, String description, boolean isWide,
                int subId, boolean roaming) {
","                int qsType, boolean activityIn, boolean activityOut, int volteIcon,
                String typeContentDescription, String description, boolean isWide,
                int subId, boolean roaming) {
","                int qsType, boolean activityIn, boolean activityOut, int volteIcon,
                String typeContentDescription, String description, boolean isWide,
                int subId, boolean roaming) {
","[1.0, 1.0]"
1209,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/CallbackHandler.java,"[(127, 138, 12), (127, 138, 12)]","            final int statusType, final int qsType,final boolean activityIn,
            final boolean activityOut, final int volteIcon,
            final String typeContentDescription, final String description, final boolean isWide,
            final int subId, boolean roaming) {
        post(new Runnable() {
            @Override
            public void run() {
                for (SignalCallback signalCluster : mSignalCallbacks) {
                    signalCluster.setMobileDataIndicators(statusIcon, qsIcon, statusType, qsType,
                            activityIn, activityOut, volteIcon, typeContentDescription,
                            description, isWide, subId, roaming);
                }
","            final int statusType, final int qsType,final boolean activityIn,
            final boolean activityOut, final int volteIcon,
            final String typeContentDescription, final String description, final boolean isWide,
            final int subId, boolean roaming) {
        post(new Runnable() {
            @Override
            public void run() {
                for (SignalCallback signalCluster : mSignalCallbacks) {
                    signalCluster.setMobileDataIndicators(statusIcon, qsIcon, statusType, qsType,
                            activityIn, activityOut, volteIcon, typeContentDescription,
                            description, isWide, subId, roaming);
                }
","            final int statusType, final int qsType,final boolean activityIn,
            final boolean activityOut, final int volteIcon,
            final String typeContentDescription, final String description, final boolean isWide,
            final int subId, boolean roaming) {
        post(new Runnable() {
            @Override
            public void run() {
                for (SignalCallback signalCluster : mSignalCallbacks) {
                    signalCluster.setMobileDataIndicators(statusIcon, qsIcon, statusType, qsType,
                            activityIn, activityOut, volteIcon, typeContentDescription,
                            description, isWide, subId, roaming);
                }
","[1.0, 1.0]"
1210,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Connection.java,"[(387, 394, 8), (387, 394, 8)]","     * Remote device supports RTT.
     * @hide
     */

    public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x08000000;

    //**********************************************************************************************
    // Next CAPABILITY value: 0x10000000
","     * Remote device supports RTT.
     * @hide
     */

    public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x08000000;

    //**********************************************************************************************
    // Next CAPABILITY value: 0x10000000
","     * Remote device supports RTT.
     * @hide
     */

    public static final int CAPABILITY_SUPPORTS_RTT_REMOTE = 0x08000000;

    //**********************************************************************************************
    // Next CAPABILITY value: 0x10000000
","[1.0, 1.0]"
1211,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Connection.java,"[(970, 971, 2), (970, 971, 2)]","        if ((capabilities & CAPABILITY_SUPPORTS_RTT_REMOTE) == CAPABILITY_SUPPORTS_RTT_REMOTE) {
            builder.append(isLong ? "" CAPABILITY_SUPPORTS_RTT_REMOTE"" : "" sup_rtt"");
","        if ((capabilities & CAPABILITY_SUPPORTS_RTT_REMOTE) == CAPABILITY_SUPPORTS_RTT_REMOTE) {
            builder.append(isLong ? "" CAPABILITY_SUPPORTS_RTT_REMOTE"" : "" sup_rtt"");
","        if ((capabilities & CAPABILITY_SUPPORTS_RTT_REMOTE) == CAPABILITY_SUPPORTS_RTT_REMOTE) {
            builder.append(isLong ? "" CAPABILITY_SUPPORTS_RTT_REMOTE"" : "" sup_rtt"");
","[1.0, 1.0]"
1212,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(1658, 1660, 3), (1658, 1660, 3)]","
        if (mPerf == null)
            mPerf = new BoostFramework();
","
        if (mPerf == null)
            mPerf = new BoostFramework();
","
        if (mPerf == null)
            mPerf = new BoostFramework();
","[1.0, 1.0]"
1213,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(552, 554, 3), (552, 554, 3)]","                activityIn, activityOut,volteIcon,
                dataContentDescription, description, icons.mIsWide,
                mSubscriptionInfo.getSubscriptionId(), mCurrentState.roaming);
","                activityIn, activityOut,volteIcon,
                dataContentDescription, description, icons.mIsWide,
                mSubscriptionInfo.getSubscriptionId(), mCurrentState.roaming);
","                activityIn, activityOut,volteIcon,
                dataContentDescription, description, icons.mIsWide,
                mSubscriptionInfo.getSubscriptionId(), mCurrentState.roaming);
","[1.0, 1.0]"
1214,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/WindowManagerService.java,"[(418, 418, 1), (418, 418, 1)]","    private BoostFramework mPerf = null;
","    private BoostFramework mPerf = null;
","    private BoostFramework mPerf = null;
","[1.0, 1.0]"
1215,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,"[(199, 202, 4), (199, 202, 4)]","
        updateResources();

        mPluginManager = pluginManager;
","
        updateResources();

        mPluginManager = pluginManager;
","
        updateResources();

        mPluginManager = pluginManager;
","[1.0, 1.0]"
1216,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/NetworkControllerBaseTest.java,"[(416, 417, 2), (416, 417, 2)]","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","[1.0, 1.0]"
1217,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/NetworkControllerBaseTest.java,"[(416, 417, 2), (450, 452, 3)]","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                ArgumentCaptor.forClass(Integer.class).capture(),
                anyString(), anyString(), anyBoolean(),
                anyInt(), eq(roaming));
","                ArgumentCaptor.forClass(Integer.class).capture(),
                ","[0.529, 0.506]"
1218,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/NetworkControllerBaseTest.java,"[(450, 452, 3), (450, 452, 3)]","                ArgumentCaptor.forClass(Integer.class).capture(),
                anyString(), anyString(), anyBoolean(),
                anyInt(), eq(roaming));
","                ArgumentCaptor.forClass(Integer.class).capture(),
                anyString(), anyString(), anyBoolean(),
                anyInt(), eq(roaming));
","                ArgumentCaptor.forClass(Integer.class).capture(),
                anyString(), anyString(), anyBoolean(),
                anyInt(), eq(roaming));
","[1.0, 1.0]"
1219,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/BluetoothAdapter.java,"[(1012, 1024, 13), (1012, 1024, 13)]","        android.util.SeempLog.record(63);
        int state = BluetoothAdapter.STATE_OFF;

        try {
            mServiceLock.readLock().lock();
            if (mService != null) {
                state = mService.getState();
            }
        } catch (RemoteException e) {
            Log.e(TAG, """", e);
        } finally {
            mServiceLock.readLock().unlock();
        }
","        android.util.SeempLog.record(63);
        int state = BluetoothAdapter.STATE_OFF;

        try {
            mServiceLock.readLock().lock();
            if (mService != null) {
                state = mService.getState();
            }
        } catch (RemoteException e) {
            Log.e(TAG, """", e);
        } finally {
            mServiceLock.readLock().unlock();
        }
","        android.util.SeempLog.record(63);
        int state = BluetoothAdapter.STATE_OFF;

        try {
            mServiceLock.readLock().lock();
            if (mService != null) {
                state = mService.getState();
            }
        } catch (RemoteException e) {
            Log.e(TAG, """", e);
        } finally {
            mServiceLock.readLock().unlock();
        }
","[1.0, 1.0]"
1220,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java,"[(55, 57, 3), (55, 57, 3)]","                int qsType, boolean activityIn, boolean activityOut, int volteIcon,
                String typeContentDescription, String description, boolean isWide,
                int subId, boolean roaming) {}
","                int qsType, boolean activityIn, boolean activityOut, int volteIcon,
                String typeContentDescription, String description, boolean isWide,
                int subId, boolean roaming) {}
","                int qsType, boolean activityIn, boolean activityOut, int volteIcon,
                String typeContentDescription, String description, boolean isWide,
                int subId, boolean roaming) {}
","[1.0, 1.0]"
1221,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java,"[(52, 52, 1), (52, 52, 1)]","import android.os.SystemProperties;
","import android.os.SystemProperties;
","import android.os.SystemProperties;
","[1.0, 1.0]"
1222,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/connectivity/NetworkAgentInfo.java,"[(19, 21, 3), (19, 21, 3)]","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_MMS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
","[1.0, 1.0]"
1223,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(198, 199, 2), (198, 199, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
1224,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiInfo.java,"[(294, 300, 7), (294, 300, 7)]","
    private int mWifiGeneration;

    private boolean mVhtMax8SpatialStreamsSupport;

    private boolean mTwtSupport;

","
    private int mWifiGeneration;

    private boolean mVhtMax8SpatialStreamsSupport;

    private boolean mTwtSupport;

","
    private int mWifiGeneration;

    private boolean mVhtMax8SpatialStreamsSupport;

    private boolean mTwtSupport;

","[1.0, 1.0]"
1225,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiInfo.java,"[(334, 336, 3), (334, 336, 3)]","        setWifiGeneration(-1);
        setTwtSupport(false);
        setVhtMax8SpatialStreamsSupport(false);
","        setWifiGeneration(-1);
        setTwtSupport(false);
        setVhtMax8SpatialStreamsSupport(false);
","        setWifiGeneration(-1);
        setTwtSupport(false);
        setVhtMax8SpatialStreamsSupport(false);
","[1.0, 1.0]"
1226,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerConstants.java,"[(434, 446, 13), (434, 446, 13)]","
        if (mPerf != null) {
          // Maximum number of cached processes we will allow.
            DEFAULT_MAX_CACHED_PROCESSES = MAX_CACHED_PROCESSES = Integer.valueOf(
                                                 mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bg_apps_limit"", ""32""));

           //Trim Settings
            USE_TRIM_SETTINGS = Boolean.parseBoolean(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.use_trim_settings"", ""true""));
            EMPTY_APP_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.empty_app_percent"", ""50""));
            TRIM_EMPTY_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_empty_percent"", ""100""));
            TRIM_CACHE_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_cache_percent"", ""100""));
            TRIM_ENABLE_MEMORY = Long.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_enable_memory"", ""1073741824""));
        }
","
        if (mPerf != null) {
          // Maximum number of cached processes we will allow.
            DEFAULT_MAX_CACHED_PROCESSES = MAX_CACHED_PROCESSES = Integer.valueOf(
                                                 mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bg_apps_limit"", ""32""));

           //Trim Settings
            USE_TRIM_SETTINGS = Boolean.parseBoolean(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.use_trim_settings"", ""true""));
            EMPTY_APP_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.empty_app_percent"", ""50""));
            TRIM_EMPTY_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_empty_percent"", ""100""));
            TRIM_CACHE_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_cache_percent"", ""100""));
            TRIM_ENABLE_MEMORY = Long.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_enable_memory"", ""1073741824""));
        }
","
        if (mPerf != null) {
          // Maximum number of cached processes we will allow.
            DEFAULT_MAX_CACHED_PROCESSES = MAX_CACHED_PROCESSES = Integer.valueOf(
                                                 mPerf.perfGetProp(""ro.vendor.qti.sys.fw.bg_apps_limit"", ""32""));

           //Trim Settings
            USE_TRIM_SETTINGS = Boolean.parseBoolean(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.use_trim_settings"", ""true""));
            EMPTY_APP_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.empty_app_percent"", ""50""));
            TRIM_EMPTY_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_empty_percent"", ""100""));
            TRIM_CACHE_PERCENT = Integer.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_cache_percent"", ""100""));
            TRIM_ENABLE_MEMORY = Long.valueOf(mPerf.perfGetProp(""ro.vendor.qti.sys.fw.trim_enable_memory"", ""1073741824""));
        }
","[1.0, 1.0]"
1227,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(198, 199, 2), (191, 192, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
1228,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarSignalPolicy.java,"[(179, 181, 3), (179, 181, 3)]","            int qsType, boolean activityIn, boolean activityOut, int volteIcon,
            String typeContentDescription, String description, boolean isWide,
            int subId, boolean roaming) {
","            int qsType, boolean activityIn, boolean activityOut, int volteIcon,
            String typeContentDescription, String description, boolean isWide,
            int subId, boolean roaming) {
","            int qsType, boolean activityIn, boolean activityOut, int volteIcon,
            String typeContentDescription, String description, boolean isWide,
            int subId, boolean roaming) {
","[1.0, 1.0]"
1229,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarSignalPolicy.java,"[(391, 392, 2), (391, 392, 2)]","        public String typeContentDescription;
        public int volteId;
","        public String typeContentDescription;
        public int volteId;
","        public String typeContentDescription;
        public int volteId;
","[1.0, 1.0]"
1230,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/CallbackHandlerTest.java,"[(125, 126, 2), (125, 126, 2)]","        mHandler.setMobileDataIndicators(status, qs, type, qsType, in, out, 0,
                typeDescription, description, wide, subId, roaming);
","        mHandler.setMobileDataIndicators(status, qs, type, qsType, in, out, 0,
                typeDescription, description, wide, subId, roaming);
","        mHandler.setMobileDataIndicators(status, qs, type, qsType, in, out, 0,
                typeDescription, description, wide, subId, roaming);
","[1.0, 1.0]"
1231,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/CallbackHandlerTest.java,"[(141, 144, 4), (141, 144, 4)]","                outArg.capture(),
                ArgumentCaptor.forClass(Integer.class).capture(),
                typeContentArg.capture(), descArg.capture(), wideArg.capture(),
                subIdArg.capture(), eq(roaming));
","                outArg.capture(),
                ArgumentCaptor.forClass(Integer.class).capture(),
                typeContentArg.capture(), descArg.capture(), wideArg.capture(),
                subIdArg.capture(), eq(roaming));
","                outArg.capture(),
                ArgumentCaptor.forClass(Integer.class).capture(),
                typeContentArg.capture(), descArg.capture(), wideArg.capture(),
                subIdArg.capture(), eq(roaming));
","[1.0, 1.0]"
1232,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTile.java,"[(258, 260, 3), (251, 253, 3)]","                int qsType, boolean activityIn, boolean activityOut, int volteIcon,
                String typeContentDescription, String description, boolean isWide,
                int subId, boolean roaming) {
","                int qsType, boolean activityIn, boolean activityOut, int volteIcon,
                String typeContentDescription, String description, boolean isWide,
                int subId, boolean roaming) {
","                int qsType, boolean activityIn, boolean activityOut, int volteIcon,
                String typeContentDescription, String description, boolean isWide,
                int subId, boolean roaming) {
","[1.0, 1.0]"
1233,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/CallbackHandler.java,"[(127, 138, 12), (127, 138, 12)]","            final int statusType, final int qsType,final boolean activityIn,
            final boolean activityOut, final int volteIcon,
            final String typeContentDescription, final String description, final boolean isWide,
            final int subId, boolean roaming) {
        post(new Runnable() {
            @Override
            public void run() {
                for (SignalCallback signalCluster : mSignalCallbacks) {
                    signalCluster.setMobileDataIndicators(statusIcon, qsIcon, statusType, qsType,
                            activityIn, activityOut, volteIcon, typeContentDescription,
                            description, isWide, subId, roaming);
                }
","            final int statusType, final int qsType,final boolean activityIn,
            final boolean activityOut, final int volteIcon,
            final String typeContentDescription, final String description, final boolean isWide,
            final int subId, boolean roaming) {
        post(new Runnable() {
            @Override
            public void run() {
                for (SignalCallback signalCluster : mSignalCallbacks) {
                    signalCluster.setMobileDataIndicators(statusIcon, qsIcon, statusType, qsType,
                            activityIn, activityOut, volteIcon, typeContentDescription,
                            description, isWide, subId, roaming);
                }
","            final int statusType, final int qsType,final boolean activityIn,
            final boolean activityOut, final int volteIcon,
            final String typeContentDescription, final String description, final boolean isWide,
            final int subId, boolean roaming) {
        post(new Runnable() {
            @Override
            public void run() {
                for (SignalCallback signalCluster : mSignalCallbacks) {
                    signalCluster.setMobileDataIndicators(statusIcon, qsIcon, statusType, qsType,
                            activityIn, activityOut, volteIcon, typeContentDescription,
                            description, isWide, subId, roaming);
                }
","[1.0, 1.0]"
1234,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(552, 554, 3), (472, 474, 3)]","                activityIn, activityOut,volteIcon,
                dataContentDescription, description, icons.mIsWide,
                mSubscriptionInfo.getSubscriptionId(), mCurrentState.roaming);
","                activityIn, activityOut,volteIcon,
                dataContentDescription, description, icons.mIsWide,
                mSubscriptionInfo.getSubscriptionId(), mCurrentState.roaming);
","                activityIn, activityOut,volteIcon,
                dataContentDescription, description, icons.mIsWide,
                mSubscriptionInfo.getSubscriptionId(), mCurrentState.roaming);
","[1.0, 1.0]"
1235,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/NetworkControllerBaseTest.java,"[(416, 417, 2), (352, 353, 2)]","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","[1.0, 1.0]"
1236,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/NetworkControllerBaseTest.java,"[(450, 452, 3), (352, 353, 2)]","                ArgumentCaptor.forClass(Integer.class).capture(),
                anyString(), anyString(), anyBoolean(),
                anyInt(), eq(roaming));
","                    ArgumentCaptor.forClass(Integer.class).capture(),
                    anyString(), anyString(), anyBoolean(), anyInt(), anyBoolean());
","                ArgumentCaptor.forClass(Integer.class).capture(),
                ","[0.506, 0.529]"
1237,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/policy/NetworkControllerBaseTest.java,"[(450, 452, 3), (385, 388, 4)]","                ArgumentCaptor.forClass(Integer.class).capture(),
                anyString(), anyString(), anyBoolean(),
                anyInt(), eq(roaming));
","                anyInt(), anyBoolean(), anyBoolean(),
                ArgumentCaptor.forClass(Integer.class).capture(),
                anyString(), anyString(), anyBoolean(),
                anyInt(), eq(roaming));
","                ArgumentCaptor.forClass(Integer.class).capture(),
                anyString(), anyString(), anyBoolean(),
                anyInt(), eq(roaming));
","[1.0, 0.75]"
1238,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java,"[(55, 57, 3), (55, 57, 3)]","                int qsType, boolean activityIn, boolean activityOut, int volteIcon,
                String typeContentDescription, String description, boolean isWide,
                int subId, boolean roaming) {}
","                int qsType, boolean activityIn, boolean activityOut, int volteIcon,
                String typeContentDescription, String description, boolean isWide,
                int subId, boolean roaming) {}
","                int qsType, boolean activityIn, boolean activityOut, int volteIcon,
                String typeContentDescription, String description, boolean isWide,
                int subId, boolean roaming) {}
","[1.0, 1.0]"
1239,"['af02bd5317cc0cced0a7646d5bbf407a181dda9c', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3473, 3475, 3), (3226, 3228, 3)]","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
        if (DEBUG_MODE) { Log.v(TAG, ""setMode(mode="" + mode + "", callingPackage="" + callingPackage + "")""); }
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
        if (DEBUG_MODE) { Log.v(TAG, ""setMode(mode="" + mode + "", callingPackage="" + callingPackage + "")""); }
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
        if (DEBUG_MODE) { Log.v(TAG, ""setMode(mode="" + mode + "", callingPackage="" + callingPackage + "")""); }
","[1.0, 1.0]"
1242,"['b6292e3e1ba3616eac1032737a91925391d94b92', 'b6292e3e1ba3616eac1032737a91925391d94b92']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(140, 144, 5), (140, 144, 5)]","    int mPhonePid;
    IActivityController mController;
    boolean mAllowRestart = true;
    SimpleDateFormat mTraceDateFormat = new SimpleDateFormat(""dd_MM_HH_mm_ss.SSS"");
    final OpenFdMonitor mOpenFdMonitor;
","    int mPhonePid;
    IActivityController mController;
    boolean mAllowRestart = true;
    SimpleDateFormat mTraceDateFormat = new SimpleDateFormat(""dd_MM_HH_mm_ss.SSS"");
    final OpenFdMonitor mOpenFdMonitor;
","    int mPhonePid;
    IActivityController mController;
    boolean mAllowRestart = true;
    SimpleDateFormat mTraceDateFormat = new SimpleDateFormat(""dd_MM_HH_mm_ss.SSS"");
    final OpenFdMonitor mOpenFdMonitor;
","[1.0, 1.0]"
1243,"['b6292e3e1ba3616eac1032737a91925391d94b92', 'b6292e3e1ba3616eac1032737a91925391d94b92']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(592, 595, 4), (592, 595, 4)]","                            ArrayList<Integer> pids = new ArrayList<Integer>();
                            pids.add(Process.myPid());
                            initialStack = ActivityManagerService.dumpStackTraces(pids,
                                    null, null, getInterestingNativePids(), null);
","                            ArrayList<Integer> pids = new ArrayList<Integer>();
                            pids.add(Process.myPid());
                            initialStack = ActivityManagerService.dumpStackTraces(pids,
                                    null, null, getInterestingNativePids(), null);
","                            ArrayList<Integer> pids = new ArrayList<Integer>();
                            pids.add(Process.myPid());
                            initialStack = ActivityManagerService.dumpStackTraces(pids,
                                    null, null, getInterestingNativePids(), null);
","[1.0, 1.0]"
1244,"['b6292e3e1ba3616eac1032737a91925391d94b92', 'b6292e3e1ba3616eac1032737a91925391d94b92']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java,"[(1292, 1293, 2), (1292, 1293, 2)]","                mStatusBarKeyguardViewManagerLazy.get().setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
","                mStatusBarKeyguardViewManagerLazy.get().setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
","                mStatusBarKeyguardViewManagerLazy.get().setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
","[1.0, 1.0]"
1245,"['b6292e3e1ba3616eac1032737a91925391d94b92', 'b6292e3e1ba3616eac1032737a91925391d94b92']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/statusbar/StatusBarManagerService.java,"[(66, 67, 2), (66, 67, 2)]","import com.android.server.UiThread;
import com.android.server.wm.WindowManagerService;
","import com.android.server.UiThread;
import com.android.server.wm.WindowManagerService;
","import com.android.server.UiThread;
import com.android.server.wm.WindowManagerService;
","[1.0, 1.0]"
1246,"['b6292e3e1ba3616eac1032737a91925391d94b92', 'b6292e3e1ba3616eac1032737a91925391d94b92']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerConstants.java,"[(30, 33, 4), (30, 33, 4)]","import android.os.Process;
import android.os.SystemProperties;
import android.os.UserHandle;
import android.os.UserManager;
","import android.os.Process;
import android.os.SystemProperties;
import android.os.UserHandle;
import android.os.UserManager;
","import android.os.Process;
import android.os.SystemProperties;
import android.os.UserHandle;
import android.os.UserManager;
","[1.0, 1.0]"
1247,"['b6292e3e1ba3616eac1032737a91925391d94b92', 'b6292e3e1ba3616eac1032737a91925391d94b92']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,"[(222, 227, 6), (222, 227, 6)]","        if (V) Log.d(TAG, "" execute supportsHighQualityAudio()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        int support = mService.supportsOptionalCodecs(device);
","        if (V) Log.d(TAG, "" execute supportsHighQualityAudio()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        int support = mService.supportsOptionalCodecs(device);
","        if (V) Log.d(TAG, "" execute supportsHighQualityAudio()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        int support = mService.supportsOptionalCodecs(device);
","[1.0, 1.0]"
1248,"['b6292e3e1ba3616eac1032737a91925391d94b92', 'b6292e3e1ba3616eac1032737a91925391d94b92']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,"[(232, 237, 6), (232, 237, 6)]","        if (V) Log.d(TAG, "" execute isHighQualityAudioEnabled()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        int enabled = mService.getOptionalCodecsEnabled(device);
","        if (V) Log.d(TAG, "" execute isHighQualityAudioEnabled()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        int enabled = mService.getOptionalCodecsEnabled(device);
","        if (V) Log.d(TAG, "" execute isHighQualityAudioEnabled()"");
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return false;
        }
        int enabled = mService.getOptionalCodecsEnabled(device);
","[1.0, 1.0]"
1249,"['b6292e3e1ba3616eac1032737a91925391d94b92', 'b6292e3e1ba3616eac1032737a91925391d94b92']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,"[(259, 268, 10), (259, 268, 10)]","        if (V) Log.d(TAG, "" execute setHighQualityAudioEnabled()"");
        int prefValue = enabled
                ? BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED
                : BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED;
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return;
        }
        mService.setOptionalCodecsEnabled(device, prefValue);
        if (getConnectionStatus(device) != BluetoothProfile.STATE_CONNECTED) {
","        if (V) Log.d(TAG, "" execute setHighQualityAudioEnabled()"");
        int prefValue = enabled
                ? BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED
                : BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED;
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return;
        }
        mService.setOptionalCodecsEnabled(device, prefValue);
        if (getConnectionStatus(device) != BluetoothProfile.STATE_CONNECTED) {
","        if (V) Log.d(TAG, "" execute setHighQualityAudioEnabled()"");
        int prefValue = enabled
                ? BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED
                : BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED;
        if (mService == null) {
            if (V) Log.d(TAG,""mService is null."");
            return;
        }
        mService.setOptionalCodecsEnabled(device, prefValue);
        if (getConnectionStatus(device) != BluetoothProfile.STATE_CONNECTED) {
","[1.0, 1.0]"
1250,"['b6292e3e1ba3616eac1032737a91925391d94b92', 'b6292e3e1ba3616eac1032737a91925391d94b92']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java,"[(279, 279, 1), (279, 279, 1)]","        if (V) Log.d(TAG, "" execute getHighQualityAudioOptionLabel()"");
","        if (V) Log.d(TAG, "" execute getHighQualityAudioOptionLabel()"");
","        if (V) Log.d(TAG, "" execute getHighQualityAudioOptionLabel()"");
","[1.0, 1.0]"
1251,"['b6292e3e1ba3616eac1032737a91925391d94b92', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java,"[(1292, 1293, 2), (1256, 1257, 2)]","                mStatusBarKeyguardViewManagerLazy.get().setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
","                mStatusBarKeyguardViewManager.setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
",".setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
","[0.696, 0.737]"
1253,"['bb9ded46832af38a453b78b92ad2de32ef1cf845', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(4018, 4020, 3), (3357, 3359, 3)]","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        final boolean stateChanged = mDeviceBroker.setSpeakerphoneOn(on, eventSource);
","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        mDeviceBroker.setSpeakerphoneOn(on, eventSource);
","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        ","[0.559, 0.667]"
1254,"['bb9ded46832af38a453b78b92ad2de32ef1cf845', 'bb9ded46832af38a453b78b92ad2de32ef1cf845']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3634, 3637, 4), (3634, 3637, 4)]","            if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
            }
","            if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
            }
","            if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
            }
","[1.0, 1.0]"
1255,"['bb9ded46832af38a453b78b92ad2de32ef1cf845', 'bb9ded46832af38a453b78b92ad2de32ef1cf845']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(4018, 4020, 3), (4018, 4020, 3)]","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        final boolean stateChanged = mDeviceBroker.setSpeakerphoneOn(on, eventSource);
","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        final boolean stateChanged = mDeviceBroker.setSpeakerphoneOn(on, eventSource);
","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        final boolean stateChanged = mDeviceBroker.setSpeakerphoneOn(on, eventSource);
","[1.0, 1.0]"
1256,"['bb9ded46832af38a453b78b92ad2de32ef1cf845', 'bb9ded46832af38a453b78b92ad2de32ef1cf845']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(223, 228, 6), (223, 228, 6)]","            mForcedUseForCommExt = mForcedUseForComm;
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In setSpeakerphoneOn(), mForcedUseForCommExt: "" + mForcedUseForCommExt);
            }
            setForceUse_Async(AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, eventSource);
            return (wasOn != isSpeakerphoneOn());
","            mForcedUseForCommExt = mForcedUseForComm;
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In setSpeakerphoneOn(), mForcedUseForCommExt: "" + mForcedUseForCommExt);
            }
            setForceUse_Async(AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, eventSource);
            return (wasOn != isSpeakerphoneOn());
","            mForcedUseForCommExt = mForcedUseForComm;
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In setSpeakerphoneOn(), mForcedUseForCommExt: "" + mForcedUseForCommExt);
            }
            setForceUse_Async(AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, eventSource);
            return (wasOn != isSpeakerphoneOn());
","[1.0, 1.0]"
1257,"['bb9ded46832af38a453b78b92ad2de32ef1cf845', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3634, 3637, 4), (3198, 3203, 6)]","            if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
            }
","            }
            // when entering RINGTONE, IN_CALL or IN_COMMUNICATION mode, clear all
            // SCO connections not started by the application changing the mode when pid changes
            if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
","            if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
","[0.944, 0.551]"
1258,"['c77ad764fad2451538f140b31601e7b8c6c59fa2', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/view/InputEventReceiver.java,"[(223, 242, 20), (217, 232, 16)]","    // Called from native code.
    @SuppressWarnings(""unused"")
    @UnsupportedAppUsage
    private void dispatchBatchedInputEventPending() {
        onBatchedInputEventPending();
    }

    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
","    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
    public static interface Factory {
        public InputEventReceiver createInputEventReceiver(
                InputChannel inputChannel, Looper looper);
","    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
","[0.724, 0.759]"
1259,"['c77ad764fad2451538f140b31601e7b8c6c59fa2', 'c77ad764fad2451538f140b31601e7b8c6c59fa2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(995, 1018, 24), (998, 1021, 24)]","        // Android framework should only set mBatteryLevel to valid range [0-100] or
        // BluetoothDevice.BATTERY_LEVEL_UNKNOWN, any other value should be a framework bug.
        // Thus assume here that if value is not BluetoothDevice.BATTERY_LEVEL_UNKNOWN, it must
        // be valid

        if (mDevice.isTwsPlusDevice() && mTwspBatteryState != -1 &&
           mTwspBatteryLevel != -1) {
            String s = ""TWSP: "";
            String chargingState;
            if (mTwspBatteryState == 1) {
                chargingState = ""Charging, "";
            } else {
                chargingState = ""Discharging, "";
            }
            s = s.concat (chargingState);
            s = s.concat(
                 com.android.settingslib.Utils.formatPercentage(mTwspBatteryLevel));
            batteryLevelPercentageString = s;
            Log.i(TAG, ""UI string"" + batteryLevelPercentageString);
        } else {
            final int batteryLevel = getBatteryLevel();
            if (batteryLevel != BluetoothDevice.BATTERY_LEVEL_UNKNOWN) {
                // TODO: name com.android.settingslib.bluetooth.Utils something different
                batteryLevelPercentageString =
","        // be valid

        if (mDevice.isTwsPlusDevice() && mTwspBatteryState != -1 &&
           mTwspBatteryLevel != -1) {
            String s = ""TWSP: "";
            String chargingState;
            if (mTwspBatteryState == 1) {
                chargingState = ""Charging, "";
            } else {
                chargingState = ""Discharging, "";
            }
            s = s.concat (chargingState);
            s = s.concat(
                 com.android.settingslib.Utils.formatPercentage(mTwspBatteryLevel));
            batteryLevelPercentageString = s;
            Log.i(TAG, ""UI string"" + batteryLevelPercentageString);
        } else {
            final int batteryLevel = getBatteryLevel();
            if (batteryLevel != BluetoothDevice.BATTERY_LEVEL_UNKNOWN) {
                // TODO: name com.android.settingslib.bluetooth.Utils something different
                batteryLevelPercentageString =
                    com.android.settingslib.Utils.formatPercentage(batteryLevel);
            }
        }
","        // be valid

        if (mDevice.isTwsPlusDevice() && mTwspBatteryState != -1 &&
           mTwspBatteryLevel != -1) {
            String s = ""TWSP: "";
            String chargingState;
            if (mTwspBatteryState == 1) {
                chargingState = ""Charging, "";
            } else {
                chargingState = ""Discharging, "";
            }
            s = s.concat (chargingState);
            s = s.concat(
                 com.android.settingslib.Utils.formatPercentage(mTwspBatteryLevel));
            batteryLevelPercentageString = s;
            Log.i(TAG, ""UI string"" + batteryLevelPercentageString);
        } else {
            final int batteryLevel = getBatteryLevel();
            if (batteryLevel != BluetoothDevice.BATTERY_LEVEL_UNKNOWN) {
                // TODO: name com.android.settingslib.bluetooth.Utils something different
                batteryLevelPercentageString =
","[0.77, 0.896]"
1260,"['c77ad764fad2451538f140b31601e7b8c6c59fa2', 'c77ad764fad2451538f140b31601e7b8c6c59fa2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/BluetoothDevice.java,"[(281, 289, 9), (280, 288, 9)]","     * Broadcast Action: Indicates the remote devices are TWS plus earbuds pair.
     * <p>Always contains the extra fields {@link #EXTRA_TWS_PLUS_DEVICE1},
     * {@link #EXTRA_TWS_PLUS_DEVICE2}.
     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
     * @hide
     */
    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
    public static final String ACTION_TWS_PLUS_DEVICE_PAIR =
            ""android.bluetooth.device.action.TWS_PLUS_DEVICE_PAIR"";
","    /**
     * Broadcast Action: Indicates the remote devices are TWS plus earbuds pair.
     * <p>Always contains the extra fields {@link #EXTRA_TWS_PLUS_DEVICE1},
     * {@link #EXTRA_TWS_PLUS_DEVICE2}.
     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
     * @hide
     */
    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
    public static final String ACTION_TWS_PLUS_DEVICE_PAIR =
","     * Broadcast Action: Indicates the remote devices are TWS plus earbuds pair.
     * <p>Always contains the extra fields {@link #EXTRA_TWS_PLUS_DEVICE1},
     * {@link #EXTRA_TWS_PLUS_DEVICE2}.
     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} to receive.
     * @hide
     */
    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
    public static final String ACTION_TWS_PLUS_DEVICE_PAIR =
","[0.859, 0.981]"
1261,"['c77ad764fad2451538f140b31601e7b8c6c59fa2', 'c77ad764fad2451538f140b31601e7b8c6c59fa2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/view/InputEventReceiver.java,"[(223, 242, 20), (225, 244, 20)]","    // Called from native code.
    @SuppressWarnings(""unused"")
    @UnsupportedAppUsage
    private void dispatchBatchedInputEventPending() {
        onBatchedInputEventPending();
    }

    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
","    @UnsupportedAppUsage
    private void dispatchBatchedInputEventPending() {
        onBatchedInputEventPending();
    }

    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
    /**
     * Factory for InputEventReceiver
","    @UnsupportedAppUsage
    private void dispatchBatchedInputEventPending() {
        onBatchedInputEventPending();
    }

    // Called from native code.
    @SuppressWarnings(""unused"")
    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
        try {
            if (mChoreographer == null)
                mChoreographer = Choreographer.getInstance();

            if (mChoreographer != null)
                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
        } catch (Exception e) {
            Log.e(TAG, ""cannot invoke setMotionEventInfo."");
        }
    }
","[0.906, 0.931]"
1272,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(371, 372, 2), (349, 350, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1273,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(191, 192, 2), (184, 185, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
1274,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(36, 39, 4), (28, 30, 3)]","import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.stub.ImsRegistrationImplBase;
","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.","[0.633, 0.799]"
1275,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(371, 372, 2), (444, 445, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1276,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(54, 56, 3), (46, 48, 3)]","import com.android.internal.telephony.TelephonyIntents;
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
import com.android.settingslib.graph.SignalDrawable;
","import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","[0.678, 0.69]"
1277,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(573, 584, 12), (573, 584, 12)]","    private PhoneStateListener mPhoneStateListener = new PhoneStateListener() {
        @Override
        public void onActiveDataSubscriptionIdChanged(int subId) {
             if (subId != mPreferredSubId) {
                 mHandler.sendMessage(mHandler.obtainMessage(EVENT_UPDATE_ACTIVE_DATA_SUBID, subId, 0));
             }
        }
    };

    private int mPreferredSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;

    /** Handler thread used for both of the handlers below. */
","    private PhoneStateListener mPhoneStateListener = new PhoneStateListener() {
        @Override
        public void onActiveDataSubscriptionIdChanged(int subId) {
             if (subId != mPreferredSubId) {
                 mHandler.sendMessage(mHandler.obtainMessage(EVENT_UPDATE_ACTIVE_DATA_SUBID, subId, 0));
             }
        }
    };

    private int mPreferredSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;

    /** Handler thread used for both of the handlers below. */
","    private PhoneStateListener mPhoneStateListener = new PhoneStateListener() {
        @Override
        public void onActiveDataSubscriptionIdChanged(int subId) {
             if (subId != mPreferredSubId) {
                 mHandler.sendMessage(mHandler.obtainMessage(EVENT_UPDATE_ACTIVE_DATA_SUBID, subId, 0));
             }
        }
    };

    private int mPreferredSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;

    /** Handler thread used for both of the handlers below. */
","[1.0, 1.0]"
1278,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(6555, 6579, 25), (6555, 6579, 25)]","
        if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
            Slog.wtf(TAG, String.format(
                    ""BUG: %s changed requestable capabilities during rematch: %s -> %s"",
                    newNetwork.name(), nc, newNetwork.networkCapabilities));
        }
        if (newNetwork.getCurrentScore() != score) {
            Slog.wtf(TAG, String.format(
                    ""BUG: %s changed score during rematch: %d -> %d"",
                    newNetwork.name(), score, newNetwork.getCurrentScore()));
        }

        if ((satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities) == false) &&
             !newNetwork.isVPN()) {
            // Force trigger permission change on non-DDS network to close all live connections
            try {
                mNMS.setNetworkPermission(newNetwork.network.netId,
                                           INetd.PERMISSION_NETWORK);
            } catch (RemoteException e) {
                loge(""Exception in setNetworkPermission: "" + e);
            }
        }
        // Notify requested networks are available after the default net is switched, but
        // before LegacyTypeTracker sends legacy broadcasts
        for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
","
        if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
            Slog.wtf(TAG, String.format(
                    ""BUG: %s changed requestable capabilities during rematch: %s -> %s"",
                    newNetwork.name(), nc, newNetwork.networkCapabilities));
        }
        if (newNetwork.getCurrentScore() != score) {
            Slog.wtf(TAG, String.format(
                    ""BUG: %s changed score during rematch: %d -> %d"",
                    newNetwork.name(), score, newNetwork.getCurrentScore()));
        }

        if ((satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities) == false) &&
             !newNetwork.isVPN()) {
            // Force trigger permission change on non-DDS network to close all live connections
            try {
                mNMS.setNetworkPermission(newNetwork.network.netId,
                                           INetd.PERMISSION_NETWORK);
            } catch (RemoteException e) {
                loge(""Exception in setNetworkPermission: "" + e);
            }
        }
        // Notify requested networks are available after the default net is switched, but
        // before LegacyTypeTracker sends legacy broadcasts
        for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
","
        if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
            Slog.wtf(TAG, String.format(
                    ""BUG: %s changed requestable capabilities during rematch: %s -> %s"",
                    newNetwork.name(), nc, newNetwork.networkCapabilities));
        }
        if (newNetwork.getCurrentScore() != score) {
            Slog.wtf(TAG, String.format(
                    ""BUG: %s changed score during rematch: %d -> %d"",
                    newNetwork.name(), score, newNetwork.getCurrentScore()));
        }

        if ((satisfiesMobileNetworkDataCheck(newNetwork.networkCapabilities) == false) &&
             !newNetwork.isVPN()) {
            // Force trigger permission change on non-DDS network to close all live connections
            try {
                mNMS.setNetworkPermission(newNetwork.network.netId,
                                           INetd.PERMISSION_NETWORK);
            } catch (RemoteException e) {
                loge(""Exception in setNetworkPermission: "" + e);
            }
        }
        // Notify requested networks are available after the default net is switched, but
        // before LegacyTypeTracker sends legacy broadcasts
        for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
","[1.0, 1.0]"
1279,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/ConnectivityService.java,"[(7393, 7469, 77), (7393, 7469, 77)]","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (mPreferredSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) return true;

            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == mPreferredSubId)) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }

    private void handleUpdateActiveDataSubId(int subId) {
        log(""Setting mPreferredSubId to "" + subId);
        mPreferredSubId = subId;
        rematchAllNetworksAndRequests();
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (mPreferredSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) return true;

            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == mPreferredSubId)) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }

    private void handleUpdateActiveDataSubId(int subId) {
        log(""Setting mPreferredSubId to "" + subId);
        mPreferredSubId = subId;
        rematchAllNetworksAndRequests();
","    private boolean isMobileNetwork(NetworkAgentInfo nai) {
        if (nai != null && nai.networkCapabilities != null &&
            nai.networkCapabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return true;
        }
        return false;
    }

    private boolean satisfiesMobileNetworkDataCheck(NetworkCapabilities agentNc) {
        if (agentNc != null && agentNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            if (mPreferredSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) return true;

            if((agentNc.hasCapability(NET_CAPABILITY_EIMS) &&
                 (mSubscriptionManager != null &&
                  (mSubscriptionManager.getActiveSubscriptionInfoList() == null ||
                   mSubscriptionManager.getActiveSubscriptionInfoList().size()==0))) ||
               (getIntSpecifier(agentNc.getNetworkSpecifier()) == mPreferredSubId)) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    private boolean satisfiesMobileMultiNetworkDataCheck(NetworkCapabilities agentNc,
            NetworkCapabilities requestNc) {
        if (requestNc != null && getIntSpecifier(requestNc.getNetworkSpecifier()) < 0) {
            return satisfiesMobileNetworkDataCheck(agentNc);
        }
        return true;
    }

    private int getIntSpecifier(NetworkSpecifier networkSpecifierObj) {
        String specifierStr = null;
        int specifier = -1;
        if (networkSpecifierObj != null
                && networkSpecifierObj instanceof StringNetworkSpecifier) {
            specifierStr = ((StringNetworkSpecifier) networkSpecifierObj).specifier;
        }
        if (specifierStr != null &&  specifierStr.isEmpty() == false) {
            try {
                specifier = Integer.parseInt(specifierStr);
            } catch (NumberFormatException e) {
                specifier = -1;
            }
        }
        return specifier;
    }

    private boolean isBestMobileMultiNetwork(NetworkAgentInfo currentNetwork,
            NetworkCapabilities currentRequestNc,
            NetworkAgentInfo newNetwork,
            NetworkCapabilities newRequestNc,
            NetworkCapabilities requestNc) {
        if (isMobileNetwork(currentNetwork) &&
            isMobileNetwork(newNetwork) &&
            satisfiesMobileMultiNetworkDataCheck(newRequestNc, requestNc) &&
            !satisfiesMobileMultiNetworkDataCheck(currentRequestNc, requestNc)) {
            return true;
        }
        return false;
    }

    private void handleUpdateTCPBuffersfor5G() {
        Network network = getActiveNetwork();
        NetworkAgentInfo ntwAgent = getNetworkAgentInfoForNetwork(network);
        if (DBG)
            log(""handleUpdateTCPBuffersfor5G nai "" + ntwAgent);
        if (ntwAgent != null)
            updateTcpBufferSizes(ntwAgent);
    }

    private void handleUpdateActiveDataSubId(int subId) {
        log(""Setting mPreferredSubId to "" + subId);
        mPreferredSubId = subId;
        rematchAllNetworksAndRequests();
","[1.0, 1.0]"
1280,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(371, 372, 2), (371, 372, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1281,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/os/Process.java,"[(859, 880, 22), (859, 880, 22)]","     * Sets the scheduling group for processes in the same cgroup.procs of uid and pid
     * @hide
     * @param uid The user identifier of the process to change.
     * @param pid The identifier of the process to change.
     * @param group The target group for this process from THREAD_GROUP_*.
     *
     * @throws IllegalArgumentException Throws IllegalArgumentException if
     * <var>tid</var> does not exist.
     * @throws SecurityException Throws SecurityException if your process does
     * not have permission to modify the given thread, or to use the given
     * priority.
     *
     * group == THREAD_GROUP_DEFAULT means to move all non-background priority
     * threads to the foreground scheduling group, but to leave background
     * priority threads alone.  group == THREAD_GROUP_BG_NONINTERACTIVE moves all
     * threads, regardless of priority, to the background scheduling group.
     * group == THREAD_GROUP_FOREGROUND is not allowed.
     *
     * Always sets cpusets.
     */
    public static final native void setCgroupProcsProcessGroup(int uid, int pid, int group)
            throws IllegalArgumentException, SecurityException;
","     * Sets the scheduling group for processes in the same cgroup.procs of uid and pid
     * @hide
     * @param uid The user identifier of the process to change.
     * @param pid The identifier of the process to change.
     * @param group The target group for this process from THREAD_GROUP_*.
     *
     * @throws IllegalArgumentException Throws IllegalArgumentException if
     * <var>tid</var> does not exist.
     * @throws SecurityException Throws SecurityException if your process does
     * not have permission to modify the given thread, or to use the given
     * priority.
     *
     * group == THREAD_GROUP_DEFAULT means to move all non-background priority
     * threads to the foreground scheduling group, but to leave background
     * priority threads alone.  group == THREAD_GROUP_BG_NONINTERACTIVE moves all
     * threads, regardless of priority, to the background scheduling group.
     * group == THREAD_GROUP_FOREGROUND is not allowed.
     *
     * Always sets cpusets.
     */
    public static final native void setCgroupProcsProcessGroup(int uid, int pid, int group)
            throws IllegalArgumentException, SecurityException;
","     * Sets the scheduling group for processes in the same cgroup.procs of uid and pid
     * @hide
     * @param uid The user identifier of the process to change.
     * @param pid The identifier of the process to change.
     * @param group The target group for this process from THREAD_GROUP_*.
     *
     * @throws IllegalArgumentException Throws IllegalArgumentException if
     * <var>tid</var> does not exist.
     * @throws SecurityException Throws SecurityException if your process does
     * not have permission to modify the given thread, or to use the given
     * priority.
     *
     * group == THREAD_GROUP_DEFAULT means to move all non-background priority
     * threads to the foreground scheduling group, but to leave background
     * priority threads alone.  group == THREAD_GROUP_BG_NONINTERACTIVE moves all
     * threads, regardless of priority, to the background scheduling group.
     * group == THREAD_GROUP_FOREGROUND is not allowed.
     *
     * Always sets cpusets.
     */
    public static final native void setCgroupProcsProcessGroup(int uid, int pid, int group)
            throws IllegalArgumentException, SecurityException;
","[1.0, 1.0]"
1282,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(2103, 2105, 3), (2103, 2105, 3)]","        mStackSupervisor.mGoingToSleepActivities.remove(next);
        next.sleeping = false;
        next.launching = true;
","        mStackSupervisor.mGoingToSleepActivities.remove(next);
        next.sleeping = false;
        next.launching = true;
","        mStackSupervisor.mGoingToSleepActivities.remove(next);
        next.sleeping = false;
        next.launching = true;
","[1.0, 1.0]"
1283,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/CachedAppOptimizer.java,"[(90, 90, 1), (90, 90, 1)]","    @VisibleForTesting static Boolean DEFAULT_USE_COMPACTION = false;
","    @VisibleForTesting static Boolean DEFAULT_USE_COMPACTION = false;
","    @VisibleForTesting static Boolean DEFAULT_USE_COMPACTION = false;
","[1.0, 1.0]"
1284,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ProcessList.java,"[(103, 104, 2), (103, 104, 2)]","import android.util.StatsLog;
import android.util.BoostFramework;
","import android.util.StatsLog;
import android.util.BoostFramework;
","import android.util.StatsLog;
import android.util.BoostFramework;
","[1.0, 1.0]"
1285,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(500, 501, 2), (500, 501, 2)]","    boolean sleeping;       // have we told the activity to sleep?
    public boolean launching;      // is activity launch in progress?
","    boolean sleeping;       // have we told the activity to sleep?
    public boolean launching;      // is activity launch in progress?
","    boolean sleeping;       // have we told the activity to sleep?
    public boolean launching;      // is activity launch in progress?
","[1.0, 1.0]"
1286,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(1644, 1660, 17), (1644, 1660, 17)]","            // Gets launch display id from options. It returns INVALID_DISPLAY if not set.
            mHandoverLaunchDisplayId = options.getLaunchDisplayId();
        }

        if (mPerf == null)
            mPerf = new BoostFramework();
    }

    static int getLockTaskLaunchMode(ActivityInfo aInfo, @Nullable ActivityOptions options) {
        int lockTaskLaunchMode = aInfo.lockTaskLaunchMode;
        if (aInfo.applicationInfo.isPrivilegedApp()
                && (lockTaskLaunchMode == LOCK_TASK_LAUNCH_MODE_ALWAYS
                || lockTaskLaunchMode == LOCK_TASK_LAUNCH_MODE_NEVER)) {
            lockTaskLaunchMode = LOCK_TASK_LAUNCH_MODE_DEFAULT;
        }
        if (options != null) {
            final boolean useLockTask = options.getLockTaskMode();
","            // Gets launch display id from options. It returns INVALID_DISPLAY if not set.
            mHandoverLaunchDisplayId = options.getLaunchDisplayId();
        }

        if (mPerf == null)
            mPerf = new BoostFramework();
    }

    static int getLockTaskLaunchMode(ActivityInfo aInfo, @Nullable ActivityOptions options) {
        int lockTaskLaunchMode = aInfo.lockTaskLaunchMode;
        if (aInfo.applicationInfo.isPrivilegedApp()
                && (lockTaskLaunchMode == LOCK_TASK_LAUNCH_MODE_ALWAYS
                || lockTaskLaunchMode == LOCK_TASK_LAUNCH_MODE_NEVER)) {
            lockTaskLaunchMode = LOCK_TASK_LAUNCH_MODE_DEFAULT;
        }
        if (options != null) {
            final boolean useLockTask = options.getLockTaskMode();
","            // Gets launch display id from options. It returns INVALID_DISPLAY if not set.
            mHandoverLaunchDisplayId = options.getLaunchDisplayId();
        }

        if (mPerf == null)
            mPerf = new BoostFramework();
    }

    static int getLockTaskLaunchMode(ActivityInfo aInfo, @Nullable ActivityOptions options) {
        int lockTaskLaunchMode = aInfo.lockTaskLaunchMode;
        if (aInfo.applicationInfo.isPrivilegedApp()
                && (lockTaskLaunchMode == LOCK_TASK_LAUNCH_MODE_ALWAYS
                || lockTaskLaunchMode == LOCK_TASK_LAUNCH_MODE_NEVER)) {
            lockTaskLaunchMode = LOCK_TASK_LAUNCH_MODE_DEFAULT;
        }
        if (options != null) {
            final boolean useLockTask = options.getLockTaskMode();
","[1.0, 1.0]"
1287,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(1665, 1666, 2), (1665, 1666, 2)]","
        return lockTaskLaunchMode;
","
        return lockTaskLaunchMode;
","
        return lockTaskLaunchMode;
","[1.0, 1.0]"
1288,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(779, 838, 60), (779, 838, 60)]","        /**
         * Puts the process record in the map.
         * <p>NOTE: Callers should avoid acquiring the mPidsSelfLocked lock before calling this
         * method.
         */
        void put(ProcessRecord app) {
            synchronized (this) {
                mPidMap.put(app.pid, app);
            }
            ActivityTriggerService atService = LocalServices.getService(ActivityTriggerService.class);
            if(atService != null) {
                atService.updateRecord(app.hostingRecord, app.info, app.pid, ActivityTriggerService.PROC_ADDED_NOTIFICATION);
            }
            mAtmInternal.onProcessMapped(app.pid, app.getWindowProcessController());
        }

        /**
         * Removes the process record from the map.
         * <p>NOTE: Callers should avoid acquiring the mPidsSelfLocked lock before calling this
         * method.
         */
        void remove(ProcessRecord app) {
            boolean removed = false;
            synchronized (this) {
                final ProcessRecord existingApp = mPidMap.get(app.pid);
                if (existingApp != null && existingApp.startSeq == app.startSeq) {
                    mPidMap.remove(app.pid);
                    removed = true;
                }
            }
            if (removed) {
                ActivityTriggerService atService = LocalServices.getService(ActivityTriggerService.class);
                if(atService != null) {
                    atService.updateRecord(app.hostingRecord, app.info, app.pid, ActivityTriggerService.PROC_REMOVED_NOTIFICATION);
                }
                mAtmInternal.onProcessUnMapped(app.pid);
            }
        }

        /**
         * Removes the process record from the map if it has a thread.
         * <p>NOTE: Callers should avoid acquiring the mPidsSelfLocked lock before calling this
         * method.
         */
        boolean removeIfNoThread(ProcessRecord app) {
            boolean removed = false;
            synchronized (this) {
                final ProcessRecord existingApp = get(app.pid);
                if (existingApp != null && existingApp.startSeq == app.startSeq
                        && app.thread == null) {
                    mPidMap.remove(app.pid);
                    removed = true;
                }
            }
            if (removed) {
                mAtmInternal.onProcessUnMapped(app.pid);
            }
            return removed;
        }

","        /**
         * Puts the process record in the map.
         * <p>NOTE: Callers should avoid acquiring the mPidsSelfLocked lock before calling this
         * method.
         */
        void put(ProcessRecord app) {
            synchronized (this) {
                mPidMap.put(app.pid, app);
            }
            ActivityTriggerService atService = LocalServices.getService(ActivityTriggerService.class);
            if(atService != null) {
                atService.updateRecord(app.hostingRecord, app.info, app.pid, ActivityTriggerService.PROC_ADDED_NOTIFICATION);
            }
            mAtmInternal.onProcessMapped(app.pid, app.getWindowProcessController());
        }

        /**
         * Removes the process record from the map.
         * <p>NOTE: Callers should avoid acquiring the mPidsSelfLocked lock before calling this
         * method.
         */
        void remove(ProcessRecord app) {
            boolean removed = false;
            synchronized (this) {
                final ProcessRecord existingApp = mPidMap.get(app.pid);
                if (existingApp != null && existingApp.startSeq == app.startSeq) {
                    mPidMap.remove(app.pid);
                    removed = true;
                }
            }
            if (removed) {
                ActivityTriggerService atService = LocalServices.getService(ActivityTriggerService.class);
                if(atService != null) {
                    atService.updateRecord(app.hostingRecord, app.info, app.pid, ActivityTriggerService.PROC_REMOVED_NOTIFICATION);
                }
                mAtmInternal.onProcessUnMapped(app.pid);
            }
        }

        /**
         * Removes the process record from the map if it has a thread.
         * <p>NOTE: Callers should avoid acquiring the mPidsSelfLocked lock before calling this
         * method.
         */
        boolean removeIfNoThread(ProcessRecord app) {
            boolean removed = false;
            synchronized (this) {
                final ProcessRecord existingApp = get(app.pid);
                if (existingApp != null && existingApp.startSeq == app.startSeq
                        && app.thread == null) {
                    mPidMap.remove(app.pid);
                    removed = true;
                }
            }
            if (removed) {
                mAtmInternal.onProcessUnMapped(app.pid);
            }
            return removed;
        }

","        /**
         * Puts the process record in the map.
         * <p>NOTE: Callers should avoid acquiring the mPidsSelfLocked lock before calling this
         * method.
         */
        void put(ProcessRecord app) {
            synchronized (this) {
                mPidMap.put(app.pid, app);
            }
            ActivityTriggerService atService = LocalServices.getService(ActivityTriggerService.class);
            if(atService != null) {
                atService.updateRecord(app.hostingRecord, app.info, app.pid, ActivityTriggerService.PROC_ADDED_NOTIFICATION);
            }
            mAtmInternal.onProcessMapped(app.pid, app.getWindowProcessController());
        }

        /**
         * Removes the process record from the map.
         * <p>NOTE: Callers should avoid acquiring the mPidsSelfLocked lock before calling this
         * method.
         */
        void remove(ProcessRecord app) {
            boolean removed = false;
            synchronized (this) {
                final ProcessRecord existingApp = mPidMap.get(app.pid);
                if (existingApp != null && existingApp.startSeq == app.startSeq) {
                    mPidMap.remove(app.pid);
                    removed = true;
                }
            }
            if (removed) {
                ActivityTriggerService atService = LocalServices.getService(ActivityTriggerService.class);
                if(atService != null) {
                    atService.updateRecord(app.hostingRecord, app.info, app.pid, ActivityTriggerService.PROC_REMOVED_NOTIFICATION);
                }
                mAtmInternal.onProcessUnMapped(app.pid);
            }
        }

        /**
         * Removes the process record from the map if it has a thread.
         * <p>NOTE: Callers should avoid acquiring the mPidsSelfLocked lock before calling this
         * method.
         */
        boolean removeIfNoThread(ProcessRecord app) {
            boolean removed = false;
            synchronized (this) {
                final ProcessRecord existingApp = get(app.pid);
                if (existingApp != null && existingApp.startSeq == app.startSeq
                        && app.thread == null) {
                    mPidMap.remove(app.pid);
                    removed = true;
                }
            }
            if (removed) {
                mAtmInternal.onProcessUnMapped(app.pid);
            }
            return removed;
        }

","[1.0, 1.0]"
1289,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(36, 39, 4), (36, 39, 4)]","import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","[1.0, 1.0]"
1290,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(54, 56, 3), (54, 56, 3)]","import com.android.internal.telephony.TelephonyIntents;
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","import com.android.internal.telephony.TelephonyIntents;
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","import com.android.internal.telephony.TelephonyIntents;
import com.android.internal.telephony.PhoneConstants;
import com.android.internal.telephony.PhoneConstants.DataState;
","[1.0, 1.0]"
1291,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(191, 192, 2), (191, 192, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
1292,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ProcessRecord.java,"[(69, 69, 1), (69, 69, 1)]","import com.android.server.Watchdog;
","import com.android.server.Watchdog;
","import com.android.server.Watchdog;
","[1.0, 1.0]"
1293,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(371, 372, 2), (398, 399, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1294,"['d28a4f6b38dbab44128b4319f665dd65c3e4ec2c', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(36, 39, 4), (29, 32, 4)]","import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","[1.0, 1.0]"
1295,"['ddc3dc79034f4570388245270b50ddad964c11f0', 'ddc3dc79034f4570388245270b50ddad964c11f0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java,"[(718, 747, 30), (718, 747, 30)]","
    @Override
    public void onMediaDataLoaded(String key, MediaData data) {
        updateMediaIcon();
    }

    @Override
    public void onMediaDataRemoved(String key) {
        updateMediaIcon();
    }

    private void updateMediaIcon() {
        mIconController.setIconVisibility(mSlotMedia, mMediaDataManager.hasActiveMedia());
    }

    private void updateHotspotIcon(int standard) {
        if (standard == ScanResult.WIFI_STANDARD_11AX) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_6_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11AC) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_5_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11N) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_4_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        }
    }
","
    @Override
    public void onMediaDataLoaded(String key, MediaData data) {
        updateMediaIcon();
    }

    @Override
    public void onMediaDataRemoved(String key) {
        updateMediaIcon();
    }

    private void updateMediaIcon() {
        mIconController.setIconVisibility(mSlotMedia, mMediaDataManager.hasActiveMedia());
    }

    private void updateHotspotIcon(int standard) {
        if (standard == ScanResult.WIFI_STANDARD_11AX) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_6_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11AC) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_5_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11N) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_4_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        }
    }
","
    @Override
    public void onMediaDataLoaded(String key, MediaData data) {
        updateMediaIcon();
    }

    @Override
    public void onMediaDataRemoved(String key) {
        updateMediaIcon();
    }

    private void updateMediaIcon() {
        mIconController.setIconVisibility(mSlotMedia, mMediaDataManager.hasActiveMedia());
    }

    private void updateHotspotIcon(int standard) {
        if (standard == ScanResult.WIFI_STANDARD_11AX) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_6_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11AC) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_5_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else if (standard == ScanResult.WIFI_STANDARD_11N) {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_wifi_4_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        } else {
            mIconController.setIcon(mSlotHotspot, R.drawable.stat_sys_hotspot,
                mResources.getString(R.string.accessibility_status_bar_hotspot));
        }
    }
","[1.0, 1.0]"
1296,"['ddc3dc79034f4570388245270b50ddad964c11f0', 'ddc3dc79034f4570388245270b50ddad964c11f0']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(1188, 1188, 1), (1188, 1188, 1)]","            case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT:
","            case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT:
","            case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT:
","[1.0, 1.0]"
1304,"['df73284a33506ba26aadbd20a1dbd01353820200', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(398, 399, 2), (349, 350, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1305,"['df73284a33506ba26aadbd20a1dbd01353820200', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1888, 1901, 14), (1809, 1819, 11)]","                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitForState(Set.of(BluetoothAdapter.STATE_OFF));
                        Message restartMsg =
                                mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mHandler.sendMessageDelayed(restartMsg, getServiceRestartMs());
","                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitForMonitoredOnOff(false, true);
","                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitFor","[0.683, 0.952]"
1306,"['df73284a33506ba26aadbd20a1dbd01353820200', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1911, 1927, 17), (1832, 1851, 20)]","                        waitForState(Set.of(BluetoothAdapter.STATE_ON));

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
","                        waitForMonitoredOnOff(true, false);

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
                        mEnable = false;
                        handleDisable();
                        waitForMonitoredOnOff(false, false);
",");

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
","[0.925, 0.812]"
1307,"['df73284a33506ba26aadbd20a1dbd01353820200', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(398, 399, 2), (444, 445, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1308,"['df73284a33506ba26aadbd20a1dbd01353820200', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(398, 399, 2), (398, 399, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1309,"['df73284a33506ba26aadbd20a1dbd01353820200', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(171, 171, 1), (171, 171, 1)]","    private boolean mTryBindOnBindTimeout = false;
","    private boolean mTryBindOnBindTimeout = false;
","    private boolean mTryBindOnBindTimeout = false;
","[1.0, 1.0]"
1310,"['df73284a33506ba26aadbd20a1dbd01353820200', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(883, 897, 15), (883, 897, 15)]","        if(appCount == 0) {
            try {
                mBluetoothLock.readLock().lock();
                if (mBluetooth != null) {
                    st = mBluetooth.getState();
                }
                if (!mEnableExternal || (st == BluetoothAdapter.STATE_BLE_ON)) {
                    if (DBG) Slog.d(TAG, ""Move to BT state OFF"");
                    sendBrEdrDownCallback();
                }
            } catch (RemoteException e) {
                Slog.e(TAG, """", e);
            } finally {
                mBluetoothLock.readLock().unlock();
            }
","        if(appCount == 0) {
            try {
                mBluetoothLock.readLock().lock();
                if (mBluetooth != null) {
                    st = mBluetooth.getState();
                }
                if (!mEnableExternal || (st == BluetoothAdapter.STATE_BLE_ON)) {
                    if (DBG) Slog.d(TAG, ""Move to BT state OFF"");
                    sendBrEdrDownCallback();
                }
            } catch (RemoteException e) {
                Slog.e(TAG, """", e);
            } finally {
                mBluetoothLock.readLock().unlock();
            }
","        if(appCount == 0) {
            try {
                mBluetoothLock.readLock().lock();
                if (mBluetooth != null) {
                    st = mBluetooth.getState();
                }
                if (!mEnableExternal || (st == BluetoothAdapter.STATE_BLE_ON)) {
                    if (DBG) Slog.d(TAG, ""Move to BT state OFF"");
                    sendBrEdrDownCallback();
                }
            } catch (RemoteException e) {
                Slog.e(TAG, """", e);
            } finally {
                mBluetoothLock.readLock().unlock();
            }
","[1.0, 1.0]"
1311,"['df73284a33506ba26aadbd20a1dbd01353820200', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(928, 941, 14), (928, 941, 14)]","            int st = mBluetooth.getState();
            if (st != BluetoothAdapter.STATE_BLE_ON) {
                if (DBG) Slog.v(TAG, ""onBluetoothServiceUp: state isn't BLE_ON: "" +
                         BluetoothAdapter.nameForState(st));
                return;
            }
           if (isAirplaneModeOn() && !mEnableExternal) {
                addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_AIRPLANE_MODE,
                    mContext.getPackageName(), false);

                mBluetooth.onBrEdrDown();
                mEnable = false;
            } else if (isBluetoothPersistedStateOnBluetooth() ||
                 mEnableExternal) {
","            int st = mBluetooth.getState();
            if (st != BluetoothAdapter.STATE_BLE_ON) {
                if (DBG) Slog.v(TAG, ""onBluetoothServiceUp: state isn't BLE_ON: "" +
                         BluetoothAdapter.nameForState(st));
                return;
            }
           if (isAirplaneModeOn() && !mEnableExternal) {
                addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_AIRPLANE_MODE,
                    mContext.getPackageName(), false);

                mBluetooth.onBrEdrDown();
                mEnable = false;
            } else if (isBluetoothPersistedStateOnBluetooth() ||
                 mEnableExternal) {
","            int st = mBluetooth.getState();
            if (st != BluetoothAdapter.STATE_BLE_ON) {
                if (DBG) Slog.v(TAG, ""onBluetoothServiceUp: state isn't BLE_ON: "" +
                         BluetoothAdapter.nameForState(st));
                return;
            }
           if (isAirplaneModeOn() && !mEnableExternal) {
                addActiveLog(BluetoothProtoEnums.ENABLE_DISABLE_REASON_AIRPLANE_MODE,
                    mContext.getPackageName(), false);

                mBluetooth.onBrEdrDown();
                mEnable = false;
            } else if (isBluetoothPersistedStateOnBluetooth() ||
                 mEnableExternal) {
","[1.0, 1.0]"
1312,"['df73284a33506ba26aadbd20a1dbd01353820200', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1888, 1901, 14), (1888, 1901, 14)]","                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitForState(Set.of(BluetoothAdapter.STATE_OFF));
                        Message restartMsg =
                                mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mHandler.sendMessageDelayed(restartMsg, getServiceRestartMs());
","                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitForState(Set.of(BluetoothAdapter.STATE_OFF));
                        Message restartMsg =
                                mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mHandler.sendMessageDelayed(restartMsg, getServiceRestartMs());
","                        // Wait for (a) is required only when Bluetooth is being
                        // turned off.
                        int state;
                        try {
                            state = mBluetooth.getState();
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""getState()"", e);
                            break;
                        }
                        if(state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_BLE_TURNING_OFF)
                            waitForState(Set.of(BluetoothAdapter.STATE_OFF));
                        Message restartMsg =
                                mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mHandler.sendMessageDelayed(restartMsg, getServiceRestartMs());
","[1.0, 1.0]"
1313,"['df73284a33506ba26aadbd20a1dbd01353820200', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1911, 1927, 17), (1911, 1927, 17)]","                        waitForState(Set.of(BluetoothAdapter.STATE_ON));

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
","                        waitForState(Set.of(BluetoothAdapter.STATE_ON));

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
","                        waitForState(Set.of(BluetoothAdapter.STATE_ON));

                        try {
                            mBluetoothLock.readLock().lock();
                            if((mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) &&
                                    ((isBluetoothPersistedStateOnBluetooth() ||
                                    !isBleAppPresent()))) {
                                Message disableMsg =
                                        mHandler.obtainMessage(MESSAGE_DISABLE);
                                mHandler.sendMessageDelayed(disableMsg, 100);
                                break;
                            }
                        } catch (RemoteException e) {
                            Slog.e(TAG, ""Unable to initiate disable"", e);
                        } finally {
                            mBluetoothLock.readLock().unlock();
                        }
","[1.0, 1.0]"
1314,"['df73284a33506ba26aadbd20a1dbd01353820200', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ProcessRecord.java,"[(1634, 1635, 2), (1634, 1635, 2)]","        String[] nativeProc = null;
        if (isSilentAnr()) {
","        String[] nativeProc = null;
        if (isSilentAnr()) {
","        String[] nativeProc = null;
        if (isSilentAnr()) {
","[1.0, 1.0]"
1315,"['df73284a33506ba26aadbd20a1dbd01353820200', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiSignalController.java,"[(128, 130, 3), (128, 130, 3)]","        boolean wifiVisible = mCurrentState.enabled
                && ((mCurrentState.connected && mCurrentState.inetCondition == 1)
                    || !mHasMobileData);
","        boolean wifiVisible = mCurrentState.enabled
                && ((mCurrentState.connected && mCurrentState.inetCondition == 1)
                    || !mHasMobileData);
","        boolean wifiVisible = mCurrentState.enabled
                && ((mCurrentState.connected && mCurrentState.inetCondition == 1)
                    || !mHasMobileData);
","[1.0, 1.0]"
1317,"['dfd2f7fed77160af2c57edfa20f1768b42aaa8da', 'dfd2f7fed77160af2c57edfa20f1768b42aaa8da']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",media/java/android/media/AudioSystem.java,"[(219, 224, 6), (219, 224, 6)]","            case AUDIO_FORMAT_CELT: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_CELT;
            case AUDIO_FORMAT_APTX_ADAPTIVE:
                     return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_ADAPTIVE;
            case AUDIO_FORMAT_APTX_TWSP:
                     return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_TWSP;
            default: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID;
","            case AUDIO_FORMAT_CELT: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_CELT;
            case AUDIO_FORMAT_APTX_ADAPTIVE:
                     return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_ADAPTIVE;
            case AUDIO_FORMAT_APTX_TWSP:
                     return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_TWSP;
            default: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID;
","            case AUDIO_FORMAT_CELT: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_CELT;
            case AUDIO_FORMAT_APTX_ADAPTIVE:
                     return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_ADAPTIVE;
            case AUDIO_FORMAT_APTX_TWSP:
                     return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_TWSP;
            default: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID;
","[1.0, 1.0]"
1318,"['dfd2f7fed77160af2c57edfa20f1768b42aaa8da', 'dfd2f7fed77160af2c57edfa20f1768b42aaa8da']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(18884, 18885, 2), (18884, 18885, 2)]","        public int startActivityAsUserEmpty(Bundle options) {
            return ActivityManagerService.this.startActivityAsUserEmpty(options);
","        public int startActivityAsUserEmpty(Bundle options) {
            return ActivityManagerService.this.startActivityAsUserEmpty(options);
","        public int startActivityAsUserEmpty(Bundle options) {
            return ActivityManagerService.this.startActivityAsUserEmpty(options);
","[1.0, 1.0]"
1319,"['dfd2f7fed77160af2c57edfa20f1768b42aaa8da', 'dfd2f7fed77160af2c57edfa20f1768b42aaa8da']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(1033, 1034, 2), (1033, 1034, 2)]","    // process external command to (dis)connect or change active A2DP device
    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = 32;
","    // process external command to (dis)connect or change active A2DP device
    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = 32;
","    // process external command to (dis)connect or change active A2DP device
    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = 32;
","[1.0, 1.0]"
1320,"['dfd2f7fed77160af2c57edfa20f1768b42aaa8da', 'dfd2f7fed77160af2c57edfa20f1768b42aaa8da']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/BtHelper.java,"[(1184, 1206, 23), (1184, 1206, 23)]","    private int mapBluetoothCodecToAudioFormat(int btCodecType) {
        switch (btCodecType) {
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_SBC:
                return AudioSystem.AUDIO_FORMAT_SBC;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_AAC:
                return AudioSystem.AUDIO_FORMAT_AAC;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX:
                return AudioSystem.AUDIO_FORMAT_APTX;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_HD:
                return AudioSystem.AUDIO_FORMAT_APTX_HD;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC:
                return AudioSystem.AUDIO_FORMAT_LDAC;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_CELT:
                return AudioSystem.AUDIO_FORMAT_CELT;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_ADAPTIVE:
                return AudioSystem.AUDIO_FORMAT_APTX_ADAPTIVE;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_TWSP:
                return AudioSystem.AUDIO_FORMAT_APTX_TWSP;
            default:
                return AudioSystem.AUDIO_FORMAT_DEFAULT;
        }
    }

","    private int mapBluetoothCodecToAudioFormat(int btCodecType) {
        switch (btCodecType) {
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_SBC:
                return AudioSystem.AUDIO_FORMAT_SBC;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_AAC:
                return AudioSystem.AUDIO_FORMAT_AAC;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX:
                return AudioSystem.AUDIO_FORMAT_APTX;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_HD:
                return AudioSystem.AUDIO_FORMAT_APTX_HD;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC:
                return AudioSystem.AUDIO_FORMAT_LDAC;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_CELT:
                return AudioSystem.AUDIO_FORMAT_CELT;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_ADAPTIVE:
                return AudioSystem.AUDIO_FORMAT_APTX_ADAPTIVE;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_TWSP:
                return AudioSystem.AUDIO_FORMAT_APTX_TWSP;
            default:
                return AudioSystem.AUDIO_FORMAT_DEFAULT;
        }
    }

","    private int mapBluetoothCodecToAudioFormat(int btCodecType) {
        switch (btCodecType) {
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_SBC:
                return AudioSystem.AUDIO_FORMAT_SBC;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_AAC:
                return AudioSystem.AUDIO_FORMAT_AAC;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX:
                return AudioSystem.AUDIO_FORMAT_APTX;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_HD:
                return AudioSystem.AUDIO_FORMAT_APTX_HD;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC:
                return AudioSystem.AUDIO_FORMAT_LDAC;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_CELT:
                return AudioSystem.AUDIO_FORMAT_CELT;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_ADAPTIVE:
                return AudioSystem.AUDIO_FORMAT_APTX_ADAPTIVE;
            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_TWSP:
                return AudioSystem.AUDIO_FORMAT_APTX_TWSP;
            default:
                return AudioSystem.AUDIO_FORMAT_DEFAULT;
        }
    }

","[1.0, 1.0]"
1321,"['dfd2f7fed77160af2c57edfa20f1768b42aaa8da', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(18884, 18885, 2), (18100, 18105, 6)]","        public int startActivityAsUserEmpty(Bundle options) {
            return ActivityManagerService.this.startActivityAsUserEmpty(options);
","        public int startActivityAsUserEmpty(Bundle options) {
            return ActivityManagerService.this.startActivityAsUserEmpty(options);
        }

        @Override
        public void killForegroundAppsForUser(int userHandle) {
","        public int startActivityAsUserEmpty(Bundle options) {
            return ActivityManagerService.this.startActivityAsUserEmpty(options);
","[1.0, 0.608]"
1322,"['e57c0a642086a0bb5c194764cf98068ea772a86d', 'e57c0a642086a0bb5c194764cf98068ea772a86d']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(994, 1002, 9), (994, 1002, 9)]","            int st = mBluetooth.getState();
            if (st != BluetoothAdapter.STATE_BLE_ON) {
                if (DBG) Slog.v(TAG, ""onBluetoothServiceUp: state isn't BLE_ON: "" +
                         BluetoothAdapter.nameForState(st));
                return;
            }
            if (!mEnableExternal && isAirplaneModeOn()) {
                // Airplane mode is turned on while enabling BLE only mode, disable
                // BLE now.
","            int st = mBluetooth.getState();
            if (st != BluetoothAdapter.STATE_BLE_ON) {
                if (DBG) Slog.v(TAG, ""onBluetoothServiceUp: state isn't BLE_ON: "" +
                         BluetoothAdapter.nameForState(st));
                return;
            }
            if (!mEnableExternal && isAirplaneModeOn()) {
                // Airplane mode is turned on while enabling BLE only mode, disable
                // BLE now.
","            int st = mBluetooth.getState();
            if (st != BluetoothAdapter.STATE_BLE_ON) {
                if (DBG) Slog.v(TAG, ""onBluetoothServiceUp: state isn't BLE_ON: "" +
                         BluetoothAdapter.nameForState(st));
                return;
            }
            if (!mEnableExternal && isAirplaneModeOn()) {
                // Airplane mode is turned on while enabling BLE only mode, disable
                // BLE now.
","[1.0, 1.0]"
1324,"['edb6252578f9b76151e5125a7fb1b16823a68418', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(29, 32, 4), (28, 30, 3)]","import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.stub.ImsRegistrationImplBase;
","import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.","[0.633, 0.799]"
1325,"['edb6252578f9b76151e5125a7fb1b16823a68418', '8d21ad0d966c1e9f96e5a65144efad2582391957']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStarter.java,"[(2438, 2445, 8), (2139, 2146, 8)]","    private void addOrReparentStartingActivity(TaskRecord parent, String reason) {
        String packageName= mService.mContext.getPackageName();
        if (mPerf != null) {
            mStartActivity.perfActivityBoostHandler =
                mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                    packageName, -1, BoostFramework.Launch.BOOST_V1);
        }
        if (mStartActivity.getTaskRecord() == null || mStartActivity.getTaskRecord() == parent) {
","        String packageName= mService.mContext.getPackageName();
        if (mPerf != null) {
            mStartActivity.perfActivityBoostHandler =
                mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                    packageName, -1, BoostFramework.Launch.BOOST_V1);
        }
        final TaskRecord sourceTask = mSourceRecord.getTask();
        final ActivityStack sourceStack = mSourceRecord.getStack();
","        String packageName= mService.mContext.getPackageName();
        if (mPerf != null) {
            mStartActivity.perfActivityBoostHandler =
                mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                    packageName, -1, BoostFramework.Launch.BOOST_V1);
        }
        ","[0.655, 0.728]"
1326,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStackSupervisor.java,"[(55, 56, 2), (55, 56, 2)]","import static com.android.server.wm.ActivityStack.ActivityState.DESTROYED;
import static com.android.server.wm.ActivityStack.REMOVE_TASK_MODE_MOVING;
","import static com.android.server.wm.ActivityStack.ActivityState.DESTROYED;
import static com.android.server.wm.ActivityStack.REMOVE_TASK_MODE_MOVING;
","import static com.android.server.wm.ActivityStack.ActivityState.DESTROYED;
import static com.android.server.wm.ActivityStack.REMOVE_TASK_MODE_MOVING;
","[1.0, 1.0]"
1327,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(59, 59, 1), (59, 59, 1)]","    private static final boolean mIsTwsConnectEnabled = false;
","    private static final boolean mIsTwsConnectEnabled = false;
","    private static final boolean mIsTwsConnectEnabled = false;
","[1.0, 1.0]"
1328,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(1978, 1979, 2), (1978, 1979, 2)]","    public boolean addNmeaListener(GpsStatus.NmeaListener listener) {
        android.util.SeempLog.record(44);
","    public boolean addNmeaListener(GpsStatus.NmeaListener listener) {
        android.util.SeempLog.record(44);
","    public boolean addNmeaListener(GpsStatus.NmeaListener listener) {
        android.util.SeempLog.record(44);
","[1.0, 1.0]"
1329,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(173, 173, 1), (173, 173, 1)]","public class ActivityStack extends ConfigurationContainer {
","public class ActivityStack extends ConfigurationContainer {
","public class ActivityStack extends ConfigurationContainer {
","[1.0, 1.0]"
1330,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(1062, 1067, 6), (1062, 1067, 6)]","    @Override
    public int setBounds(Rect bounds) {
        return super.setBounds(!inMultiWindowMode() ? null : bounds);
    }

    public ActivityRecord topRunningActivityLocked() {
","    @Override
    public int setBounds(Rect bounds) {
        return super.setBounds(!inMultiWindowMode() ? null : bounds);
    }

    public ActivityRecord topRunningActivityLocked() {
","    @Override
    public int setBounds(Rect bounds) {
        return super.setBounds(!inMultiWindowMode() ? null : bounds);
    }

    public ActivityRecord topRunningActivityLocked() {
","[1.0, 1.0]"
1331,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java,"[(2571, 2578, 8), (2571, 2578, 8)]","                mode = TelephonyManager.getTelephonyProperty(phoneId,
                         ""ro.telephony.default_network"",
                         Integer.toString(RILConstants.NETWORK_MODE_WCDMA_PREF));
                if (phoneId == 0) {
                    val = mode;
                } else {
                    val = val + "","" + mode;
                }
","                mode = TelephonyManager.getTelephonyProperty(phoneId,
                         ""ro.telephony.default_network"",
                         Integer.toString(RILConstants.NETWORK_MODE_WCDMA_PREF));
                if (phoneId == 0) {
                    val = mode;
                } else {
                    val = val + "","" + mode;
                }
","                mode = TelephonyManager.getTelephonyProperty(phoneId,
                         ""ro.telephony.default_network"",
                         Integer.toString(RILConstants.NETWORK_MODE_WCDMA_PREF));
                if (phoneId == 0) {
                    val = mode;
                } else {
                    val = val + "","" + mode;
                }
","[1.0, 1.0]"
1332,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java,"[(1256, 1257, 2), (1256, 1257, 2)]","                mStatusBarKeyguardViewManager.setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
","                mStatusBarKeyguardViewManager.setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
","                mStatusBarKeyguardViewManager.setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
","[1.0, 1.0]"
1333,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java,"[(189, 190, 2), (189, 190, 2)]","        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        mContext.registerReceiver(mIntentReceiver, filter, null, mHandler);
","        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        mContext.registerReceiver(mIntentReceiver, filter, null, mHandler);
","        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
        mContext.registerReceiver(mIntentReceiver, filter, null, mHandler);
","[1.0, 1.0]"
1334,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/ScanResult.java,"[(498, 499, 2), (498, 499, 2)]","        public static final int EID_EXTENSION = 255;
        public static final int EID_EXT_HE_CAPABILITIES = 35;
","        public static final int EID_EXTENSION = 255;
        public static final int EID_EXT_HE_CAPABILITIES = 35;
","        public static final int EID_EXTENSION = 255;
        public static final int EID_EXT_HE_CAPABILITIES = 35;
","[1.0, 1.0]"
1335,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/DisplayRotation.java,"[(217, 233, 17), (217, 233, 17)]","    /**
     * Broadcast Action: WiFi Display video is enabled or disabled
     *
     * <p>The intent will have the following extra values:</p>
     * <ul>
     *    <li><em>state</em> - 0 for disabled, 1 for enabled. </li>
     * </ul>
     */

    private static final String ACTION_WIFI_DISPLAY_VIDEO =
                    ""org.codeaurora.intent.action.WIFI_DISPLAY_VIDEO"";

    /**
     * Wifi Display specific variables
     */
    private boolean mWifiDisplayConnected = false;
    private int mWifiDisplayRotation = -1;
","    /**
     * Broadcast Action: WiFi Display video is enabled or disabled
     *
     * <p>The intent will have the following extra values:</p>
     * <ul>
     *    <li><em>state</em> - 0 for disabled, 1 for enabled. </li>
     * </ul>
     */

    private static final String ACTION_WIFI_DISPLAY_VIDEO =
                    ""org.codeaurora.intent.action.WIFI_DISPLAY_VIDEO"";

    /**
     * Wifi Display specific variables
     */
    private boolean mWifiDisplayConnected = false;
    private int mWifiDisplayRotation = -1;
","    /**
     * Broadcast Action: WiFi Display video is enabled or disabled
     *
     * <p>The intent will have the following extra values:</p>
     * <ul>
     *    <li><em>state</em> - 0 for disabled, 1 for enabled. </li>
     * </ul>
     */

    private static final String ACTION_WIFI_DISPLAY_VIDEO =
                    ""org.codeaurora.intent.action.WIFI_DISPLAY_VIDEO"";

    /**
     * Wifi Display specific variables
     */
    private boolean mWifiDisplayConnected = false;
    private int mWifiDisplayRotation = -1;
","[1.0, 1.0]"
1336,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(418, 419, 2), (418, 419, 2)]","    public int perfActivityBoostHandler = -1; //perflock handler when activity is created.
    private TaskRecord task;        // the task this is in.
","    public int perfActivityBoostHandler = -1; //perflock handler when activity is created.
    private TaskRecord task;        // the task this is in.
","    public int perfActivityBoostHandler = -1; //perflock handler when activity is created.
    private TaskRecord task;        // the task this is in.
","[1.0, 1.0]"
1337,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(5764, 5783, 20), (5764, 5783, 20)]","    public int isAppInfoGame() {
        int isGame = 0;
        if (info.applicationInfo != null) {
            isGame = (info.applicationInfo.category == ApplicationInfo.CATEGORY_GAME ||
                      (info.applicationInfo.flags & ApplicationInfo.FLAG_IS_GAME) == ApplicationInfo.FLAG_IS_GAME) ? 1 : 0;
        }
        return isGame;
    }

    /**
     * Creates a layer to apply crop to an animation.
     */
    private SurfaceControl createAnimationBoundsLayer(Transaction t) {
        ProtoLog.i(WM_DEBUG_APP_TRANSITIONS_ANIM, ""Creating animation bounds layer"");
        final SurfaceControl.Builder builder = makeAnimationLeash()
                .setParent(getAnimationLeashParent())
                .setName(getSurfaceControl() + "" - animation-bounds"");
        final SurfaceControl boundsLayer = builder.build();
        t.show(boundsLayer);
        return boundsLayer;
","    public int isAppInfoGame() {
        int isGame = 0;
        if (info.applicationInfo != null) {
            isGame = (info.applicationInfo.category == ApplicationInfo.CATEGORY_GAME ||
                      (info.applicationInfo.flags & ApplicationInfo.FLAG_IS_GAME) == ApplicationInfo.FLAG_IS_GAME) ? 1 : 0;
        }
        return isGame;
    }

    /**
     * Creates a layer to apply crop to an animation.
     */
    private SurfaceControl createAnimationBoundsLayer(Transaction t) {
        ProtoLog.i(WM_DEBUG_APP_TRANSITIONS_ANIM, ""Creating animation bounds layer"");
        final SurfaceControl.Builder builder = makeAnimationLeash()
                .setParent(getAnimationLeashParent())
                .setName(getSurfaceControl() + "" - animation-bounds"");
        final SurfaceControl boundsLayer = builder.build();
        t.show(boundsLayer);
        return boundsLayer;
","    public int isAppInfoGame() {
        int isGame = 0;
        if (info.applicationInfo != null) {
            isGame = (info.applicationInfo.category == ApplicationInfo.CATEGORY_GAME ||
                      (info.applicationInfo.flags & ApplicationInfo.FLAG_IS_GAME) == ApplicationInfo.FLAG_IS_GAME) ? 1 : 0;
        }
        return isGame;
    }

    /**
     * Creates a layer to apply crop to an animation.
     */
    private SurfaceControl createAnimationBoundsLayer(Transaction t) {
        ProtoLog.i(WM_DEBUG_APP_TRANSITIONS_ANIM, ""Creating animation bounds layer"");
        final SurfaceControl.Builder builder = makeAnimationLeash()
                .setParent(getAnimationLeashParent())
                .setName(getSurfaceControl() + "" - animation-bounds"");
        final SurfaceControl boundsLayer = builder.build();
        t.show(boundsLayer);
        return boundsLayer;
","[1.0, 1.0]"
1338,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(29, 32, 4), (29, 32, 4)]","import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","import android.telephony.CellSignalStrengthNr;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsReasonInfo;
import android.telephony.ims.feature.MmTelFeature;
","[1.0, 1.0]"
1339,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(66, 66, 1), (66, 66, 1)]","import java.util.List;
","import java.util.List;
","import java.util.List;
","[1.0, 1.0]"
1340,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(137, 139, 3), (137, 139, 3)]","        mFiveGStateListener = new FiveGStateListener();
        mFiveGState = new FiveGServiceState();
        mPhoneStateListener = new MobilePhoneStateListener(receiverLooper);
","        mFiveGStateListener = new FiveGStateListener();
        mFiveGState = new FiveGServiceState();
        mPhoneStateListener = new MobilePhoneStateListener(receiverLooper);
","        mFiveGStateListener = new FiveGStateListener();
        mFiveGState = new FiveGServiceState();
        mPhoneStateListener = new MobilePhoneStateListener(receiverLooper);
","[1.0, 1.0]"
1341,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStarter.java,"[(1534, 1541, 8), (1534, 1541, 8)]","            final TaskRecord taskToAffiliate = (mLaunchTaskBehind && mSourceRecord != null)
                    ? mSourceRecord.getTaskRecord() : null;
            String packageName= mService.mContext.getPackageName();
            if (mPerf != null) {
                mStartActivity.perfActivityBoostHandler =
                    mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                        packageName, -1, BoostFramework.Launch.BOOST_V1);
            }
","            final TaskRecord taskToAffiliate = (mLaunchTaskBehind && mSourceRecord != null)
                    ? mSourceRecord.getTaskRecord() : null;
            String packageName= mService.mContext.getPackageName();
            if (mPerf != null) {
                mStartActivity.perfActivityBoostHandler =
                    mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                        packageName, -1, BoostFramework.Launch.BOOST_V1);
            }
","            final TaskRecord taskToAffiliate = (mLaunchTaskBehind && mSourceRecord != null)
                    ? mSourceRecord.getTaskRecord() : null;
            String packageName= mService.mContext.getPackageName();
            if (mPerf != null) {
                mStartActivity.perfActivityBoostHandler =
                    mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                        packageName, -1, BoostFramework.Launch.BOOST_V1);
            }
","[1.0, 1.0]"
1342,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStarter.java,"[(2438, 2445, 8), (2438, 2445, 8)]","    private void addOrReparentStartingActivity(TaskRecord parent, String reason) {
        String packageName= mService.mContext.getPackageName();
        if (mPerf != null) {
            mStartActivity.perfActivityBoostHandler =
                mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                    packageName, -1, BoostFramework.Launch.BOOST_V1);
        }
        if (mStartActivity.getTaskRecord() == null || mStartActivity.getTaskRecord() == parent) {
","    private void addOrReparentStartingActivity(TaskRecord parent, String reason) {
        String packageName= mService.mContext.getPackageName();
        if (mPerf != null) {
            mStartActivity.perfActivityBoostHandler =
                mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                    packageName, -1, BoostFramework.Launch.BOOST_V1);
        }
        if (mStartActivity.getTaskRecord() == null || mStartActivity.getTaskRecord() == parent) {
","    private void addOrReparentStartingActivity(TaskRecord parent, String reason) {
        String packageName= mService.mContext.getPackageName();
        if (mPerf != null) {
            mStartActivity.perfActivityBoostHandler =
                mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                    packageName, -1, BoostFramework.Launch.BOOST_V1);
        }
        if (mStartActivity.getTaskRecord() == null || mStartActivity.getTaskRecord() == parent) {
","[1.0, 1.0]"
1343,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(3477, 3490, 14), (3477, 3490, 14)]","         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(String Macaddr, int numClients);
","         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(String Macaddr, int numClients);
","         * Called when Stations connected to soft AP.
         *
         * @param Macaddr Mac Address of connected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaConnected(String Macaddr, int numClients);

        /**
         * Called when Stations disconnected to soft AP.
         *
         * @param Macaddr Mac Address of Disconnected Stations to soft AP
         * @param numClients number of connected clients
         */
        public abstract void onStaDisconnected(String Macaddr, int numClients);
","[1.0, 1.0]"
1344,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiManager.java,"[(3532, 3543, 12), (3532, 3543, 12)]","        public void onStaConnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaConnected Macaddr ="" + Macaddr);
            mHandler.post(() -> {
                mCallback.onStaConnected(Macaddr, numClients);
            });
        }

        @Override
        public void onStaDisconnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaDisconnected Macaddr ="" + Macaddr);
            mHandler.post(() -> {
                mCallback.onStaDisconnected(Macaddr, numClients);
","        public void onStaConnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaConnected Macaddr ="" + Macaddr);
            mHandler.post(() -> {
                mCallback.onStaConnected(Macaddr, numClients);
            });
        }

        @Override
        public void onStaDisconnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaDisconnected Macaddr ="" + Macaddr);
            mHandler.post(() -> {
                mCallback.onStaDisconnected(Macaddr, numClients);
","        public void onStaConnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaConnected Macaddr ="" + Macaddr);
            mHandler.post(() -> {
                mCallback.onStaConnected(Macaddr, numClients);
            });
        }

        @Override
        public void onStaDisconnected(String Macaddr, int numClients) throws RemoteException {
            Log.v(TAG, ""SoftApCallbackProxy: ["" + numClients + ""]onStaDisconnected Macaddr ="" + Macaddr);
            mHandler.post(() -> {
                mCallback.onStaDisconnected(Macaddr, numClients);
","[1.0, 1.0]"
1345,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java,"[(321, 322, 2), (321, 322, 2)]","        filter.addAction(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
        mContext.registerReceiver(this, filter, null, mReceiverHandler);
","        filter.addAction(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
        mContext.registerReceiver(this, filter, null, mReceiverHandler);
","        filter.addAction(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
        mContext.registerReceiver(this, filter, null, mReceiverHandler);
","[1.0, 1.0]"
1346,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiInfo.java,"[(788, 791, 4), (788, 791, 4)]","                .append("", Wifi Generation: "").append(mWifiGeneration)
                .append("", TWT support: "").append(mTwtSupport)
                .append("", Eight Max VHT Spatial streams support: "").append(mVhtMax8SpatialStreamsSupport)
                .append("", Wi-Fi technology: "").append(mWifiTechnology)
","                .append("", Wifi Generation: "").append(mWifiGeneration)
                .append("", TWT support: "").append(mTwtSupport)
                .append("", Eight Max VHT Spatial streams support: "").append(mVhtMax8SpatialStreamsSupport)
                .append("", Wi-Fi technology: "").append(mWifiTechnology)
","                .append("", Wifi Generation: "").append(mWifiGeneration)
                .append("", TWT support: "").append(mTwtSupport)
                .append("", Eight Max VHT Spatial streams support: "").append(mVhtMax8SpatialStreamsSupport)
                .append("", Wi-Fi technology: "").append(mWifiTechnology)
","[1.0, 1.0]"
1347,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiInfo.java,"[(847, 850, 4), (847, 850, 4)]","        dest.writeInt(mWifiGeneration);
        dest.writeInt(mVhtMax8SpatialStreamsSupport ? 1 : 0);
        dest.writeInt(mTwtSupport ? 1 : 0);
        dest.writeInt(mWifiTechnology);
","        dest.writeInt(mWifiGeneration);
        dest.writeInt(mVhtMax8SpatialStreamsSupport ? 1 : 0);
        dest.writeInt(mTwtSupport ? 1 : 0);
        dest.writeInt(mWifiTechnology);
","        dest.writeInt(mWifiGeneration);
        dest.writeInt(mVhtMax8SpatialStreamsSupport ? 1 : 0);
        dest.writeInt(mTwtSupport ? 1 : 0);
        dest.writeInt(mWifiTechnology);
","[1.0, 1.0]"
1348,"['edb6252578f9b76151e5125a7fb1b16823a68418', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiInfo.java,"[(892, 895, 4), (892, 895, 4)]","                info.mWifiGeneration = in.readInt();
                info.mVhtMax8SpatialStreamsSupport = in.readInt() != 0;
                info.mTwtSupport = in.readInt() != 0;
                info.mWifiTechnology = in.readInt();
","                info.mWifiGeneration = in.readInt();
                info.mVhtMax8SpatialStreamsSupport = in.readInt() != 0;
                info.mTwtSupport = in.readInt() != 0;
                info.mWifiTechnology = in.readInt();
","                info.mWifiGeneration = in.readInt();
                info.mVhtMax8SpatialStreamsSupport = in.readInt() != 0;
                info.mTwtSupport = in.readInt() != 0;
                info.mWifiTechnology = in.readInt();
","[1.0, 1.0]"
1349,"['f6f595c8a4c17ed2347482c43e2cccc89531224e', 'f6f595c8a4c17ed2347482c43e2cccc89531224e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiEnterpriseConfig.java,"[(97, 97, 1), (97, 97, 1)]","    public static final String KEY_SIMNUM          = ""sim_num"";
","    public static final String KEY_SIMNUM          = ""sim_num"";
","    public static final String KEY_SIMNUM          = ""sim_num"";
","[1.0, 1.0]"
1350,"['f6f595c8a4c17ed2347482c43e2cccc89531224e', 'f6f595c8a4c17ed2347482c43e2cccc89531224e']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/Tethering/src/com/android/networkstack/tethering/Tethering.java,"[(500, 500, 1), (500, 500, 1)]","                if (ifaceNameToType(iface) == TETHERING_WIGIG) {
","                if (ifaceNameToType(iface) == TETHERING_WIGIG) {
","                if (ifaceNameToType(iface) == TETHERING_WIGIG) {
","[1.0, 1.0]"
1355,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', '188a21cc8ac704f36fd3f2984b4da86307ab7949']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(900, 900, 1), (868, 868, 1)]","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","[1.0, 1.0]"
1356,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', '1a06b5ab8af3c54728101c4dff83c8b5a6113ba9']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(849, 852, 4), (854, 857, 4)]","                        == BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET)) {
                    mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_ALLOWED);
                } else {
                    mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_REJECTED);
","                        == BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET)) {
                    mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_ALLOWED);
                } else {
                    mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_REJECTED);
","                        == BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET)) {
                    mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_ALLOWED);
                } else {
                    mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_REJECTED);
","[1.0, 1.0]"
1357,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', '2b252c526c654de6d04ec0165b4b8f039b37f82b']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(900, 900, 1), (817, 817, 1)]","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","[1.0, 1.0]"
1358,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'b576b28ececdf87e488eaf196c28e48371784746']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/BtHelper.java,"[(268, 338, 71), (239, 307, 69)]","    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

    // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
    @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
","    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

","    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

","[0.962, 1.0]"
1359,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActiveServices.java,"[(2541, 2550, 10), (2273, 2282, 10)]","                + r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");

        if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
            for (int i=mRestartingServices.size()-1; i>=0; i--) {
                ServiceRecord r2 = mRestartingServices.get(i);
                Slog.w(TAG,""Restarting list - i ""+i+"" r2.nextRestartTime ""
                           +r2.nextRestartTime+"" r2.name ""+r2.name);
            }
        }

","                + r.shortName + "" in "" + r.restartDelay + ""ms"");

        if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
            for (int i=mRestartingServices.size()-1; i>=0; i--) {
                ServiceRecord r2 = mRestartingServices.get(i);
                Slog.w(TAG,""Restarting list - i ""+i+"" r2.nextRestartTime ""
                           +r2.nextRestartTime+"" r2.name ""+r2.name);
            }
        }

","Name + "" in "" + r.restartDelay + ""ms"");

        if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
            for (int i=mRestartingServices.size()-1; i>=0; i--) {
                ServiceRecord r2 = mRestartingServices.get(i);
                Slog.w(TAG,""Restarting list - i ""+i+"" r2.nextRestartTime ""
                           +r2.nextRestartTime+"" r2.name ""+r2.name);
            }
        }

","[0.923, 0.941]"
1360,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(900, 900, 1), (887, 887, 1)]","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","[1.0, 1.0]"
1361,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(1096, 1099, 4), (1076, 1079, 4)]","        boolean imsRegistered;
        boolean voiceCapable;
        boolean videoCapable;

","        boolean imsRegistered;
        boolean voiceCapable;
        boolean videoCapable;

","        boolean imsRegistered;
        boolean voiceCapable;
        boolean videoCapable;

","[1.0, 1.0]"
1362,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(1115, 1117, 3), (1095, 1097, 3)]","            imsRegistered = state.imsRegistered;
            voiceCapable = state.voiceCapable;
            videoCapable = state.videoCapable;
","            imsRegistered = state.imsRegistered;
            voiceCapable = state.voiceCapable;
            videoCapable = state.videoCapable;
","            imsRegistered = state.imsRegistered;
            voiceCapable = state.voiceCapable;
            videoCapable = state.videoCapable;
","[1.0, 1.0]"
1363,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(1135, 1137, 3), (1115, 1117, 3)]","            builder.append(""imsRegistered="").append(imsRegistered).append(',');
            builder.append(""voiceCapable="").append(voiceCapable).append(',');
            builder.append(""videoCapable="").append(videoCapable);
","            builder.append(""imsRegistered="").append(imsRegistered).append(',');
            builder.append(""voiceCapable="").append(voiceCapable).append(',');
            builder.append(""videoCapable="").append(videoCapable);
","            builder.append(""imsRegistered="").append(imsRegistered).append(',');
            builder.append(""voiceCapable="").append(voiceCapable).append(',');
            builder.append(""videoCapable="").append(videoCapable);
","[1.0, 1.0]"
1364,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(1153, 1155, 3), (1133, 1135, 3)]","                    && ((MobileState) o).imsRegistered == imsRegistered
                    && ((MobileState) o).voiceCapable == voiceCapable
                    && ((MobileState) o).videoCapable == videoCapable;
","                    && ((MobileState) o).imsRegistered == imsRegistered
                    && ((MobileState) o).voiceCapable == voiceCapable
                    && ((MobileState) o).videoCapable == videoCapable;
","                    && ((MobileState) o).imsRegistered == imsRegistered
                    && ((MobileState) o).voiceCapable == voiceCapable
                    && ((MobileState) o).videoCapable == videoCapable;
","[1.0, 1.0]"
1365,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3198, 3203, 6), (3198, 3203, 6)]","            }
            // when entering RINGTONE, IN_CALL or IN_COMMUNICATION mode, clear all
            // SCO connections not started by the application changing the mode when pid changes
            if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
","            }
            // when entering RINGTONE, IN_CALL or IN_COMMUNICATION mode, clear all
            // SCO connections not started by the application changing the mode when pid changes
            if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
","            }
            // when entering RINGTONE, IN_CALL or IN_COMMUNICATION mode, clear all
            // SCO connections not started by the application changing the mode when pid changes
            if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
                Log.i(TAG, ""In binderDied(), calling disconnectBluetoothSco()"");
                mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
","[1.0, 1.0]"
1366,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3226, 3228, 3), (3226, 3228, 3)]","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
        if (DEBUG_MODE) { Log.v(TAG, ""setMode(mode="" + mode + "", callingPackage="" + callingPackage + "")""); }
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
        if (DEBUG_MODE) { Log.v(TAG, ""setMode(mode="" + mode + "", callingPackage="" + callingPackage + "")""); }
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
        if (DEBUG_MODE) { Log.v(TAG, ""setMode(mode="" + mode + "", callingPackage="" + callingPackage + "")""); }
","[1.0, 1.0]"
1367,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3256, 3261, 6), (3256, 3261, 6)]","        }
        // when entering RINGTONE, IN_CALL or IN_COMMUNICATION mode, clear all
        // SCO connections not started by the application changing the mode when pid changes
        if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
            mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
","        }
        // when entering RINGTONE, IN_CALL or IN_COMMUNICATION mode, clear all
        // SCO connections not started by the application changing the mode when pid changes
        if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
            mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
","        }
        // when entering RINGTONE, IN_CALL or IN_COMMUNICATION mode, clear all
        // SCO connections not started by the application changing the mode when pid changes
        if ((newModeOwnerPid != oldModeOwnerPid) && (newModeOwnerPid != 0)) {
            Log.i(TAG, ""In setMode(), calling disconnectBluetoothSco()"");
            mDeviceBroker.postDisconnectBluetoothSco(newModeOwnerPid);
","[1.0, 1.0]"
1368,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(849, 852, 4), (849, 852, 4)]","                        == BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET)) {
                    mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_ALLOWED);
                } else {
                    mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_REJECTED);
","                        == BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET)) {
                    mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_ALLOWED);
                } else {
                    mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_REJECTED);
","                        == BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET)) {
                    mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_ALLOWED);
                } else {
                    mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_REJECTED);
","[1.0, 1.0]"
1369,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/BtHelper.java,"[(268, 338, 71), (268, 338, 71)]","    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

    // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
    @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
","    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

    // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
    @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
","    //SCO device tracking for TWSPLUS device
    private HashMap<BluetoothDevice, Integer> mScoClientDevices =
                                          new HashMap<BluetoothDevice, Integer>();

    private void updateTwsPlusScoState(BluetoothDevice device, Integer state) {
        if (mScoClientDevices.containsKey(device)) {
            Integer prevState = mScoClientDevices.get(device);
            Log.i(TAG, ""updateTwsPlusScoState: prevState: "" + prevState + ""state: "" + state);
            if (state != prevState) {
                mScoClientDevices.remove(device);
                mScoClientDevices.put(device, state);
            }
        } else {
            mScoClientDevices.put(device, state);
        }
    }

    private boolean isAudioPathUp() {
        boolean ret = false;
        Iterator it = mScoClientDevices.entrySet().iterator();
        for (Integer value :  mScoClientDevices.values()) {
            if (value == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                ret = true;
                break;
            }
        }
        Log.d(TAG, ""isAudioPathUp returns"" + ret);
        return ret;
    }

    private boolean checkAndUpdatTwsPlusScoState(Intent intent, Integer state) {
        //default ret value is true
        //so that legacy devices fallsthru
        boolean ret = true;
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        Log.i(TAG, ""device:"" + device);

        if (device == null) {
           Log.e(TAG, ""checkAndUpdatTwsPlusScoState: device is null"");
           //intent cant have device has null
           //in case it is treat them as non-twsplus case and return true
           return ret;
        }

        if (device.isTwsPlusDevice()) {
            if (state == BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                //if adding new Device
                //check if there is no device already connected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""No need to bringup audio-path"");
                    ret = false;
                }
                //Update the States now
                updateTwsPlusScoState(device, state);
            } else {
                //For disconnect cases, update the state first
                updateTwsPlusScoState(device, state);
                //if deleting new Device
                //check if all devices are disconnected
                if (isAudioPathUp()) {
                    Log.i(TAG, ""not good to tear down audio-path"");
                    ret = false;
                }
            }
        }
        Log.i(TAG, ""checkAndUpdatTwsPlusScoState returns "" + ret);
        return ret;
    }

    // @GuardedBy(""AudioDeviceBroker.mSetModeLock"")
    @GuardedBy(""AudioDeviceBroker.mDeviceStateLock"")
","[1.0, 1.0]"
1370,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(220, 223, 4), (220, 223, 4)]","        synchronized (mDeviceStateLock) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
","        synchronized (mDeviceStateLock) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
","        synchronized (mDeviceStateLock) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
","[1.0, 1.0]"
1371,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(220, 223, 4), (341, 345, 5)]","        synchronized (mDeviceStateLock) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
","        synchronized (mDeviceStateLock) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isBluetoothScoOnForApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","        synchronized (mDeviceStateLock) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In is","[0.594, 0.518]"
1372,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(328, 336, 9), (328, 336, 9)]","        synchronized (mDeviceStateLock) {
            if (on)
                mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
            else if (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO)
                mForcedUseForCommExt = AudioSystem.FORCE_NONE;
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In setBluetoothScoOnByApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","        synchronized (mDeviceStateLock) {
            if (on)
                mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
            else if (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO)
                mForcedUseForCommExt = AudioSystem.FORCE_NONE;
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In setBluetoothScoOnByApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","        synchronized (mDeviceStateLock) {
            if (on)
                mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
            else if (mForcedUseForCommExt == AudioSystem.FORCE_BT_SCO)
                mForcedUseForCommExt = AudioSystem.FORCE_NONE;
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In setBluetoothScoOnByApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","[1.0, 1.0]"
1373,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(341, 345, 5), (341, 345, 5)]","        synchronized (mDeviceStateLock) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isBluetoothScoOnForApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","        synchronized (mDeviceStateLock) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isBluetoothScoOnForApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","        synchronized (mDeviceStateLock) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isBluetoothScoOnForApp(), mForcedUseForCommExt: "" +
                      mForcedUseForCommExt);
            }
","[1.0, 1.0]"
1374,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(351, 354, 4), (351, 354, 4)]","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
        synchronized (mDeviceStateLock) {
","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
        synchronized (mDeviceStateLock) {
","        if (AudioService.DEBUG_SCO) {
            Log.i(TAG, ""setBluetoothScoOn: "" + on + "" "" + eventSource);
        }
        synchronized (mDeviceStateLock) {
","[1.0, 1.0]"
1375,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStack.java,"[(3826, 3895, 70), (3826, 3895, 70)]","        return stack;
    }

    final void stopActivityLocked(ActivityRecord r) {
        if (DEBUG_SWITCH) Slog.d(TAG_SWITCH, ""Stopping: "" + r);
        r.launching = false;
        if ((r.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_HISTORY) != 0
                || (r.info.flags&ActivityInfo.FLAG_NO_HISTORY) != 0) {
            if (!r.finishing) {
                if (!shouldSleepActivities()) {
                    if (DEBUG_STATES) Slog.d(TAG_STATES, ""no-history finish of "" + r);
                    if (r.finishIfPossible(""stop-no-history"", false /* oomAdj */)
                            != FINISH_RESULT_CANCELLED) {
                        // {@link adjustFocusedActivityStack} must have been already called.
                        r.resumeKeyDispatchingLocked();
                        return;
                    }
                } else {
                    if (DEBUG_STATES) Slog.d(TAG_STATES, ""Not finishing noHistory "" + r
                            + "" on stop because we're just sleeping"");
                }
            }
        }

        if (r.attachedToProcess()) {
            adjustFocusedActivityStack(r, ""stopActivity"");
            r.resumeKeyDispatchingLocked();
            try {
                r.stopped = false;

                if (DEBUG_STATES) Slog.v(TAG_STATES,
                        ""Moving to STOPPING: "" + r + "" (stop requested)"");
                r.setState(STOPPING, ""stopActivityLocked"");

                if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
                    mActivityPluginDelegate.activitySuspendNotification
                        (r.info.applicationInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
                }
                if (DEBUG_VISIBILITY) Slog.v(TAG_VISIBILITY,
                        ""Stopping visible="" + r.visible + "" for "" + r);

                if (mActivityTrigger != null) {
                    mActivityTrigger.activityStopTrigger(r.intent, r.info, r.info.applicationInfo);
                }

                if (!r.visible) {
                    r.setVisible(false);
                }
                EventLogTags.writeAmStopActivity(
                        r.mUserId, System.identityHashCode(r), r.shortComponentName);
                mService.getLifecycleManager().scheduleTransaction(r.app.getThread(), r.appToken,
                        StopActivityItem.obtain(r.visible, r.configChangeFlags));
                if (shouldSleepOrShutDownActivities()) {
                    r.setSleeping(true);
                }
                Message msg = mHandler.obtainMessage(STOP_TIMEOUT_MSG, r);
                mHandler.sendMessageDelayed(msg, STOP_TIMEOUT);
            } catch (Exception e) {
                // Maybe just ignore exceptions here...  if the process
                // has crashed, our death notification will clean things
                // up.
                Slog.w(TAG, ""Exception thrown during pause"", e);
                // Just in case, assume it to be stopped.
                r.stopped = true;
                if (DEBUG_STATES) Slog.v(TAG_STATES, ""Stop failed; moving to STOPPED: "" + r);
                r.setState(STOPPED, ""stopActivityLocked"");
                if (r.deferRelaunchUntilPaused) {
                    destroyActivityLocked(r, true, ""stop-except"");
                }
            }
","        return stack;
    }

    final void stopActivityLocked(ActivityRecord r) {
        if (DEBUG_SWITCH) Slog.d(TAG_SWITCH, ""Stopping: "" + r);
        r.launching = false;
        if ((r.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_HISTORY) != 0
                || (r.info.flags&ActivityInfo.FLAG_NO_HISTORY) != 0) {
            if (!r.finishing) {
                if (!shouldSleepActivities()) {
                    if (DEBUG_STATES) Slog.d(TAG_STATES, ""no-history finish of "" + r);
                    if (r.finishIfPossible(""stop-no-history"", false /* oomAdj */)
                            != FINISH_RESULT_CANCELLED) {
                        // {@link adjustFocusedActivityStack} must have been already called.
                        r.resumeKeyDispatchingLocked();
                        return;
                    }
                } else {
                    if (DEBUG_STATES) Slog.d(TAG_STATES, ""Not finishing noHistory "" + r
                            + "" on stop because we're just sleeping"");
                }
            }
        }

        if (r.attachedToProcess()) {
            adjustFocusedActivityStack(r, ""stopActivity"");
            r.resumeKeyDispatchingLocked();
            try {
                r.stopped = false;

                if (DEBUG_STATES) Slog.v(TAG_STATES,
                        ""Moving to STOPPING: "" + r + "" (stop requested)"");
                r.setState(STOPPING, ""stopActivityLocked"");

                if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
                    mActivityPluginDelegate.activitySuspendNotification
                        (r.info.applicationInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
                }
                if (DEBUG_VISIBILITY) Slog.v(TAG_VISIBILITY,
                        ""Stopping visible="" + r.visible + "" for "" + r);

                if (mActivityTrigger != null) {
                    mActivityTrigger.activityStopTrigger(r.intent, r.info, r.info.applicationInfo);
                }

                if (!r.visible) {
                    r.setVisible(false);
                }
                EventLogTags.writeAmStopActivity(
                        r.mUserId, System.identityHashCode(r), r.shortComponentName);
                mService.getLifecycleManager().scheduleTransaction(r.app.getThread(), r.appToken,
                        StopActivityItem.obtain(r.visible, r.configChangeFlags));
                if (shouldSleepOrShutDownActivities()) {
                    r.setSleeping(true);
                }
                Message msg = mHandler.obtainMessage(STOP_TIMEOUT_MSG, r);
                mHandler.sendMessageDelayed(msg, STOP_TIMEOUT);
            } catch (Exception e) {
                // Maybe just ignore exceptions here...  if the process
                // has crashed, our death notification will clean things
                // up.
                Slog.w(TAG, ""Exception thrown during pause"", e);
                // Just in case, assume it to be stopped.
                r.stopped = true;
                if (DEBUG_STATES) Slog.v(TAG_STATES, ""Stop failed; moving to STOPPED: "" + r);
                r.setState(STOPPED, ""stopActivityLocked"");
                if (r.deferRelaunchUntilPaused) {
                    destroyActivityLocked(r, true, ""stop-except"");
                }
            }
","        return stack;
    }

    final void stopActivityLocked(ActivityRecord r) {
        if (DEBUG_SWITCH) Slog.d(TAG_SWITCH, ""Stopping: "" + r);
        r.launching = false;
        if ((r.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_HISTORY) != 0
                || (r.info.flags&ActivityInfo.FLAG_NO_HISTORY) != 0) {
            if (!r.finishing) {
                if (!shouldSleepActivities()) {
                    if (DEBUG_STATES) Slog.d(TAG_STATES, ""no-history finish of "" + r);
                    if (r.finishIfPossible(""stop-no-history"", false /* oomAdj */)
                            != FINISH_RESULT_CANCELLED) {
                        // {@link adjustFocusedActivityStack} must have been already called.
                        r.resumeKeyDispatchingLocked();
                        return;
                    }
                } else {
                    if (DEBUG_STATES) Slog.d(TAG_STATES, ""Not finishing noHistory "" + r
                            + "" on stop because we're just sleeping"");
                }
            }
        }

        if (r.attachedToProcess()) {
            adjustFocusedActivityStack(r, ""stopActivity"");
            r.resumeKeyDispatchingLocked();
            try {
                r.stopped = false;

                if (DEBUG_STATES) Slog.v(TAG_STATES,
                        ""Moving to STOPPING: "" + r + "" (stop requested)"");
                r.setState(STOPPING, ""stopActivityLocked"");

                if (mActivityPluginDelegate != null && getWindowingMode() != WINDOWING_MODE_UNDEFINED) {
                    mActivityPluginDelegate.activitySuspendNotification
                        (r.info.applicationInfo.packageName, getWindowingMode() == WINDOWING_MODE_FULLSCREEN, false);
                }
                if (DEBUG_VISIBILITY) Slog.v(TAG_VISIBILITY,
                        ""Stopping visible="" + r.visible + "" for "" + r);

                if (mActivityTrigger != null) {
                    mActivityTrigger.activityStopTrigger(r.intent, r.info, r.info.applicationInfo);
                }

                if (!r.visible) {
                    r.setVisible(false);
                }
                EventLogTags.writeAmStopActivity(
                        r.mUserId, System.identityHashCode(r), r.shortComponentName);
                mService.getLifecycleManager().scheduleTransaction(r.app.getThread(), r.appToken,
                        StopActivityItem.obtain(r.visible, r.configChangeFlags));
                if (shouldSleepOrShutDownActivities()) {
                    r.setSleeping(true);
                }
                Message msg = mHandler.obtainMessage(STOP_TIMEOUT_MSG, r);
                mHandler.sendMessageDelayed(msg, STOP_TIMEOUT);
            } catch (Exception e) {
                // Maybe just ignore exceptions here...  if the process
                // has crashed, our death notification will clean things
                // up.
                Slog.w(TAG, ""Exception thrown during pause"", e);
                // Just in case, assume it to be stopped.
                r.stopped = true;
                if (DEBUG_STATES) Slog.v(TAG_STATES, ""Stop failed; moving to STOPPED: "" + r);
                r.setState(STOPPED, ""stopActivityLocked"");
                if (r.deferRelaunchUntilPaused) {
                    destroyActivityLocked(r, true, ""stop-except"");
                }
            }
","[1.0, 1.0]"
1376,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(8907, 9055, 149), (8907, 9055, 149)]","        private static final Validator AWARE_LOCK_ENABLED_VALIDATOR = BOOLEAN_VALIDATOR;

        /**
         * This are the settings to be backed up.
         *
         * NOTE: Settings are backed up and restored in the order they appear
         *       in this array. If you have one setting depending on another,
         *       make sure that they are ordered appropriately.
         *
         * @hide
         */
        @UnsupportedAppUsage
        public static final String[] SETTINGS_TO_BACKUP = {
            BUGREPORT_IN_POWER_MENU,                            // moved to global
            ALLOW_MOCK_LOCATION,
            USB_MASS_STORAGE_ENABLED,                           // moved to global
            ACCESSIBILITY_DISPLAY_INVERSION_ENABLED,
            ACCESSIBILITY_DISPLAY_DALTONIZER,
            ACCESSIBILITY_DISPLAY_DALTONIZER_ENABLED,
            ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
            ACCESSIBILITY_DISPLAY_MAGNIFICATION_NAVBAR_ENABLED,
            AUTOFILL_SERVICE,
            ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
            ENABLED_ACCESSIBILITY_SERVICES,
            ENABLED_VR_LISTENERS,
            TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
            TOUCH_EXPLORATION_ENABLED,
            ACCESSIBILITY_ENABLED,
            ACCESSIBILITY_SHORTCUT_TARGET_SERVICE,
            ACCESSIBILITY_BUTTON_TARGET_COMPONENT,
            ACCESSIBILITY_SHORTCUT_DIALOG_SHOWN,
            ACCESSIBILITY_SHORTCUT_ENABLED,
            ACCESSIBILITY_SHORTCUT_ON_LOCK_SCREEN,
            ACCESSIBILITY_HIGH_TEXT_CONTRAST_ENABLED,
            ACCESSIBILITY_CAPTIONING_PRESET,
            ACCESSIBILITY_CAPTIONING_ENABLED,
            ACCESSIBILITY_CAPTIONING_LOCALE,
            ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR,
            ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR,
            ACCESSIBILITY_CAPTIONING_EDGE_TYPE,
            ACCESSIBILITY_CAPTIONING_EDGE_COLOR,
            ACCESSIBILITY_CAPTIONING_TYPEFACE,
            ACCESSIBILITY_CAPTIONING_FONT_SCALE,
            ACCESSIBILITY_CAPTIONING_WINDOW_COLOR,
            TTS_DEFAULT_RATE,
            TTS_DEFAULT_PITCH,
            TTS_DEFAULT_SYNTH,
            TTS_ENABLED_PLUGINS,
            TTS_DEFAULT_LOCALE,
            SHOW_IME_WITH_HARD_KEYBOARD,
            WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,            // moved to global
            WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,               // moved to global
            WIFI_NUM_OPEN_NETWORKS_KEPT,                        // moved to global
            MOUNT_PLAY_NOTIFICATION_SND,
            MOUNT_UMS_AUTOSTART,
            MOUNT_UMS_PROMPT,
            MOUNT_UMS_NOTIFY_ENABLED,
            DOUBLE_TAP_TO_WAKE,
            WAKE_GESTURE_ENABLED,
            LONG_PRESS_TIMEOUT,
            CAMERA_GESTURE_DISABLED,
            ACCESSIBILITY_AUTOCLICK_ENABLED,
            ACCESSIBILITY_AUTOCLICK_DELAY,
            ACCESSIBILITY_LARGE_POINTER_ICON,
            PREFERRED_TTY_MODE,
            ENHANCED_VOICE_PRIVACY_ENABLED,
            TTY_MODE_ENABLED,
            RTT_CALLING_MODE,
            INCALL_POWER_BUTTON_BEHAVIOR,
            NIGHT_DISPLAY_CUSTOM_START_TIME,
            NIGHT_DISPLAY_CUSTOM_END_TIME,
            NIGHT_DISPLAY_COLOR_TEMPERATURE,
            NIGHT_DISPLAY_AUTO_MODE,
            DISPLAY_WHITE_BALANCE_ENABLED,
            SYNC_PARENT_SOUNDS,
            CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED,
            CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED,
            SYSTEM_NAVIGATION_KEYS_ENABLED,
            QS_TILES,
            DOZE_ENABLED,
            DOZE_ALWAYS_ON,
            DOZE_PICK_UP_GESTURE,
            DOZE_DOUBLE_TAP_GESTURE,
            DOZE_TAP_SCREEN_GESTURE,
            DOZE_WAKE_LOCK_SCREEN_GESTURE,
            DOZE_WAKE_DISPLAY_GESTURE,
            NFC_PAYMENT_DEFAULT_COMPONENT,
            AUTOMATIC_STORAGE_MANAGER_DAYS_TO_RETAIN,
            FACE_UNLOCK_KEYGUARD_ENABLED,
            SHOW_MEDIA_WHEN_BYPASSING,
            FACE_UNLOCK_DISMISSES_KEYGUARD,
            FACE_UNLOCK_APP_ENABLED,
            FACE_UNLOCK_ALWAYS_REQUIRE_CONFIRMATION,
            ASSIST_GESTURE_ENABLED,
            ASSIST_GESTURE_SILENCE_ALERTS_ENABLED,
            ASSIST_GESTURE_WAKE_ENABLED,
            VR_DISPLAY_MODE,
            NOTIFICATION_BADGING,
            NOTIFICATION_BUBBLES,
            NOTIFICATION_DISMISS_RTL,
            QS_AUTO_ADDED_TILES,
            SCREENSAVER_ENABLED,
            SCREENSAVER_COMPONENTS,
            SCREENSAVER_ACTIVATE_ON_DOCK,
            SCREENSAVER_ACTIVATE_ON_SLEEP,
            LOCKDOWN_IN_POWER_MENU,
            SHOW_FIRST_CRASH_DIALOG_DEV_OPTION,
            VOLUME_HUSH_GESTURE,
            MANUAL_RINGER_TOGGLE_COUNT,
            HUSH_GESTURE_USED,
            IN_CALL_NOTIFICATION_ENABLED,
            LOCK_SCREEN_ALLOW_PRIVATE_NOTIFICATIONS,
            LOCK_SCREEN_CUSTOM_CLOCK_FACE,
            LOCK_SCREEN_SHOW_NOTIFICATIONS,
            LOCK_SCREEN_SHOW_SILENT_NOTIFICATIONS,
            SHOW_NOTIFICATION_SNOOZE,
            ZEN_DURATION,
            SHOW_ZEN_UPGRADE_NOTIFICATION,
            SHOW_ZEN_SETTINGS_SUGGESTION,
            ZEN_SETTINGS_UPDATED,
            ZEN_SETTINGS_SUGGESTION_VIEWED,
            CHARGING_SOUNDS_ENABLED,
            CHARGING_VIBRATION_ENABLED,
            WIFI_DISCONNECT_DELAY_DURATION,
            ACCESSIBILITY_NON_INTERACTIVE_UI_TIMEOUT_MS,
            ACCESSIBILITY_INTERACTIVE_UI_TIMEOUT_MS,
            NOTIFICATION_NEW_INTERRUPTION_MODEL,
            TRUST_AGENTS_EXTEND_UNLOCK,
            UI_NIGHT_MODE,
            LOCK_SCREEN_WHEN_TRUST_LOST,
            SKIP_GESTURE,
            SKIP_DIRECTION,
            SILENCE_GESTURE,
            THEME_CUSTOMIZATION_OVERLAY_PACKAGES,
            NAVIGATION_MODE,
            AWARE_ENABLED,
            SKIP_GESTURE_COUNT,
            SKIP_TOUCH_COUNT,
            SILENCE_ALARMS_GESTURE_COUNT,
            SILENCE_CALL_GESTURE_COUNT,
            SILENCE_TIMER_GESTURE_COUNT,
            SILENCE_ALARMS_TOUCH_COUNT,
            SILENCE_CALL_TOUCH_COUNT,
            SILENCE_TIMER_TOUCH_COUNT,
            DARK_MODE_DIALOG_SEEN,
            GLOBAL_ACTIONS_PANEL_ENABLED,
            AWARE_LOCK_ENABLED
        };

","        private static final Validator AWARE_LOCK_ENABLED_VALIDATOR = BOOLEAN_VALIDATOR;

        /**
         * This are the settings to be backed up.
         *
         * NOTE: Settings are backed up and restored in the order they appear
         *       in this array. If you have one setting depending on another,
         *       make sure that they are ordered appropriately.
         *
         * @hide
         */
        @UnsupportedAppUsage
        public static final String[] SETTINGS_TO_BACKUP = {
            BUGREPORT_IN_POWER_MENU,                            // moved to global
            ALLOW_MOCK_LOCATION,
            USB_MASS_STORAGE_ENABLED,                           // moved to global
            ACCESSIBILITY_DISPLAY_INVERSION_ENABLED,
            ACCESSIBILITY_DISPLAY_DALTONIZER,
            ACCESSIBILITY_DISPLAY_DALTONIZER_ENABLED,
            ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
            ACCESSIBILITY_DISPLAY_MAGNIFICATION_NAVBAR_ENABLED,
            AUTOFILL_SERVICE,
            ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
            ENABLED_ACCESSIBILITY_SERVICES,
            ENABLED_VR_LISTENERS,
            TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
            TOUCH_EXPLORATION_ENABLED,
            ACCESSIBILITY_ENABLED,
            ACCESSIBILITY_SHORTCUT_TARGET_SERVICE,
            ACCESSIBILITY_BUTTON_TARGET_COMPONENT,
            ACCESSIBILITY_SHORTCUT_DIALOG_SHOWN,
            ACCESSIBILITY_SHORTCUT_ENABLED,
            ACCESSIBILITY_SHORTCUT_ON_LOCK_SCREEN,
            ACCESSIBILITY_HIGH_TEXT_CONTRAST_ENABLED,
            ACCESSIBILITY_CAPTIONING_PRESET,
            ACCESSIBILITY_CAPTIONING_ENABLED,
            ACCESSIBILITY_CAPTIONING_LOCALE,
            ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR,
            ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR,
            ACCESSIBILITY_CAPTIONING_EDGE_TYPE,
            ACCESSIBILITY_CAPTIONING_EDGE_COLOR,
            ACCESSIBILITY_CAPTIONING_TYPEFACE,
            ACCESSIBILITY_CAPTIONING_FONT_SCALE,
            ACCESSIBILITY_CAPTIONING_WINDOW_COLOR,
            TTS_DEFAULT_RATE,
            TTS_DEFAULT_PITCH,
            TTS_DEFAULT_SYNTH,
            TTS_ENABLED_PLUGINS,
            TTS_DEFAULT_LOCALE,
            SHOW_IME_WITH_HARD_KEYBOARD,
            WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,            // moved to global
            WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,               // moved to global
            WIFI_NUM_OPEN_NETWORKS_KEPT,                        // moved to global
            MOUNT_PLAY_NOTIFICATION_SND,
            MOUNT_UMS_AUTOSTART,
            MOUNT_UMS_PROMPT,
            MOUNT_UMS_NOTIFY_ENABLED,
            DOUBLE_TAP_TO_WAKE,
            WAKE_GESTURE_ENABLED,
            LONG_PRESS_TIMEOUT,
            CAMERA_GESTURE_DISABLED,
            ACCESSIBILITY_AUTOCLICK_ENABLED,
            ACCESSIBILITY_AUTOCLICK_DELAY,
            ACCESSIBILITY_LARGE_POINTER_ICON,
            PREFERRED_TTY_MODE,
            ENHANCED_VOICE_PRIVACY_ENABLED,
            TTY_MODE_ENABLED,
            RTT_CALLING_MODE,
            INCALL_POWER_BUTTON_BEHAVIOR,
            NIGHT_DISPLAY_CUSTOM_START_TIME,
            NIGHT_DISPLAY_CUSTOM_END_TIME,
            NIGHT_DISPLAY_COLOR_TEMPERATURE,
            NIGHT_DISPLAY_AUTO_MODE,
            DISPLAY_WHITE_BALANCE_ENABLED,
            SYNC_PARENT_SOUNDS,
            CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED,
            CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED,
            SYSTEM_NAVIGATION_KEYS_ENABLED,
            QS_TILES,
            DOZE_ENABLED,
            DOZE_ALWAYS_ON,
            DOZE_PICK_UP_GESTURE,
            DOZE_DOUBLE_TAP_GESTURE,
            DOZE_TAP_SCREEN_GESTURE,
            DOZE_WAKE_LOCK_SCREEN_GESTURE,
            DOZE_WAKE_DISPLAY_GESTURE,
            NFC_PAYMENT_DEFAULT_COMPONENT,
            AUTOMATIC_STORAGE_MANAGER_DAYS_TO_RETAIN,
            FACE_UNLOCK_KEYGUARD_ENABLED,
            SHOW_MEDIA_WHEN_BYPASSING,
            FACE_UNLOCK_DISMISSES_KEYGUARD,
            FACE_UNLOCK_APP_ENABLED,
            FACE_UNLOCK_ALWAYS_REQUIRE_CONFIRMATION,
            ASSIST_GESTURE_ENABLED,
            ASSIST_GESTURE_SILENCE_ALERTS_ENABLED,
            ASSIST_GESTURE_WAKE_ENABLED,
            VR_DISPLAY_MODE,
            NOTIFICATION_BADGING,
            NOTIFICATION_BUBBLES,
            NOTIFICATION_DISMISS_RTL,
            QS_AUTO_ADDED_TILES,
            SCREENSAVER_ENABLED,
            SCREENSAVER_COMPONENTS,
            SCREENSAVER_ACTIVATE_ON_DOCK,
            SCREENSAVER_ACTIVATE_ON_SLEEP,
            LOCKDOWN_IN_POWER_MENU,
            SHOW_FIRST_CRASH_DIALOG_DEV_OPTION,
            VOLUME_HUSH_GESTURE,
            MANUAL_RINGER_TOGGLE_COUNT,
            HUSH_GESTURE_USED,
            IN_CALL_NOTIFICATION_ENABLED,
            LOCK_SCREEN_ALLOW_PRIVATE_NOTIFICATIONS,
            LOCK_SCREEN_CUSTOM_CLOCK_FACE,
            LOCK_SCREEN_SHOW_NOTIFICATIONS,
            LOCK_SCREEN_SHOW_SILENT_NOTIFICATIONS,
            SHOW_NOTIFICATION_SNOOZE,
            ZEN_DURATION,
            SHOW_ZEN_UPGRADE_NOTIFICATION,
            SHOW_ZEN_SETTINGS_SUGGESTION,
            ZEN_SETTINGS_UPDATED,
            ZEN_SETTINGS_SUGGESTION_VIEWED,
            CHARGING_SOUNDS_ENABLED,
            CHARGING_VIBRATION_ENABLED,
            WIFI_DISCONNECT_DELAY_DURATION,
            ACCESSIBILITY_NON_INTERACTIVE_UI_TIMEOUT_MS,
            ACCESSIBILITY_INTERACTIVE_UI_TIMEOUT_MS,
            NOTIFICATION_NEW_INTERRUPTION_MODEL,
            TRUST_AGENTS_EXTEND_UNLOCK,
            UI_NIGHT_MODE,
            LOCK_SCREEN_WHEN_TRUST_LOST,
            SKIP_GESTURE,
            SKIP_DIRECTION,
            SILENCE_GESTURE,
            THEME_CUSTOMIZATION_OVERLAY_PACKAGES,
            NAVIGATION_MODE,
            AWARE_ENABLED,
            SKIP_GESTURE_COUNT,
            SKIP_TOUCH_COUNT,
            SILENCE_ALARMS_GESTURE_COUNT,
            SILENCE_CALL_GESTURE_COUNT,
            SILENCE_TIMER_GESTURE_COUNT,
            SILENCE_ALARMS_TOUCH_COUNT,
            SILENCE_CALL_TOUCH_COUNT,
            SILENCE_TIMER_TOUCH_COUNT,
            DARK_MODE_DIALOG_SEEN,
            GLOBAL_ACTIONS_PANEL_ENABLED,
            AWARE_LOCK_ENABLED
        };

","        private static final Validator AWARE_LOCK_ENABLED_VALIDATOR = BOOLEAN_VALIDATOR;

        /**
         * This are the settings to be backed up.
         *
         * NOTE: Settings are backed up and restored in the order they appear
         *       in this array. If you have one setting depending on another,
         *       make sure that they are ordered appropriately.
         *
         * @hide
         */
        @UnsupportedAppUsage
        public static final String[] SETTINGS_TO_BACKUP = {
            BUGREPORT_IN_POWER_MENU,                            // moved to global
            ALLOW_MOCK_LOCATION,
            USB_MASS_STORAGE_ENABLED,                           // moved to global
            ACCESSIBILITY_DISPLAY_INVERSION_ENABLED,
            ACCESSIBILITY_DISPLAY_DALTONIZER,
            ACCESSIBILITY_DISPLAY_DALTONIZER_ENABLED,
            ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
            ACCESSIBILITY_DISPLAY_MAGNIFICATION_NAVBAR_ENABLED,
            AUTOFILL_SERVICE,
            ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
            ENABLED_ACCESSIBILITY_SERVICES,
            ENABLED_VR_LISTENERS,
            TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
            TOUCH_EXPLORATION_ENABLED,
            ACCESSIBILITY_ENABLED,
            ACCESSIBILITY_SHORTCUT_TARGET_SERVICE,
            ACCESSIBILITY_BUTTON_TARGET_COMPONENT,
            ACCESSIBILITY_SHORTCUT_DIALOG_SHOWN,
            ACCESSIBILITY_SHORTCUT_ENABLED,
            ACCESSIBILITY_SHORTCUT_ON_LOCK_SCREEN,
            ACCESSIBILITY_HIGH_TEXT_CONTRAST_ENABLED,
            ACCESSIBILITY_CAPTIONING_PRESET,
            ACCESSIBILITY_CAPTIONING_ENABLED,
            ACCESSIBILITY_CAPTIONING_LOCALE,
            ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR,
            ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR,
            ACCESSIBILITY_CAPTIONING_EDGE_TYPE,
            ACCESSIBILITY_CAPTIONING_EDGE_COLOR,
            ACCESSIBILITY_CAPTIONING_TYPEFACE,
            ACCESSIBILITY_CAPTIONING_FONT_SCALE,
            ACCESSIBILITY_CAPTIONING_WINDOW_COLOR,
            TTS_DEFAULT_RATE,
            TTS_DEFAULT_PITCH,
            TTS_DEFAULT_SYNTH,
            TTS_ENABLED_PLUGINS,
            TTS_DEFAULT_LOCALE,
            SHOW_IME_WITH_HARD_KEYBOARD,
            WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,            // moved to global
            WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,               // moved to global
            WIFI_NUM_OPEN_NETWORKS_KEPT,                        // moved to global
            MOUNT_PLAY_NOTIFICATION_SND,
            MOUNT_UMS_AUTOSTART,
            MOUNT_UMS_PROMPT,
            MOUNT_UMS_NOTIFY_ENABLED,
            DOUBLE_TAP_TO_WAKE,
            WAKE_GESTURE_ENABLED,
            LONG_PRESS_TIMEOUT,
            CAMERA_GESTURE_DISABLED,
            ACCESSIBILITY_AUTOCLICK_ENABLED,
            ACCESSIBILITY_AUTOCLICK_DELAY,
            ACCESSIBILITY_LARGE_POINTER_ICON,
            PREFERRED_TTY_MODE,
            ENHANCED_VOICE_PRIVACY_ENABLED,
            TTY_MODE_ENABLED,
            RTT_CALLING_MODE,
            INCALL_POWER_BUTTON_BEHAVIOR,
            NIGHT_DISPLAY_CUSTOM_START_TIME,
            NIGHT_DISPLAY_CUSTOM_END_TIME,
            NIGHT_DISPLAY_COLOR_TEMPERATURE,
            NIGHT_DISPLAY_AUTO_MODE,
            DISPLAY_WHITE_BALANCE_ENABLED,
            SYNC_PARENT_SOUNDS,
            CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED,
            CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED,
            SYSTEM_NAVIGATION_KEYS_ENABLED,
            QS_TILES,
            DOZE_ENABLED,
            DOZE_ALWAYS_ON,
            DOZE_PICK_UP_GESTURE,
            DOZE_DOUBLE_TAP_GESTURE,
            DOZE_TAP_SCREEN_GESTURE,
            DOZE_WAKE_LOCK_SCREEN_GESTURE,
            DOZE_WAKE_DISPLAY_GESTURE,
            NFC_PAYMENT_DEFAULT_COMPONENT,
            AUTOMATIC_STORAGE_MANAGER_DAYS_TO_RETAIN,
            FACE_UNLOCK_KEYGUARD_ENABLED,
            SHOW_MEDIA_WHEN_BYPASSING,
            FACE_UNLOCK_DISMISSES_KEYGUARD,
            FACE_UNLOCK_APP_ENABLED,
            FACE_UNLOCK_ALWAYS_REQUIRE_CONFIRMATION,
            ASSIST_GESTURE_ENABLED,
            ASSIST_GESTURE_SILENCE_ALERTS_ENABLED,
            ASSIST_GESTURE_WAKE_ENABLED,
            VR_DISPLAY_MODE,
            NOTIFICATION_BADGING,
            NOTIFICATION_BUBBLES,
            NOTIFICATION_DISMISS_RTL,
            QS_AUTO_ADDED_TILES,
            SCREENSAVER_ENABLED,
            SCREENSAVER_COMPONENTS,
            SCREENSAVER_ACTIVATE_ON_DOCK,
            SCREENSAVER_ACTIVATE_ON_SLEEP,
            LOCKDOWN_IN_POWER_MENU,
            SHOW_FIRST_CRASH_DIALOG_DEV_OPTION,
            VOLUME_HUSH_GESTURE,
            MANUAL_RINGER_TOGGLE_COUNT,
            HUSH_GESTURE_USED,
            IN_CALL_NOTIFICATION_ENABLED,
            LOCK_SCREEN_ALLOW_PRIVATE_NOTIFICATIONS,
            LOCK_SCREEN_CUSTOM_CLOCK_FACE,
            LOCK_SCREEN_SHOW_NOTIFICATIONS,
            LOCK_SCREEN_SHOW_SILENT_NOTIFICATIONS,
            SHOW_NOTIFICATION_SNOOZE,
            ZEN_DURATION,
            SHOW_ZEN_UPGRADE_NOTIFICATION,
            SHOW_ZEN_SETTINGS_SUGGESTION,
            ZEN_SETTINGS_UPDATED,
            ZEN_SETTINGS_SUGGESTION_VIEWED,
            CHARGING_SOUNDS_ENABLED,
            CHARGING_VIBRATION_ENABLED,
            WIFI_DISCONNECT_DELAY_DURATION,
            ACCESSIBILITY_NON_INTERACTIVE_UI_TIMEOUT_MS,
            ACCESSIBILITY_INTERACTIVE_UI_TIMEOUT_MS,
            NOTIFICATION_NEW_INTERRUPTION_MODEL,
            TRUST_AGENTS_EXTEND_UNLOCK,
            UI_NIGHT_MODE,
            LOCK_SCREEN_WHEN_TRUST_LOST,
            SKIP_GESTURE,
            SKIP_DIRECTION,
            SILENCE_GESTURE,
            THEME_CUSTOMIZATION_OVERLAY_PACKAGES,
            NAVIGATION_MODE,
            AWARE_ENABLED,
            SKIP_GESTURE_COUNT,
            SKIP_TOUCH_COUNT,
            SILENCE_ALARMS_GESTURE_COUNT,
            SILENCE_CALL_GESTURE_COUNT,
            SILENCE_TIMER_GESTURE_COUNT,
            SILENCE_ALARMS_TOUCH_COUNT,
            SILENCE_CALL_TOUCH_COUNT,
            SILENCE_TIMER_TOUCH_COUNT,
            DARK_MODE_DIALOG_SEEN,
            GLOBAL_ACTIONS_PANEL_ENABLED,
            AWARE_LOCK_ENABLED
        };

","[1.0, 1.0]"
1377,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/provider/Settings.java,"[(9071, 9266, 196), (9071, 9266, 196)]","         * All settings in {@link SETTINGS_TO_BACKUP} and {@link DEVICE_SPECIFIC_SETTINGS_TO_BACKUP}
         * array *must* have a non-null validator, otherwise they won't be restored.
         *
         * @hide
         */
        public static final Map<String, Validator> VALIDATORS = new ArrayMap<>();
        static {
            VALIDATORS.put(BUGREPORT_IN_POWER_MENU, BUGREPORT_IN_POWER_MENU_VALIDATOR);
            VALIDATORS.put(ALLOW_MOCK_LOCATION, ALLOW_MOCK_LOCATION_VALIDATOR);
            VALIDATORS.put(USB_MASS_STORAGE_ENABLED, USB_MASS_STORAGE_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_INVERSION_ENABLED,
                    ACCESSIBILITY_DISPLAY_INVERSION_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_DALTONIZER,
                    ACCESSIBILITY_DISPLAY_DALTONIZER_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_DALTONIZER_ENABLED,
                    ACCESSIBILITY_DISPLAY_DALTONIZER_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
                    ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_MAGNIFICATION_NAVBAR_ENABLED,
                    ACCESSIBILITY_DISPLAY_MAGNIFICATION_NAVBAR_ENABLED_VALIDATOR);
            VALIDATORS.put(AUTOFILL_SERVICE, AUTOFILL_SERVICE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
                    ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE_VALIDATOR);
            VALIDATORS.put(ENABLED_ACCESSIBILITY_SERVICES,
                    ENABLED_ACCESSIBILITY_SERVICES_VALIDATOR);
            VALIDATORS.put(ENABLED_VR_LISTENERS, ENABLED_VR_LISTENERS_VALIDATOR);
            VALIDATORS.put(TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
                    TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES_VALIDATOR);
            VALIDATORS.put(TOUCH_EXPLORATION_ENABLED, TOUCH_EXPLORATION_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_ENABLED, ACCESSIBILITY_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_TARGET_SERVICE,
                    ACCESSIBILITY_SHORTCUT_TARGET_SERVICE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_BUTTON_TARGET_COMPONENT,
                    ACCESSIBILITY_BUTTON_TARGET_COMPONENT_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_DIALOG_SHOWN,
                    ACCESSIBILITY_SHORTCUT_DIALOG_SHOWN_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_ENABLED,
                    ACCESSIBILITY_SHORTCUT_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_ON_LOCK_SCREEN,
                    ACCESSIBILITY_SHORTCUT_ON_LOCK_SCREEN_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_HIGH_TEXT_CONTRAST_ENABLED,
                    ACCESSIBILITY_HIGH_TEXT_CONTRAST_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_PRESET,
                    ACCESSIBILITY_CAPTIONING_PRESET_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_ENABLED,
                    ACCESSIBILITY_CAPTIONING_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_LOCALE,
                    ACCESSIBILITY_CAPTIONING_LOCALE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR,
                    ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR,
                    ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_EDGE_TYPE,
                    ACCESSIBILITY_CAPTIONING_EDGE_TYPE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_EDGE_COLOR,
                    ACCESSIBILITY_CAPTIONING_EDGE_COLOR_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_TYPEFACE,
                    ACCESSIBILITY_CAPTIONING_TYPEFACE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_FONT_SCALE,
                    ACCESSIBILITY_CAPTIONING_FONT_SCALE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_WINDOW_COLOR,
                    ACCESSIBILITY_CAPTIONING_WINDOW_COLOR_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_RATE, TTS_DEFAULT_RATE_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_PITCH, TTS_DEFAULT_PITCH_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_SYNTH, TTS_DEFAULT_SYNTH_VALIDATOR);
            VALIDATORS.put(TTS_ENABLED_PLUGINS, TTS_ENABLED_PLUGINS_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_LOCALE, TTS_DEFAULT_LOCALE_VALIDATOR);
            VALIDATORS.put(SHOW_IME_WITH_HARD_KEYBOARD, SHOW_IME_WITH_HARD_KEYBOARD_VALIDATOR);
            VALIDATORS.put(WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,
                    WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON_VALIDATOR);
            VALIDATORS.put(WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,
                    WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY_VALIDATOR);
            VALIDATORS.put(WIFI_NUM_OPEN_NETWORKS_KEPT, WIFI_NUM_OPEN_NETWORKS_KEPT_VALIDATOR);
            VALIDATORS.put(MOUNT_PLAY_NOTIFICATION_SND, MOUNT_PLAY_NOTIFICATION_SND_VALIDATOR);
            VALIDATORS.put(MOUNT_UMS_AUTOSTART, MOUNT_UMS_AUTOSTART_VALIDATOR);
            VALIDATORS.put(MOUNT_UMS_PROMPT, MOUNT_UMS_PROMPT_VALIDATOR);
            VALIDATORS.put(MOUNT_UMS_NOTIFY_ENABLED, MOUNT_UMS_NOTIFY_ENABLED_VALIDATOR);
            VALIDATORS.put(DOUBLE_TAP_TO_WAKE, DOUBLE_TAP_TO_WAKE_VALIDATOR);
            VALIDATORS.put(WAKE_GESTURE_ENABLED, WAKE_GESTURE_ENABLED_VALIDATOR);
            VALIDATORS.put(LONG_PRESS_TIMEOUT, LONG_PRESS_TIMEOUT_VALIDATOR);
            VALIDATORS.put(CAMERA_GESTURE_DISABLED, CAMERA_GESTURE_DISABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_AUTOCLICK_ENABLED,
                    ACCESSIBILITY_AUTOCLICK_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_AUTOCLICK_DELAY, ACCESSIBILITY_AUTOCLICK_DELAY_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_LARGE_POINTER_ICON,
                    ACCESSIBILITY_LARGE_POINTER_ICON_VALIDATOR);
            VALIDATORS.put(PREFERRED_TTY_MODE, PREFERRED_TTY_MODE_VALIDATOR);
            VALIDATORS.put(ENHANCED_VOICE_PRIVACY_ENABLED,
                    ENHANCED_VOICE_PRIVACY_ENABLED_VALIDATOR);
            VALIDATORS.put(TTY_MODE_ENABLED, TTY_MODE_ENABLED_VALIDATOR);
            VALIDATORS.put(RTT_CALLING_MODE, RTT_CALLING_MODE_VALIDATOR);
            VALIDATORS.put(INCALL_POWER_BUTTON_BEHAVIOR, INCALL_POWER_BUTTON_BEHAVIOR_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_CUSTOM_START_TIME,
                    NIGHT_DISPLAY_CUSTOM_START_TIME_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_CUSTOM_END_TIME, NIGHT_DISPLAY_CUSTOM_END_TIME_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_COLOR_TEMPERATURE,
                    NIGHT_DISPLAY_COLOR_TEMPERATURE_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_AUTO_MODE, NIGHT_DISPLAY_AUTO_MODE_VALIDATOR);
            VALIDATORS.put(DISPLAY_WHITE_BALANCE_ENABLED, DISPLAY_WHITE_BALANCE_ENABLED_VALIDATOR);
            VALIDATORS.put(SYNC_PARENT_SOUNDS, SYNC_PARENT_SOUNDS_VALIDATOR);
            VALIDATORS.put(CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED,
                    CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED_VALIDATOR);
            VALIDATORS.put(CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED,
                    CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED_VALIDATOR);
            VALIDATORS.put(SYSTEM_NAVIGATION_KEYS_ENABLED,
                    SYSTEM_NAVIGATION_KEYS_ENABLED_VALIDATOR);
            VALIDATORS.put(QS_TILES, QS_TILES_VALIDATOR);
            VALIDATORS.put(DOZE_ENABLED, DOZE_ENABLED_VALIDATOR);
            VALIDATORS.put(DOZE_ALWAYS_ON, DOZE_ALWAYS_ON_VALIDATOR);
            VALIDATORS.put(DOZE_PICK_UP_GESTURE, DOZE_PICK_UP_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_DOUBLE_TAP_GESTURE, DOZE_DOUBLE_TAP_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_TAP_SCREEN_GESTURE, DOZE_TAP_SCREEN_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_WAKE_LOCK_SCREEN_GESTURE, DOZE_WAKE_LOCK_SCREEN_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_WAKE_DISPLAY_GESTURE, DOZE_WAKE_DISPLAY_GESTURE_VALIDATOR);
            VALIDATORS.put(NFC_PAYMENT_DEFAULT_COMPONENT, NFC_PAYMENT_DEFAULT_COMPONENT_VALIDATOR);
            VALIDATORS.put(AUTOMATIC_STORAGE_MANAGER_DAYS_TO_RETAIN,
                    AUTOMATIC_STORAGE_MANAGER_DAYS_TO_RETAIN_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_KEYGUARD_ENABLED, FACE_UNLOCK_KEYGUARD_ENABLED_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_DISMISSES_KEYGUARD,
                    FACE_UNLOCK_DISMISSES_KEYGUARD_VALIDATOR);
            VALIDATORS.put(SHOW_MEDIA_WHEN_BYPASSING, SHOW_MEDIA_WHEN_BYPASSING_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_APP_ENABLED, FACE_UNLOCK_APP_ENABLED_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_ALWAYS_REQUIRE_CONFIRMATION,
                    FACE_UNLOCK_ALWAYS_REQUIRE_CONFIRMATION_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_ENABLED, ASSIST_GESTURE_ENABLED_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_SILENCE_ALERTS_ENABLED,
                    ASSIST_GESTURE_SILENCE_ALERTS_ENABLED_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_WAKE_ENABLED, ASSIST_GESTURE_WAKE_ENABLED_VALIDATOR);
            VALIDATORS.put(VR_DISPLAY_MODE, VR_DISPLAY_MODE_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_BADGING, NOTIFICATION_BADGING_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_BUBBLES, NOTIFICATION_BUBBLES_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_DISMISS_RTL, NOTIFICATION_DISMISS_RTL_VALIDATOR);
            VALIDATORS.put(QS_AUTO_ADDED_TILES, QS_AUTO_ADDED_TILES_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_ENABLED, SCREENSAVER_ENABLED_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_COMPONENTS, SCREENSAVER_COMPONENTS_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_ACTIVATE_ON_DOCK, SCREENSAVER_ACTIVATE_ON_DOCK_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_ACTIVATE_ON_SLEEP, SCREENSAVER_ACTIVATE_ON_SLEEP_VALIDATOR);
            VALIDATORS.put(LOCKDOWN_IN_POWER_MENU, LOCKDOWN_IN_POWER_MENU_VALIDATOR);
            VALIDATORS.put(SHOW_FIRST_CRASH_DIALOG_DEV_OPTION,
                    SHOW_FIRST_CRASH_DIALOG_DEV_OPTION_VALIDATOR);
            VALIDATORS.put(VOLUME_HUSH_GESTURE, VOLUME_HUSH_GESTURE_VALIDATOR);
            VALIDATORS.put(ENABLED_NOTIFICATION_LISTENERS,
                    ENABLED_NOTIFICATION_LISTENERS_VALIDATOR); //legacy restore setting
            VALIDATORS.put(ENABLED_NOTIFICATION_ASSISTANT,
                    ENABLED_NOTIFICATION_ASSISTANT_VALIDATOR); //legacy restore setting
            VALIDATORS.put(ENABLED_NOTIFICATION_POLICY_ACCESS_PACKAGES,
                    ENABLED_NOTIFICATION_POLICY_ACCESS_PACKAGES_VALIDATOR); //legacy restore setting
            VALIDATORS.put(HUSH_GESTURE_USED, HUSH_GESTURE_USED_VALIDATOR);
            VALIDATORS.put(MANUAL_RINGER_TOGGLE_COUNT, MANUAL_RINGER_TOGGLE_COUNT_VALIDATOR);
            VALIDATORS.put(IN_CALL_NOTIFICATION_ENABLED, IN_CALL_NOTIFICATION_ENABLED_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_ALLOW_PRIVATE_NOTIFICATIONS, BOOLEAN_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_SHOW_NOTIFICATIONS, BOOLEAN_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_SHOW_SILENT_NOTIFICATIONS, BOOLEAN_VALIDATOR);
            VALIDATORS.put(SHOW_NOTIFICATION_SNOOZE, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ZEN_DURATION, ZEN_DURATION_VALIDATOR);
            VALIDATORS.put(SHOW_ZEN_UPGRADE_NOTIFICATION, BOOLEAN_VALIDATOR);
            VALIDATORS.put(SHOW_ZEN_SETTINGS_SUGGESTION, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ZEN_SETTINGS_UPDATED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ZEN_SETTINGS_SUGGESTION_VIEWED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(CHARGING_SOUNDS_ENABLED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(CHARGING_VIBRATION_ENABLED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_NON_INTERACTIVE_UI_TIMEOUT_MS,
                    NON_NEGATIVE_INTEGER_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_INTERACTIVE_UI_TIMEOUT_MS, NON_NEGATIVE_INTEGER_VALIDATOR);
            VALIDATORS.put(USER_SETUP_COMPLETE, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_SETUP_COMPLETE, BOOLEAN_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_NEW_INTERRUPTION_MODEL, BOOLEAN_VALIDATOR);
            VALIDATORS.put(TRUST_AGENTS_EXTEND_UNLOCK, TRUST_AGENTS_EXTEND_UNLOCK_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_CUSTOM_CLOCK_FACE, LOCK_SCREEN_CUSTOM_CLOCK_FACE_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_WHEN_TRUST_LOST, LOCK_SCREEN_WHEN_TRUST_LOST_VALIDATOR);
            VALIDATORS.put(SKIP_GESTURE, SKIP_GESTURE_VALIDATOR);
            VALIDATORS.put(SKIP_DIRECTION, SKIP_DIRECTION_VALIDATOR);
            VALIDATORS.put(SKIP_DIRECTION, SKIP_DIRECTION_VALIDATOR);
            VALIDATORS.put(SILENCE_GESTURE, SILENCE_GESTURE_VALIDATOR);
            VALIDATORS.put(THEME_CUSTOMIZATION_OVERLAY_PACKAGES,
                    THEME_CUSTOMIZATION_OVERLAY_PACKAGES_VALIDATOR);
            VALIDATORS.put(NAVIGATION_MODE, NAVIGATION_MODE_VALIDATOR);
            VALIDATORS.put(AWARE_ENABLED, AWARE_ENABLED_VALIDATOR);
            VALIDATORS.put(SKIP_GESTURE_COUNT, SKIP_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SKIP_TOUCH_COUNT, SKIP_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_ALARMS_GESTURE_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_TIMER_GESTURE_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_CALL_GESTURE_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_ALARMS_TOUCH_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_TIMER_TOUCH_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_CALL_TOUCH_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(ODI_CAPTIONS_ENABLED, ODI_CAPTIONS_ENABLED_VALIDATOR);
            VALIDATORS.put(DARK_MODE_DIALOG_SEEN, BOOLEAN_VALIDATOR);
            VALIDATORS.put(UI_NIGHT_MODE, UI_NIGHT_MODE_VALIDATOR);
            VALIDATORS.put(GLOBAL_ACTIONS_PANEL_ENABLED, GLOBAL_ACTIONS_PANEL_ENABLED_VALIDATOR);
            VALIDATORS.put(AWARE_LOCK_ENABLED, AWARE_LOCK_ENABLED_VALIDATOR);
            VALIDATORS.put(DISPLAY_DENSITY_FORCED, DISPLAY_DENSITY_FORCED_VALIDATOR);
        }

        /**
","         * All settings in {@link SETTINGS_TO_BACKUP} and {@link DEVICE_SPECIFIC_SETTINGS_TO_BACKUP}
         * array *must* have a non-null validator, otherwise they won't be restored.
         *
         * @hide
         */
        public static final Map<String, Validator> VALIDATORS = new ArrayMap<>();
        static {
            VALIDATORS.put(BUGREPORT_IN_POWER_MENU, BUGREPORT_IN_POWER_MENU_VALIDATOR);
            VALIDATORS.put(ALLOW_MOCK_LOCATION, ALLOW_MOCK_LOCATION_VALIDATOR);
            VALIDATORS.put(USB_MASS_STORAGE_ENABLED, USB_MASS_STORAGE_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_INVERSION_ENABLED,
                    ACCESSIBILITY_DISPLAY_INVERSION_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_DALTONIZER,
                    ACCESSIBILITY_DISPLAY_DALTONIZER_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_DALTONIZER_ENABLED,
                    ACCESSIBILITY_DISPLAY_DALTONIZER_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
                    ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_MAGNIFICATION_NAVBAR_ENABLED,
                    ACCESSIBILITY_DISPLAY_MAGNIFICATION_NAVBAR_ENABLED_VALIDATOR);
            VALIDATORS.put(AUTOFILL_SERVICE, AUTOFILL_SERVICE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
                    ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE_VALIDATOR);
            VALIDATORS.put(ENABLED_ACCESSIBILITY_SERVICES,
                    ENABLED_ACCESSIBILITY_SERVICES_VALIDATOR);
            VALIDATORS.put(ENABLED_VR_LISTENERS, ENABLED_VR_LISTENERS_VALIDATOR);
            VALIDATORS.put(TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
                    TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES_VALIDATOR);
            VALIDATORS.put(TOUCH_EXPLORATION_ENABLED, TOUCH_EXPLORATION_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_ENABLED, ACCESSIBILITY_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_TARGET_SERVICE,
                    ACCESSIBILITY_SHORTCUT_TARGET_SERVICE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_BUTTON_TARGET_COMPONENT,
                    ACCESSIBILITY_BUTTON_TARGET_COMPONENT_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_DIALOG_SHOWN,
                    ACCESSIBILITY_SHORTCUT_DIALOG_SHOWN_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_ENABLED,
                    ACCESSIBILITY_SHORTCUT_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_ON_LOCK_SCREEN,
                    ACCESSIBILITY_SHORTCUT_ON_LOCK_SCREEN_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_HIGH_TEXT_CONTRAST_ENABLED,
                    ACCESSIBILITY_HIGH_TEXT_CONTRAST_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_PRESET,
                    ACCESSIBILITY_CAPTIONING_PRESET_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_ENABLED,
                    ACCESSIBILITY_CAPTIONING_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_LOCALE,
                    ACCESSIBILITY_CAPTIONING_LOCALE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR,
                    ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR,
                    ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_EDGE_TYPE,
                    ACCESSIBILITY_CAPTIONING_EDGE_TYPE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_EDGE_COLOR,
                    ACCESSIBILITY_CAPTIONING_EDGE_COLOR_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_TYPEFACE,
                    ACCESSIBILITY_CAPTIONING_TYPEFACE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_FONT_SCALE,
                    ACCESSIBILITY_CAPTIONING_FONT_SCALE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_WINDOW_COLOR,
                    ACCESSIBILITY_CAPTIONING_WINDOW_COLOR_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_RATE, TTS_DEFAULT_RATE_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_PITCH, TTS_DEFAULT_PITCH_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_SYNTH, TTS_DEFAULT_SYNTH_VALIDATOR);
            VALIDATORS.put(TTS_ENABLED_PLUGINS, TTS_ENABLED_PLUGINS_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_LOCALE, TTS_DEFAULT_LOCALE_VALIDATOR);
            VALIDATORS.put(SHOW_IME_WITH_HARD_KEYBOARD, SHOW_IME_WITH_HARD_KEYBOARD_VALIDATOR);
            VALIDATORS.put(WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,
                    WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON_VALIDATOR);
            VALIDATORS.put(WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,
                    WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY_VALIDATOR);
            VALIDATORS.put(WIFI_NUM_OPEN_NETWORKS_KEPT, WIFI_NUM_OPEN_NETWORKS_KEPT_VALIDATOR);
            VALIDATORS.put(MOUNT_PLAY_NOTIFICATION_SND, MOUNT_PLAY_NOTIFICATION_SND_VALIDATOR);
            VALIDATORS.put(MOUNT_UMS_AUTOSTART, MOUNT_UMS_AUTOSTART_VALIDATOR);
            VALIDATORS.put(MOUNT_UMS_PROMPT, MOUNT_UMS_PROMPT_VALIDATOR);
            VALIDATORS.put(MOUNT_UMS_NOTIFY_ENABLED, MOUNT_UMS_NOTIFY_ENABLED_VALIDATOR);
            VALIDATORS.put(DOUBLE_TAP_TO_WAKE, DOUBLE_TAP_TO_WAKE_VALIDATOR);
            VALIDATORS.put(WAKE_GESTURE_ENABLED, WAKE_GESTURE_ENABLED_VALIDATOR);
            VALIDATORS.put(LONG_PRESS_TIMEOUT, LONG_PRESS_TIMEOUT_VALIDATOR);
            VALIDATORS.put(CAMERA_GESTURE_DISABLED, CAMERA_GESTURE_DISABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_AUTOCLICK_ENABLED,
                    ACCESSIBILITY_AUTOCLICK_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_AUTOCLICK_DELAY, ACCESSIBILITY_AUTOCLICK_DELAY_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_LARGE_POINTER_ICON,
                    ACCESSIBILITY_LARGE_POINTER_ICON_VALIDATOR);
            VALIDATORS.put(PREFERRED_TTY_MODE, PREFERRED_TTY_MODE_VALIDATOR);
            VALIDATORS.put(ENHANCED_VOICE_PRIVACY_ENABLED,
                    ENHANCED_VOICE_PRIVACY_ENABLED_VALIDATOR);
            VALIDATORS.put(TTY_MODE_ENABLED, TTY_MODE_ENABLED_VALIDATOR);
            VALIDATORS.put(RTT_CALLING_MODE, RTT_CALLING_MODE_VALIDATOR);
            VALIDATORS.put(INCALL_POWER_BUTTON_BEHAVIOR, INCALL_POWER_BUTTON_BEHAVIOR_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_CUSTOM_START_TIME,
                    NIGHT_DISPLAY_CUSTOM_START_TIME_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_CUSTOM_END_TIME, NIGHT_DISPLAY_CUSTOM_END_TIME_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_COLOR_TEMPERATURE,
                    NIGHT_DISPLAY_COLOR_TEMPERATURE_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_AUTO_MODE, NIGHT_DISPLAY_AUTO_MODE_VALIDATOR);
            VALIDATORS.put(DISPLAY_WHITE_BALANCE_ENABLED, DISPLAY_WHITE_BALANCE_ENABLED_VALIDATOR);
            VALIDATORS.put(SYNC_PARENT_SOUNDS, SYNC_PARENT_SOUNDS_VALIDATOR);
            VALIDATORS.put(CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED,
                    CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED_VALIDATOR);
            VALIDATORS.put(CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED,
                    CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED_VALIDATOR);
            VALIDATORS.put(SYSTEM_NAVIGATION_KEYS_ENABLED,
                    SYSTEM_NAVIGATION_KEYS_ENABLED_VALIDATOR);
            VALIDATORS.put(QS_TILES, QS_TILES_VALIDATOR);
            VALIDATORS.put(DOZE_ENABLED, DOZE_ENABLED_VALIDATOR);
            VALIDATORS.put(DOZE_ALWAYS_ON, DOZE_ALWAYS_ON_VALIDATOR);
            VALIDATORS.put(DOZE_PICK_UP_GESTURE, DOZE_PICK_UP_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_DOUBLE_TAP_GESTURE, DOZE_DOUBLE_TAP_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_TAP_SCREEN_GESTURE, DOZE_TAP_SCREEN_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_WAKE_LOCK_SCREEN_GESTURE, DOZE_WAKE_LOCK_SCREEN_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_WAKE_DISPLAY_GESTURE, DOZE_WAKE_DISPLAY_GESTURE_VALIDATOR);
            VALIDATORS.put(NFC_PAYMENT_DEFAULT_COMPONENT, NFC_PAYMENT_DEFAULT_COMPONENT_VALIDATOR);
            VALIDATORS.put(AUTOMATIC_STORAGE_MANAGER_DAYS_TO_RETAIN,
                    AUTOMATIC_STORAGE_MANAGER_DAYS_TO_RETAIN_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_KEYGUARD_ENABLED, FACE_UNLOCK_KEYGUARD_ENABLED_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_DISMISSES_KEYGUARD,
                    FACE_UNLOCK_DISMISSES_KEYGUARD_VALIDATOR);
            VALIDATORS.put(SHOW_MEDIA_WHEN_BYPASSING, SHOW_MEDIA_WHEN_BYPASSING_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_APP_ENABLED, FACE_UNLOCK_APP_ENABLED_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_ALWAYS_REQUIRE_CONFIRMATION,
                    FACE_UNLOCK_ALWAYS_REQUIRE_CONFIRMATION_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_ENABLED, ASSIST_GESTURE_ENABLED_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_SILENCE_ALERTS_ENABLED,
                    ASSIST_GESTURE_SILENCE_ALERTS_ENABLED_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_WAKE_ENABLED, ASSIST_GESTURE_WAKE_ENABLED_VALIDATOR);
            VALIDATORS.put(VR_DISPLAY_MODE, VR_DISPLAY_MODE_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_BADGING, NOTIFICATION_BADGING_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_BUBBLES, NOTIFICATION_BUBBLES_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_DISMISS_RTL, NOTIFICATION_DISMISS_RTL_VALIDATOR);
            VALIDATORS.put(QS_AUTO_ADDED_TILES, QS_AUTO_ADDED_TILES_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_ENABLED, SCREENSAVER_ENABLED_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_COMPONENTS, SCREENSAVER_COMPONENTS_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_ACTIVATE_ON_DOCK, SCREENSAVER_ACTIVATE_ON_DOCK_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_ACTIVATE_ON_SLEEP, SCREENSAVER_ACTIVATE_ON_SLEEP_VALIDATOR);
            VALIDATORS.put(LOCKDOWN_IN_POWER_MENU, LOCKDOWN_IN_POWER_MENU_VALIDATOR);
            VALIDATORS.put(SHOW_FIRST_CRASH_DIALOG_DEV_OPTION,
                    SHOW_FIRST_CRASH_DIALOG_DEV_OPTION_VALIDATOR);
            VALIDATORS.put(VOLUME_HUSH_GESTURE, VOLUME_HUSH_GESTURE_VALIDATOR);
            VALIDATORS.put(ENABLED_NOTIFICATION_LISTENERS,
                    ENABLED_NOTIFICATION_LISTENERS_VALIDATOR); //legacy restore setting
            VALIDATORS.put(ENABLED_NOTIFICATION_ASSISTANT,
                    ENABLED_NOTIFICATION_ASSISTANT_VALIDATOR); //legacy restore setting
            VALIDATORS.put(ENABLED_NOTIFICATION_POLICY_ACCESS_PACKAGES,
                    ENABLED_NOTIFICATION_POLICY_ACCESS_PACKAGES_VALIDATOR); //legacy restore setting
            VALIDATORS.put(HUSH_GESTURE_USED, HUSH_GESTURE_USED_VALIDATOR);
            VALIDATORS.put(MANUAL_RINGER_TOGGLE_COUNT, MANUAL_RINGER_TOGGLE_COUNT_VALIDATOR);
            VALIDATORS.put(IN_CALL_NOTIFICATION_ENABLED, IN_CALL_NOTIFICATION_ENABLED_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_ALLOW_PRIVATE_NOTIFICATIONS, BOOLEAN_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_SHOW_NOTIFICATIONS, BOOLEAN_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_SHOW_SILENT_NOTIFICATIONS, BOOLEAN_VALIDATOR);
            VALIDATORS.put(SHOW_NOTIFICATION_SNOOZE, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ZEN_DURATION, ZEN_DURATION_VALIDATOR);
            VALIDATORS.put(SHOW_ZEN_UPGRADE_NOTIFICATION, BOOLEAN_VALIDATOR);
            VALIDATORS.put(SHOW_ZEN_SETTINGS_SUGGESTION, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ZEN_SETTINGS_UPDATED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ZEN_SETTINGS_SUGGESTION_VIEWED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(CHARGING_SOUNDS_ENABLED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(CHARGING_VIBRATION_ENABLED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_NON_INTERACTIVE_UI_TIMEOUT_MS,
                    NON_NEGATIVE_INTEGER_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_INTERACTIVE_UI_TIMEOUT_MS, NON_NEGATIVE_INTEGER_VALIDATOR);
            VALIDATORS.put(USER_SETUP_COMPLETE, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_SETUP_COMPLETE, BOOLEAN_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_NEW_INTERRUPTION_MODEL, BOOLEAN_VALIDATOR);
            VALIDATORS.put(TRUST_AGENTS_EXTEND_UNLOCK, TRUST_AGENTS_EXTEND_UNLOCK_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_CUSTOM_CLOCK_FACE, LOCK_SCREEN_CUSTOM_CLOCK_FACE_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_WHEN_TRUST_LOST, LOCK_SCREEN_WHEN_TRUST_LOST_VALIDATOR);
            VALIDATORS.put(SKIP_GESTURE, SKIP_GESTURE_VALIDATOR);
            VALIDATORS.put(SKIP_DIRECTION, SKIP_DIRECTION_VALIDATOR);
            VALIDATORS.put(SKIP_DIRECTION, SKIP_DIRECTION_VALIDATOR);
            VALIDATORS.put(SILENCE_GESTURE, SILENCE_GESTURE_VALIDATOR);
            VALIDATORS.put(THEME_CUSTOMIZATION_OVERLAY_PACKAGES,
                    THEME_CUSTOMIZATION_OVERLAY_PACKAGES_VALIDATOR);
            VALIDATORS.put(NAVIGATION_MODE, NAVIGATION_MODE_VALIDATOR);
            VALIDATORS.put(AWARE_ENABLED, AWARE_ENABLED_VALIDATOR);
            VALIDATORS.put(SKIP_GESTURE_COUNT, SKIP_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SKIP_TOUCH_COUNT, SKIP_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_ALARMS_GESTURE_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_TIMER_GESTURE_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_CALL_GESTURE_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_ALARMS_TOUCH_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_TIMER_TOUCH_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_CALL_TOUCH_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(ODI_CAPTIONS_ENABLED, ODI_CAPTIONS_ENABLED_VALIDATOR);
            VALIDATORS.put(DARK_MODE_DIALOG_SEEN, BOOLEAN_VALIDATOR);
            VALIDATORS.put(UI_NIGHT_MODE, UI_NIGHT_MODE_VALIDATOR);
            VALIDATORS.put(GLOBAL_ACTIONS_PANEL_ENABLED, GLOBAL_ACTIONS_PANEL_ENABLED_VALIDATOR);
            VALIDATORS.put(AWARE_LOCK_ENABLED, AWARE_LOCK_ENABLED_VALIDATOR);
            VALIDATORS.put(DISPLAY_DENSITY_FORCED, DISPLAY_DENSITY_FORCED_VALIDATOR);
        }

        /**
","         * All settings in {@link SETTINGS_TO_BACKUP} and {@link DEVICE_SPECIFIC_SETTINGS_TO_BACKUP}
         * array *must* have a non-null validator, otherwise they won't be restored.
         *
         * @hide
         */
        public static final Map<String, Validator> VALIDATORS = new ArrayMap<>();
        static {
            VALIDATORS.put(BUGREPORT_IN_POWER_MENU, BUGREPORT_IN_POWER_MENU_VALIDATOR);
            VALIDATORS.put(ALLOW_MOCK_LOCATION, ALLOW_MOCK_LOCATION_VALIDATOR);
            VALIDATORS.put(USB_MASS_STORAGE_ENABLED, USB_MASS_STORAGE_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_INVERSION_ENABLED,
                    ACCESSIBILITY_DISPLAY_INVERSION_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_DALTONIZER,
                    ACCESSIBILITY_DISPLAY_DALTONIZER_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_DALTONIZER_ENABLED,
                    ACCESSIBILITY_DISPLAY_DALTONIZER_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
                    ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_MAGNIFICATION_NAVBAR_ENABLED,
                    ACCESSIBILITY_DISPLAY_MAGNIFICATION_NAVBAR_ENABLED_VALIDATOR);
            VALIDATORS.put(AUTOFILL_SERVICE, AUTOFILL_SERVICE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE,
                    ACCESSIBILITY_DISPLAY_MAGNIFICATION_SCALE_VALIDATOR);
            VALIDATORS.put(ENABLED_ACCESSIBILITY_SERVICES,
                    ENABLED_ACCESSIBILITY_SERVICES_VALIDATOR);
            VALIDATORS.put(ENABLED_VR_LISTENERS, ENABLED_VR_LISTENERS_VALIDATOR);
            VALIDATORS.put(TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES,
                    TOUCH_EXPLORATION_GRANTED_ACCESSIBILITY_SERVICES_VALIDATOR);
            VALIDATORS.put(TOUCH_EXPLORATION_ENABLED, TOUCH_EXPLORATION_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_ENABLED, ACCESSIBILITY_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_TARGET_SERVICE,
                    ACCESSIBILITY_SHORTCUT_TARGET_SERVICE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_BUTTON_TARGET_COMPONENT,
                    ACCESSIBILITY_BUTTON_TARGET_COMPONENT_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_DIALOG_SHOWN,
                    ACCESSIBILITY_SHORTCUT_DIALOG_SHOWN_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_ENABLED,
                    ACCESSIBILITY_SHORTCUT_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_SHORTCUT_ON_LOCK_SCREEN,
                    ACCESSIBILITY_SHORTCUT_ON_LOCK_SCREEN_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_HIGH_TEXT_CONTRAST_ENABLED,
                    ACCESSIBILITY_HIGH_TEXT_CONTRAST_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_PRESET,
                    ACCESSIBILITY_CAPTIONING_PRESET_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_ENABLED,
                    ACCESSIBILITY_CAPTIONING_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_LOCALE,
                    ACCESSIBILITY_CAPTIONING_LOCALE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR,
                    ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR,
                    ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_EDGE_TYPE,
                    ACCESSIBILITY_CAPTIONING_EDGE_TYPE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_EDGE_COLOR,
                    ACCESSIBILITY_CAPTIONING_EDGE_COLOR_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_TYPEFACE,
                    ACCESSIBILITY_CAPTIONING_TYPEFACE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_FONT_SCALE,
                    ACCESSIBILITY_CAPTIONING_FONT_SCALE_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_CAPTIONING_WINDOW_COLOR,
                    ACCESSIBILITY_CAPTIONING_WINDOW_COLOR_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_RATE, TTS_DEFAULT_RATE_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_PITCH, TTS_DEFAULT_PITCH_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_SYNTH, TTS_DEFAULT_SYNTH_VALIDATOR);
            VALIDATORS.put(TTS_ENABLED_PLUGINS, TTS_ENABLED_PLUGINS_VALIDATOR);
            VALIDATORS.put(TTS_DEFAULT_LOCALE, TTS_DEFAULT_LOCALE_VALIDATOR);
            VALIDATORS.put(SHOW_IME_WITH_HARD_KEYBOARD, SHOW_IME_WITH_HARD_KEYBOARD_VALIDATOR);
            VALIDATORS.put(WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,
                    WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON_VALIDATOR);
            VALIDATORS.put(WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,
                    WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY_VALIDATOR);
            VALIDATORS.put(WIFI_NUM_OPEN_NETWORKS_KEPT, WIFI_NUM_OPEN_NETWORKS_KEPT_VALIDATOR);
            VALIDATORS.put(MOUNT_PLAY_NOTIFICATION_SND, MOUNT_PLAY_NOTIFICATION_SND_VALIDATOR);
            VALIDATORS.put(MOUNT_UMS_AUTOSTART, MOUNT_UMS_AUTOSTART_VALIDATOR);
            VALIDATORS.put(MOUNT_UMS_PROMPT, MOUNT_UMS_PROMPT_VALIDATOR);
            VALIDATORS.put(MOUNT_UMS_NOTIFY_ENABLED, MOUNT_UMS_NOTIFY_ENABLED_VALIDATOR);
            VALIDATORS.put(DOUBLE_TAP_TO_WAKE, DOUBLE_TAP_TO_WAKE_VALIDATOR);
            VALIDATORS.put(WAKE_GESTURE_ENABLED, WAKE_GESTURE_ENABLED_VALIDATOR);
            VALIDATORS.put(LONG_PRESS_TIMEOUT, LONG_PRESS_TIMEOUT_VALIDATOR);
            VALIDATORS.put(CAMERA_GESTURE_DISABLED, CAMERA_GESTURE_DISABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_AUTOCLICK_ENABLED,
                    ACCESSIBILITY_AUTOCLICK_ENABLED_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_AUTOCLICK_DELAY, ACCESSIBILITY_AUTOCLICK_DELAY_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_LARGE_POINTER_ICON,
                    ACCESSIBILITY_LARGE_POINTER_ICON_VALIDATOR);
            VALIDATORS.put(PREFERRED_TTY_MODE, PREFERRED_TTY_MODE_VALIDATOR);
            VALIDATORS.put(ENHANCED_VOICE_PRIVACY_ENABLED,
                    ENHANCED_VOICE_PRIVACY_ENABLED_VALIDATOR);
            VALIDATORS.put(TTY_MODE_ENABLED, TTY_MODE_ENABLED_VALIDATOR);
            VALIDATORS.put(RTT_CALLING_MODE, RTT_CALLING_MODE_VALIDATOR);
            VALIDATORS.put(INCALL_POWER_BUTTON_BEHAVIOR, INCALL_POWER_BUTTON_BEHAVIOR_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_CUSTOM_START_TIME,
                    NIGHT_DISPLAY_CUSTOM_START_TIME_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_CUSTOM_END_TIME, NIGHT_DISPLAY_CUSTOM_END_TIME_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_COLOR_TEMPERATURE,
                    NIGHT_DISPLAY_COLOR_TEMPERATURE_VALIDATOR);
            VALIDATORS.put(NIGHT_DISPLAY_AUTO_MODE, NIGHT_DISPLAY_AUTO_MODE_VALIDATOR);
            VALIDATORS.put(DISPLAY_WHITE_BALANCE_ENABLED, DISPLAY_WHITE_BALANCE_ENABLED_VALIDATOR);
            VALIDATORS.put(SYNC_PARENT_SOUNDS, SYNC_PARENT_SOUNDS_VALIDATOR);
            VALIDATORS.put(CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED,
                    CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED_VALIDATOR);
            VALIDATORS.put(CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED,
                    CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED_VALIDATOR);
            VALIDATORS.put(SYSTEM_NAVIGATION_KEYS_ENABLED,
                    SYSTEM_NAVIGATION_KEYS_ENABLED_VALIDATOR);
            VALIDATORS.put(QS_TILES, QS_TILES_VALIDATOR);
            VALIDATORS.put(DOZE_ENABLED, DOZE_ENABLED_VALIDATOR);
            VALIDATORS.put(DOZE_ALWAYS_ON, DOZE_ALWAYS_ON_VALIDATOR);
            VALIDATORS.put(DOZE_PICK_UP_GESTURE, DOZE_PICK_UP_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_DOUBLE_TAP_GESTURE, DOZE_DOUBLE_TAP_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_TAP_SCREEN_GESTURE, DOZE_TAP_SCREEN_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_WAKE_LOCK_SCREEN_GESTURE, DOZE_WAKE_LOCK_SCREEN_GESTURE_VALIDATOR);
            VALIDATORS.put(DOZE_WAKE_DISPLAY_GESTURE, DOZE_WAKE_DISPLAY_GESTURE_VALIDATOR);
            VALIDATORS.put(NFC_PAYMENT_DEFAULT_COMPONENT, NFC_PAYMENT_DEFAULT_COMPONENT_VALIDATOR);
            VALIDATORS.put(AUTOMATIC_STORAGE_MANAGER_DAYS_TO_RETAIN,
                    AUTOMATIC_STORAGE_MANAGER_DAYS_TO_RETAIN_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_KEYGUARD_ENABLED, FACE_UNLOCK_KEYGUARD_ENABLED_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_DISMISSES_KEYGUARD,
                    FACE_UNLOCK_DISMISSES_KEYGUARD_VALIDATOR);
            VALIDATORS.put(SHOW_MEDIA_WHEN_BYPASSING, SHOW_MEDIA_WHEN_BYPASSING_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_APP_ENABLED, FACE_UNLOCK_APP_ENABLED_VALIDATOR);
            VALIDATORS.put(FACE_UNLOCK_ALWAYS_REQUIRE_CONFIRMATION,
                    FACE_UNLOCK_ALWAYS_REQUIRE_CONFIRMATION_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_ENABLED, ASSIST_GESTURE_ENABLED_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_SILENCE_ALERTS_ENABLED,
                    ASSIST_GESTURE_SILENCE_ALERTS_ENABLED_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_WAKE_ENABLED, ASSIST_GESTURE_WAKE_ENABLED_VALIDATOR);
            VALIDATORS.put(VR_DISPLAY_MODE, VR_DISPLAY_MODE_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_BADGING, NOTIFICATION_BADGING_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_BUBBLES, NOTIFICATION_BUBBLES_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_DISMISS_RTL, NOTIFICATION_DISMISS_RTL_VALIDATOR);
            VALIDATORS.put(QS_AUTO_ADDED_TILES, QS_AUTO_ADDED_TILES_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_ENABLED, SCREENSAVER_ENABLED_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_COMPONENTS, SCREENSAVER_COMPONENTS_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_ACTIVATE_ON_DOCK, SCREENSAVER_ACTIVATE_ON_DOCK_VALIDATOR);
            VALIDATORS.put(SCREENSAVER_ACTIVATE_ON_SLEEP, SCREENSAVER_ACTIVATE_ON_SLEEP_VALIDATOR);
            VALIDATORS.put(LOCKDOWN_IN_POWER_MENU, LOCKDOWN_IN_POWER_MENU_VALIDATOR);
            VALIDATORS.put(SHOW_FIRST_CRASH_DIALOG_DEV_OPTION,
                    SHOW_FIRST_CRASH_DIALOG_DEV_OPTION_VALIDATOR);
            VALIDATORS.put(VOLUME_HUSH_GESTURE, VOLUME_HUSH_GESTURE_VALIDATOR);
            VALIDATORS.put(ENABLED_NOTIFICATION_LISTENERS,
                    ENABLED_NOTIFICATION_LISTENERS_VALIDATOR); //legacy restore setting
            VALIDATORS.put(ENABLED_NOTIFICATION_ASSISTANT,
                    ENABLED_NOTIFICATION_ASSISTANT_VALIDATOR); //legacy restore setting
            VALIDATORS.put(ENABLED_NOTIFICATION_POLICY_ACCESS_PACKAGES,
                    ENABLED_NOTIFICATION_POLICY_ACCESS_PACKAGES_VALIDATOR); //legacy restore setting
            VALIDATORS.put(HUSH_GESTURE_USED, HUSH_GESTURE_USED_VALIDATOR);
            VALIDATORS.put(MANUAL_RINGER_TOGGLE_COUNT, MANUAL_RINGER_TOGGLE_COUNT_VALIDATOR);
            VALIDATORS.put(IN_CALL_NOTIFICATION_ENABLED, IN_CALL_NOTIFICATION_ENABLED_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_ALLOW_PRIVATE_NOTIFICATIONS, BOOLEAN_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_SHOW_NOTIFICATIONS, BOOLEAN_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_SHOW_SILENT_NOTIFICATIONS, BOOLEAN_VALIDATOR);
            VALIDATORS.put(SHOW_NOTIFICATION_SNOOZE, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ZEN_DURATION, ZEN_DURATION_VALIDATOR);
            VALIDATORS.put(SHOW_ZEN_UPGRADE_NOTIFICATION, BOOLEAN_VALIDATOR);
            VALIDATORS.put(SHOW_ZEN_SETTINGS_SUGGESTION, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ZEN_SETTINGS_UPDATED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ZEN_SETTINGS_SUGGESTION_VIEWED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(CHARGING_SOUNDS_ENABLED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(CHARGING_VIBRATION_ENABLED, BOOLEAN_VALIDATOR);
            VALIDATORS.put(WIFI_DISCONNECT_DELAY_DURATION, WIFI_DISCONNECT_DELAY_DURATION_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_NON_INTERACTIVE_UI_TIMEOUT_MS,
                    NON_NEGATIVE_INTEGER_VALIDATOR);
            VALIDATORS.put(ACCESSIBILITY_INTERACTIVE_UI_TIMEOUT_MS, NON_NEGATIVE_INTEGER_VALIDATOR);
            VALIDATORS.put(USER_SETUP_COMPLETE, BOOLEAN_VALIDATOR);
            VALIDATORS.put(ASSIST_GESTURE_SETUP_COMPLETE, BOOLEAN_VALIDATOR);
            VALIDATORS.put(NOTIFICATION_NEW_INTERRUPTION_MODEL, BOOLEAN_VALIDATOR);
            VALIDATORS.put(TRUST_AGENTS_EXTEND_UNLOCK, TRUST_AGENTS_EXTEND_UNLOCK_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_CUSTOM_CLOCK_FACE, LOCK_SCREEN_CUSTOM_CLOCK_FACE_VALIDATOR);
            VALIDATORS.put(LOCK_SCREEN_WHEN_TRUST_LOST, LOCK_SCREEN_WHEN_TRUST_LOST_VALIDATOR);
            VALIDATORS.put(SKIP_GESTURE, SKIP_GESTURE_VALIDATOR);
            VALIDATORS.put(SKIP_DIRECTION, SKIP_DIRECTION_VALIDATOR);
            VALIDATORS.put(SKIP_DIRECTION, SKIP_DIRECTION_VALIDATOR);
            VALIDATORS.put(SILENCE_GESTURE, SILENCE_GESTURE_VALIDATOR);
            VALIDATORS.put(THEME_CUSTOMIZATION_OVERLAY_PACKAGES,
                    THEME_CUSTOMIZATION_OVERLAY_PACKAGES_VALIDATOR);
            VALIDATORS.put(NAVIGATION_MODE, NAVIGATION_MODE_VALIDATOR);
            VALIDATORS.put(AWARE_ENABLED, AWARE_ENABLED_VALIDATOR);
            VALIDATORS.put(SKIP_GESTURE_COUNT, SKIP_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SKIP_TOUCH_COUNT, SKIP_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_ALARMS_GESTURE_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_TIMER_GESTURE_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_CALL_GESTURE_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_ALARMS_TOUCH_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_TIMER_TOUCH_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(SILENCE_CALL_TOUCH_COUNT, SILENCE_GESTURE_COUNT_VALIDATOR);
            VALIDATORS.put(ODI_CAPTIONS_ENABLED, ODI_CAPTIONS_ENABLED_VALIDATOR);
            VALIDATORS.put(DARK_MODE_DIALOG_SEEN, BOOLEAN_VALIDATOR);
            VALIDATORS.put(UI_NIGHT_MODE, UI_NIGHT_MODE_VALIDATOR);
            VALIDATORS.put(GLOBAL_ACTIONS_PANEL_ENABLED, GLOBAL_ACTIONS_PANEL_ENABLED_VALIDATOR);
            VALIDATORS.put(AWARE_LOCK_ENABLED, AWARE_LOCK_ENABLED_VALIDATOR);
            VALIDATORS.put(DISPLAY_DENSITY_FORCED, DISPLAY_DENSITY_FORCED_VALIDATOR);
        }

        /**
","[1.0, 1.0]"
1378,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(18100, 18105, 6), (18100, 18105, 6)]","        public int startActivityAsUserEmpty(Bundle options) {
            return ActivityManagerService.this.startActivityAsUserEmpty(options);
        }

        @Override
        public void killForegroundAppsForUser(int userHandle) {
","        public int startActivityAsUserEmpty(Bundle options) {
            return ActivityManagerService.this.startActivityAsUserEmpty(options);
        }

        @Override
        public void killForegroundAppsForUser(int userHandle) {
","        public int startActivityAsUserEmpty(Bundle options) {
            return ActivityManagerService.this.startActivityAsUserEmpty(options);
        }

        @Override
        public void killForegroundAppsForUser(int userHandle) {
","[1.0, 1.0]"
1379,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActiveServices.java,"[(2541, 2550, 10), (2541, 2550, 10)]","                + r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");

        if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
            for (int i=mRestartingServices.size()-1; i>=0; i--) {
                ServiceRecord r2 = mRestartingServices.get(i);
                Slog.w(TAG,""Restarting list - i ""+i+"" r2.nextRestartTime ""
                           +r2.nextRestartTime+"" r2.name ""+r2.name);
            }
        }

","                + r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");

        if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
            for (int i=mRestartingServices.size()-1; i>=0; i--) {
                ServiceRecord r2 = mRestartingServices.get(i);
                Slog.w(TAG,""Restarting list - i ""+i+"" r2.nextRestartTime ""
                           +r2.nextRestartTime+"" r2.name ""+r2.name);
            }
        }

","                + r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");

        if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
            for (int i=mRestartingServices.size()-1; i>=0; i--) {
                ServiceRecord r2 = mRestartingServices.get(i);
                Slog.w(TAG,""Restarting list - i ""+i+"" r2.nextRestartTime ""
                           +r2.nextRestartTime+"" r2.name ""+r2.name);
            }
        }

","[1.0, 1.0]"
1380,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(900, 900, 1), (900, 900, 1)]","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","        pw.println(""  mFiveGState="" + mFiveGState + "","");
","[1.0, 1.0]"
1381,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(1096, 1099, 4), (1096, 1099, 4)]","        boolean imsRegistered;
        boolean voiceCapable;
        boolean videoCapable;

","        boolean imsRegistered;
        boolean voiceCapable;
        boolean videoCapable;

","        boolean imsRegistered;
        boolean voiceCapable;
        boolean videoCapable;

","[1.0, 1.0]"
1382,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(1115, 1117, 3), (1115, 1117, 3)]","            imsRegistered = state.imsRegistered;
            voiceCapable = state.voiceCapable;
            videoCapable = state.videoCapable;
","            imsRegistered = state.imsRegistered;
            voiceCapable = state.voiceCapable;
            videoCapable = state.videoCapable;
","            imsRegistered = state.imsRegistered;
            voiceCapable = state.voiceCapable;
            videoCapable = state.videoCapable;
","[1.0, 1.0]"
1383,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(1135, 1137, 3), (1135, 1137, 3)]","            builder.append(""imsRegistered="").append(imsRegistered).append(',');
            builder.append(""voiceCapable="").append(voiceCapable).append(',');
            builder.append(""videoCapable="").append(videoCapable);
","            builder.append(""imsRegistered="").append(imsRegistered).append(',');
            builder.append(""voiceCapable="").append(voiceCapable).append(',');
            builder.append(""videoCapable="").append(videoCapable);
","            builder.append(""imsRegistered="").append(imsRegistered).append(',');
            builder.append(""voiceCapable="").append(voiceCapable).append(',');
            builder.append(""videoCapable="").append(videoCapable);
","[1.0, 1.0]"
1384,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(1153, 1155, 3), (1153, 1155, 3)]","                    && ((MobileState) o).imsRegistered == imsRegistered
                    && ((MobileState) o).voiceCapable == voiceCapable
                    && ((MobileState) o).videoCapable == videoCapable;
","                    && ((MobileState) o).imsRegistered == imsRegistered
                    && ((MobileState) o).voiceCapable == voiceCapable
                    && ((MobileState) o).videoCapable == videoCapable;
","                    && ((MobileState) o).imsRegistered == imsRegistered
                    && ((MobileState) o).voiceCapable == voiceCapable
                    && ((MobileState) o).videoCapable == videoCapable;
","[1.0, 1.0]"
1385,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/WindowManagerService.java,"[(297, 299, 3), (297, 299, 3)]","    static final boolean localLOGV = DEBUG;
    static WindowState mFocusingWindow;
    String mFocusingActivity;
","    static final boolean localLOGV = DEBUG;
    static WindowState mFocusingWindow;
    String mFocusingActivity;
","    static final boolean localLOGV = DEBUG;
    static WindowState mFocusingWindow;
    String mFocusingActivity;
","[1.0, 1.0]"
1386,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStarter.java,"[(1682, 1705, 24), (1682, 1705, 24)]","        boolean newTask = false;
        final TaskRecord taskToAffiliate = (mLaunchTaskBehind && mSourceRecord != null)
                ? mSourceRecord.getTaskRecord() : null;

        // Should this be considered a new task?
        int result = START_SUCCESS;
        if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask
                && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {
            newTask = true;
            String packageName= mService.mContext.getPackageName();
            if (mPerf != null) {
                mStartActivity.perfActivityBoostHandler =
                    mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                        packageName, -1, BoostFramework.Launch.BOOST_V1);
            }
            result = setTaskFromReuseOrCreateNewTask(taskToAffiliate);
        } else if (mSourceRecord != null) {
            result = setTaskFromSourceRecord();
        } else if (mInTask != null) {
            result = setTaskFromInTask();
        } else {
            // This not being started from an existing activity, and not part of a new task...
            // just put it in the top task, though these days this case should never happen.
            result = setTaskToCurrentTopOrCreateNewTask();
","        boolean newTask = false;
        final TaskRecord taskToAffiliate = (mLaunchTaskBehind && mSourceRecord != null)
                ? mSourceRecord.getTaskRecord() : null;

        // Should this be considered a new task?
        int result = START_SUCCESS;
        if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask
                && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {
            newTask = true;
            String packageName= mService.mContext.getPackageName();
            if (mPerf != null) {
                mStartActivity.perfActivityBoostHandler =
                    mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                        packageName, -1, BoostFramework.Launch.BOOST_V1);
            }
            result = setTaskFromReuseOrCreateNewTask(taskToAffiliate);
        } else if (mSourceRecord != null) {
            result = setTaskFromSourceRecord();
        } else if (mInTask != null) {
            result = setTaskFromInTask();
        } else {
            // This not being started from an existing activity, and not part of a new task...
            // just put it in the top task, though these days this case should never happen.
            result = setTaskToCurrentTopOrCreateNewTask();
","        boolean newTask = false;
        final TaskRecord taskToAffiliate = (mLaunchTaskBehind && mSourceRecord != null)
                ? mSourceRecord.getTaskRecord() : null;

        // Should this be considered a new task?
        int result = START_SUCCESS;
        if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask
                && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {
            newTask = true;
            String packageName= mService.mContext.getPackageName();
            if (mPerf != null) {
                mStartActivity.perfActivityBoostHandler =
                    mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                        packageName, -1, BoostFramework.Launch.BOOST_V1);
            }
            result = setTaskFromReuseOrCreateNewTask(taskToAffiliate);
        } else if (mSourceRecord != null) {
            result = setTaskFromSourceRecord();
        } else if (mInTask != null) {
            result = setTaskFromInTask();
        } else {
            // This not being started from an existing activity, and not part of a new task...
            // just put it in the top task, though these days this case should never happen.
            result = setTaskToCurrentTopOrCreateNewTask();
","[1.0, 1.0]"
1387,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityStarter.java,"[(2381, 2546, 166), (2381, 2546, 166)]","    private int setTaskFromSourceRecord() {
        if (mService.getLockTaskController().isLockTaskModeViolation(
                mSourceRecord.getTaskRecord())) {
            Slog.e(TAG, ""Attempted Lock Task Mode violation mStartActivity="" + mStartActivity);
            return START_RETURN_LOCK_TASK_MODE_VIOLATION;
        }
        String packageName= mService.mContext.getPackageName();
        if (mPerf != null) {
            mStartActivity.perfActivityBoostHandler =
                mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                    packageName, -1, BoostFramework.Launch.BOOST_V1);
        }

        final TaskRecord sourceTask = mSourceRecord.getTaskRecord();
        final ActivityStack sourceStack = mSourceRecord.getActivityStack();
        if (mRestrictedBgActivity && !sourceTask.containsAppUid(mCallingUid)) {
            if (handleBackgroundActivityAbort(mStartActivity)) {
                return START_ABORTED;
            }
        }
        // We only want to allow changing stack in two cases:
        // 1. If the target task is not the top one. Otherwise we would move the launching task to
        //    the other side, rather than show two side by side.
        // 2. If activity is not allowed on target display.
        final int targetDisplayId = mTargetStack != null ? mTargetStack.mDisplayId
                : sourceStack.mDisplayId;
        final boolean moveStackAllowed = sourceStack.topTask() != sourceTask
                || !mStartActivity.canBeLaunchedOnDisplay(targetDisplayId);
        if (moveStackAllowed) {
            mTargetStack = getLaunchStack(mStartActivity, mLaunchFlags,
                    mStartActivity.getTaskRecord(), mOptions);
            // If target stack is not found now - we can't just rely on the source stack, as it may
            // be not suitable. Let's check other displays.
            if (mTargetStack == null && targetDisplayId != sourceStack.mDisplayId) {
                // Can't use target display, lets find a stack on the source display.
                mTargetStack = mRootActivityContainer.getValidLaunchStackOnDisplay(
                        sourceStack.mDisplayId, mStartActivity, mOptions, mLaunchParams);
            }
            if (mTargetStack == null) {
                // There are no suitable stacks on the target and source display(s). Look on all
                // displays.
                mTargetStack = mRootActivityContainer.getNextValidLaunchStack(
                        mStartActivity, -1 /* currentFocus */);
            }
        }

        if (mTargetStack == null) {
            mTargetStack = sourceStack;
        } else if (mTargetStack != sourceStack) {
            sourceTask.reparent(mTargetStack, ON_TOP, REPARENT_MOVE_STACK_TO_FRONT, !ANIMATE,
                    DEFER_RESUME, ""launchToSide"");
        }

        final TaskRecord topTask = mTargetStack.topTask();
        if (topTask != sourceTask && !mAvoidMoveToFront) {
            mTargetStack.moveTaskToFrontLocked(sourceTask, mNoAnimation, mOptions,
                    mStartActivity.appTimeTracker, ""sourceTaskToFront"");
        } else if (mDoResume) {
            mTargetStack.moveToFront(""sourceStackToFront"");
        }

        if (!mAddingToTask && (mLaunchFlags & FLAG_ACTIVITY_CLEAR_TOP) != 0) {
            // In this case, we are adding the activity to an existing task, but the caller has
            // asked to clear that task if the activity is already running.
            ActivityRecord top = sourceTask.performClearTaskLocked(mStartActivity, mLaunchFlags);
            mKeepCurTransition = true;
            if (top != null) {
                ActivityStack.logStartActivity(AM_NEW_INTENT, mStartActivity, top.getTaskRecord());
                deliverNewIntent(top);
                // For paranoia, make sure we have correctly resumed the top activity.
                mTargetStack.mLastPausedActivity = null;
                if (mDoResume) {
                    mRootActivityContainer.resumeFocusedStacksTopActivities();
                }
                ActivityOptions.abort(mOptions);
                return START_DELIVERED_TO_TOP;
            }
        } else if (!mAddingToTask && (mLaunchFlags & FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
            // In this case, we are launching an activity in our own task that may already be
            // running somewhere in the history, and we want to shuffle it to the front of the
            // stack if so.
            final ActivityRecord top = sourceTask.findActivityInHistoryLocked(mStartActivity);
            if (top != null) {
                final TaskRecord task = top.getTaskRecord();
                task.moveActivityToFrontLocked(top);
                top.updateOptionsLocked(mOptions);
                ActivityStack.logStartActivity(AM_NEW_INTENT, mStartActivity, task);
                deliverNewIntent(top);
                mTargetStack.mLastPausedActivity = null;
                if (mDoResume) {
                    mRootActivityContainer.resumeFocusedStacksTopActivities();
                }
                return START_DELIVERED_TO_TOP;
            }
        }

        // An existing activity is starting this new activity, so we want to keep the new one in
        // the same task as the one that is starting it.
        addOrReparentStartingActivity(sourceTask, ""setTaskFromSourceRecord"");
        if (DEBUG_TASKS) Slog.v(TAG_TASKS, ""Starting new activity "" + mStartActivity
                + "" in existing task "" + mStartActivity.getTaskRecord()
                + "" from source "" + mSourceRecord);
        return START_SUCCESS;
    }

    private int setTaskFromInTask() {
        // The caller is asking that the new activity be started in an explicit
        // task it has provided to us.
        if (mService.getLockTaskController().isLockTaskModeViolation(mInTask)) {
            Slog.e(TAG, ""Attempted Lock Task Mode violation mStartActivity="" + mStartActivity);
            return START_RETURN_LOCK_TASK_MODE_VIOLATION;
        }

        mTargetStack = mInTask.getStack();

        // Check whether we should actually launch the new activity in to the task,
        // or just reuse the current activity on top.
        ActivityRecord top = mInTask.getTopActivity();
        if (top != null && top.mActivityComponent.equals(mStartActivity.mActivityComponent)
                && top.mUserId == mStartActivity.mUserId) {
            if ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0
                    || isLaunchModeOneOf(LAUNCH_SINGLE_TOP, LAUNCH_SINGLE_TASK)) {
                mTargetStack.moveTaskToFrontLocked(mInTask, mNoAnimation, mOptions,
                        mStartActivity.appTimeTracker, ""inTaskToFront"");
                if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {
                    // We don't need to start a new activity, and the client said not to do
                    // anything if that is the case, so this is it!
                    return START_RETURN_INTENT_TO_CALLER;
                }
                deliverNewIntent(top);
                return START_DELIVERED_TO_TOP;
            }
        }

        if (!mAddingToTask) {
            mTargetStack.moveTaskToFrontLocked(mInTask, mNoAnimation, mOptions,
                    mStartActivity.appTimeTracker, ""inTaskToFront"");
            // We don't actually want to have this activity added to the task, so just
            // stop here but still tell the caller that we consumed the intent.
            ActivityOptions.abort(mOptions);
            return START_TASK_TO_FRONT;
        }

        if (!mLaunchParams.mBounds.isEmpty()) {
            // TODO: Shouldn't we already know what stack to use by the time we get here?
            ActivityStack stack = mRootActivityContainer.getLaunchStack(
                    null, null, mInTask, ON_TOP);
            if (stack != mInTask.getStack()) {
                mInTask.reparent(stack, ON_TOP, REPARENT_KEEP_STACK_AT_FRONT, !ANIMATE,
                        DEFER_RESUME, ""inTaskToFront"");
                mTargetStack = mInTask.getStack();
            }

            updateBounds(mInTask, mLaunchParams.mBounds);
        }

        mTargetStack.moveTaskToFrontLocked(
                mInTask, mNoAnimation, mOptions, mStartActivity.appTimeTracker, ""inTaskToFront"");

        addOrReparentStartingActivity(mInTask, ""setTaskFromInTask"");
        if (DEBUG_TASKS) Slog.v(TAG_TASKS, ""Starting new activity "" + mStartActivity
                + "" in explicit task "" + mStartActivity.getTaskRecord());

        return START_SUCCESS;
    }

","    private int setTaskFromSourceRecord() {
        if (mService.getLockTaskController().isLockTaskModeViolation(
                mSourceRecord.getTaskRecord())) {
            Slog.e(TAG, ""Attempted Lock Task Mode violation mStartActivity="" + mStartActivity);
            return START_RETURN_LOCK_TASK_MODE_VIOLATION;
        }
        String packageName= mService.mContext.getPackageName();
        if (mPerf != null) {
            mStartActivity.perfActivityBoostHandler =
                mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                    packageName, -1, BoostFramework.Launch.BOOST_V1);
        }

        final TaskRecord sourceTask = mSourceRecord.getTaskRecord();
        final ActivityStack sourceStack = mSourceRecord.getActivityStack();
        if (mRestrictedBgActivity && !sourceTask.containsAppUid(mCallingUid)) {
            if (handleBackgroundActivityAbort(mStartActivity)) {
                return START_ABORTED;
            }
        }
        // We only want to allow changing stack in two cases:
        // 1. If the target task is not the top one. Otherwise we would move the launching task to
        //    the other side, rather than show two side by side.
        // 2. If activity is not allowed on target display.
        final int targetDisplayId = mTargetStack != null ? mTargetStack.mDisplayId
                : sourceStack.mDisplayId;
        final boolean moveStackAllowed = sourceStack.topTask() != sourceTask
                || !mStartActivity.canBeLaunchedOnDisplay(targetDisplayId);
        if (moveStackAllowed) {
            mTargetStack = getLaunchStack(mStartActivity, mLaunchFlags,
                    mStartActivity.getTaskRecord(), mOptions);
            // If target stack is not found now - we can't just rely on the source stack, as it may
            // be not suitable. Let's check other displays.
            if (mTargetStack == null && targetDisplayId != sourceStack.mDisplayId) {
                // Can't use target display, lets find a stack on the source display.
                mTargetStack = mRootActivityContainer.getValidLaunchStackOnDisplay(
                        sourceStack.mDisplayId, mStartActivity, mOptions, mLaunchParams);
            }
            if (mTargetStack == null) {
                // There are no suitable stacks on the target and source display(s). Look on all
                // displays.
                mTargetStack = mRootActivityContainer.getNextValidLaunchStack(
                        mStartActivity, -1 /* currentFocus */);
            }
        }

        if (mTargetStack == null) {
            mTargetStack = sourceStack;
        } else if (mTargetStack != sourceStack) {
            sourceTask.reparent(mTargetStack, ON_TOP, REPARENT_MOVE_STACK_TO_FRONT, !ANIMATE,
                    DEFER_RESUME, ""launchToSide"");
        }

        final TaskRecord topTask = mTargetStack.topTask();
        if (topTask != sourceTask && !mAvoidMoveToFront) {
            mTargetStack.moveTaskToFrontLocked(sourceTask, mNoAnimation, mOptions,
                    mStartActivity.appTimeTracker, ""sourceTaskToFront"");
        } else if (mDoResume) {
            mTargetStack.moveToFront(""sourceStackToFront"");
        }

        if (!mAddingToTask && (mLaunchFlags & FLAG_ACTIVITY_CLEAR_TOP) != 0) {
            // In this case, we are adding the activity to an existing task, but the caller has
            // asked to clear that task if the activity is already running.
            ActivityRecord top = sourceTask.performClearTaskLocked(mStartActivity, mLaunchFlags);
            mKeepCurTransition = true;
            if (top != null) {
                ActivityStack.logStartActivity(AM_NEW_INTENT, mStartActivity, top.getTaskRecord());
                deliverNewIntent(top);
                // For paranoia, make sure we have correctly resumed the top activity.
                mTargetStack.mLastPausedActivity = null;
                if (mDoResume) {
                    mRootActivityContainer.resumeFocusedStacksTopActivities();
                }
                ActivityOptions.abort(mOptions);
                return START_DELIVERED_TO_TOP;
            }
        } else if (!mAddingToTask && (mLaunchFlags & FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
            // In this case, we are launching an activity in our own task that may already be
            // running somewhere in the history, and we want to shuffle it to the front of the
            // stack if so.
            final ActivityRecord top = sourceTask.findActivityInHistoryLocked(mStartActivity);
            if (top != null) {
                final TaskRecord task = top.getTaskRecord();
                task.moveActivityToFrontLocked(top);
                top.updateOptionsLocked(mOptions);
                ActivityStack.logStartActivity(AM_NEW_INTENT, mStartActivity, task);
                deliverNewIntent(top);
                mTargetStack.mLastPausedActivity = null;
                if (mDoResume) {
                    mRootActivityContainer.resumeFocusedStacksTopActivities();
                }
                return START_DELIVERED_TO_TOP;
            }
        }

        // An existing activity is starting this new activity, so we want to keep the new one in
        // the same task as the one that is starting it.
        addOrReparentStartingActivity(sourceTask, ""setTaskFromSourceRecord"");
        if (DEBUG_TASKS) Slog.v(TAG_TASKS, ""Starting new activity "" + mStartActivity
                + "" in existing task "" + mStartActivity.getTaskRecord()
                + "" from source "" + mSourceRecord);
        return START_SUCCESS;
    }

    private int setTaskFromInTask() {
        // The caller is asking that the new activity be started in an explicit
        // task it has provided to us.
        if (mService.getLockTaskController().isLockTaskModeViolation(mInTask)) {
            Slog.e(TAG, ""Attempted Lock Task Mode violation mStartActivity="" + mStartActivity);
            return START_RETURN_LOCK_TASK_MODE_VIOLATION;
        }

        mTargetStack = mInTask.getStack();

        // Check whether we should actually launch the new activity in to the task,
        // or just reuse the current activity on top.
        ActivityRecord top = mInTask.getTopActivity();
        if (top != null && top.mActivityComponent.equals(mStartActivity.mActivityComponent)
                && top.mUserId == mStartActivity.mUserId) {
            if ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0
                    || isLaunchModeOneOf(LAUNCH_SINGLE_TOP, LAUNCH_SINGLE_TASK)) {
                mTargetStack.moveTaskToFrontLocked(mInTask, mNoAnimation, mOptions,
                        mStartActivity.appTimeTracker, ""inTaskToFront"");
                if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {
                    // We don't need to start a new activity, and the client said not to do
                    // anything if that is the case, so this is it!
                    return START_RETURN_INTENT_TO_CALLER;
                }
                deliverNewIntent(top);
                return START_DELIVERED_TO_TOP;
            }
        }

        if (!mAddingToTask) {
            mTargetStack.moveTaskToFrontLocked(mInTask, mNoAnimation, mOptions,
                    mStartActivity.appTimeTracker, ""inTaskToFront"");
            // We don't actually want to have this activity added to the task, so just
            // stop here but still tell the caller that we consumed the intent.
            ActivityOptions.abort(mOptions);
            return START_TASK_TO_FRONT;
        }

        if (!mLaunchParams.mBounds.isEmpty()) {
            // TODO: Shouldn't we already know what stack to use by the time we get here?
            ActivityStack stack = mRootActivityContainer.getLaunchStack(
                    null, null, mInTask, ON_TOP);
            if (stack != mInTask.getStack()) {
                mInTask.reparent(stack, ON_TOP, REPARENT_KEEP_STACK_AT_FRONT, !ANIMATE,
                        DEFER_RESUME, ""inTaskToFront"");
                mTargetStack = mInTask.getStack();
            }

            updateBounds(mInTask, mLaunchParams.mBounds);
        }

        mTargetStack.moveTaskToFrontLocked(
                mInTask, mNoAnimation, mOptions, mStartActivity.appTimeTracker, ""inTaskToFront"");

        addOrReparentStartingActivity(mInTask, ""setTaskFromInTask"");
        if (DEBUG_TASKS) Slog.v(TAG_TASKS, ""Starting new activity "" + mStartActivity
                + "" in explicit task "" + mStartActivity.getTaskRecord());

        return START_SUCCESS;
    }

","    private int setTaskFromSourceRecord() {
        if (mService.getLockTaskController().isLockTaskModeViolation(
                mSourceRecord.getTaskRecord())) {
            Slog.e(TAG, ""Attempted Lock Task Mode violation mStartActivity="" + mStartActivity);
            return START_RETURN_LOCK_TASK_MODE_VIOLATION;
        }
        String packageName= mService.mContext.getPackageName();
        if (mPerf != null) {
            mStartActivity.perfActivityBoostHandler =
                mPerf.perfHint(BoostFramework.VENDOR_HINT_FIRST_LAUNCH_BOOST,
                                    packageName, -1, BoostFramework.Launch.BOOST_V1);
        }

        final TaskRecord sourceTask = mSourceRecord.getTaskRecord();
        final ActivityStack sourceStack = mSourceRecord.getActivityStack();
        if (mRestrictedBgActivity && !sourceTask.containsAppUid(mCallingUid)) {
            if (handleBackgroundActivityAbort(mStartActivity)) {
                return START_ABORTED;
            }
        }
        // We only want to allow changing stack in two cases:
        // 1. If the target task is not the top one. Otherwise we would move the launching task to
        //    the other side, rather than show two side by side.
        // 2. If activity is not allowed on target display.
        final int targetDisplayId = mTargetStack != null ? mTargetStack.mDisplayId
                : sourceStack.mDisplayId;
        final boolean moveStackAllowed = sourceStack.topTask() != sourceTask
                || !mStartActivity.canBeLaunchedOnDisplay(targetDisplayId);
        if (moveStackAllowed) {
            mTargetStack = getLaunchStack(mStartActivity, mLaunchFlags,
                    mStartActivity.getTaskRecord(), mOptions);
            // If target stack is not found now - we can't just rely on the source stack, as it may
            // be not suitable. Let's check other displays.
            if (mTargetStack == null && targetDisplayId != sourceStack.mDisplayId) {
                // Can't use target display, lets find a stack on the source display.
                mTargetStack = mRootActivityContainer.getValidLaunchStackOnDisplay(
                        sourceStack.mDisplayId, mStartActivity, mOptions, mLaunchParams);
            }
            if (mTargetStack == null) {
                // There are no suitable stacks on the target and source display(s). Look on all
                // displays.
                mTargetStack = mRootActivityContainer.getNextValidLaunchStack(
                        mStartActivity, -1 /* currentFocus */);
            }
        }

        if (mTargetStack == null) {
            mTargetStack = sourceStack;
        } else if (mTargetStack != sourceStack) {
            sourceTask.reparent(mTargetStack, ON_TOP, REPARENT_MOVE_STACK_TO_FRONT, !ANIMATE,
                    DEFER_RESUME, ""launchToSide"");
        }

        final TaskRecord topTask = mTargetStack.topTask();
        if (topTask != sourceTask && !mAvoidMoveToFront) {
            mTargetStack.moveTaskToFrontLocked(sourceTask, mNoAnimation, mOptions,
                    mStartActivity.appTimeTracker, ""sourceTaskToFront"");
        } else if (mDoResume) {
            mTargetStack.moveToFront(""sourceStackToFront"");
        }

        if (!mAddingToTask && (mLaunchFlags & FLAG_ACTIVITY_CLEAR_TOP) != 0) {
            // In this case, we are adding the activity to an existing task, but the caller has
            // asked to clear that task if the activity is already running.
            ActivityRecord top = sourceTask.performClearTaskLocked(mStartActivity, mLaunchFlags);
            mKeepCurTransition = true;
            if (top != null) {
                ActivityStack.logStartActivity(AM_NEW_INTENT, mStartActivity, top.getTaskRecord());
                deliverNewIntent(top);
                // For paranoia, make sure we have correctly resumed the top activity.
                mTargetStack.mLastPausedActivity = null;
                if (mDoResume) {
                    mRootActivityContainer.resumeFocusedStacksTopActivities();
                }
                ActivityOptions.abort(mOptions);
                return START_DELIVERED_TO_TOP;
            }
        } else if (!mAddingToTask && (mLaunchFlags & FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
            // In this case, we are launching an activity in our own task that may already be
            // running somewhere in the history, and we want to shuffle it to the front of the
            // stack if so.
            final ActivityRecord top = sourceTask.findActivityInHistoryLocked(mStartActivity);
            if (top != null) {
                final TaskRecord task = top.getTaskRecord();
                task.moveActivityToFrontLocked(top);
                top.updateOptionsLocked(mOptions);
                ActivityStack.logStartActivity(AM_NEW_INTENT, mStartActivity, task);
                deliverNewIntent(top);
                mTargetStack.mLastPausedActivity = null;
                if (mDoResume) {
                    mRootActivityContainer.resumeFocusedStacksTopActivities();
                }
                return START_DELIVERED_TO_TOP;
            }
        }

        // An existing activity is starting this new activity, so we want to keep the new one in
        // the same task as the one that is starting it.
        addOrReparentStartingActivity(sourceTask, ""setTaskFromSourceRecord"");
        if (DEBUG_TASKS) Slog.v(TAG_TASKS, ""Starting new activity "" + mStartActivity
                + "" in existing task "" + mStartActivity.getTaskRecord()
                + "" from source "" + mSourceRecord);
        return START_SUCCESS;
    }

    private int setTaskFromInTask() {
        // The caller is asking that the new activity be started in an explicit
        // task it has provided to us.
        if (mService.getLockTaskController().isLockTaskModeViolation(mInTask)) {
            Slog.e(TAG, ""Attempted Lock Task Mode violation mStartActivity="" + mStartActivity);
            return START_RETURN_LOCK_TASK_MODE_VIOLATION;
        }

        mTargetStack = mInTask.getStack();

        // Check whether we should actually launch the new activity in to the task,
        // or just reuse the current activity on top.
        ActivityRecord top = mInTask.getTopActivity();
        if (top != null && top.mActivityComponent.equals(mStartActivity.mActivityComponent)
                && top.mUserId == mStartActivity.mUserId) {
            if ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0
                    || isLaunchModeOneOf(LAUNCH_SINGLE_TOP, LAUNCH_SINGLE_TASK)) {
                mTargetStack.moveTaskToFrontLocked(mInTask, mNoAnimation, mOptions,
                        mStartActivity.appTimeTracker, ""inTaskToFront"");
                if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {
                    // We don't need to start a new activity, and the client said not to do
                    // anything if that is the case, so this is it!
                    return START_RETURN_INTENT_TO_CALLER;
                }
                deliverNewIntent(top);
                return START_DELIVERED_TO_TOP;
            }
        }

        if (!mAddingToTask) {
            mTargetStack.moveTaskToFrontLocked(mInTask, mNoAnimation, mOptions,
                    mStartActivity.appTimeTracker, ""inTaskToFront"");
            // We don't actually want to have this activity added to the task, so just
            // stop here but still tell the caller that we consumed the intent.
            ActivityOptions.abort(mOptions);
            return START_TASK_TO_FRONT;
        }

        if (!mLaunchParams.mBounds.isEmpty()) {
            // TODO: Shouldn't we already know what stack to use by the time we get here?
            ActivityStack stack = mRootActivityContainer.getLaunchStack(
                    null, null, mInTask, ON_TOP);
            if (stack != mInTask.getStack()) {
                mInTask.reparent(stack, ON_TOP, REPARENT_KEEP_STACK_AT_FRONT, !ANIMATE,
                        DEFER_RESUME, ""inTaskToFront"");
                mTargetStack = mInTask.getStack();
            }

            updateBounds(mInTask, mLaunchParams.mBounds);
        }

        mTargetStack.moveTaskToFrontLocked(
                mInTask, mNoAnimation, mOptions, mStartActivity.appTimeTracker, ""inTaskToFront"");

        addOrReparentStartingActivity(mInTask, ""setTaskFromInTask"");
        if (DEBUG_TASKS) Slog.v(TAG_TASKS, ""Starting new activity "" + mStartActivity
                + "" in explicit task "" + mStartActivity.getTaskRecord());

        return START_SUCCESS;
    }

","[1.0, 1.0]"
1388,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java,"[(121, 121, 1), (121, 121, 1)]","    private EmergencyCarrierArea mEmergencyCarrierArea;
","    private EmergencyCarrierArea mEmergencyCarrierArea;
","    private EmergencyCarrierArea mEmergencyCarrierArea;
","[1.0, 1.0]"
1389,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2616, 2616, 1), (2616, 2616, 1)]","        dest.writeString(oweTransIfaceName);
","        dest.writeString(oweTransIfaceName);
","        dest.writeString(oweTransIfaceName);
","[1.0, 1.0]"
1390,"['fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",wifi/java/android/net/wifi/WifiConfiguration.java,"[(2695, 2695, 1), (2695, 2695, 1)]","                config.oweTransIfaceName = in.readString();
","                config.oweTransIfaceName = in.readString();
","                config.oweTransIfaceName = in.readString();
","[1.0, 1.0]"
1391,"['fd65619dfea934f9f1f28a80e9599e2d8e3e77f3', 'fd65619dfea934f9f1f28a80e9599e2d8e3e77f3']","['aospa-ruby-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/TaskDisplayArea.java,"[(57, 57, 1), (57, 57, 1)]","import android.util.BoostFramework;
","import android.util.BoostFramework;
","import android.util.BoostFramework;
","[1.0, 1.0]"
1392,"['022e461c46ee3629d43ba134e977a0f3353c8782', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/DisplayModeDirector.java,"[(1176, 1176, 1), (1096, 1096, 1)]","        private boolean mIsDeviceActive = false;
","        private boolean mScreenOn = false;
",        private boolean m,"[0.51, 0.581]"
1393,"['022e461c46ee3629d43ba134e977a0f3353c8782', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/DisplayModeDirector.java,"[(1573, 1574, 2), (1313, 1315, 3)]","                Slog.d(TAG, ""Display brightness "" + mBrightness + "", ambient lux "" +  mAmbientLux +
                        "", Vote "" + vote);
","            if (DEBUG) {
                Slog.d(TAG, ""Display brightness "" + brightness + "", ambient lux "" +  mAmbientLux +
                        "", Vote "" + vote);
","rightness + "", ambient lux "" +  mAmbientLux +
                        "", Vote "" + vote);
","[0.622, 0.533]"
1394,"['02a7ee5d65cb8d40fd1dde9aaf6b5ead9222a5a6', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(638, 639, 2), (349, 350, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1395,"['02a7ee5d65cb8d40fd1dde9aaf6b5ead9222a5a6', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(638, 639, 2), (444, 445, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1396,"['02a7ee5d65cb8d40fd1dde9aaf6b5ead9222a5a6', 'a9736185db896fe2edde0281d71102b35327b7f8']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(638, 639, 2), (431, 432, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1397,"['02a7ee5d65cb8d40fd1dde9aaf6b5ead9222a5a6', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(638, 639, 2), (371, 372, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1398,"['02a7ee5d65cb8d40fd1dde9aaf6b5ead9222a5a6', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(638, 639, 2), (398, 399, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1399,"['1b62159ffcebb2c102e129b2e778a8f65b7e5948', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(587, 588, 2), (349, 350, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1400,"['1b62159ffcebb2c102e129b2e778a8f65b7e5948', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(587, 588, 2), (444, 445, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1401,"['1b62159ffcebb2c102e129b2e778a8f65b7e5948', 'a9736185db896fe2edde0281d71102b35327b7f8']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(587, 588, 2), (431, 432, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1402,"['1b62159ffcebb2c102e129b2e778a8f65b7e5948', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(587, 588, 2), (371, 372, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1403,"['1b62159ffcebb2c102e129b2e778a8f65b7e5948', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(587, 588, 2), (398, 399, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1404,"['2051462f672b5986ef321bf1de3657e7653864e8', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1267, 1306, 40), (1122, 1160, 39)]","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.ACCESS_KEYGUARD_SECURE_STORAGE,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

    private void setKeystorePassword(byte[] password, int userHandle) {
","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.","[0.837, 0.891]"
1405,"['2051462f672b5986ef321bf1de3657e7653864e8', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(574, 575, 2), (349, 350, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1406,"['2051462f672b5986ef321bf1de3657e7653864e8', '3a5272699e3e16fbfdc397480898bb27abeb2caa']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/locksettings/LockSettingsService.java,"[(1267, 1306, 40), (1108, 1147, 40)]","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.ACCESS_KEYGUARD_SECURE_STORAGE,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

    private void setKeystorePassword(byte[] password, int userHandle) {
","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.MANAGE_DEVICE_ADMINS,
                    ""no crypt_keeper or admin permission to get the password"");

       return mSavePassword;
    }

    private void setKeystorePassword(String password, int userHandle) {
","    public void retainPassword(String password) {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (password != null)
                mSavePassword = password;
            else
                mSavePassword = DEFAULT_PASSWORD;
        }
    }

    public void sanitizePassword() {
        if (LockPatternUtils.isDeviceEncryptionEnabled()) {
            mSavePassword = DEFAULT_PASSWORD;
        }
    }

    private boolean checkCryptKeeperPermissions() {
        boolean permission_err = false;
        try {
            mContext.enforceCallingOrSelfPermission(
                       android.Manifest.permission.CRYPT_KEEPER,
                       ""no permission to get the password"");
        } catch (SecurityException e) {
            permission_err = true;
        }
        return permission_err;
    }

    public String getPassword() {
       /** if calling process does't have crypt keeper or admin permissions,
         * throw the exception.
         */
       if (checkCryptKeeperPermissions())
            mContext.enforceCallingOrSelfPermission(
                    android.Manifest.permission.","[0.837, 0.843]"
1407,"['2051462f672b5986ef321bf1de3657e7653864e8', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/tiles/HotspotTile.java,"[(19, 20, 2), (20, 21, 2)]","import android.annotation.Nullable;
import android.content.Context;
","import android.content.ComponentName;
import android.content.Context;
","e;
import android.content.Context;
","[0.515, 0.5]"
1408,"['2051462f672b5986ef321bf1de3657e7653864e8', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(574, 575, 2), (444, 445, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1409,"['2051462f672b5986ef321bf1de3657e7653864e8', 'a9736185db896fe2edde0281d71102b35327b7f8']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(574, 575, 2), (431, 432, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1410,"['2051462f672b5986ef321bf1de3657e7653864e8', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(574, 575, 2), (371, 372, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1411,"['2051462f672b5986ef321bf1de3657e7653864e8', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(574, 575, 2), (398, 399, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1412,"['21cdef883cc867db55340b25d5c95e19b12ab383', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(747, 747, 1), (688, 688, 1)]","                                    subject, report.toString(), finalStack, null);
","                                    subject, null, finalStack, null);
","                                    subject, ","[0.542, 0.643]"
1413,"['21cdef883cc867db55340b25d5c95e19b12ab383', '8faa0d981413f18b2468dde1b1fe71e248df0df1']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/Watchdog.java,"[(747, 747, 1), (695, 695, 1)]","                                    subject, report.toString(), finalStack, null);
","                                    subject, cpuInfo, finalStack, null);
","                                    subject, ","[0.542, 0.616]"
1414,"['24818fca475a6726f5ef0cae42149615079af6e9', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(542, 543, 2), (349, 350, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1415,"['24818fca475a6726f5ef0cae42149615079af6e9', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(1742, 1744, 3), (1662, 1664, 3)]","
        if (mPerf == null)
            mPerf = new BoostFramework();
","
        if (mPerf == null)
            mPerf = new BoostFramework();
","
        if (mPerf == null)
            mPerf = new BoostFramework();
","[1.0, 1.0]"
1416,"['24818fca475a6726f5ef0cae42149615079af6e9', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(4165, 4166, 2), (3238, 3239, 2)]","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
","[1.0, 1.0]"
1417,"['24818fca475a6726f5ef0cae42149615079af6e9', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/com/android/internal/telephony/uicc/IccUtils.java,"[(32, 32, 1), (31, 31, 1)]","import java.nio.charset.Charset;
","import java.nio.charset.Charset;
","import java.nio.charset.Charset;
","[1.0, 1.0]"
1418,"['24818fca475a6726f5ef0cae42149615079af6e9', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(542, 543, 2), (444, 445, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1419,"['24818fca475a6726f5ef0cae42149615079af6e9', 'a9736185db896fe2edde0281d71102b35327b7f8']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(542, 543, 2), (431, 432, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1420,"['24818fca475a6726f5ef0cae42149615079af6e9', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(4165, 4166, 2), (3473, 3475, 3)]","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
        if (DEBUG_MODE) { Log.v(TAG, ""setMode(mode="" + mode + "", callingPackage="" + callingPackage + "")""); }
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
","[1.0, 0.578]"
1421,"['24818fca475a6726f5ef0cae42149615079af6e9', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(1742, 1744, 3), (1658, 1660, 3)]","
        if (mPerf == null)
            mPerf = new BoostFramework();
","
        if (mPerf == null)
            mPerf = new BoostFramework();
","
        if (mPerf == null)
            mPerf = new BoostFramework();
","[1.0, 1.0]"
1422,"['24818fca475a6726f5ef0cae42149615079af6e9', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(542, 543, 2), (371, 372, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1423,"['24818fca475a6726f5ef0cae42149615079af6e9', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(542, 543, 2), (398, 399, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1424,"['24818fca475a6726f5ef0cae42149615079af6e9', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(4165, 4166, 2), (3226, 3228, 3)]","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
        if (DEBUG_MODE) { Log.v(TAG, ""setMode(mode="" + mode + "", callingPackage="" + callingPackage + "")""); }
","        Log.i(TAG, ""setMode(mode = "" + mode + "", callingPackage = "" +
                  callingPackage + "", Process ID: "" + Binder.getCallingPid());
","[1.0, 0.578]"
1426,"['26017c68ee11d3f2d54ca731119c8dc4ddb842cf', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceInventory.java,"[(1305, 1305, 1), (846, 846, 1)]","            delay = SystemProperties.getInt(""audio.sys.noisy.broadcast.delay"", 700);
","            delay = SystemProperties.getInt(""audio.sys.noisy.broadcast.delay"", 700);
","            delay = SystemProperties.getInt(""audio.sys.noisy.broadcast.delay"", 700);
","[1.0, 1.0]"
1427,"['26017c68ee11d3f2d54ca731119c8dc4ddb842cf', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/LocalDisplayAdapter.java,"[(606, 625, 20), (544, 565, 22)]","                } else if (isBuiltIn) {
                    mInfo.type = Display.TYPE_INTERNAL;
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                    mInfo.name = getContext().getResources().getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;

                    if (SystemProperties.getBoolean(
                                    ""vendor.display.builtin_presentation"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRESENTATION;
                    } else {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRIVATE;
                    }

                    if (!SystemProperties.getBoolean(
                                    ""vendor.display.builtin_mirroring"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_OWN_CONTENT_ONLY;
                    }

                    mInfo.setAssumedDensityForExternalDisplay(mActiveSfDisplayMode.width, mActiveSfDisplayMode.height);
","                    mInfo.type = Display.TYPE_BUILT_IN;
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                } else if (isBuiltIn) {
                    mInfo.type = Display.TYPE_BUILT_IN;
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                    mInfo.name = getContext().getResources().getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;

                    if (SystemProperties.getBoolean(
                                    ""vendor.display.builtin_presentation"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRESENTATION;
                    } else {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRIVATE;
                    }

                    if (!SystemProperties.getBoolean(
                                    ""vendor.display.builtin_mirroring"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_OWN_CONTENT_ONLY;
                    }

                    mInfo.setAssumedDensityForExternalDisplay(config.width, config.height);
",";
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                    mInfo.name = getContext().getResources().getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;

                    if (SystemProperties.getBoolean(
                                    ""vendor.display.builtin_presentation"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRESENTATION;
                    } else {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRIVATE;
                    }

                    if (!SystemProperties.getBoolean(
                                    ""vendor.display.builtin_mirroring"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_OWN_CONTENT_ONLY;
                    }

                    mInfo.setAssumedDensityForExternalDisplay(","[0.863, 0.795]"
1428,"['26017c68ee11d3f2d54ca731119c8dc4ddb842cf', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceInventory.java,"[(1305, 1305, 1), (854, 854, 1)]","            delay = SystemProperties.getInt(""audio.sys.noisy.broadcast.delay"", 700);
","            delay = SystemProperties.getInt(""audio.sys.noisy.broadcast.delay"", 700);
","            delay = SystemProperties.getInt(""audio.sys.noisy.broadcast.delay"", 700);
","[1.0, 1.0]"
1429,"['26017c68ee11d3f2d54ca731119c8dc4ddb842cf', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/WindowManagerService.java,"[(350, 351, 2), (297, 299, 3)]","    static WindowState mFocusingWindow;
    String mFocusingActivity;
","    static final boolean localLOGV = DEBUG;
    static WindowState mFocusingWindow;
    String mFocusingActivity;
","    static WindowState mFocusingWindow;
    String mFocusingActivity;
","[1.0, 0.614]"
1430,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(16154, 16156, 3), (16283, 16285, 3)]","        if (DEBUG_INSTALL) Slog.d(TAG, ""New package installed in "" + pkg.getCodePath());
        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
","        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
        synchronized (mPackages) {
","        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
","[0.553, 0.759]"
1431,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(943, 943, 1), (2329, 2329, 1)]","        android.util.SeempLog.record(47);
","        android.util.SeempLog.record(48);
",        android.util.SeempLog.record(4,"[0.905, 0.905]"
1432,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(3719, 3720, 2), (3715, 3716, 2)]","            Log.i(TAG, ""In binderDied(), calling setModeOwnerPid()"");
            mDeviceBroker.postSetModeOwnerPid(newModeOwnerPid);
","            Log.i(TAG, ""In binderDied(), calling setModeOwnerPid()"");
            mDeviceBroker.postSetModeOwnerPid(newModeOwnerPid);
","            Log.i(TAG, ""In binderDied(), calling setModeOwnerPid()"");
            mDeviceBroker.postSetModeOwnerPid(newModeOwnerPid);
","[1.0, 1.0]"
1433,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/Utils.java,"[(380, 380, 1), (380, 380, 1)]","        return getWifiIconResource(level, 0 /* standard */, false /* isReady */);
","        return getWifiIconResource(level, 0 /* standard */, false /* isReady */);
","        return getWifiIconResource(level, 0 /* standard */, false /* isReady */);
","[1.0, 1.0]"
1434,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/Utils.java,"[(386, 407, 22), (386, 407, 22)]","     * @param level The number of bars to show (0-4)
     * @throws IllegalArgumentException if an invalid RSSI level is given.
     */
    public static int getWifiIconResource(int level, int standard, boolean isReady) {
        if (level < 0 || level >= WIFI_PIE.length) {
            throw new IllegalArgumentException(""No Wifi icon found for level: "" + level);
        }

        switch (standard) {
            case 4:
                return WIFI_4_PIE[level];
            case 5:
                if (isReady) {
                    return WIFI_6_PIE[level];
                } else {
                    return WIFI_5_PIE[level];
                }
            case 6:
                return WIFI_6_PIE[level];
            default:
                return WIFI_PIE[level];
       }
","     * @param level The number of bars to show (0-4)
     * @throws IllegalArgumentException if an invalid RSSI level is given.
     */
    public static int getWifiIconResource(int level, int standard, boolean isReady) {
        if (level < 0 || level >= WIFI_PIE.length) {
            throw new IllegalArgumentException(""No Wifi icon found for level: "" + level);
        }

        switch (standard) {
            case 4:
                return WIFI_4_PIE[level];
            case 5:
                if (isReady) {
                    return WIFI_6_PIE[level];
                } else {
                    return WIFI_5_PIE[level];
                }
            case 6:
                return WIFI_6_PIE[level];
            default:
                return WIFI_PIE[level];
       }
","     * @param level The number of bars to show (0-4)
     * @throws IllegalArgumentException if an invalid RSSI level is given.
     */
    public static int getWifiIconResource(int level, int standard, boolean isReady) {
        if (level < 0 || level >= WIFI_PIE.length) {
            throw new IllegalArgumentException(""No Wifi icon found for level: "" + level);
        }

        switch (standard) {
            case 4:
                return WIFI_4_PIE[level];
            case 5:
                if (isReady) {
                    return WIFI_6_PIE[level];
                } else {
                    return WIFI_5_PIE[level];
                }
            case 6:
                return WIFI_6_PIE[level];
            default:
                return WIFI_PIE[level];
       }
","[1.0, 1.0]"
1435,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/WifiEntryPreference.java,"[(67, 69, 3), (67, 69, 3)]","    private int mWifiStandard;
    private boolean mVhtMax8SpatialStreamsSupport;
    private boolean mHe8ssCapableAp;
","    private int mWifiStandard;
    private boolean mVhtMax8SpatialStreamsSupport;
    private boolean mHe8ssCapableAp;
","    private int mWifiStandard;
    private boolean mVhtMax8SpatialStreamsSupport;
    private boolean mHe8ssCapableAp;
","[1.0, 1.0]"
1436,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/WifiEntryPreference.java,"[(142, 152, 11), (142, 152, 11)]","        final int standard = mWifiEntry.getWifiStandard();
        final boolean vhtMax8SpatialStreamsSupport = mWifiEntry.isVhtMax8SpatialStreamsSupported();
        final boolean he8ssCapableAp = mWifiEntry.isHe8ssCapableAp();

        if (level != mLevel || standard != mWifiStandard || he8ssCapableAp != mHe8ssCapableAp ||
                vhtMax8SpatialStreamsSupport != mVhtMax8SpatialStreamsSupport) {
            mLevel = level;
            mWifiStandard = standard;
            mHe8ssCapableAp = he8ssCapableAp;
            mVhtMax8SpatialStreamsSupport = vhtMax8SpatialStreamsSupport;
            updateIcon(mLevel, mWifiStandard, mHe8ssCapableAp && mVhtMax8SpatialStreamsSupport);
","        final int standard = mWifiEntry.getWifiStandard();
        final boolean vhtMax8SpatialStreamsSupport = mWifiEntry.isVhtMax8SpatialStreamsSupported();
        final boolean he8ssCapableAp = mWifiEntry.isHe8ssCapableAp();

        if (level != mLevel || standard != mWifiStandard || he8ssCapableAp != mHe8ssCapableAp ||
                vhtMax8SpatialStreamsSupport != mVhtMax8SpatialStreamsSupport) {
            mLevel = level;
            mWifiStandard = standard;
            mHe8ssCapableAp = he8ssCapableAp;
            mVhtMax8SpatialStreamsSupport = vhtMax8SpatialStreamsSupport;
            updateIcon(mLevel, mWifiStandard, mHe8ssCapableAp && mVhtMax8SpatialStreamsSupport);
","        final int standard = mWifiEntry.getWifiStandard();
        final boolean vhtMax8SpatialStreamsSupport = mWifiEntry.isVhtMax8SpatialStreamsSupported();
        final boolean he8ssCapableAp = mWifiEntry.isHe8ssCapableAp();

        if (level != mLevel || standard != mWifiStandard || he8ssCapableAp != mHe8ssCapableAp ||
                vhtMax8SpatialStreamsSupport != mVhtMax8SpatialStreamsSupport) {
            mLevel = level;
            mWifiStandard = standard;
            mHe8ssCapableAp = he8ssCapableAp;
            mVhtMax8SpatialStreamsSupport = vhtMax8SpatialStreamsSupport;
            updateIcon(mLevel, mWifiStandard, mHe8ssCapableAp && mVhtMax8SpatialStreamsSupport);
","[1.0, 1.0]"
1437,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/WifiEntryPreference.java,"[(211, 211, 1), (211, 211, 1)]","    private void updateIcon(int level, int standard, boolean isReady) {
","    private void updateIcon(int level, int standard, boolean isReady) {
","    private void updateIcon(int level, int standard, boolean isReady) {
","[1.0, 1.0]"
1438,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/WifiEntryPreference.java,"[(217, 217, 1), (217, 217, 1)]","        final Drawable drawable = mIconInjector.getIcon(level, standard, isReady);
","        final Drawable drawable = mIconInjector.getIcon(level, standard, isReady);
","        final Drawable drawable = mIconInjector.getIcon(level, standard, isReady);
","[1.0, 1.0]"
1439,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/CachedAppOptimizer.java,"[(286, 358, 73), (286, 358, 73)]","        Process.setThreadGroupAndCpuset(mCachedAppOptimizerThread.getThreadId(),
                Process.THREAD_GROUP_SYSTEM);
        setAppCompactProperties();
    }

    private void setAppCompactProperties() {
        boolean useCompaction =
                    Boolean.valueOf(mPerf.perfGetProp(""vendor.appcompact.enable_app_compact"",
                        ""false""));
        int someCompactionType =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.some_compact_type"",
                        String.valueOf(COMPACT_ACTION_ANON_FLAG)));
        int fullCompactionType =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.full_compact_type"",
                        String.valueOf(COMPACT_ACTION_ANON_FLAG)));
        int compactThrottleSomeSome =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_somesome"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_1)));
        int compactThrottleSomeFull =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_somefull"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_2)));
        int compactThrottleFullSome =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_fullsome"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_3)));
        int compactThrottleFullFull =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_fullfull"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_4)));
        int compactThrottleBfgs =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_bfgs"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_5)));
        int compactThrottlePersistent =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_persistent"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_6)));
        int fullRssThrottleKB =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.rss_throttle_kb"",
                        String.valueOf(DEFAULT_COMPACT_FULL_RSS_THROTTLE_KB)));
        int deltaRssThrottleKB =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.delta_rss_throttle_kb"",
                        String.valueOf(DEFAULT_COMPACT_FULL_DELTA_RSS_THROTTLE_KB)));

        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_ACTION_1,
                        String.valueOf(someCompactionType), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_ACTION_2,
                        String.valueOf(fullCompactionType), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_1,
                        String.valueOf(compactThrottleSomeSome), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_2,
                        String.valueOf(compactThrottleSomeFull), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_3,
                        String.valueOf(compactThrottleFullSome), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_4,
                        String.valueOf(compactThrottleFullFull), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_5,
                        String.valueOf(compactThrottleBfgs), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_6,
                        String.valueOf(compactThrottlePersistent), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_FULL_RSS_THROTTLE_KB,
                        String.valueOf(fullRssThrottleKB), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_FULL_DELTA_RSS_THROTTLE_KB,
                        String.valueOf(deltaRssThrottleKB), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_USE_COMPACTION,
                        String.valueOf(useCompaction), true);
","        Process.setThreadGroupAndCpuset(mCachedAppOptimizerThread.getThreadId(),
                Process.THREAD_GROUP_SYSTEM);
        setAppCompactProperties();
    }

    private void setAppCompactProperties() {
        boolean useCompaction =
                    Boolean.valueOf(mPerf.perfGetProp(""vendor.appcompact.enable_app_compact"",
                        ""false""));
        int someCompactionType =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.some_compact_type"",
                        String.valueOf(COMPACT_ACTION_ANON_FLAG)));
        int fullCompactionType =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.full_compact_type"",
                        String.valueOf(COMPACT_ACTION_ANON_FLAG)));
        int compactThrottleSomeSome =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_somesome"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_1)));
        int compactThrottleSomeFull =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_somefull"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_2)));
        int compactThrottleFullSome =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_fullsome"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_3)));
        int compactThrottleFullFull =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_fullfull"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_4)));
        int compactThrottleBfgs =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_bfgs"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_5)));
        int compactThrottlePersistent =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_persistent"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_6)));
        int fullRssThrottleKB =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.rss_throttle_kb"",
                        String.valueOf(DEFAULT_COMPACT_FULL_RSS_THROTTLE_KB)));
        int deltaRssThrottleKB =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.delta_rss_throttle_kb"",
                        String.valueOf(DEFAULT_COMPACT_FULL_DELTA_RSS_THROTTLE_KB)));

        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_ACTION_1,
                        String.valueOf(someCompactionType), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_ACTION_2,
                        String.valueOf(fullCompactionType), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_1,
                        String.valueOf(compactThrottleSomeSome), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_2,
                        String.valueOf(compactThrottleSomeFull), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_3,
                        String.valueOf(compactThrottleFullSome), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_4,
                        String.valueOf(compactThrottleFullFull), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_5,
                        String.valueOf(compactThrottleBfgs), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_6,
                        String.valueOf(compactThrottlePersistent), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_FULL_RSS_THROTTLE_KB,
                        String.valueOf(fullRssThrottleKB), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_FULL_DELTA_RSS_THROTTLE_KB,
                        String.valueOf(deltaRssThrottleKB), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_USE_COMPACTION,
                        String.valueOf(useCompaction), true);
","        Process.setThreadGroupAndCpuset(mCachedAppOptimizerThread.getThreadId(),
                Process.THREAD_GROUP_SYSTEM);
        setAppCompactProperties();
    }

    private void setAppCompactProperties() {
        boolean useCompaction =
                    Boolean.valueOf(mPerf.perfGetProp(""vendor.appcompact.enable_app_compact"",
                        ""false""));
        int someCompactionType =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.some_compact_type"",
                        String.valueOf(COMPACT_ACTION_ANON_FLAG)));
        int fullCompactionType =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.full_compact_type"",
                        String.valueOf(COMPACT_ACTION_ANON_FLAG)));
        int compactThrottleSomeSome =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_somesome"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_1)));
        int compactThrottleSomeFull =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_somefull"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_2)));
        int compactThrottleFullSome =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_fullsome"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_3)));
        int compactThrottleFullFull =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_fullfull"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_4)));
        int compactThrottleBfgs =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_bfgs"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_5)));
        int compactThrottlePersistent =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.compact_throttle_persistent"",
                        String.valueOf(DEFAULT_COMPACT_THROTTLE_6)));
        int fullRssThrottleKB =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.rss_throttle_kb"",
                        String.valueOf(DEFAULT_COMPACT_FULL_RSS_THROTTLE_KB)));
        int deltaRssThrottleKB =
                    Integer.valueOf(mPerf.perfGetProp(""vendor.appcompact.delta_rss_throttle_kb"",
                        String.valueOf(DEFAULT_COMPACT_FULL_DELTA_RSS_THROTTLE_KB)));

        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_ACTION_1,
                        String.valueOf(someCompactionType), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_ACTION_2,
                        String.valueOf(fullCompactionType), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_1,
                        String.valueOf(compactThrottleSomeSome), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_2,
                        String.valueOf(compactThrottleSomeFull), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_3,
                        String.valueOf(compactThrottleFullSome), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_4,
                        String.valueOf(compactThrottleFullFull), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_5,
                        String.valueOf(compactThrottleBfgs), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_THROTTLE_6,
                        String.valueOf(compactThrottlePersistent), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_FULL_RSS_THROTTLE_KB,
                        String.valueOf(fullRssThrottleKB), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_COMPACT_FULL_DELTA_RSS_THROTTLE_KB,
                        String.valueOf(deltaRssThrottleKB), true);
        DeviceConfig.setProperty(
                    DeviceConfig.NAMESPACE_ACTIVITY_MANAGER, KEY_USE_COMPACTION,
                        String.valueOf(useCompaction), true);
","[1.0, 1.0]"
1440,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(99, 99, 1), (98, 98, 1)]","    private static final String BLUETOOTH_PRIVILEGED_PERM = android.Manifest.permission.BLUETOOTH_PRIVILEGED;
","    private static final String BLUETOOTH_PRIVILEGED_PERM = android.Manifest.permission.BLUETOOTH_PRIVILEGED;
","    private static final String BLUETOOTH_PRIVILEGED_PERM = android.Manifest.permission.BLUETOOTH_PRIVILEGED;
","[1.0, 1.0]"
1441,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerConstants.java,"[(29, 30, 2), (28, 29, 2)]","import android.os.Process;
import android.os.SystemProperties;
","import android.os.SystemProperties;
import android.os.Process;
","import android.os.SystemProperties;
","[0.571, 0.571]"
1442,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerConstants.java,"[(29, 30, 2), (25, 26, 2)]","import android.os.Process;
import android.os.SystemProperties;
","import android.os.SystemProperties;
import android.os.Process;
","import android.os.SystemProperties;
","[0.571, 0.571]"
1443,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '69bee5bb55994d647b678b2cb2ce1becd3d77b32']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/TaskDisplayArea.java,"[(158, 162, 5), (147, 154, 8)]","    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = null;
    public BoostFramework mUxPerf = null;
","    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = null;
    public BoostFramework mUxPerf = null;

    TaskDisplayArea(DisplayContent displayContent, WindowManagerService service) {
        super(service, Type.ANY, ""TaskContainers"", FEATURE_TASK_CONTAINER);
","    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = null;
    public BoostFramework mUxPerf = null;
","[1.0, 0.595]"
1444,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(1092, 1108, 17), (929, 944, 16)]","                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
                } break;
                case MSG_IL_SAVE_PREF_DEVICE_FOR_STRATEGY: {
","                } break;
                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
","                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
","[0.922, 0.976]"
1445,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', 'a97ca47ee3713a075711c311c49e3951264007ef']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(943, 943, 1), (1780, 1781, 2)]","        android.util.SeempLog.record(47);
","        android.util.SeempLog.record(43);
        return false;
",        android.util.SeempLog.record(4,"[0.905, 0.594]"
1446,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(16154, 16156, 3), (15147, 15149, 3)]","        if (DEBUG_INSTALL) Slog.d(TAG, ""New package installed in "" + pkg.getCodePath());
        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
","        if (DEBUG_INSTALL) Slog.d(TAG, ""New package installed in "" + pkg.codePath);
        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
",");
        if (pkgName != null)
            acquireUxPerfLock(BoostFramework.UXE_EVENT_PKG_INSTALL, pkgName, 0);
","[0.568, 0.582]"
1447,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(1092, 1108, 17), (931, 945, 15)]","                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
                } break;
                case MSG_IL_SAVE_PREF_DEVICE_FOR_STRATEGY: {
","                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
","                case MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT: {
                    final BtDeviceConnectionInfo info = (BtDeviceConnectionInfo) msg.obj;
                    AudioService.sDeviceLogger.log((new AudioEventLogger.StringEvent(
                    ""handleBluetoothA2dpActiveDeviceChangeExt ""
                           + "" state="" + info.mState
                           // only querying address as this is the only readily available
                           // field on the device
                           + "" addr="" + info.mDevice.getAddress()
                           + "" prof="" + info.mProfile + "" supprNoisy="" + info.mSupprNoisy
                           + "" vol="" + info.mVolume)).printLog(TAG));
                    synchronized (mDeviceStateLock) {
                        mDeviceInventory.handleBluetoothA2dpActiveDeviceChangeExt(
                                info.mDevice, info.mState, info.mProfile,
                                info.mSupprNoisy, info.mVolume);
                    }
","[0.922, 1.0]"
1448,"['27e7f8c2aa4ce0a2f59b3bf1969b06bfd1e9ebca', 'b6292e3e1ba3616eac1032737a91925391d94b92']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerConstants.java,"[(29, 30, 2), (30, 33, 4)]","import android.os.Process;
import android.os.SystemProperties;
","import android.os.Process;
import android.os.SystemProperties;
import android.os.UserHandle;
import android.os.UserManager;
","import android.os.Process;
import android.os.SystemProperties;
","[1.0, 0.508]"
1449,"['337095f9d277c566cb888bc3adbac16576f1ae70', '1581c348fc5d6cbf1673b3dbc5960637f891d488']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActiveServices.java,"[(3626, 3632, 7), (2547, 2552, 6)]","                    app.stopService(r);
                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");
                    }
","                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortName + "" in "" + r.restartDelay + ""ms"");
                    }
","                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.short","[0.713, 0.815]"
1450,"['337095f9d277c566cb888bc3adbac16576f1ae70', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/LocalDisplayAdapter.java,"[(609, 628, 20), (544, 565, 22)]","                } else if (isBuiltIn) {
                    mInfo.type = Display.TYPE_INTERNAL;
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                    mInfo.name = getContext().getResources().getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;

                    if (SystemProperties.getBoolean(
                                    ""vendor.display.builtin_presentation"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRESENTATION;
                    } else {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRIVATE;
                    }

                    if (!SystemProperties.getBoolean(
                                    ""vendor.display.builtin_mirroring"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_OWN_CONTENT_ONLY;
                    }

                    mInfo.setAssumedDensityForExternalDisplay(config.width, config.height);
","                    mInfo.type = Display.TYPE_BUILT_IN;
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                } else if (isBuiltIn) {
                    mInfo.type = Display.TYPE_BUILT_IN;
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                    mInfo.name = getContext().getResources().getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;

                    if (SystemProperties.getBoolean(
                                    ""vendor.display.builtin_presentation"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRESENTATION;
                    } else {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRIVATE;
                    }

                    if (!SystemProperties.getBoolean(
                                    ""vendor.display.builtin_mirroring"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_OWN_CONTENT_ONLY;
                    }

                    mInfo.setAssumedDensityForExternalDisplay(config.width, config.height);
",";
                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
                    mInfo.name = getContext().getResources().getString(
                            com.android.internal.R.string.display_manager_built_in_display_name);
                    mInfo.flags |= DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;

                    if (SystemProperties.getBoolean(
                                    ""vendor.display.builtin_presentation"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRESENTATION;
                    } else {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRIVATE;
                    }

                    if (!SystemProperties.getBoolean(
                                    ""vendor.display.builtin_mirroring"", false)) {
                        mInfo.flags |= DisplayDeviceInfo.FLAG_OWN_CONTENT_ONLY;
                    }

                    mInfo.setAssumedDensityForExternalDisplay(config.width, config.height);
","[0.913, 0.819]"
1451,"['337095f9d277c566cb888bc3adbac16576f1ae70', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ProcessList.java,"[(512, 515, 4), (409, 412, 4)]","    /**
     * BoostFramework Object
     */
    public static BoostFramework mPerfServiceStartHint = new BoostFramework();
","    /**
     * BoostFramework Object
     */
    public static BoostFramework mPerfServiceStartHint = new BoostFramework();
","    /**
     * BoostFramework Object
     */
    public static BoostFramework mPerfServiceStartHint = new BoostFramework();
","[1.0, 1.0]"
1452,"['337095f9d277c566cb888bc3adbac16576f1ae70', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActiveServices.java,"[(3626, 3632, 7), (3198, 3204, 7)]","                    app.stopService(r);
                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");
                    }
","                    app.services.remove(r);
                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");
                    }
","e(r);
                    r.app = null;
                    if (SERVICE_RESCHEDULE && DEBUG_DELAYED_SERVICE) {
                    Slog.w(TAG, "" Failed to create Service !!!! .""
                           +""This will introduce huge delay...  ""
                           +r.shortInstanceName + "" in "" + r.restartDelay + ""ms"");
                    }
","[0.911, 0.902]"
1453,"['337095f9d277c566cb888bc3adbac16576f1ae70', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/OomAdjuster.java,"[(1151, 1160, 10), (583, 596, 14)]","        if ((numBServices > mBServiceAppThreshold) && (true == mService.mAppProfiler.allowLowerMemLevelLocked())
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }

        mProcessList.incrementProcStateSeqAndNotifyAppsLocked(activeUids);
","        if ((numBServices > mBServiceAppThreshold) && (true == mService.mAllowLowerMemLevel)
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }

        mService.incrementProcStateSeqAndNotifyAppsLocked();

        mNumServiceProcs = mNewNumServiceProcs;

        boolean allChanged = mService.updateLowMemStateLocked(numCached, numEmpty, numTrimming);
",")
                && (selectedAppRecord != null)) {
            ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid,
                    ProcessList.CACHED_APP_MAX_ADJ);
            selectedAppRecord.setAdj = selectedAppRecord.curAdj;
            if (DEBUG_OOM_ADJ) Slog.d(TAG,""app.processName = "" + selectedAppRecord.processName
                        + "" app.pid = "" + selectedAppRecord.pid + "" is moved to higher adj"");
        }

        m","[0.724, 0.615]"
1454,"['337095f9d277c566cb888bc3adbac16576f1ae70', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java,"[(121, 122, 2), (120, 121, 2)]","    private EmergencyCarrierArea mEmergencyCarrierArea;

","    private EmergencyCarrierArea mEmergencyCarrierArea;
    private final UnlockMethodCache mUnlockMethodCache;
","    private EmergencyCarrierArea mEmergencyCarrierArea;
","[0.982, 0.5]"
1455,"['337095f9d277c566cb888bc3adbac16576f1ae70', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/content/pm/ApplicationInfo.java,"[(2266, 2266, 1), (2190, 2190, 1)]","    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
","    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
","    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
","[1.0, 1.0]"
1456,"['337095f9d277c566cb888bc3adbac16576f1ae70', 'a33382db0bb0bc29bab84f1e5ee36d682bea593e']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/content/pm/ApplicationInfo.java,"[(2280, 2280, 1), (2202, 2202, 1)]","    /** {@hide} */ public int canOverrideRes() { return overrideRes; }
","    /** {@hide} */ public int canOverrideRes() { return overrideRes; }
","    /** {@hide} */ public int canOverrideRes() { return overrideRes; }
","[1.0, 1.0]"
1457,"['337095f9d277c566cb888bc3adbac16576f1ae70', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ProcessList.java,"[(106, 106, 1), (103, 104, 2)]","import android.util.BoostFramework;
","import android.util.StatsLog;
import android.util.BoostFramework;
","import android.util.BoostFramework;
","[1.0, 0.545]"
1458,"['337095f9d277c566cb888bc3adbac16576f1ae70', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java,"[(121, 122, 2), (121, 121, 1)]","    private EmergencyCarrierArea mEmergencyCarrierArea;

","    private EmergencyCarrierArea mEmergencyCarrierArea;
","    private EmergencyCarrierArea mEmergencyCarrierArea;
","[0.982, 1.0]"
1459,"['3933f277a025be704e68ea593536e492831a7e05', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(479, 480, 2), (349, 350, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1460,"['3933f277a025be704e68ea593536e492831a7e05', '587cb520382d349c91bd59ada23fbefcdb44314f']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanel.java,"[(485, 490, 6), (288, 291, 4)]","        for (TileRecord r : mRecords) {
            r.tile.clearState();
        }
        if (mListening) {
            refreshAllTiles();
        }
","        for (TileRecord r : mRecords) {
            r.tile.clearState();
        }
        refreshAllTiles();
","        for (TileRecord r : mRecords) {
            r.tile.clearState();
        }
        ","[0.607, 0.827]"
1461,"['3933f277a025be704e68ea593536e492831a7e05', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(479, 480, 2), (444, 445, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1462,"['3933f277a025be704e68ea593536e492831a7e05', 'a9736185db896fe2edde0281d71102b35327b7f8']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(479, 480, 2), (431, 432, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1463,"['3933f277a025be704e68ea593536e492831a7e05', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(479, 480, 2), (371, 372, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1464,"['3933f277a025be704e68ea593536e492831a7e05', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(506, 507, 2), (500, 501, 2)]","    private boolean mSetToSleep; // have we told the activity to sleep?
    public boolean launching;      // is activity launch in progress?
","    boolean sleeping;       // have we told the activity to sleep?
    public boolean launching;      // is activity launch in progress?
"," // have we told the activity to sleep?
    public boolean launching;      // is activity launch in progress?
","[0.775, 0.803]"
1465,"['3933f277a025be704e68ea593536e492831a7e05', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(479, 480, 2), (398, 399, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1466,"['3e8cb98421761bb7dfafe59a22a15fe2e176f272', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(5397, 5397, 1), (3546, 3547, 2)]","        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
","        Log.i(TAG, ""In startBluetoothSco()"");
        int scoAudioMode =
","        Log.i(TAG, ""In startBluetoothSco","[0.702, 0.548]"
1467,"['3e8cb98421761bb7dfafe59a22a15fe2e176f272', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(5369, 5374, 6), (4039, 4044, 6)]","        Log.i(TAG, ""In startBluetoothSco()"");
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if ((adapter == null) || (adapter.getState() != BluetoothAdapter.STATE_ON)) {
             Log.i(TAG, ""startBluetoothSco(), BT is not turned ON or adapter is null"");
             return;
        }
","        Log.i(TAG, ""In startBluetoothSco()"");
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if ((adapter == null) || (adapter.getState() != BluetoothAdapter.STATE_ON)) {
             Log.i(TAG, ""startBluetoothSco(), BT is not turned ON or adapter is null"");
             return;
        }
","        Log.i(TAG, ""In startBluetoothSco()"");
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if ((adapter == null) || (adapter.getState() != BluetoothAdapter.STATE_ON)) {
             Log.i(TAG, ""startBluetoothSco(), BT is not turned ON or adapter is null"");
             return;
        }
","[1.0, 1.0]"
1468,"['3e8cb98421761bb7dfafe59a22a15fe2e176f272', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(5397, 5397, 1), (4056, 4056, 1)]","        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
","        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
","        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
","[1.0, 1.0]"
1469,"['3e8cb98421761bb7dfafe59a22a15fe2e176f272', '62f4dee264cabcd5595e6e4c0a6ab3228281d3e0']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(5397, 5397, 1), (4064, 4064, 1)]","        Log.i(TAG, ""In startBluetoothScoVirtualCall()"");
","        Log.i(TAG, ""In startBluetoothScoInt(), scoAudioMode: "" + scoAudioMode);
","        Log.i(TAG, ""In startBluetoothSco","[0.702, 0.5]"
1470,"['3e8cb98421761bb7dfafe59a22a15fe2e176f272', 'e15313dd5c01373f4e046366a36472a1913e3e39']","['aospa-sapphire-SAP-block_text', 'omnirom-12.0-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(25571, 25572, 2), (4458, 4458, 1)]","            int flags;
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
","                if (umInternal.isUserUnlockingOrUnlocked(userId)) {
",            if (umInternal.isUserUnlockingOrUnlocked(user,"[0.648, 0.838]"
1471,"['3e8cb98421761bb7dfafe59a22a15fe2e176f272', 'e15313dd5c01373f4e046366a36472a1913e3e39']","['aospa-sapphire-SAP-block_text', 'omnirom-12.0-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(25571, 25572, 2), (25451, 25451, 1)]","            int flags;
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
","            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
","            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
","[0.739, 1.0]"
1473,"['449f659b21d039b8692602294b040038ac1e6ccb', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/bluetooth/BluetoothCodecConfig.java,"[(64, 78, 15), (64, 78, 15)]","    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 4;

    public static final int SOURCE_CODEC_TYPE_LDAC = 5;

    public static final int SOURCE_CODEC_TYPE_APTX_TWSP = 6;

    public static final int SOURCE_CODEC_TYPE_MAX = 7;

    /* CELT is not an A2DP Codec and only used to fetch encoder
    ** format for BA usecase, moving out of a2dp codec value list
    */
    public static final int SOURCE_CODEC_TYPE_CELT = 8;

   public static final int SOURCE_CODEC_TYPE_LC3 = 9;

","    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 4;

    public static final int SOURCE_CODEC_TYPE_LDAC = 5;

    public static final int SOURCE_CODEC_TYPE_APTX_TWSP = 6;

    public static final int SOURCE_CODEC_TYPE_MAX = 7;

    /* CELT is not an A2DP Codec and only used to fetch encoder
    ** format for BA usecase, moving out of a2dp codec value list
    */
    public static final int SOURCE_CODEC_TYPE_CELT = 8;

    public static final int SOURCE_CODEC_TYPE_LC3 = 9;

","    public static final int SOURCE_CODEC_TYPE_APTX_ADAPTIVE = 4;

    public static final int SOURCE_CODEC_TYPE_LDAC = 5;

    public static final int SOURCE_CODEC_TYPE_APTX_TWSP = 6;

    public static final int SOURCE_CODEC_TYPE_MAX = 7;

    /* CELT is not an A2DP Codec and only used to fetch encoder
    ** format for BA usecase, moving out of a2dp codec value list
    */
    public static final int SOURCE_CODEC_TYPE_CELT = 8;

   ","[0.894, 0.892]"
1474,"['449f659b21d039b8692602294b040038ac1e6ccb', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(4401, 4403, 3), (3357, 3359, 3)]","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        final boolean stateChanged = mDeviceBroker.setSpeakerphoneOn(cb, pid, on, eventSource);
","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        mDeviceBroker.setSpeakerphoneOn(on, eventSource);
","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        ","[0.532, 0.667]"
1475,"['449f659b21d039b8692602294b040038ac1e6ccb', '69bee5bb55994d647b678b2cb2ce1becd3d77b32']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/TaskDisplayArea.java,"[(159, 164, 6), (147, 154, 8)]","    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = null;
    public BoostFramework mUxPerf = null;

","    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = null;
    public BoostFramework mUxPerf = null;

    TaskDisplayArea(DisplayContent displayContent, WindowManagerService service) {
        super(service, Type.ANY, ""TaskContainers"", FEATURE_TASK_CONTAINER);
","    public static boolean mPerfSendTapHint = false;
    public static boolean mIsPerfBoostAcquired = false;
    public static int mPerfHandle = -1;
    public BoostFramework mPerfBoost = null;
    public BoostFramework mUxPerf = null;

","[1.0, 0.597]"
1476,"['449f659b21d039b8692602294b040038ac1e6ccb', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(303, 306, 4), (221, 223, 3)]","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
            return (mForcedUseForCommExt == AudioSystem.FORCE_SPEAKER);
","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
","[0.683, 1.0]"
1477,"['449f659b21d039b8692602294b040038ac1e6ccb', 'bb9ded46832af38a453b78b92ad2de32ef1cf845']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioService.java,"[(4401, 4403, 3), (4018, 4020, 3)]","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        final boolean stateChanged = mDeviceBroker.setSpeakerphoneOn(cb, pid, on, eventSource);
","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        final boolean stateChanged = mDeviceBroker.setSpeakerphoneOn(on, eventSource);
","        Log.i(TAG, ""In setSpeakerphoneOn(), on: "" + on + "", eventSource: "" + eventSource);

        final boolean stateChanged = mDeviceBroker.setSpeakerphoneOn(","[0.856, 0.899]"
1478,"['449f659b21d039b8692602294b040038ac1e6ccb', 'fa63f69f0fdfc50fe92caa22dbe1b4b120807ed2']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(303, 306, 4), (220, 223, 4)]","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
            return (mForcedUseForCommExt == AudioSystem.FORCE_SPEAKER);
","        synchronized (mDeviceStateLock) {
            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
","            if (AudioService.DEBUG_SCO) {
                Log.i(TAG, ""In isSpeakerphoneOn(), mForcedUseForCommExt: "" +mForcedUseForCommExt);
            }
","[0.683, 0.787]"
1479,"['757dbb836469bbdd7eb8312deaf584fe0c99c17d', '2edeff882ab756e76b3a028a1568d8774ddc0257']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(970, 973, 4), (945, 951, 7)]","                if ((mDevice.getBluetoothClass() != null) &&
                   (mDevice.getBluetoothClass().getDeviceClass()
                        == BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE ||
                    mDevice.getBluetoothClass().getDeviceClass()
","            if (getPhonebookPermissionChoice() == CachedBluetoothDevice.ACCESS_UNKNOWN) {
                if ((mDevice.getBluetoothClass() != null) &&
                   (mDevice.getBluetoothClass().getDeviceClass()
                        == BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE ||
                    mDevice.getBluetoothClass().getDeviceClass()
                        == BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET)) {
                    setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
","                if ((mDevice.getBluetoothClass() != null) &&
                   (mDevice.getBluetoothClass().getDeviceClass()
                        == BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE ||
                    mDevice.getBluetoothClass().getDeviceClass()
","[1.0, 0.505]"
1480,"['757dbb836469bbdd7eb8312deaf584fe0c99c17d', '8d21ad0d966c1e9f96e5a65144efad2582391957']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(236, 236, 1), (167, 167, 1)]","    public static final int SECURITY_DPP = 7;
","    public static final int SECURITY_DPP = 7;
","    public static final int SECURITY_DPP = 7;
","[1.0, 1.0]"
1481,"['757dbb836469bbdd7eb8312deaf584fe0c99c17d', 'b76115be4efabffaa6febc57cec47acc2f933c79']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java,"[(236, 236, 1), (166, 166, 1)]","    public static final int SECURITY_DPP = 7;
","    public static final int SECURITY_DPP = 6;
",    public static final int SECURITY_DPP = ,"[0.935, 0.935]"
1482,"['7fd6edc3a3ff37a750641d5e192835fe217f6050', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(716, 716, 1), (2329, 2329, 1)]","        android.util.SeempLog.record(46);
","        android.util.SeempLog.record(48);
",        android.util.SeempLog.record(4,"[0.905, 0.905]"
1483,"['7fd6edc3a3ff37a750641d5e192835fe217f6050', '82ca638edd627c1b70aae1505f06c8ddaef731d2']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1347, 1349, 3), (1308, 1310, 3)]","        if (isBluetoothAvailableForBinding() == false) {
            Slog.w(TAG, ""bindBluetoothProfileService:Trying to bind to profile: ""
                       + bluetoothProfile + "", while Bluetooth is disabled"");
","        if (isBluetoothAvailableForBinding() == false) {
            Slog.w(TAG, ""bindBluetoothProfileService:Trying to bind to profile: ""
                       + bluetoothProfile + "", while Bluetooth is disabled"");
","        if (isBluetoothAvailableForBinding() == false) {
            Slog.w(TAG, ""bindBluetoothProfileService:Trying to bind to profile: ""
                       + bluetoothProfile + "", while Bluetooth is disabled"");
","[1.0, 1.0]"
1484,"['7fd6edc3a3ff37a750641d5e192835fe217f6050', 'a97ca47ee3713a075711c311c49e3951264007ef']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",location/java/android/location/LocationManager.java,"[(716, 716, 1), (1780, 1781, 2)]","        android.util.SeempLog.record(46);
","        android.util.SeempLog.record(43);
        return false;
",        android.util.SeempLog.record(4,"[0.905, 0.594]"
1485,"['7fd6edc3a3ff37a750641d5e192835fe217f6050', 'd1ffad806502fc4ff57f88b4eb543cc81fc601a1']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/BluetoothManagerService.java,"[(1347, 1349, 3), (1308, 1310, 3)]","        if (isBluetoothAvailableForBinding() == false) {
            Slog.w(TAG, ""bindBluetoothProfileService:Trying to bind to profile: ""
                       + bluetoothProfile + "", while Bluetooth is disabled"");
","        if (isBluetoothAvailableForBinding() == false) {
            Slog.w(TAG, ""bindBluetoothProfileService:Trying to bind to profile: ""
                       + bluetoothProfile + "", while Bluetooth is disabled"");
","        if (isBluetoothAvailableForBinding() == false) {
            Slog.w(TAG, ""bindBluetoothProfileService:Trying to bind to profile: ""
                       + bluetoothProfile + "", while Bluetooth is disabled"");
","[1.0, 1.0]"
1486,"['7fd6edc3a3ff37a750641d5e192835fe217f6050', 'dfd2f7fed77160af2c57edfa20f1768b42aaa8da']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/audio/AudioDeviceBroker.java,"[(1314, 1317, 4), (1033, 1034, 2)]","
    // process external command to (dis)connect or change active A2DP device
    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = 64;

","    // process external command to (dis)connect or change active A2DP device
    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = 32;
","    // process external command to (dis)connect or change active A2DP device
    private static final int MSG_L_A2DP_ACTIVE_DEVICE_CHANGE_EXT = ","[0.96, 0.973]"
1487,"['8abdf0e95a5d15a310b6df69d33a4510a0b44b4a', '24adcf1303bc4e0f0203c9ea0c691d7faa0c2aba']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/ScreenDecorations.java,"[(597, 597, 1), (597, 597, 1)]","        int newRoundedDefault = mContext.getResources().getDimensionPixelSize(
","        int newRoundedDefault = mContext.getResources().getDimensionPixelSize(
","        int newRoundedDefault = mContext.getResources().getDimensionPixelSize(
","[1.0, 1.0]"
1488,"['8abdf0e95a5d15a310b6df69d33a4510a0b44b4a', '2b1a920917d6b9235c008921845152448c7e5fc7']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/ScreenDecorations.java,"[(597, 597, 1), (597, 597, 1)]","        int newRoundedDefault = mContext.getResources().getDimensionPixelSize(
","        int newRoundedDefault = mContext.getResources().getDimensionPixelSize(
","        int newRoundedDefault = mContext.getResources().getDimensionPixelSize(
","[1.0, 1.0]"
1489,"['8abdf0e95a5d15a310b6df69d33a4510a0b44b4a', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/util/sensors/AsyncSensorManager.java,"[(100, 107, 8), (100, 102, 3)]","        if ( sensor == null ) {
            Log.e(TAG, ""sensor cannot be null \n"" + Log.getStackTraceString(new Throwable()));
            return false;
        }
        mHandler.post(() -> {
            if ( sensor == null ) {
                Log.e(TAG, ""sensor cannot be null"");
            }
","        if ( sensor == null ) {
            Log.e(TAG, ""sensor cannot be null \n"" + Log.getStackTraceString(new Throwable()));
            return false;
","        if ( sensor == null ) {
            Log.e(TAG, ""sensor cannot be null \n"" + Log.getStackTraceString(new Throwable()));
            return false;
","[0.517, 1.0]"
1490,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(444, 445, 2), (349, 350, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1491,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/DisplayModeDirector.java,"[(1081, 1082, 2), (1081, 1082, 2)]","        private boolean mShouldObserveDisplayChange;
        private boolean mShouldObserveAmbientChange;
","        private boolean mShouldObserveDisplayChange;
        private boolean mShouldObserveAmbientChange;
","        private boolean mShouldObserveDisplayChange;
        private boolean mShouldObserveAmbientChange;
","[1.0, 1.0]"
1492,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/DisplayModeDirector.java,"[(1096, 1096, 1), (1096, 1096, 1)]","        private boolean mScreenOn = false;
","        private boolean mScreenOn = false;
","        private boolean mScreenOn = false;
","[1.0, 1.0]"
1493,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/DisplayModeDirector.java,"[(1179, 1179, 1), (1179, 1179, 1)]","            pw.println(""    mRefreshRateInZone: "" + mRefreshRateInZone);
","            pw.println(""    mRefreshRateInZone: "" + mRefreshRateInZone);
","            pw.println(""    mRefreshRateInZone: "" + mRefreshRateInZone);
","[1.0, 1.0]"
1494,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/DisplayModeDirector.java,"[(1313, 1315, 3), (1313, 1315, 3)]","            if (DEBUG) {
                Slog.d(TAG, ""Display brightness "" + brightness + "", ambient lux "" +  mAmbientLux +
                        "", Vote "" + vote);
","            if (DEBUG) {
                Slog.d(TAG, ""Display brightness "" + brightness + "", ambient lux "" +  mAmbientLux +
                        "", Vote "" + vote);
","            if (DEBUG) {
                Slog.d(TAG, ""Display brightness "" + brightness + "", ambient lux "" +  mAmbientLux +
                        "", Vote "" + vote);
","[1.0, 1.0]"
1495,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/DisplayModeDirector.java,"[(1320, 1322, 3), (1320, 1322, 3)]","        private void onScreenOn(boolean on) {
            if (mScreenOn != on) {
                mScreenOn = on;
","        private void onScreenOn(boolean on) {
            if (mScreenOn != on) {
                mScreenOn = on;
","        private void onScreenOn(boolean on) {
            if (mScreenOn != on) {
                mScreenOn = on;
","[1.0, 1.0]"
1496,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/DisplayModeDirector.java,"[(1332, 1333, 2), (1332, 1333, 2)]","            if (mShouldObserveAmbientChange && mScreenOn && !mLowPowerModeEnabled
                    && mRefreshRateChangeable) {
","            if (mShouldObserveAmbientChange && mScreenOn && !mLowPowerModeEnabled
                    && mRefreshRateChangeable) {
","            if (mShouldObserveAmbientChange && mScreenOn && !mLowPowerModeEnabled
                    && mRefreshRateChangeable) {
","[1.0, 1.0]"
1497,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/DisplayModeDirector.java,"[(1342, 1346, 5), (1342, 1346, 5)]","        private boolean isDefaultDisplayOn() {
            final Display display = mContext.getSystemService(DisplayManager.class)
                    .getDisplay(Display.DEFAULT_DISPLAY);
            return display.getState() != Display.STATE_OFF
                    && mContext.getSystemService(PowerManager.class).isInteractive();
","        private boolean isDefaultDisplayOn() {
            final Display display = mContext.getSystemService(DisplayManager.class)
                    .getDisplay(Display.DEFAULT_DISPLAY);
            return display.getState() != Display.STATE_OFF
                    && mContext.getSystemService(PowerManager.class).isInteractive();
","        private boolean isDefaultDisplayOn() {
            final Display display = mContext.getSystemService(DisplayManager.class)
                    .getDisplay(Display.DEFAULT_DISPLAY);
            return display.getState() != Display.STATE_OFF
                    && mContext.getSystemService(PowerManager.class).isInteractive();
","[1.0, 1.0]"
1498,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/display/DisplayModeDirector.java,"[(1372, 1372, 1), (1372, 1372, 1)]","                mAmbientFilter.addValue(now, mLastSensorData);
","                mAmbientFilter.addValue(now, mLastSensorData);
","                mAmbientFilter.addValue(now, mLastSensorData);
","[1.0, 1.0]"
1499,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(444, 445, 2), (444, 445, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1500,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'a9736185db896fe2edde0281d71102b35327b7f8']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(444, 445, 2), (431, 432, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1501,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(444, 445, 2), (371, 372, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1502,"['9272406e82304c5a2a8124c75eedb4b5fdf7273a', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(444, 445, 2), (398, 399, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1503,"['ac442e0398fe7344f66cbbd4d2af15b1bfdbf46b', '43ceded8caaffead0a2a1967f42a4ef4bb658ced']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityTaskManagerService.java,"[(390, 390, 1), (376, 377, 2)]","    public ActivityStackSupervisor mStackSupervisor;
","    public ActivityStackSupervisor mStackSupervisor;
    RootActivityContainer mRootActivityContainer;
","    public ActivityStackSupervisor mStackSupervisor;
","[1.0, 0.515]"
1504,"['ac442e0398fe7344f66cbbd4d2af15b1bfdbf46b', '567b4cf7b54062947b5eabe6ecef7b70fbb7301b']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityTaskManagerService.java,"[(390, 390, 1), (352, 352, 1)]","    public ActivityStackSupervisor mStackSupervisor;
","    public ActivityStackSupervisor mStackSupervisor;
","    public ActivityStackSupervisor mStackSupervisor;
","[1.0, 1.0]"
1505,"['ac442e0398fe7344f66cbbd4d2af15b1bfdbf46b', '8d21ad0d966c1e9f96e5a65144efad2582391957']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityTaskManagerService.java,"[(390, 390, 1), (353, 353, 1)]","    public ActivityStackSupervisor mStackSupervisor;
","    public ActivityStackSupervisor mStackSupervisor;
","    public ActivityStackSupervisor mStackSupervisor;
","[1.0, 1.0]"
1506,"['ac442e0398fe7344f66cbbd4d2af15b1bfdbf46b', 'ae1b3a8f3221dbe692fd90d414cfe5040538c264']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(5094, 5099, 6), (4679, 4684, 6)]","            mStackSupervisor.updateHomeProcess(task.getBottomMostActivity().app);
            try {
                mStackSupervisor.new PreferredAppsTask().execute();
            } catch (Exception e) {
                Slog.v (TAG, ""Exception: "" + e);
            }
","            mStackSupervisor.updateHomeProcess(task.getChildAt(0).app);
            try {
                mStackSupervisor.new PreferredAppsTask().execute();
            } catch (Exception e) {
                Slog.v (TAG, ""Exception: "" + e);
            }
",").app);
            try {
                mStackSupervisor.new PreferredAppsTask().execute();
            } catch (Exception e) {
                Slog.v (TAG, ""Exception: "" + e);
            }
","[0.723, 0.751]"
1507,"['b03d6d43646266d456c22154a1f6fd945bf79f83', '71998c3d8b36220df1be12fe6e1ba7eda81cde41']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(1668, 1669, 2), (1662, 1664, 3)]","        if (mPerf == null)
            mPerf = new BoostFramework();
","
        if (mPerf == null)
            mPerf = new BoostFramework();
","        if (mPerf == null)
            mPerf = new BoostFramework();
","[1.0, 0.986]"
1508,"['b03d6d43646266d456c22154a1f6fd945bf79f83', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/wm/ActivityRecord.java,"[(1668, 1669, 2), (1658, 1660, 3)]","        if (mPerf == null)
            mPerf = new BoostFramework();
","
        if (mPerf == null)
            mPerf = new BoostFramework();
","        if (mPerf == null)
            mPerf = new BoostFramework();
","[1.0, 0.986]"
1509,"['b6d6690a3594cd78966e26508247d4ab1b66776f', 'e15313dd5c01373f4e046366a36472a1913e3e39']","['aospa-sapphire-SAP-block_text', 'omnirom-12.0-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(25218, 25219, 2), (4458, 4458, 1)]","            int flags = 0;
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
","                if (umInternal.isUserUnlockingOrUnlocked(userId)) {
",            if (umInternal.isUserUnlockingOrUnlocked(user,"[0.62, 0.838]"
1510,"['b6d6690a3594cd78966e26508247d4ab1b66776f', 'e15313dd5c01373f4e046366a36472a1913e3e39']","['aospa-sapphire-SAP-block_text', 'omnirom-12.0-SAP-block_text']",services/core/java/com/android/server/pm/PackageManagerService.java,"[(25218, 25219, 2), (25451, 25451, 1)]","            int flags = 0;
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
","            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
","            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
","[0.707, 1.0]"
1511,"['e85435d4d9a2f7122bd5c97ad0a25c768d124a0e', '2775a5a9b030266a910301e8b464811acafcd5fa']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(308, 308, 1), (313, 313, 1)]","import com.android.internal.app.ActivityTrigger;
","import com.android.internal.app.ActivityTrigger;
","import com.android.internal.app.ActivityTrigger;
","[1.0, 1.0]"
1512,"['e85435d4d9a2f7122bd5c97ad0a25c768d124a0e', '35fa949362e35d8514c64a645b6448424f174c82']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(490, 491, 2), (349, 350, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1513,"['e85435d4d9a2f7122bd5c97ad0a25c768d124a0e', '81b587a542e8381268a9ba8e7461712ef23cd11f']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActiveServices.java,"[(3186, 3210, 25), (2459, 2487, 29)]","            if(SERVICE_RESCHEDULE) {
                boolean shouldDelay = false;
                ActivityRecord top_rc = mAm.mTaskSupervisor.getTopResumedActivity();

                boolean isPersistent
                        = !((r.serviceInfo.applicationInfo.flags&ApplicationInfo.FLAG_PERSISTENT) == 0);
                if(top_rc != null) {
                    if(top_rc.launching && !r.shortInstanceName.contains(top_rc.packageName)
                            && !isPersistent) {
                        shouldDelay = true;
                    }
                }
                if(!shouldDelay) {
                    bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
                } else {
                    if (DEBUG_DELAYED_SERVICE) {
                        Slog.v(TAG, ""Reschedule service restart due to app launch""
                              +"" r.shortInstanceName ""+r.shortInstanceName+"" r.app = ""+r.app);
                    }
                    r.resetRestartCounter();
                    scheduleServiceRestartLocked(r, true);
                }
            } else {
                bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
            }
","            if(SERVICE_RESCHEDULE) {
                boolean shouldDelay = false;
                ActivityRecord top_rc = null;
                ActivityStack stack = mAm.mStackSupervisor.mRootActivityContainer.getTopDisplayFocusedStack();
                if(stack != null) {
                    top_rc = stack.topRunningActivityLocked();
                }

                boolean isPersistent
                        = !((r.serviceInfo.applicationInfo.flags&ApplicationInfo.FLAG_PERSISTENT) == 0);
                if(top_rc != null) {
                    if(top_rc.launching && !r.shortInstanceName.contains(top_rc.packageName)
                            && !isPersistent) {
                        shouldDelay = true;
                    }
                }
                if(!shouldDelay) {
                    bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
                } else {
                    if (DEBUG_DELAYED_SERVICE) {
                        Slog.v(TAG, ""Reschedule service restart due to app launch""
                              +"" r.shortInstanceName ""+r.shortInstanceName+"" r.app = ""+r.app);
                    }
                    r.resetRestartCounter();
                    scheduleServiceRestartLocked(r, true);
                }
            } else {
                bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
            }
","

                boolean isPersistent
                        = !((r.serviceInfo.applicationInfo.flags&ApplicationInfo.FLAG_PERSISTENT) == 0);
                if(top_rc != null) {
                    if(top_rc.launching && !r.shortInstanceName.contains(top_rc.packageName)
                            && !isPersistent) {
                        shouldDelay = true;
                    }
                }
                if(!shouldDelay) {
                    bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
                } else {
                    if (DEBUG_DELAYED_SERVICE) {
                        Slog.v(TAG, ""Reschedule service restart due to app launch""
                              +"" r.shortInstanceName ""+r.shortInstanceName+"" r.app = ""+r.app);
                    }
                    r.resetRestartCounter();
                    scheduleServiceRestartLocked(r, true);
                }
            } else {
                bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false);
            }
","[0.867, 0.753]"
1514,"['e85435d4d9a2f7122bd5c97ad0a25c768d124a0e', 'a362a5abfe0dbcf48877c5b02d1a8da8d9c504c6']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(490, 491, 2), (444, 445, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1515,"['e85435d4d9a2f7122bd5c97ad0a25c768d124a0e', 'a9736185db896fe2edde0281d71102b35327b7f8']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(490, 491, 2), (431, 432, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1516,"['e85435d4d9a2f7122bd5c97ad0a25c768d124a0e', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(490, 491, 2), (371, 372, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1517,"['e85435d4d9a2f7122bd5c97ad0a25c768d124a0e', 'df73284a33506ba26aadbd20a1dbd01353820200']","['aospa-sapphire-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/app/ActivityManagerInternal.java,"[(490, 491, 2), (398, 399, 2)]","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","    // Starts a process as empty.
    public abstract int startActivityAsUserEmpty(Bundle options);
","[1.0, 1.0]"
1518,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '1730c08a2fd38f0ff8135692a855ada865130939']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(144, 144, 1), (153, 153, 1)]","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","[1.0, 1.0]"
1519,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '3d2fc559e13b7293212955f1858d443f4fe8234e']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(184, 185, 2), (199, 200, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
1520,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(144, 144, 1), (144, 144, 1)]","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","[1.0, 1.0]"
1521,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(334, 335, 2), (334, 335, 2)]","                case MSG_LOCALE_CHANGED:
                    handleLocaleChanged();
","                case MSG_LOCALE_CHANGED:
                    handleLocaleChanged();
","                case MSG_LOCALE_CHANGED:
                    handleLocaleChanged();
","[1.0, 1.0]"
1522,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(802, 803, 2), (802, 803, 2)]","            } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);
","            } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);
","            } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
                mHandler.sendEmptyMessage(MSG_LOCALE_CHANGED);
","[1.0, 1.0]"
1523,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Call.java,"[(355, 359, 5), (355, 359, 5)]","        /**
         * Add participant in an active or conference call option
         * @hide
         */
        public static final int CAPABILITY_ADD_PARTICIPANT = 0x01000000;
","        /**
         * Add participant in an active or conference call option
         * @hide
         */
        public static final int CAPABILITY_ADD_PARTICIPANT = 0x01000000;
","        /**
         * Add participant in an active or conference call option
         * @hide
         */
        public static final int CAPABILITY_ADD_PARTICIPANT = 0x01000000;
","[1.0, 1.0]"
1524,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Call.java,"[(537, 538, 2), (537, 538, 2)]","            if (can(capabilities, CAPABILITY_ADD_PARTICIPANT)) {
                builder.append("" CAPABILITY_ADD_PARTICIPANT"");
","            if (can(capabilities, CAPABILITY_ADD_PARTICIPANT)) {
                builder.append("" CAPABILITY_ADD_PARTICIPANT"");
","            if (can(capabilities, CAPABILITY_ADD_PARTICIPANT)) {
                builder.append("" CAPABILITY_ADD_PARTICIPANT"");
","[1.0, 1.0]"
1525,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/Connection.java,"[(331, 337, 7), (331, 337, 7)]","    /**
     * Add participant in an active or conference call option
     *
     * @hide
     */
    public static final int CAPABILITY_ADD_PARTICIPANT = 0x02000000;

","    /**
     * Add participant in an active or conference call option
     *
     * @hide
     */
    public static final int CAPABILITY_ADD_PARTICIPANT = 0x02000000;

","    /**
     * Add participant in an active or conference call option
     *
     * @hide
     */
    public static final int CAPABILITY_ADD_PARTICIPANT = 0x02000000;

","[1.0, 1.0]"
1526,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '4e4914b22b779e6376bb00ae20636175b2a70d8c']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(184, 185, 2), (184, 185, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
1527,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '657230bb5e95ec8560c534360cac5a25fd743129']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(144, 144, 1), (156, 156, 1)]","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","[1.0, 1.0]"
1528,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(144, 144, 1), (151, 151, 1)]","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","    private static final int MSG_LOCALE_CHANGED = 500;
","[1.0, 1.0]"
1529,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', 'af02bd5317cc0cced0a7646d5bbf407a181dda9c']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(184, 185, 2), (198, 199, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
1530,"['4e4914b22b779e6376bb00ae20636175b2a70d8c', 'd28a4f6b38dbab44128b4319f665dd65c3e4ec2c']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",telecomm/java/android/telecom/ConnectionService.java,"[(184, 185, 2), (191, 192, 2)]","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","    //Proprietary values starts after this.
    private static final int MSG_ADD_PARTICIPANT_WITH_CONFERENCE = 40;
","[1.0, 1.0]"
1531,"['595572aed3270fda20949d9c19381969d40ecfd4', '595572aed3270fda20949d9c19381969d40ecfd4']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(271, 276, 6), (271, 276, 6)]","            if (mConfig.readIconsFromXml) {
                return getIcons().mSingleSignalIcon;
            }else {
                return SignalDrawable.getState(level, getNumLevels(),
                        mCurrentState.inetCondition == 0);
            }
","            if (mConfig.readIconsFromXml) {
                return getIcons().mSingleSignalIcon;
            }else {
                return SignalDrawable.getState(level, getNumLevels(),
                        mCurrentState.inetCondition == 0);
            }
","            if (mConfig.readIconsFromXml) {
                return getIcons().mSingleSignalIcon;
            }else {
                return SignalDrawable.getState(level, getNumLevels(),
                        mCurrentState.inetCondition == 0);
            }
","[1.0, 1.0]"
1532,"['595572aed3270fda20949d9c19381969d40ecfd4', '595572aed3270fda20949d9c19381969d40ecfd4']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(836, 847, 12), (836, 847, 12)]","                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
                int qsDataType) {
                this(name, sbIcons, qsIcons, contentDesc, sbNullState, qsNullState, sbDiscState,
                        qsDiscState, discContentDesc, dataContentDesc, dataType, isWide,
                        qsDataType, 0, 0, 0, 0);
        }

        public MobileIconGroup(String name, int[][] sbIcons, int[][] qsIcons, int[] contentDesc,
                int sbNullState, int qsNullState, int sbDiscState, int qsDiscState,
                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
                int qsDataType, int singleSignalIcon, int stackedDataIcon,
                int stackedVoicelIcon, int activityId) {
","                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
                int qsDataType) {
                this(name, sbIcons, qsIcons, contentDesc, sbNullState, qsNullState, sbDiscState,
                        qsDiscState, discContentDesc, dataContentDesc, dataType, isWide,
                        qsDataType, 0, 0, 0, 0);
        }

        public MobileIconGroup(String name, int[][] sbIcons, int[][] qsIcons, int[] contentDesc,
                int sbNullState, int qsNullState, int sbDiscState, int qsDiscState,
                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
                int qsDataType, int singleSignalIcon, int stackedDataIcon,
                int stackedVoicelIcon, int activityId) {
","                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
                int qsDataType) {
                this(name, sbIcons, qsIcons, contentDesc, sbNullState, qsNullState, sbDiscState,
                        qsDiscState, discContentDesc, dataContentDesc, dataType, isWide,
                        qsDataType, 0, 0, 0, 0);
        }

        public MobileIconGroup(String name, int[][] sbIcons, int[][] qsIcons, int[] contentDesc,
                int sbNullState, int qsNullState, int sbDiscState, int qsDiscState,
                int discContentDesc, int dataContentDesc, int dataType, boolean isWide,
                int qsDataType, int singleSignalIcon, int stackedDataIcon,
                int stackedVoicelIcon, int activityId) {
","[1.0, 1.0]"
1533,"['595572aed3270fda20949d9c19381969d40ecfd4', '595572aed3270fda20949d9c19381969d40ecfd4']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java,"[(853, 857, 5), (853, 857, 5)]","            mQsDataType = qsDataType;
            mSingleSignalIcon = singleSignalIcon;
            mStackedDataIcon = stackedDataIcon;
            mStackedVoiceIcon = stackedVoicelIcon;
            mActivityId = activityId;
","            mQsDataType = qsDataType;
            mSingleSignalIcon = singleSignalIcon;
            mStackedDataIcon = stackedDataIcon;
            mStackedVoiceIcon = stackedVoicelIcon;
            mActivityId = activityId;
","            mQsDataType = qsDataType;
            mSingleSignalIcon = singleSignalIcon;
            mStackedDataIcon = stackedDataIcon;
            mStackedVoiceIcon = stackedVoicelIcon;
            mActivityId = activityId;
","[1.0, 1.0]"
1534,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanelController.java,"[(32, 34, 3), (32, 34, 3)]","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","[1.0, 1.0]"
1535,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",core/java/android/hardware/Camera.java,"[(338, 341, 4), (334, 337, 4)]","        if(cameraId >= getNumberOfCameras()){
            throw new RuntimeException(""Unknown camera ID"");
        }
        _getCameraInfo(cameraId, cameraInfo);
","        if (cameraId >= getNumberOfCameras()) {
            throw new RuntimeException(""Unknown camera ID"");
        }
        _getCameraInfo(cameraId, cameraInfo);
","{
            throw new RuntimeException(""Unknown camera ID"");
        }
        _getCameraInfo(cameraId, cameraInfo);
","[0.73, 0.721]"
1536,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",core/java/android/app/StatusBarManager.java,"[(233, 233, 1), (233, 233, 1)]","    public static final int CAMERA_LAUNCH_SOURCE_SCREEN_GESTURE = 3;
","    public static final int CAMERA_LAUNCH_SOURCE_SCREEN_GESTURE = 3;
","    public static final int CAMERA_LAUNCH_SOURCE_SCREEN_GESTURE = 3;
","[1.0, 1.0]"
1537,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/tuner/TunerActivity.java,"[(65, 73, 9), (69, 77, 9)]","            final Fragment fragment;
            if (""com.android.settings.action.DEMO_MODE"".equals(action)) {
                fragment = new DemoModeFragment(mDemoModeController);
            } else if (""com.android.settings.action.STATUS_BAR_TUNER"".equals(action)) {
                fragment = new StatusBarTuner();
            } else {
                fragment = new TunerFragment(mTunerService);
            }

","            final Fragment fragment;
            if (""com.android.settings.action.DEMO_MODE"".equals(action)) {
                fragment = new DemoModeFragment(mDemoModeController);
            } else if (""com.android.settings.action.STATUS_BAR_TUNER"".equals(action)) {
                fragment = new StatusBarTuner();
            } else {
                fragment = new TunerFragment(mTunerService);
            }

","            final Fragment fragment;
            if (""com.android.settings.action.DEMO_MODE"".equals(action)) {
                fragment = new DemoModeFragment(mDemoModeController);
            } else if (""com.android.settings.action.STATUS_BAR_TUNER"".equals(action)) {
                fragment = new StatusBarTuner();
            } else {
                fragment = new TunerFragment(mTunerService);
            }

","[1.0, 1.0]"
1538,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"[(51, 51, 1), (51, 51, 1)]","import android.content.Context;
","import android.content.Context;
","import android.content.Context;
","[1.0, 1.0]"
1539,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"[(77, 77, 1), (77, 77, 1)]","import android.view.GestureDetector;
","import android.view.GestureDetector;
","import android.view.GestureDetector;
","[1.0, 1.0]"
1540,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",services/core/java/com/android/server/media/MediaSessionRecord.java,"[(939, 940, 2), (939, 940, 2)]","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","[1.0, 1.0]"
1541,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationIconContainer.java,"[(143, 147, 5), (143, 147, 5)]","    public final int MAX_ICONS_ON_LOCKSCREEN =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIconsOnLock);
    public final int MAX_STATIC_ICONS =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIcons);
    private static final int MAX_DOTS = 1;
","    public final int MAX_ICONS_ON_LOCKSCREEN =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIconsOnLock);
    public final int MAX_STATIC_ICONS =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIcons);
    private static final int MAX_DOTS = 1;
","    public final int MAX_ICONS_ON_LOCKSCREEN =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIconsOnLock);
    public final int MAX_STATIC_ICONS =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIcons);
    private static final int MAX_DOTS = 1;
","[1.0, 1.0]"
1542,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(405, 456, 52), (405, 456, 52)]","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","[1.0, 1.0]"
1543,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(493, 496, 4), (493, 496, 4)]","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","[1.0, 1.0]"
1544,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(536, 541, 6), (536, 541, 6)]","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","[1.0, 1.0]"
1545,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(558, 562, 5), (558, 562, 5)]","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","[1.0, 1.0]"
1546,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(615, 618, 4), (615, 618, 4)]","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","[1.0, 1.0]"
1547,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(623, 629, 7), (623, 629, 7)]","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","[1.0, 1.0]"
1548,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(731, 734, 4), (731, 734, 4)]","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","[1.0, 1.0]"
1549,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(844, 850, 7), (844, 850, 7)]","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","[1.0, 1.0]"
1550,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1117, 1127, 11), (1117, 1127, 11)]","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","[1.0, 1.0]"
1551,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1292, 1295, 4), (1292, 1295, 4)]","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","[1.0, 1.0]"
1552,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1311, 1314, 4), (1311, 1314, 4)]","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","[1.0, 1.0]"
1553,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1360, 1363, 4), (1360, 1363, 4)]","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","[1.0, 1.0]"
1554,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1447, 1450, 4), (1447, 1450, 4)]","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","[1.0, 1.0]"
1555,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1490, 1494, 5), (1490, 1494, 5)]","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","[1.0, 1.0]"
1556,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1501, 1505, 5), (1501, 1505, 5)]","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","[1.0, 1.0]"
1557,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1512, 1516, 5), (1512, 1516, 5)]","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","[1.0, 1.0]"
1558,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1524, 1527, 4), (1524, 1527, 4)]","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","[1.0, 1.0]"
1559,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1535, 1539, 5), (1535, 1539, 5)]","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","[1.0, 1.0]"
1560,"['74a21b989f82a6a024f29085ad324e939472bed1', '1ab0b23a1d46b60a76015f090ada435f10bc9ecd']","['aospa-topaz-SAP-block_text', 'calyx-13-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManagerTest.java,"[(532, 535, 4), (532, 535, 4)]","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","[1.0, 1.0]"
1561,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanelController.java,"[(32, 34, 3), (34, 36, 3)]","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","[1.0, 1.0]"
1562,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/theme/ThemeOverlayController.java,"[(371, 374, 4), (380, 383, 4)]","            @Main Resources resources, WakefulnessLifecycle wakefulnessLifecycle,
            ConfigurationController configurationController) {
        super(context);

","            @Main Resources resources, WakefulnessLifecycle wakefulnessLifecycle,
            ConfigurationController configurationController) {
        super(context);

","            @Main Resources resources, WakefulnessLifecycle wakefulnessLifecycle,
            ConfigurationController configurationController) {
        super(context);

","[1.0, 1.0]"
1563,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",core/java/android/hardware/Camera.java,"[(338, 341, 4), (334, 337, 4)]","        if(cameraId >= getNumberOfCameras()){
            throw new RuntimeException(""Unknown camera ID"");
        }
        _getCameraInfo(cameraId, cameraInfo);
","        if (cameraId >= getNumberOfCameras()) {
            throw new RuntimeException(""Unknown camera ID"");
        }
        _getCameraInfo(cameraId, cameraInfo);
","{
            throw new RuntimeException(""Unknown camera ID"");
        }
        _getCameraInfo(cameraId, cameraInfo);
","[0.73, 0.721]"
1564,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/screenshot/ImageExporterTest.java,"[(100, 100, 1), (100, 100, 1)]","                exporter.export(DIRECT_EXECUTOR, requestId, original, CAPTURE_TIME, null);
","                exporter.export(DIRECT_EXECUTOR, requestId, original, CAPTURE_TIME, null);
","                exporter.export(DIRECT_EXECUTOR, requestId, original, CAPTURE_TIME, null);
","[1.0, 1.0]"
1565,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/customize/QSCustomizer.java,"[(80, 84, 5), (80, 84, 5)]","        SpannableString resetText = new SpannableString(
                mContext.getString(com.android.internal.R.string.reset));
        resetText.setSpan(new ForegroundColorSpan(isNightMode() ?
                Color.WHITE : Color.BLACK), 0, resetText.length(), 0);
        toolbar.getMenu().add(Menu.NONE, MENU_RESET, 0, resetText);
","        SpannableString resetText = new SpannableString(
                mContext.getString(com.android.internal.R.string.reset));
        resetText.setSpan(new ForegroundColorSpan(isNightMode() ?
                Color.WHITE : Color.BLACK), 0, resetText.length(), 0);
        toolbar.getMenu().add(Menu.NONE, MENU_RESET, 0, resetText);
","        SpannableString resetText = new SpannableString(
                mContext.getString(com.android.internal.R.string.reset));
        resetText.setSpan(new ForegroundColorSpan(isNightMode() ?
                Color.WHITE : Color.BLACK), 0, resetText.length(), 0);
        toolbar.getMenu().add(Menu.NONE, MENU_RESET, 0, resetText);
","[1.0, 1.0]"
1566,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",core/java/android/app/StatusBarManager.java,"[(233, 233, 1), (233, 233, 1)]","    public static final int CAMERA_LAUNCH_SOURCE_SCREEN_GESTURE = 3;
","    public static final int CAMERA_LAUNCH_SOURCE_SCREEN_GESTURE = 3;
","    public static final int CAMERA_LAUNCH_SOURCE_SCREEN_GESTURE = 3;
","[1.0, 1.0]"
1567,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/tuner/TunerActivity.java,"[(65, 73, 9), (69, 77, 9)]","            final Fragment fragment;
            if (""com.android.settings.action.DEMO_MODE"".equals(action)) {
                fragment = new DemoModeFragment(mDemoModeController);
            } else if (""com.android.settings.action.STATUS_BAR_TUNER"".equals(action)) {
                fragment = new StatusBarTuner();
            } else {
                fragment = new TunerFragment(mTunerService);
            }

","            final Fragment fragment;
            if (""com.android.settings.action.DEMO_MODE"".equals(action)) {
                fragment = new DemoModeFragment(mDemoModeController);
            } else if (""com.android.settings.action.STATUS_BAR_TUNER"".equals(action)) {
                fragment = new StatusBarTuner();
            } else {
                fragment = new TunerFragment(mTunerService);
            }

","            final Fragment fragment;
            if (""com.android.settings.action.DEMO_MODE"".equals(action)) {
                fragment = new DemoModeFragment(mDemoModeController);
            } else if (""com.android.settings.action.STATUS_BAR_TUNER"".equals(action)) {
                fragment = new StatusBarTuner();
            } else {
                fragment = new TunerFragment(mTunerService);
            }

","[1.0, 1.0]"
1568,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/screenshot/SaveImageInBackgroundTask.java,"[(136, 137, 2), (136, 137, 2)]","                    mImageExporter.export(Runnable::run, requestId, image,
                            params != null ? params[0] : null);
","                    mImageExporter.export(Runnable::run, requestId, image,
                            params != null ? params[0] : null);
","                    mImageExporter.export(Runnable::run, requestId, image,
                            params != null ? params[0] : null);
","[1.0, 1.0]"
1569,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"[(51, 51, 1), (51, 51, 1)]","import android.content.Context;
","import android.content.Context;
","import android.content.Context;
","[1.0, 1.0]"
1570,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"[(77, 77, 1), (77, 77, 1)]","import android.view.GestureDetector;
","import android.view.GestureDetector;
","import android.view.GestureDetector;
","[1.0, 1.0]"
1571,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/screenshot/LongScreenshotActivity.java,"[(391, 391, 1), (400, 400, 1)]","                mLongScreenshotHolder.getForegroundAppName());
","                mLongScreenshotHolder.getForegroundAppName());
","                mLongScreenshotHolder.getForegroundAppName());
","[1.0, 1.0]"
1572,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/screenshot/ImageExporter.java,"[(150, 151, 2), (150, 151, 2)]","            String foregroundAppName) {
        return export(executor, requestId, bitmap, ZonedDateTime.now(), foregroundAppName);
","            String foregroundAppName) {
        return export(executor, requestId, bitmap, ZonedDateTime.now(), foregroundAppName);
","            String foregroundAppName) {
        return export(executor, requestId, bitmap, ZonedDateTime.now(), foregroundAppName);
","[1.0, 1.0]"
1573,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/screenshot/ImageExporter.java,"[(164, 167, 4), (164, 167, 4)]","            ZonedDateTime captureTime, String foregroundAppName) {

        final Task task = new Task(mResolver, requestId, bitmap, captureTime, foregroundAppName,
                mCompressFormat, mQuality, /* publish */ true);
","            ZonedDateTime captureTime, String foregroundAppName) {

        final Task task = new Task(mResolver, requestId, bitmap, captureTime, foregroundAppName,
                mCompressFormat, mQuality, /* publish */ true);
","            ZonedDateTime captureTime, String foregroundAppName) {

        final Task task = new Task(mResolver, requestId, bitmap, captureTime, foregroundAppName,
                mCompressFormat, mQuality, /* publish */ true);
","[1.0, 1.0]"
1574,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/screenshot/ImageExporter.java,"[(240, 240, 1), (240, 240, 1)]","                String foregroundAppName, CompressFormat format, int quality, boolean publish) {
","                String foregroundAppName, CompressFormat format, int quality, boolean publish) {
","                String foregroundAppName, CompressFormat format, int quality, boolean publish) {
","[1.0, 1.0]"
1575,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/screenshot/ImageExporter.java,"[(247, 247, 1), (247, 247, 1)]","            mFileName = createFilename(mCaptureTime, mFormat, foregroundAppName);
","            mFileName = createFilename(mCaptureTime, mFormat, foregroundAppName);
","            mFileName = createFilename(mCaptureTime, mFormat, foregroundAppName);
","[1.0, 1.0]"
1576,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",services/core/java/com/android/server/media/MediaSessionRecord.java,"[(939, 940, 2), (939, 940, 2)]","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","[1.0, 1.0]"
1577,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationIconContainer.java,"[(143, 147, 5), (143, 147, 5)]","    public final int MAX_ICONS_ON_LOCKSCREEN =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIconsOnLock);
    public final int MAX_STATIC_ICONS =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIcons);
    private static final int MAX_DOTS = 1;
","    public final int MAX_ICONS_ON_LOCKSCREEN =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIconsOnLock);
    public final int MAX_STATIC_ICONS =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIcons);
    private static final int MAX_DOTS = 1;
","    public final int MAX_ICONS_ON_LOCKSCREEN =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIconsOnLock);
    public final int MAX_STATIC_ICONS =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIcons);
    private static final int MAX_DOTS = 1;
","[1.0, 1.0]"
1578,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(405, 456, 52), (405, 456, 52)]","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","[1.0, 1.0]"
1579,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(493, 496, 4), (493, 496, 4)]","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","[1.0, 1.0]"
1580,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(536, 541, 6), (536, 541, 6)]","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","[1.0, 1.0]"
1581,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(558, 562, 5), (558, 562, 5)]","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","[1.0, 1.0]"
1582,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(615, 618, 4), (615, 618, 4)]","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","[1.0, 1.0]"
1583,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(623, 629, 7), (623, 629, 7)]","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","[1.0, 1.0]"
1584,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(731, 734, 4), (731, 734, 4)]","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","[1.0, 1.0]"
1585,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(844, 850, 7), (844, 850, 7)]","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","[1.0, 1.0]"
1586,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1117, 1127, 11), (1117, 1127, 11)]","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","[1.0, 1.0]"
1587,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1292, 1295, 4), (1292, 1295, 4)]","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","[1.0, 1.0]"
1588,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1311, 1314, 4), (1311, 1314, 4)]","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","[1.0, 1.0]"
1589,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1360, 1363, 4), (1360, 1363, 4)]","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","[1.0, 1.0]"
1590,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1447, 1450, 4), (1447, 1450, 4)]","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","[1.0, 1.0]"
1591,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1490, 1494, 5), (1490, 1494, 5)]","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","[1.0, 1.0]"
1592,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1501, 1505, 5), (1501, 1505, 5)]","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","[1.0, 1.0]"
1593,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1512, 1516, 5), (1512, 1516, 5)]","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","[1.0, 1.0]"
1594,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1524, 1527, 4), (1524, 1527, 4)]","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","[1.0, 1.0]"
1595,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1535, 1539, 5), (1535, 1539, 5)]","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","[1.0, 1.0]"
1596,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManagerTest.java,"[(532, 535, 4), (532, 535, 4)]","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","[1.0, 1.0]"
1597,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/ScrimState.java,"[(122, 122, 1), (122, 122, 1)]","            mBehindTint = Color.TRANSPARENT;
","            mBehindTint = Color.TRANSPARENT;
","            mBehindTint = Color.TRANSPARENT;
","[1.0, 1.0]"
1598,"['74a21b989f82a6a024f29085ad324e939472bed1', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['aospa-topaz-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/ScrimState.java,"[(152, 157, 6), (152, 157, 6)]","
        // to make sure correct color is returned before ""prepare"" is called
        @Override
        public int getBehindTint() {
            return Color.TRANSPARENT;
        }
","
        // to make sure correct color is returned before ""prepare"" is called
        @Override
        public int getBehindTint() {
            return Color.TRANSPARENT;
        }
","
        // to make sure correct color is returned before ""prepare"" is called
        @Override
        public int getBehindTint() {
            return Color.TRANSPARENT;
        }
","[1.0, 1.0]"
1599,"['74a21b989f82a6a024f29085ad324e939472bed1', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",core/java/android/hardware/camera2/CameraManager.java,"[(26, 26, 1), (24, 24, 1)]","import android.app.ActivityThread;
","import android.app.ActivityThread;
","import android.app.ActivityThread;
","[1.0, 1.0]"
1600,"['74a21b989f82a6a024f29085ad324e939472bed1', 'b6292e3e1ba3616eac1032737a91925391d94b92']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java,"[(1821, 1823, 3), (1292, 1293, 2)]","                mUpdateMonitor.setKeyguardOccluded(isOccluded);
                mKeyguardViewControllerLazy.get().setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
","                mStatusBarKeyguardViewManagerLazy.get().setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
","erLazy.get().setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
","[0.577, 0.762]"
1601,"['74a21b989f82a6a024f29085ad324e939472bed1', 'edb6252578f9b76151e5125a7fb1b16823a68418']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java,"[(1821, 1823, 3), (1256, 1257, 2)]","                mUpdateMonitor.setKeyguardOccluded(isOccluded);
                mKeyguardViewControllerLazy.get().setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
","                mStatusBarKeyguardViewManager.setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
",".setOccluded(isOccluded,
                        (Dependency.get(KeyguardUpdateMonitor.class).isSimPinSecure()?false:animate)
","[0.527, 0.737]"
1602,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanelController.java,"[(32, 34, 3), (32, 34, 3)]","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","[1.0, 1.0]"
1603,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",services/core/java/com/android/server/media/MediaSessionRecord.java,"[(939, 940, 2), (939, 940, 2)]","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","[1.0, 1.0]"
1604,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(405, 456, 52), (405, 456, 52)]","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","[1.0, 1.0]"
1605,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(493, 496, 4), (493, 496, 4)]","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","[1.0, 1.0]"
1606,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(536, 541, 6), (536, 541, 6)]","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","[1.0, 1.0]"
1607,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(558, 562, 5), (558, 562, 5)]","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","[1.0, 1.0]"
1608,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(615, 618, 4), (615, 618, 4)]","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","[1.0, 1.0]"
1609,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(623, 629, 7), (623, 629, 7)]","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","[1.0, 1.0]"
1610,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(731, 734, 4), (731, 734, 4)]","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","[1.0, 1.0]"
1611,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(844, 850, 7), (844, 850, 7)]","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","[1.0, 1.0]"
1612,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1117, 1127, 11), (1117, 1127, 11)]","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","[1.0, 1.0]"
1613,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1292, 1295, 4), (1292, 1295, 4)]","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","[1.0, 1.0]"
1614,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1311, 1314, 4), (1311, 1314, 4)]","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","[1.0, 1.0]"
1615,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1360, 1363, 4), (1360, 1363, 4)]","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","[1.0, 1.0]"
1616,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1447, 1450, 4), (1447, 1450, 4)]","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","[1.0, 1.0]"
1617,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1490, 1494, 5), (1490, 1494, 5)]","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","[1.0, 1.0]"
1618,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1501, 1505, 5), (1501, 1505, 5)]","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","[1.0, 1.0]"
1619,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1512, 1516, 5), (1512, 1516, 5)]","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","[1.0, 1.0]"
1620,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1524, 1527, 4), (1524, 1527, 4)]","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","[1.0, 1.0]"
1621,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1535, 1539, 5), (1535, 1539, 5)]","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","[1.0, 1.0]"
1622,"['74a21b989f82a6a024f29085ad324e939472bed1', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['aospa-topaz-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManagerTest.java,"[(532, 535, 4), (532, 535, 4)]","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","[1.0, 1.0]"
1623,"['af01b38e0a0664bc87b649248b0c13fbe0925193', 'af01b38e0a0664bc87b649248b0c13fbe0925193']","['aospa-topaz-SAP-block_text', 'omnirom-11-SAP-block_text']",services/usb/java/com/android/server/usb/UsbDeviceManager.java,"[(1346, 1350, 5), (1346, 1350, 5)]","        private String getChargingFunctions() {
            String func = SystemProperties.get(getPersistProp(true),
                    UsbManager.USB_FUNCTION_NONE);
            if (UsbManager.USB_FUNCTION_NONE.equals(func)) {
                func = UsbManager.USB_FUNCTION_MTP;
","        private String getChargingFunctions() {
            String func = SystemProperties.get(getPersistProp(true),
                    UsbManager.USB_FUNCTION_NONE);
            if (UsbManager.USB_FUNCTION_NONE.equals(func)) {
                func = UsbManager.USB_FUNCTION_MTP;
","        private String getChargingFunctions() {
            String func = SystemProperties.get(getPersistProp(true),
                    UsbManager.USB_FUNCTION_NONE);
            if (UsbManager.USB_FUNCTION_NONE.equals(func)) {
                func = UsbManager.USB_FUNCTION_MTP;
","[1.0, 1.0]"
1624,"['c5b9da0f6b5ab4da9e1ee4b8dfb3de427cdac2d9', 'd274c33a679b96f638f6b6d14abb2472dd3fc2ac']","['calyx-11-SAP-block_text', 'lineage-18.1-SAP-block_text']",core/java/com/android/internal/app/ChooserActivity.java,"[(2828, 2828, 1), (2828, 2828, 1)]","        return ChooserGridAdapter.MAX_TARGETS_PER_ROW_LANDSCAPE;
","        return ChooserGridAdapter.MAX_TARGETS_PER_ROW_LANDSCAPE;
","        return ChooserGridAdapter.MAX_TARGETS_PER_ROW_LANDSCAPE;
","[1.0, 1.0]"
1625,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java,"[(62, 64, 3), (62, 64, 3)]","    private boolean mScramblePin;

    private List<Integer> mNumbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 0);
","    private boolean mScramblePin;

    private List<Integer> mNumbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 0);
","    private boolean mScramblePin;

    private List<Integer> mNumbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 0);
","[1.0, 1.0]"
1626,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",services/appwidget/java/com/android/server/appwidget/AppWidgetXmlUtil.java,"[(96, 96, 1), (96, 96, 1)]","        out.attribute(null, ATTR_OS_FINGERPRINT, Build.VERSION.INCREMENTAL);
","        out.attribute(null, ATTR_OS_FINGERPRINT, Build.VERSION.INCREMENTAL);
","        out.attribute(null, ATTR_OS_FINGERPRINT, Build.VERSION.INCREMENTAL);
","[1.0, 1.0]"
1627,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QuickStatusBarHeader.java,"[(282, 284, 3), (300, 302, 3)]","        qqsLP.topMargin = largeScreenHeaderActive || !mUseCombinedQSHeader
                ? mContext.getResources().getDimensionPixelSize(R.dimen.qqs_layout_margin_top)
                : SystemBarUtils.getQuickQsOffsetHeight(mContext);
","        qqsLP.topMargin = largeScreenHeaderActive || !mUseCombinedQSHeader
                ? mContext.getResources().getDimensionPixelSize(R.dimen.qqs_layout_margin_top)
                : SystemBarUtils.getQuickQsOffsetHeight(mContext);
","        qqsLP.topMargin = largeScreenHeaderActive || !mUseCombinedQSHeader
                ? mContext.getResources().getDimensionPixelSize(R.dimen.qqs_layout_margin_top)
                : SystemBarUtils.getQuickQsOffsetHeight(mContext);
","[1.0, 1.0]"
1628,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManagerTest.java,"[(532, 535, 4), (532, 535, 4)]","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","[1.0, 1.0]"
1629,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",services/core/java/com/android/server/media/MediaSessionRecord.java,"[(939, 940, 2), (939, 940, 2)]","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","[1.0, 1.0]"
1630,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",services/core/java/com/android/server/statusbar/StatusBarManagerService.java,"[(2161, 2167, 7), (2158, 2164, 7)]","    @Override
    public void startAssist(Bundle args) {
        enforceStatusBarService();
        if (mBar != null) {
            try {
                mBar.startAssist(args);
            } catch (RemoteException ex) {
","    @Override
    public void startAssist(Bundle args) {
        enforceStatusBarService();
        if (mBar != null) {
            try {
                mBar.startAssist(args);
            } catch (RemoteException ex) {
","    @Override
    public void startAssist(Bundle args) {
        enforceStatusBarService();
        if (mBar != null) {
            try {
                mBar.startAssist(args);
            } catch (RemoteException ex) {
","[1.0, 1.0]"
1631,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",core/java/android/hardware/Camera.java,"[(334, 337, 4), (334, 337, 4)]","        if (cameraId >= getNumberOfCameras()) {
            throw new RuntimeException(""Unknown camera ID"");
        }
        _getCameraInfo(cameraId, cameraInfo);
","        if (cameraId >= getNumberOfCameras()) {
            throw new RuntimeException(""Unknown camera ID"");
        }
        _getCameraInfo(cameraId, cameraInfo);
","        if (cameraId >= getNumberOfCameras()) {
            throw new RuntimeException(""Unknown camera ID"");
        }
        _getCameraInfo(cameraId, cameraInfo);
","[1.0, 1.0]"
1632,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/screenshot/ScreenshotView.java,"[(783, 784, 2), (783, 784, 2)]","            startSharedTransition(
                    imageData.viewTransition.get());
","            startSharedTransition(
                    imageData.viewTransition.get());
","            startSharedTransition(
                    imageData.viewTransition.get());
","[1.0, 1.0]"
1633,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanelController.java,"[(32, 34, 3), (34, 36, 3)]","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","[1.0, 1.0]"
1634,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",core/java/android/app/StatusBarManager.java,"[(233, 233, 1), (233, 233, 1)]","    public static final int CAMERA_LAUNCH_SOURCE_SCREEN_GESTURE = 3;
","    public static final int CAMERA_LAUNCH_SOURCE_SCREEN_GESTURE = 3;
","    public static final int CAMERA_LAUNCH_SOURCE_SCREEN_GESTURE = 3;
","[1.0, 1.0]"
1635,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(405, 456, 52), (405, 456, 52)]","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","[1.0, 1.0]"
1636,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(493, 496, 4), (493, 496, 4)]","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","[1.0, 1.0]"
1637,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(536, 541, 6), (536, 541, 6)]","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","[1.0, 1.0]"
1638,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(558, 562, 5), (558, 562, 5)]","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","[1.0, 1.0]"
1639,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(615, 618, 4), (615, 618, 4)]","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","[1.0, 1.0]"
1640,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(623, 629, 7), (623, 629, 7)]","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","[1.0, 1.0]"
1641,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(731, 734, 4), (731, 734, 4)]","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","[1.0, 1.0]"
1642,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(844, 850, 7), (844, 850, 7)]","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","[1.0, 1.0]"
1643,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1117, 1127, 11), (1117, 1127, 11)]","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","[1.0, 1.0]"
1644,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1292, 1295, 4), (1292, 1295, 4)]","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","[1.0, 1.0]"
1645,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1311, 1314, 4), (1311, 1314, 4)]","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","[1.0, 1.0]"
1646,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1360, 1363, 4), (1360, 1363, 4)]","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","[1.0, 1.0]"
1647,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1447, 1450, 4), (1447, 1450, 4)]","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","[1.0, 1.0]"
1648,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1490, 1494, 5), (1490, 1494, 5)]","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","[1.0, 1.0]"
1649,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1501, 1505, 5), (1501, 1505, 5)]","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","[1.0, 1.0]"
1650,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1512, 1516, 5), (1512, 1516, 5)]","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","[1.0, 1.0]"
1651,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1524, 1527, 4), (1524, 1527, 4)]","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","[1.0, 1.0]"
1652,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1535, 1539, 5), (1535, 1539, 5)]","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","[1.0, 1.0]"
1653,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"[(51, 51, 1), (51, 51, 1)]","import android.content.Context;
","import android.content.Context;
","import android.content.Context;
","[1.0, 1.0]"
1654,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"[(77, 77, 1), (77, 77, 1)]","import android.view.GestureDetector;
","import android.view.GestureDetector;
","import android.view.GestureDetector;
","[1.0, 1.0]"
1655,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"[(298, 319, 22), (298, 319, 22)]","    private final NotificationIconAreaController mNotificationIconAreaController;

    /**
     * Maximum time before which we will expand the panel even for slow motions when getting a
     * touch passed over from launcher.
     */
    private static final int MAX_TIME_TO_OPEN_WHEN_FLINGING_FROM_LAUNCHER = 300;

    private static final int MAX_DOWN_EVENT_BUFFER_SIZE = 50;

    private static final String COUNTER_PANEL_OPEN = ""panel_open"";
    private static final String COUNTER_PANEL_OPEN_QS = ""panel_open_qs"";
    private static final String COUNTER_PANEL_OPEN_PEEK = ""panel_open_peek"";

    private static final String STATUS_BAR_QUICK_QS_PULLDOWN =
            ""lineagesystem:"" + LineageSettings.System.STATUS_BAR_QUICK_QS_PULLDOWN;
    private static final String DOUBLE_TAP_SLEEP_GESTURE =
            ""lineagesystem:"" + LineageSettings.System.DOUBLE_TAP_SLEEP_GESTURE;

    private static final Rect M_DUMMY_DIRTY_RECT = new Rect(0, 0, 1, 1);
    private static final Rect EMPTY_RECT = new Rect();

","    private final NotificationIconAreaController mNotificationIconAreaController;

    /**
     * Maximum time before which we will expand the panel even for slow motions when getting a
     * touch passed over from launcher.
     */
    private static final int MAX_TIME_TO_OPEN_WHEN_FLINGING_FROM_LAUNCHER = 300;

    private static final int MAX_DOWN_EVENT_BUFFER_SIZE = 50;

    private static final String COUNTER_PANEL_OPEN = ""panel_open"";
    private static final String COUNTER_PANEL_OPEN_QS = ""panel_open_qs"";
    private static final String COUNTER_PANEL_OPEN_PEEK = ""panel_open_peek"";

    private static final String STATUS_BAR_QUICK_QS_PULLDOWN =
            ""lineagesystem:"" + LineageSettings.System.STATUS_BAR_QUICK_QS_PULLDOWN;
    private static final String DOUBLE_TAP_SLEEP_GESTURE =
            ""lineagesystem:"" + LineageSettings.System.DOUBLE_TAP_SLEEP_GESTURE;

    private static final Rect M_DUMMY_DIRTY_RECT = new Rect(0, 0, 1, 1);
    private static final Rect EMPTY_RECT = new Rect();

","    private final NotificationIconAreaController mNotificationIconAreaController;

    /**
     * Maximum time before which we will expand the panel even for slow motions when getting a
     * touch passed over from launcher.
     */
    private static final int MAX_TIME_TO_OPEN_WHEN_FLINGING_FROM_LAUNCHER = 300;

    private static final int MAX_DOWN_EVENT_BUFFER_SIZE = 50;

    private static final String COUNTER_PANEL_OPEN = ""panel_open"";
    private static final String COUNTER_PANEL_OPEN_QS = ""panel_open_qs"";
    private static final String COUNTER_PANEL_OPEN_PEEK = ""panel_open_peek"";

    private static final String STATUS_BAR_QUICK_QS_PULLDOWN =
            ""lineagesystem:"" + LineageSettings.System.STATUS_BAR_QUICK_QS_PULLDOWN;
    private static final String DOUBLE_TAP_SLEEP_GESTURE =
            ""lineagesystem:"" + LineageSettings.System.DOUBLE_TAP_SLEEP_GESTURE;

    private static final Rect M_DUMMY_DIRTY_RECT = new Rect(0, 0, 1, 1);
    private static final Rect EMPTY_RECT = new Rect();

","[1.0, 1.0]"
1656,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"[(358, 360, 3), (358, 360, 3)]","
    private final TunerService mTunerService;

","
    private final TunerService mTunerService;

","
    private final TunerService mTunerService;

","[1.0, 1.0]"
1657,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"[(797, 815, 19), (797, 815, 19)]","            TunerService tunerService,
            Context context) {
        super(view,
                falsingManager,
                dozeLog,
                keyguardStateController,
                (SysuiStatusBarStateController) statusBarStateController,
                notificationShadeWindowController,
                vibratorHelper,
                statusBarKeyguardViewManager,
                latencyTracker,
                flingAnimationUtilsBuilder.get(),
                statusBarTouchableRegionManager,
                lockscreenGestureLogger,
                panelExpansionStateManager,
                ambientState,
                interactionJankMonitor,
                shadeLogger,
                systemClock);
","            TunerService tunerService,
            Context context) {
        super(view,
                falsingManager,
                dozeLog,
                keyguardStateController,
                (SysuiStatusBarStateController) statusBarStateController,
                notificationShadeWindowController,
                vibratorHelper,
                statusBarKeyguardViewManager,
                latencyTracker,
                flingAnimationUtilsBuilder.get(),
                statusBarTouchableRegionManager,
                lockscreenGestureLogger,
                panelExpansionStateManager,
                ambientState,
                interactionJankMonitor,
                shadeLogger,
                systemClock);
","            TunerService tunerService,
            Context context) {
        super(view,
                falsingManager,
                dozeLog,
                keyguardStateController,
                (SysuiStatusBarStateController) statusBarStateController,
                notificationShadeWindowController,
                vibratorHelper,
                statusBarKeyguardViewManager,
                latencyTracker,
                flingAnimationUtilsBuilder.get(),
                statusBarTouchableRegionManager,
                lockscreenGestureLogger,
                panelExpansionStateManager,
                ambientState,
                interactionJankMonitor,
                shadeLogger,
                systemClock);
","[1.0, 1.0]"
1658,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"[(4216, 4394, 179), (4216, 4394, 179)]","    @Override
    protected OnLayoutChangeListener createLayoutChangeListener() {
        return new OnLayoutChangeListenerImpl();
    }

    @Override
    protected TouchHandler createTouchHandler() {
        return new TouchHandler() {

            private long mLastTouchDownTime = -1L;

            @Override
            public boolean onInterceptTouchEvent(MotionEvent event) {
                if (SPEW_LOGCAT) {
                    Log.v(TAG,
                            ""NPVC onInterceptTouchEvent ("" + event.getId() + ""): ("" + event.getX()
                                    + "","" + event.getY() + "")"");
                }
                if (mBlockTouches || mQs.disallowPanelTouches()) {
                    return false;
                }
                initDownStates(event);
                // Do not let touches go to shade or QS if the bouncer is visible,
                // but still let user swipe down to expand the panel, dismissing the bouncer.
                if (mCentralSurfaces.isBouncerShowing()) {
                    return true;
                }
                if (mCommandQueue.panelsEnabled()
                        && !mNotificationStackScrollLayoutController.isLongPressInProgress()
                        && mHeadsUpTouchHelper.onInterceptTouchEvent(event)) {
                    mMetricsLogger.count(COUNTER_PANEL_OPEN, 1);
                    mMetricsLogger.count(COUNTER_PANEL_OPEN_PEEK, 1);
                    return true;
                }
                if (!shouldQuickSettingsIntercept(mDownX, mDownY, 0)
                        && mPulseExpansionHandler.onInterceptTouchEvent(event)) {
                    return true;
                }

                if (!isFullyCollapsed() && onQsIntercept(event)) {
                    if (DEBUG_LOGCAT) Log.d(TAG, ""onQsIntercept true"");
                    return true;
                }
                return super.onInterceptTouchEvent(event);
            }

            @Override
            public boolean onTouch(View v, MotionEvent event) {
                if (event.getAction() == MotionEvent.ACTION_DOWN) {
                    if (event.getDownTime() == mLastTouchDownTime) {
                        // An issue can occur when swiping down after unlock, where multiple down
                        // events are received in this handler with identical downTimes. Until the
                        // source of the issue can be located, detect this case and ignore.
                        // see b/193350347
                        Log.w(TAG, ""Duplicate down event detected... ignoring"");
                        return true;
                    }
                    mLastTouchDownTime = event.getDownTime();
                }


                if (mBlockTouches || (mQsFullyExpanded && mQs != null
                        && mQs.disallowPanelTouches())) {
                    return false;
                }

                // Do not allow panel expansion if bouncer is scrimmed or showing over a dream,
                // otherwise user would be able to pull down QS or expand the shade.
                if (mCentralSurfaces.isBouncerShowingScrimmed()
                        || mCentralSurfaces.isBouncerShowingOverDream()) {
                    return false;
                }

                if (mDoubleTapToSleepEnabled && !mPulsing && !mDozing) {
                    mDoubleTapGesture.onTouchEvent(event);
                }

                // Make sure the next touch won't the blocked after the current ends.
                if (event.getAction() == MotionEvent.ACTION_UP
                        || event.getAction() == MotionEvent.ACTION_CANCEL) {
                    mBlockingExpansionForCurrentTouch = false;
                }
                // When touch focus transfer happens, ACTION_DOWN->ACTION_UP may happen immediately
                // without any ACTION_MOVE event.
                // In such case, simply expand the panel instead of being stuck at the bottom bar.
                if (mLastEventSynthesizedDown && event.getAction() == MotionEvent.ACTION_UP) {
                    expand(true /* animate */);
                }
                initDownStates(event);

                // If pulse is expanding already, let's give it the touch. There are situations
                // where the panel starts expanding even though we're also pulsing
                boolean pulseShouldGetTouch = (!mIsExpanding
                        && !shouldQuickSettingsIntercept(mDownX, mDownY, 0))
                        || mPulseExpansionHandler.isExpanding();
                if (pulseShouldGetTouch && mPulseExpansionHandler.onTouchEvent(event)) {
                    // We're expanding all the other ones shouldn't get this anymore
                    mShadeLog.logMotionEvent(event, ""onTouch: PulseExpansionHandler handled event"");
                    return true;
                }
                if (mListenForHeadsUp && !mHeadsUpTouchHelper.isTrackingHeadsUp()
                        && !mNotificationStackScrollLayoutController.isLongPressInProgress()
                        && mHeadsUpTouchHelper.onInterceptTouchEvent(event)) {
                    mMetricsLogger.count(COUNTER_PANEL_OPEN_PEEK, 1);
                }
                boolean handled = mHeadsUpTouchHelper.onTouchEvent(event);

                if (!mHeadsUpTouchHelper.isTrackingHeadsUp() && handleQsTouch(event)) {
                    mShadeLog.logMotionEvent(event, ""onTouch: handleQsTouch handled event"");
                    return true;
                }
                if (event.getActionMasked() == MotionEvent.ACTION_DOWN && isFullyCollapsed()) {
                    mMetricsLogger.count(COUNTER_PANEL_OPEN, 1);
                    handled = true;
                }

                if (event.getActionMasked() == MotionEvent.ACTION_DOWN && isFullyExpanded()
                        && mStatusBarKeyguardViewManager.isShowing()) {
                    mStatusBarKeyguardViewManager.updateKeyguardPosition(event.getX());
                }

                handled |= super.onTouch(v, event);
                return !mDozing || mPulsing || handled;
            }
        };
    }

    private final PhoneStatusBarView.TouchEventHandler mStatusBarViewTouchEventHandler =
            new PhoneStatusBarView.TouchEventHandler() {
                @Override
                public void onInterceptTouchEvent(MotionEvent event) {
                    mCentralSurfaces.onTouchEvent(event);
                }

                @Override
                public boolean handleTouchEvent(MotionEvent event) {
                    mCentralSurfaces.onTouchEvent(event);

                    // TODO(b/202981994): Move the touch debugging in this method to a central
                    //  location. (Right now, it's split between CentralSurfaces and here.)

                    // If panels aren't enabled, ignore the gesture and don't pass it down to the
                    // panel view.
                    if (!mCommandQueue.panelsEnabled()) {
                        if (event.getAction() == MotionEvent.ACTION_DOWN) {
                            Log.v(
                                    TAG,
                                    String.format(
                                            ""onTouchForwardedFromStatusBar: ""
                                                    + ""panel disabled, ignoring touch at (%d,%d)"",
                                            (int) event.getX(),
                                            (int) event.getY()
                                    )
                            );
                        }
                        return false;
                    }

                    // If the view that would receive the touch is disabled, just have status bar
                    // eat the gesture.
                    if (event.getAction() == MotionEvent.ACTION_DOWN && !mView.isEnabled()) {
                        Log.v(TAG,
                                String.format(
                                        ""onTouchForwardedFromStatusBar: ""
                                                + ""panel view disabled, eating touch at (%d,%d)"",
                                        (int) event.getX(),
                                        (int) event.getY()
                                )
                        );
                        return true;
                    }

                    return mView.dispatchTouchEvent(event);
                }
            };

    @Override
    protected OnConfigurationChangedListener createOnConfigurationChangedListener() {
        return new OnConfigurationChangedListener();
","    @Override
    protected OnLayoutChangeListener createLayoutChangeListener() {
        return new OnLayoutChangeListenerImpl();
    }

    @Override
    protected TouchHandler createTouchHandler() {
        return new TouchHandler() {

            private long mLastTouchDownTime = -1L;

            @Override
            public boolean onInterceptTouchEvent(MotionEvent event) {
                if (SPEW_LOGCAT) {
                    Log.v(TAG,
                            ""NPVC onInterceptTouchEvent ("" + event.getId() + ""): ("" + event.getX()
                                    + "","" + event.getY() + "")"");
                }
                if (mBlockTouches || mQs.disallowPanelTouches()) {
                    return false;
                }
                initDownStates(event);
                // Do not let touches go to shade or QS if the bouncer is visible,
                // but still let user swipe down to expand the panel, dismissing the bouncer.
                if (mCentralSurfaces.isBouncerShowing()) {
                    return true;
                }
                if (mCommandQueue.panelsEnabled()
                        && !mNotificationStackScrollLayoutController.isLongPressInProgress()
                        && mHeadsUpTouchHelper.onInterceptTouchEvent(event)) {
                    mMetricsLogger.count(COUNTER_PANEL_OPEN, 1);
                    mMetricsLogger.count(COUNTER_PANEL_OPEN_PEEK, 1);
                    return true;
                }
                if (!shouldQuickSettingsIntercept(mDownX, mDownY, 0)
                        && mPulseExpansionHandler.onInterceptTouchEvent(event)) {
                    return true;
                }

                if (!isFullyCollapsed() && onQsIntercept(event)) {
                    if (DEBUG_LOGCAT) Log.d(TAG, ""onQsIntercept true"");
                    return true;
                }
                return super.onInterceptTouchEvent(event);
            }

            @Override
            public boolean onTouch(View v, MotionEvent event) {
                if (event.getAction() == MotionEvent.ACTION_DOWN) {
                    if (event.getDownTime() == mLastTouchDownTime) {
                        // An issue can occur when swiping down after unlock, where multiple down
                        // events are received in this handler with identical downTimes. Until the
                        // source of the issue can be located, detect this case and ignore.
                        // see b/193350347
                        Log.w(TAG, ""Duplicate down event detected... ignoring"");
                        return true;
                    }
                    mLastTouchDownTime = event.getDownTime();
                }


                if (mBlockTouches || (mQsFullyExpanded && mQs != null
                        && mQs.disallowPanelTouches())) {
                    return false;
                }

                // Do not allow panel expansion if bouncer is scrimmed or showing over a dream,
                // otherwise user would be able to pull down QS or expand the shade.
                if (mCentralSurfaces.isBouncerShowingScrimmed()
                        || mCentralSurfaces.isBouncerShowingOverDream()) {
                    return false;
                }

                if (mDoubleTapToSleepEnabled && !mPulsing && !mDozing) {
                    mDoubleTapGesture.onTouchEvent(event);
                }

                // Make sure the next touch won't the blocked after the current ends.
                if (event.getAction() == MotionEvent.ACTION_UP
                        || event.getAction() == MotionEvent.ACTION_CANCEL) {
                    mBlockingExpansionForCurrentTouch = false;
                }
                // When touch focus transfer happens, ACTION_DOWN->ACTION_UP may happen immediately
                // without any ACTION_MOVE event.
                // In such case, simply expand the panel instead of being stuck at the bottom bar.
                if (mLastEventSynthesizedDown && event.getAction() == MotionEvent.ACTION_UP) {
                    expand(true /* animate */);
                }
                initDownStates(event);

                // If pulse is expanding already, let's give it the touch. There are situations
                // where the panel starts expanding even though we're also pulsing
                boolean pulseShouldGetTouch = (!mIsExpanding
                        && !shouldQuickSettingsIntercept(mDownX, mDownY, 0))
                        || mPulseExpansionHandler.isExpanding();
                if (pulseShouldGetTouch && mPulseExpansionHandler.onTouchEvent(event)) {
                    // We're expanding all the other ones shouldn't get this anymore
                    mShadeLog.logMotionEvent(event, ""onTouch: PulseExpansionHandler handled event"");
                    return true;
                }
                if (mListenForHeadsUp && !mHeadsUpTouchHelper.isTrackingHeadsUp()
                        && !mNotificationStackScrollLayoutController.isLongPressInProgress()
                        && mHeadsUpTouchHelper.onInterceptTouchEvent(event)) {
                    mMetricsLogger.count(COUNTER_PANEL_OPEN_PEEK, 1);
                }
                boolean handled = mHeadsUpTouchHelper.onTouchEvent(event);

                if (!mHeadsUpTouchHelper.isTrackingHeadsUp() && handleQsTouch(event)) {
                    mShadeLog.logMotionEvent(event, ""onTouch: handleQsTouch handled event"");
                    return true;
                }
                if (event.getActionMasked() == MotionEvent.ACTION_DOWN && isFullyCollapsed()) {
                    mMetricsLogger.count(COUNTER_PANEL_OPEN, 1);
                    handled = true;
                }

                if (event.getActionMasked() == MotionEvent.ACTION_DOWN && isFullyExpanded()
                        && mStatusBarKeyguardViewManager.isShowing()) {
                    mStatusBarKeyguardViewManager.updateKeyguardPosition(event.getX());
                }

                handled |= super.onTouch(v, event);
                return !mDozing || mPulsing || handled;
            }
        };
    }

    private final PhoneStatusBarView.TouchEventHandler mStatusBarViewTouchEventHandler =
            new PhoneStatusBarView.TouchEventHandler() {
                @Override
                public void onInterceptTouchEvent(MotionEvent event) {
                    mCentralSurfaces.onTouchEvent(event);
                }

                @Override
                public boolean handleTouchEvent(MotionEvent event) {
                    mCentralSurfaces.onTouchEvent(event);

                    // TODO(b/202981994): Move the touch debugging in this method to a central
                    //  location. (Right now, it's split between CentralSurfaces and here.)

                    // If panels aren't enabled, ignore the gesture and don't pass it down to the
                    // panel view.
                    if (!mCommandQueue.panelsEnabled()) {
                        if (event.getAction() == MotionEvent.ACTION_DOWN) {
                            Log.v(
                                    TAG,
                                    String.format(
                                            ""onTouchForwardedFromStatusBar: ""
                                                    + ""panel disabled, ignoring touch at (%d,%d)"",
                                            (int) event.getX(),
                                            (int) event.getY()
                                    )
                            );
                        }
                        return false;
                    }

                    // If the view that would receive the touch is disabled, just have status bar
                    // eat the gesture.
                    if (event.getAction() == MotionEvent.ACTION_DOWN && !mView.isEnabled()) {
                        Log.v(TAG,
                                String.format(
                                        ""onTouchForwardedFromStatusBar: ""
                                                + ""panel view disabled, eating touch at (%d,%d)"",
                                        (int) event.getX(),
                                        (int) event.getY()
                                )
                        );
                        return true;
                    }

                    return mView.dispatchTouchEvent(event);
                }
            };

    @Override
    protected OnConfigurationChangedListener createOnConfigurationChangedListener() {
        return new OnConfigurationChangedListener();
","    @Override
    protected OnLayoutChangeListener createLayoutChangeListener() {
        return new OnLayoutChangeListenerImpl();
    }

    @Override
    protected TouchHandler createTouchHandler() {
        return new TouchHandler() {

            private long mLastTouchDownTime = -1L;

            @Override
            public boolean onInterceptTouchEvent(MotionEvent event) {
                if (SPEW_LOGCAT) {
                    Log.v(TAG,
                            ""NPVC onInterceptTouchEvent ("" + event.getId() + ""): ("" + event.getX()
                                    + "","" + event.getY() + "")"");
                }
                if (mBlockTouches || mQs.disallowPanelTouches()) {
                    return false;
                }
                initDownStates(event);
                // Do not let touches go to shade or QS if the bouncer is visible,
                // but still let user swipe down to expand the panel, dismissing the bouncer.
                if (mCentralSurfaces.isBouncerShowing()) {
                    return true;
                }
                if (mCommandQueue.panelsEnabled()
                        && !mNotificationStackScrollLayoutController.isLongPressInProgress()
                        && mHeadsUpTouchHelper.onInterceptTouchEvent(event)) {
                    mMetricsLogger.count(COUNTER_PANEL_OPEN, 1);
                    mMetricsLogger.count(COUNTER_PANEL_OPEN_PEEK, 1);
                    return true;
                }
                if (!shouldQuickSettingsIntercept(mDownX, mDownY, 0)
                        && mPulseExpansionHandler.onInterceptTouchEvent(event)) {
                    return true;
                }

                if (!isFullyCollapsed() && onQsIntercept(event)) {
                    if (DEBUG_LOGCAT) Log.d(TAG, ""onQsIntercept true"");
                    return true;
                }
                return super.onInterceptTouchEvent(event);
            }

            @Override
            public boolean onTouch(View v, MotionEvent event) {
                if (event.getAction() == MotionEvent.ACTION_DOWN) {
                    if (event.getDownTime() == mLastTouchDownTime) {
                        // An issue can occur when swiping down after unlock, where multiple down
                        // events are received in this handler with identical downTimes. Until the
                        // source of the issue can be located, detect this case and ignore.
                        // see b/193350347
                        Log.w(TAG, ""Duplicate down event detected... ignoring"");
                        return true;
                    }
                    mLastTouchDownTime = event.getDownTime();
                }


                if (mBlockTouches || (mQsFullyExpanded && mQs != null
                        && mQs.disallowPanelTouches())) {
                    return false;
                }

                // Do not allow panel expansion if bouncer is scrimmed or showing over a dream,
                // otherwise user would be able to pull down QS or expand the shade.
                if (mCentralSurfaces.isBouncerShowingScrimmed()
                        || mCentralSurfaces.isBouncerShowingOverDream()) {
                    return false;
                }

                if (mDoubleTapToSleepEnabled && !mPulsing && !mDozing) {
                    mDoubleTapGesture.onTouchEvent(event);
                }

                // Make sure the next touch won't the blocked after the current ends.
                if (event.getAction() == MotionEvent.ACTION_UP
                        || event.getAction() == MotionEvent.ACTION_CANCEL) {
                    mBlockingExpansionForCurrentTouch = false;
                }
                // When touch focus transfer happens, ACTION_DOWN->ACTION_UP may happen immediately
                // without any ACTION_MOVE event.
                // In such case, simply expand the panel instead of being stuck at the bottom bar.
                if (mLastEventSynthesizedDown && event.getAction() == MotionEvent.ACTION_UP) {
                    expand(true /* animate */);
                }
                initDownStates(event);

                // If pulse is expanding already, let's give it the touch. There are situations
                // where the panel starts expanding even though we're also pulsing
                boolean pulseShouldGetTouch = (!mIsExpanding
                        && !shouldQuickSettingsIntercept(mDownX, mDownY, 0))
                        || mPulseExpansionHandler.isExpanding();
                if (pulseShouldGetTouch && mPulseExpansionHandler.onTouchEvent(event)) {
                    // We're expanding all the other ones shouldn't get this anymore
                    mShadeLog.logMotionEvent(event, ""onTouch: PulseExpansionHandler handled event"");
                    return true;
                }
                if (mListenForHeadsUp && !mHeadsUpTouchHelper.isTrackingHeadsUp()
                        && !mNotificationStackScrollLayoutController.isLongPressInProgress()
                        && mHeadsUpTouchHelper.onInterceptTouchEvent(event)) {
                    mMetricsLogger.count(COUNTER_PANEL_OPEN_PEEK, 1);
                }
                boolean handled = mHeadsUpTouchHelper.onTouchEvent(event);

                if (!mHeadsUpTouchHelper.isTrackingHeadsUp() && handleQsTouch(event)) {
                    mShadeLog.logMotionEvent(event, ""onTouch: handleQsTouch handled event"");
                    return true;
                }
                if (event.getActionMasked() == MotionEvent.ACTION_DOWN && isFullyCollapsed()) {
                    mMetricsLogger.count(COUNTER_PANEL_OPEN, 1);
                    handled = true;
                }

                if (event.getActionMasked() == MotionEvent.ACTION_DOWN && isFullyExpanded()
                        && mStatusBarKeyguardViewManager.isShowing()) {
                    mStatusBarKeyguardViewManager.updateKeyguardPosition(event.getX());
                }

                handled |= super.onTouch(v, event);
                return !mDozing || mPulsing || handled;
            }
        };
    }

    private final PhoneStatusBarView.TouchEventHandler mStatusBarViewTouchEventHandler =
            new PhoneStatusBarView.TouchEventHandler() {
                @Override
                public void onInterceptTouchEvent(MotionEvent event) {
                    mCentralSurfaces.onTouchEvent(event);
                }

                @Override
                public boolean handleTouchEvent(MotionEvent event) {
                    mCentralSurfaces.onTouchEvent(event);

                    // TODO(b/202981994): Move the touch debugging in this method to a central
                    //  location. (Right now, it's split between CentralSurfaces and here.)

                    // If panels aren't enabled, ignore the gesture and don't pass it down to the
                    // panel view.
                    if (!mCommandQueue.panelsEnabled()) {
                        if (event.getAction() == MotionEvent.ACTION_DOWN) {
                            Log.v(
                                    TAG,
                                    String.format(
                                            ""onTouchForwardedFromStatusBar: ""
                                                    + ""panel disabled, ignoring touch at (%d,%d)"",
                                            (int) event.getX(),
                                            (int) event.getY()
                                    )
                            );
                        }
                        return false;
                    }

                    // If the view that would receive the touch is disabled, just have status bar
                    // eat the gesture.
                    if (event.getAction() == MotionEvent.ACTION_DOWN && !mView.isEnabled()) {
                        Log.v(TAG,
                                String.format(
                                        ""onTouchForwardedFromStatusBar: ""
                                                + ""panel view disabled, eating touch at (%d,%d)"",
                                        (int) event.getX(),
                                        (int) event.getY()
                                )
                        );
                        return true;
                    }

                    return mView.dispatchTouchEvent(event);
                }
            };

    @Override
    protected OnConfigurationChangedListener createOnConfigurationChangedListener() {
        return new OnConfigurationChangedListener();
","[1.0, 1.0]"
1659,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/shade/NotificationPanelViewController.java,"[(4830, 4831, 2), (4830, 4831, 2)]","    private class OnAttachStateChangeListener implements View.OnAttachStateChangeListener,
            TunerService.Tunable {
","    private class OnAttachStateChangeListener implements View.OnAttachStateChangeListener,
            TunerService.Tunable {
","    private class OnAttachStateChangeListener implements View.OnAttachStateChangeListener,
            TunerService.Tunable {
","[1.0, 1.0]"
1660,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/screenshot/SaveImageInBackgroundTask.java,"[(161, 164, 4), (162, 165, 4)]","            mImageData.viewTransition = createViewAction(mContext, mContext.getResources(), uri);
            mImageData.shareTransition = createShareAction(mContext, mContext.getResources(), uri);
            mImageData.editTransition = createEditAction(mContext, mContext.getResources(), uri);
            mImageData.deleteAction = createDeleteAction(mContext, mContext.getResources(), uri);
","            mImageData.viewTransition = createViewAction(mContext, mContext.getResources(), uri);
            mImageData.shareTransition = createShareAction(mContext, mContext.getResources(), uri);
            mImageData.editTransition = createEditAction(mContext, mContext.getResources(), uri);
            mImageData.deleteAction = createDeleteAction(mContext, mContext.getResources(), uri);
","            mImageData.viewTransition = createViewAction(mContext, mContext.getResources(), uri);
            mImageData.shareTransition = createShareAction(mContext, mContext.getResources(), uri);
            mImageData.editTransition = createEditAction(mContext, mContext.getResources(), uri);
            mImageData.deleteAction = createDeleteAction(mContext, mContext.getResources(), uri);
","[1.0, 1.0]"
1661,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/tuner/TunerActivity.java,"[(69, 77, 9), (69, 77, 9)]","            final Fragment fragment;
            if (""com.android.settings.action.DEMO_MODE"".equals(action)) {
                fragment = new DemoModeFragment(mDemoModeController);
            } else if (""com.android.settings.action.STATUS_BAR_TUNER"".equals(action)) {
                fragment = new StatusBarTuner();
            } else {
                fragment = new TunerFragment(mTunerService);
            }

","            final Fragment fragment;
            if (""com.android.settings.action.DEMO_MODE"".equals(action)) {
                fragment = new DemoModeFragment(mDemoModeController);
            } else if (""com.android.settings.action.STATUS_BAR_TUNER"".equals(action)) {
                fragment = new StatusBarTuner();
            } else {
                fragment = new TunerFragment(mTunerService);
            }

","            final Fragment fragment;
            if (""com.android.settings.action.DEMO_MODE"".equals(action)) {
                fragment = new DemoModeFragment(mDemoModeController);
            } else if (""com.android.settings.action.STATUS_BAR_TUNER"".equals(action)) {
                fragment = new StatusBarTuner();
            } else {
                fragment = new TunerFragment(mTunerService);
            }

","[1.0, 1.0]"
1662,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', 'e33699a6fd9e692b2332b3c10642d49af617234e']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationIconContainer.java,"[(143, 147, 5), (143, 147, 5)]","    public final int MAX_ICONS_ON_LOCKSCREEN =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIconsOnLock);
    public final int MAX_STATIC_ICONS =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIcons);
    private static final int MAX_DOTS = 1;
","    public final int MAX_ICONS_ON_LOCKSCREEN =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIconsOnLock);
    public final int MAX_STATIC_ICONS =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIcons);
    private static final int MAX_DOTS = 1;
","    public final int MAX_ICONS_ON_LOCKSCREEN =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIconsOnLock);
    public final int MAX_STATIC_ICONS =
            getResources().getInteger(R.integer.config_maxVisibleNotificationIcons);
    private static final int MAX_DOTS = 1;
","[1.0, 1.0]"
1663,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",services/appwidget/java/com/android/server/appwidget/AppWidgetXmlUtil.java,"[(96, 96, 1), (96, 96, 1)]","        out.attribute(null, ATTR_OS_FINGERPRINT, Build.VERSION.INCREMENTAL);
","        out.attribute(null, ATTR_OS_FINGERPRINT, String.valueOf(Build.TIME));
","        out.attribute(null, ATTR_OS_FINGERPRINT, ","[0.636, 0.628]"
1664,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManagerTest.java,"[(532, 535, 4), (532, 535, 4)]","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","[1.0, 1.0]"
1665,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",services/core/java/com/android/server/media/MediaSessionRecord.java,"[(939, 940, 2), (939, 940, 2)]","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","[1.0, 1.0]"
1666,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanelController.java,"[(32, 34, 3), (32, 34, 3)]","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","[1.0, 1.0]"
1667,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(405, 456, 52), (405, 456, 52)]","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","[1.0, 1.0]"
1668,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(493, 496, 4), (493, 496, 4)]","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","[1.0, 1.0]"
1669,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(536, 541, 6), (536, 541, 6)]","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","[1.0, 1.0]"
1670,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(558, 562, 5), (558, 562, 5)]","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","[1.0, 1.0]"
1671,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(615, 618, 4), (615, 618, 4)]","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","[1.0, 1.0]"
1672,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(623, 629, 7), (623, 629, 7)]","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","[1.0, 1.0]"
1673,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(731, 734, 4), (731, 734, 4)]","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","[1.0, 1.0]"
1674,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(844, 850, 7), (844, 850, 7)]","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","[1.0, 1.0]"
1675,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1117, 1127, 11), (1117, 1127, 11)]","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","[1.0, 1.0]"
1676,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1292, 1295, 4), (1292, 1295, 4)]","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","[1.0, 1.0]"
1677,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1311, 1314, 4), (1311, 1314, 4)]","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","[1.0, 1.0]"
1678,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1360, 1363, 4), (1360, 1363, 4)]","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","[1.0, 1.0]"
1679,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1447, 1450, 4), (1447, 1450, 4)]","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","[1.0, 1.0]"
1680,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1490, 1494, 5), (1490, 1494, 5)]","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","[1.0, 1.0]"
1681,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1501, 1505, 5), (1501, 1505, 5)]","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","[1.0, 1.0]"
1682,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1512, 1516, 5), (1512, 1516, 5)]","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","[1.0, 1.0]"
1683,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1524, 1527, 4), (1524, 1527, 4)]","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","[1.0, 1.0]"
1684,"['1ab0b23a1d46b60a76015f090ada435f10bc9ecd', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1535, 1539, 5), (1535, 1539, 5)]","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","[1.0, 1.0]"
1685,"['72ae328c0ea598eaf6e115a44520b2e7f3cc9eba', '5cb9413cc504ba46231d9eef0ea04abd6f435b7a']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/fragment/CollapsedStatusBarFragment.java,"[(489, 489, 1), (510, 510, 1)]","            animateShow(mNetworkTrafficHolder, animate);
","            animateShow(mNetworkTrafficHolder, animate);
","            animateShow(mNetworkTrafficHolder, animate);
","[1.0, 1.0]"
1686,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', 'f67897bc05520f743974fc397aa96e4049a057b3']","['calyx-13-SAP-block_text', 'lineage-17.1-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java,"[(34, 34, 1), (35, 35, 1)]","    private View mLeftSide, mStatusIcons, mNetworkTraffic, mBattery;
","    private View mLeftSide, mStatusIcons, mNetworkTraffic, mBattery, mClock;
","    private View mLeftSide, mStatusIcons, mNetworkTraffic, mBattery","[0.971, 0.87]"
1687,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/NumPadKey.java,"[(40, 42, 3), (40, 42, 3)]","import lineageos.providers.LineageSettings;

public class NumPadKey extends ViewGroup {
","import lineageos.providers.LineageSettings;

public class NumPadKey extends ViewGroup {
","import lineageos.providers.LineageSettings;

public class NumPadKey extends ViewGroup {
","[1.0, 1.0]"
1688,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(760, 760, 1), (760, 760, 1)]","            Log.d(TAG, ""handleFingerprintAuthFailed()""
","            Log.d(TAG, ""handleFingerprintAuthFailed()""
","            Log.d(TAG, ""handleFingerprintAuthFailed()""
","[1.0, 1.0]"
1689,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(760, 760, 1), (795, 795, 1)]","            Log.d(TAG, ""handleFingerprintAuthFailed()""
","            Log.d(TAG, ""handleFingerprintAuthenticated()""
","            Log.d(TAG, ""handleFingerprintAuth","[0.818, 0.776]"
1690,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(795, 795, 1), (795, 795, 1)]","            Log.d(TAG, ""handleFingerprintAuthenticated()""
","            Log.d(TAG, ""handleFingerprintAuthenticated()""
","            Log.d(TAG, ""handleFingerprintAuthenticated()""
","[1.0, 1.0]"
1691,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/connectivity/MobileSignalController.java,"[(274, 274, 1), (274, 274, 1)]","        if (mProviderModelBehavior) {
","        if (mProviderModelBehavior) {
","        if (mProviderModelBehavior) {
","[1.0, 1.0]"
1692,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/BluetoothControllerImpl.java,"[(326, 343, 18), (326, 343, 18)]","    public int getBatteryLevel() {
        if (!mConnectedDevices.isEmpty()) {
            return mConnectedDevices.get(0).getBatteryLevel();
        }
        return -1;
    }

    private void updateBattery() {
        int batteryLevel = getBatteryLevel();
        if (batteryLevel != mBatteryLevel) {
            mBatteryLevel = batteryLevel;
            mHandler.sendEmptyMessage(H.MSG_STATE_CHANGED);
        }
    }

    @Override
    public void onBluetoothStateChanged(int bluetoothState) {
        if (DEBUG) Log.d(TAG, ""BluetoothStateChanged="" + stateToString(bluetoothState));
","    public int getBatteryLevel() {
        if (!mConnectedDevices.isEmpty()) {
            return mConnectedDevices.get(0).getBatteryLevel();
        }
        return -1;
    }

    private void updateBattery() {
        int batteryLevel = getBatteryLevel();
        if (batteryLevel != mBatteryLevel) {
            mBatteryLevel = batteryLevel;
            mHandler.sendEmptyMessage(H.MSG_STATE_CHANGED);
        }
    }

    @Override
    public void onBluetoothStateChanged(int bluetoothState) {
        if (DEBUG) Log.d(TAG, ""BluetoothStateChanged="" + stateToString(bluetoothState));
","    public int getBatteryLevel() {
        if (!mConnectedDevices.isEmpty()) {
            return mConnectedDevices.get(0).getBatteryLevel();
        }
        return -1;
    }

    private void updateBattery() {
        int batteryLevel = getBatteryLevel();
        if (batteryLevel != mBatteryLevel) {
            mBatteryLevel = batteryLevel;
            mHandler.sendEmptyMessage(H.MSG_STATE_CHANGED);
        }
    }

    @Override
    public void onBluetoothStateChanged(int bluetoothState) {
        if (DEBUG) Log.d(TAG, ""BluetoothStateChanged="" + stateToString(bluetoothState));
","[1.0, 1.0]"
1693,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/navigationbar/NavigationBarView.java,"[(85, 86, 2), (85, 86, 2)]","import com.android.systemui.statusbar.phone.NotificationPanelViewController;
import com.android.systemui.tuner.TunerService;
","import com.android.systemui.statusbar.phone.NotificationPanelViewController;
import com.android.systemui.tuner.TunerService;
","import com.android.systemui.statusbar.phone.NotificationPanelViewController;
import com.android.systemui.tuner.TunerService;
","[1.0, 1.0]"
1694,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/fragment/CollapsedStatusBarFragment.java,"[(236, 237, 2), (240, 242, 3)]","        mSystemIconArea = mStatusBar.findViewById(R.id.system_icon_area);
        mNetworkTrafficHolder = mStatusBar.findViewById(R.id.network_traffic_holder);
","        mSystemIconArea = mStatusBar.findViewById(R.id.system_icon_area);
        mNetworkTrafficHolder = mStatusBar.findViewById(R.id.network_traffic_holder);
        mClockController = mStatusBar.getClockController();
","        mSystemIconArea = mStatusBar.findViewById(R.id.system_icon_area);
        mNetworkTrafficHolder = mStatusBar.findViewById(R.id.network_traffic_holder);
","[1.0, 0.727]"
1695,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/fragment/CollapsedStatusBarFragment.java,"[(479, 481, 3), (500, 502, 3)]","    private void hideSystemIconArea(boolean animate) {
        animateHide(mSystemIconArea, animate);
        animateHide(mNetworkTrafficHolder, animate);
","    private void hideSystemIconArea(boolean animate) {
        animateHide(mSystemIconArea, animate);
        animateHide(mNetworkTrafficHolder, animate);
","    private void hideSystemIconArea(boolean animate) {
        animateHide(mSystemIconArea, animate);
        animateHide(mNetworkTrafficHolder, animate);
","[1.0, 1.0]"
1696,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/fragment/CollapsedStatusBarFragment.java,"[(488, 494, 7), (509, 515, 7)]","            animateShow(mSystemIconArea, animate);
            animateShow(mNetworkTrafficHolder, animate);
        } else {
            // We are in the middle of a system status event animation, which will animate the
            // alpha (but not the visibility). Allow the view to become visible again
            mSystemIconArea.setVisibility(View.VISIBLE);
            mNetworkTrafficHolder.setVisibility(View.VISIBLE);
","            animateShow(mSystemIconArea, animate);
            animateShow(mNetworkTrafficHolder, animate);
        } else {
            // We are in the middle of a system status event animation, which will animate the
            // alpha (but not the visibility). Allow the view to become visible again
            mSystemIconArea.setVisibility(View.VISIBLE);
            mNetworkTrafficHolder.setVisibility(View.VISIBLE);
","            animateShow(mSystemIconArea, animate);
            animateShow(mNetworkTrafficHolder, animate);
        } else {
            // We are in the middle of a system status event animation, which will animate the
            // alpha (but not the visibility). Allow the view to become visible again
            mSystemIconArea.setVisibility(View.VISIBLE);
            mNetworkTrafficHolder.setVisibility(View.VISIBLE);
","[1.0, 1.0]"
1697,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/qs/QSTileHostTest.java,"[(134, 135, 2), (134, 135, 2)]","    private FakeExecutor mMainExecutor;

","    private FakeExecutor mMainExecutor;

","    private FakeExecutor mMainExecutor;

","[1.0, 1.0]"
1698,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/qs/QSTileHostTest.java,"[(153, 153, 1), (153, 153, 1)]","                mTileServiceRequestControllerBuilder, mTileLifecycleManagerFactory);
","                mTileServiceRequestControllerBuilder, mTileLifecycleManagerFactory);
","                mTileServiceRequestControllerBuilder, mTileLifecycleManagerFactory);
","[1.0, 1.0]"
1699,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/qs/QSTileHostTest.java,"[(496, 500, 5), (496, 500, 5)]","                TileLifecycleManager.Factory tileLifecycleManagerFactory) {
            super(context, iconController, defaultFactory, mainExecutor, pluginManager,
                    tunerService, autoTiles, dumpManager, Optional.of(centralSurfaces), qsLogger,
                    uiEventLogger, userTracker, secureSettings, customTileStatePersister,
                    tileServiceRequestControllerBuilder, tileLifecycleManagerFactory);
","                TileLifecycleManager.Factory tileLifecycleManagerFactory) {
            super(context, iconController, defaultFactory, mainExecutor, pluginManager,
                    tunerService, autoTiles, dumpManager, Optional.of(centralSurfaces), qsLogger,
                    uiEventLogger, userTracker, secureSettings, customTileStatePersister,
                    tileServiceRequestControllerBuilder, tileLifecycleManagerFactory);
","                TileLifecycleManager.Factory tileLifecycleManagerFactory) {
            super(context, iconController, defaultFactory, mainExecutor, pluginManager,
                    tunerService, autoTiles, dumpManager, Optional.of(centralSurfaces), qsLogger,
                    uiEventLogger, userTracker, secureSettings, customTileStatePersister,
                    tileServiceRequestControllerBuilder, tileLifecycleManagerFactory);
","[1.0, 1.0]"
1700,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSTileHost.java,"[(14, 14, 1), (14, 14, 1)]","
","
","
","[1.0, 1.0]"
1701,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",telephony/java/android/telephony/AccessNetworkConstants.java,"[(117, 117, 1), (117, 117, 1)]","            switch (str.toUpperCase()) {
","            switch (str.toUpperCase()) {
","            switch (str.toUpperCase()) {
","[1.0, 1.0]"
1702,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(374, 374, 1), (374, 374, 1)]","            mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
","            mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
","            mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
","[1.0, 1.0]"
1703,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java,"[(34, 34, 1), (34, 34, 1)]","    private View mLeftSide, mStatusIcons, mNetworkTraffic, mBattery;
","    private View mLeftSide, mStatusIcons, mNetworkTraffic, mBattery;
","    private View mLeftSide, mStatusIcons, mNetworkTraffic, mBattery;
","[1.0, 1.0]"
1704,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",services/core/java/com/android/server/connectivity/Vpn.java,"[(2964, 3067, 104), (2937, 3040, 104)]","                    switch (ikeException.getErrorType()) {
                        case IkeProtocolException.ERROR_TYPE_NO_PROPOSAL_CHOSEN: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_INVALID_KE_PAYLOAD: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_AUTHENTICATION_FAILED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_SINGLE_PAIR_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_FAILED_CP_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_TS_UNACCEPTABLE:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_NOT_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                            markFailedAndDisconnect(exception);
                            return;
                        // All other cases possibly recoverable.
                        default:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                    }
                } else if (exception instanceof IllegalArgumentException) {
                    // Failed to build IKE/ChildSessionParams; fatal profile configuration error
                    markFailedAndDisconnect(exception);
                    return;
                } else if (exception instanceof IkeNetworkLostException) {
                    // TODO(b/230548427): Remove SDK check once VPN related stuff are
                    //  decoupled from ConnectivityServiceTest.
                    if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                        sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                VpnManager.ERROR_CLASS_RECOVERABLE,
                                VpnManager.ERROR_CODE_NETWORK_LOST,
                                getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                mActiveNetwork,
                                getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                        mUnderlyingNetworkCapabilities),
                                getRedactedLinkPropertiesOfUnderlyingNetwork(
                                        mUnderlyingLinkProperties));
                    }
                } else if (exception instanceof IkeNonProtocolException) {
                    if (exception.getCause() instanceof UnknownHostException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_UNKNOWN_HOST,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IkeTimeoutException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_PROTOCOL_TIMEOUT,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IOException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_IO,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    }
                } else if (exception != null) {
                    Log.wtf(TAG, ""onSessionLost: exception = "" + exception);
","                    switch (ikeException.getErrorType()) {
                        case IkeProtocolException.ERROR_TYPE_NO_PROPOSAL_CHOSEN: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_INVALID_KE_PAYLOAD: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_AUTHENTICATION_FAILED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_SINGLE_PAIR_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_FAILED_CP_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_TS_UNACCEPTABLE:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_NOT_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                            markFailedAndDisconnect(exception);
                            return;
                        // All other cases possibly recoverable.
                        default:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                    }
                } else if (exception instanceof IllegalArgumentException) {
                    // Failed to build IKE/ChildSessionParams; fatal profile configuration error
                    markFailedAndDisconnect(exception);
                    return;
                } else if (exception instanceof IkeNetworkLostException) {
                    // TODO(b/230548427): Remove SDK check once VPN related stuff are
                    //  decoupled from ConnectivityServiceTest.
                    if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                        sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                VpnManager.ERROR_CLASS_RECOVERABLE,
                                VpnManager.ERROR_CODE_NETWORK_LOST,
                                getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                mActiveNetwork,
                                getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                        mUnderlyingNetworkCapabilities),
                                getRedactedLinkPropertiesOfUnderlyingNetwork(
                                        mUnderlyingLinkProperties));
                    }
                } else if (exception instanceof IkeNonProtocolException) {
                    if (exception.getCause() instanceof UnknownHostException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_UNKNOWN_HOST,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IkeTimeoutException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_PROTOCOL_TIMEOUT,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IOException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_IO,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    }
                } else if (exception != null) {
                    Log.wtf(TAG, ""onSessionLost: exception = "" + exception);
","                    switch (ikeException.getErrorType()) {
                        case IkeProtocolException.ERROR_TYPE_NO_PROPOSAL_CHOSEN: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_INVALID_KE_PAYLOAD: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_AUTHENTICATION_FAILED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_SINGLE_PAIR_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_FAILED_CP_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_TS_UNACCEPTABLE:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_NOT_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                            markFailedAndDisconnect(exception);
                            return;
                        // All other cases possibly recoverable.
                        default:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                    }
                } else if (exception instanceof IllegalArgumentException) {
                    // Failed to build IKE/ChildSessionParams; fatal profile configuration error
                    markFailedAndDisconnect(exception);
                    return;
                } else if (exception instanceof IkeNetworkLostException) {
                    // TODO(b/230548427): Remove SDK check once VPN related stuff are
                    //  decoupled from ConnectivityServiceTest.
                    if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                        sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                VpnManager.ERROR_CLASS_RECOVERABLE,
                                VpnManager.ERROR_CODE_NETWORK_LOST,
                                getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                mActiveNetwork,
                                getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                        mUnderlyingNetworkCapabilities),
                                getRedactedLinkPropertiesOfUnderlyingNetwork(
                                        mUnderlyingLinkProperties));
                    }
                } else if (exception instanceof IkeNonProtocolException) {
                    if (exception.getCause() instanceof UnknownHostException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_UNKNOWN_HOST,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IkeTimeoutException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_PROTOCOL_TIMEOUT,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IOException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_IO,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    }
                } else if (exception != null) {
                    Log.wtf(TAG, ""onSessionLost: exception = "" + exception);
","[1.0, 1.0]"
1705,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/keyguard/KeyguardSecurityContainerControllerTest.java,"[(74, 74, 1), (74, 74, 1)]","    private static final int VIEW_WIDTH = 1600;
","    private static final int VIEW_WIDTH = 1600;
","    private static final int VIEW_WIDTH = 1600;
","[1.0, 1.0]"
1706,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",core/java/com/android/internal/widget/LocalImageResolver.java,"[(112, 118, 7), (112, 118, 7)]","                if (!(TextUtils.isEmpty(icon.getResPackage())
                        || context.getPackageName().equals(icon.getResPackage()))) {
                    // We can't properly resolve icons from other packages here, so fall back.
                    return icon.loadDrawable(context);
                }

                Drawable result = resolveImage(icon.getResId(), context, maxWidth, maxHeight);
","                if (!(TextUtils.isEmpty(icon.getResPackage())
                        || context.getPackageName().equals(icon.getResPackage()))) {
                    // We can't properly resolve icons from other packages here, so fall back.
                    return icon.loadDrawable(context);
                }

                Drawable result = resolveImage(icon.getResId(), context, maxWidth, maxHeight);
","                if (!(TextUtils.isEmpty(icon.getResPackage())
                        || context.getPackageName().equals(icon.getResPackage()))) {
                    // We can't properly resolve icons from other packages here, so fall back.
                    return icon.loadDrawable(context);
                }

                Drawable result = resolveImage(icon.getResId(), context, maxWidth, maxHeight);
","[1.0, 1.0]"
1707,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/tileimpl/QSFactoryImpl.java,"[(108, 115, 8), (110, 119, 10)]","    private final Provider<AmbientDisplayTile> mAmbientDisplayTileProvider;
    private final Provider<AODTile> mAODTileProvider;
    private final Provider<CaffeineTile> mCaffeineTileProvider;
    private final Provider<HeadsUpTile> mHeadsUpTileProvider;
    private final Provider<ReadingModeTile> mReadingModeTileProvider;
    private final Provider<SyncTile> mSyncTileProvider;
    private final Provider<PowerShareTile> mPowerShareTileProvider;
    private final Provider<UsbTetherTile> mUsbTetherTileProvider;
","    private final Provider<AmbientDisplayTile> mAmbientDisplayTileProvider;
    private final Provider<AODTile> mAODTileProvider;
    private final Provider<CaffeineTile> mCaffeineTileProvider;
    private final Provider<HeadsUpTile> mHeadsUpTileProvider;
    private final Provider<ReadingModeTile> mReadingModeTileProvider;
    private final Provider<SyncTile> mSyncTileProvider;
    private final Provider<PowerShareTile> mPowerShareTileProvider;
    private final Provider<ProfilesTile> mProfilesTileProvider;
    private final Provider<UsbTetherTile> mUsbTetherTileProvider;
    private final Provider<VpnTile> mVpnTileProvider;
","    private final Provider<AmbientDisplayTile> mAmbientDisplayTileProvider;
    private final Provider<AODTile> mAODTileProvider;
    private final Provider<CaffeineTile> mCaffeineTileProvider;
    private final Provider<HeadsUpTile> mHeadsUpTileProvider;
    private final Provider<ReadingModeTile> mReadingModeTileProvider;
    private final Provider<SyncTile> mSyncTileProvider;
    private final Provider<PowerShareTile> mPowerShareTileProvider;
    private final Provider<","[0.924, 0.752]"
1708,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/tileimpl/QSFactoryImpl.java,"[(153, 160, 8), (157, 166, 10)]","            Provider<AmbientDisplayTile> ambientDisplayTileProvider,
            Provider<AODTile> aodTileProvider,
            Provider<CaffeineTile> caffeineTileProvider,
            Provider<HeadsUpTile> headsUpTileProvider,
            Provider<PowerShareTile> powerShareTileProvider,
            Provider<ReadingModeTile> readingModeTileProvider,
            Provider<SyncTile> syncTileProvider,
            Provider<UsbTetherTile> usbTetherTileProvider) {
","            Provider<AmbientDisplayTile> ambientDisplayTileProvider,
            Provider<AODTile> aodTileProvider,
            Provider<CaffeineTile> caffeineTileProvider,
            Provider<HeadsUpTile> headsUpTileProvider,
            Provider<PowerShareTile> powerShareTileProvider,
            Provider<ProfilesTile> profilesTileProvider,
            Provider<ReadingModeTile> readingModeTileProvider,
            Provider<SyncTile> syncTileProvider,
            Provider<UsbTetherTile> usbTetherTileProvider,
            Provider<VpnTile> vpnTileProvider) {
","            Provider<AmbientDisplayTile> ambientDisplayTileProvider,
            Provider<AODTile> aodTileProvider,
            Provider<CaffeineTile> caffeineTileProvider,
            Provider<HeadsUpTile> headsUpTileProvider,
            Provider<PowerShareTile> powerShareTileProvider,
            Provider<","[0.671, 0.548]"
1709,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/tileimpl/QSFactoryImpl.java,"[(193, 200, 8), (199, 208, 10)]","        mAmbientDisplayTileProvider = ambientDisplayTileProvider;
        mAODTileProvider = aodTileProvider;
        mCaffeineTileProvider = caffeineTileProvider;
        mHeadsUpTileProvider = headsUpTileProvider;
        mReadingModeTileProvider = readingModeTileProvider;
        mSyncTileProvider = syncTileProvider;
        mPowerShareTileProvider = powerShareTileProvider;
        mUsbTetherTileProvider = usbTetherTileProvider;
","        mAmbientDisplayTileProvider = ambientDisplayTileProvider;
        mAODTileProvider = aodTileProvider;
        mCaffeineTileProvider = caffeineTileProvider;
        mHeadsUpTileProvider = headsUpTileProvider;
        mReadingModeTileProvider = readingModeTileProvider;
        mSyncTileProvider = syncTileProvider;
        mPowerShareTileProvider = powerShareTileProvider;
        mProfilesTileProvider = profilesTileProvider;
        mUsbTetherTileProvider = usbTetherTileProvider;
        mVpnTileProvider = vpnTileProvider;
","        mAmbientDisplayTileProvider = ambientDisplayTileProvider;
        mAODTileProvider = aodTileProvider;
        mCaffeineTileProvider = caffeineTileProvider;
        mHeadsUpTileProvider = headsUpTileProvider;
        mReadingModeTileProvider = readingModeTileProvider;
        mSyncTileProvider = syncTileProvider;
        mPowerShareTileProvider = powerShareTileProvider;
        m","[0.892, 0.728]"
1710,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', '58a632b15f68b88e6fd57c317d348a26a7ec2c6f']","['calyx-13-SAP-block_text', 'lineage-20.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/tileimpl/QSFactoryImpl.java,"[(274, 290, 17), (282, 302, 21)]","            // Additional tiles.
            case ""ambient_display"":
                return mAmbientDisplayTileProvider.get();
            case ""aod"":
                return mAODTileProvider.get();
            case ""caffeine"":
                return mCaffeineTileProvider.get();
            case ""heads_up"":
                return mHeadsUpTileProvider.get();
            case ""reading_mode"":
                return mReadingModeTileProvider.get();
            case ""sync"":
                return mSyncTileProvider.get();
            case ""powershare"":
                return mPowerShareTileProvider.get();
            case ""usb_tether"":
                return mUsbTetherTileProvider.get();
","            // Additional tiles.
            case ""ambient_display"":
                return mAmbientDisplayTileProvider.get();
            case ""aod"":
                return mAODTileProvider.get();
            case ""caffeine"":
                return mCaffeineTileProvider.get();
            case ""heads_up"":
                return mHeadsUpTileProvider.get();
            case ""reading_mode"":
                return mReadingModeTileProvider.get();
            case ""sync"":
                return mSyncTileProvider.get();
            case ""powershare"":
                return mPowerShareTileProvider.get();
            case ""profiles"":
                return mProfilesTileProvider.get();
            case ""usb_tether"":
                return mUsbTetherTileProvider.get();
            case ""vpn"":
                return mVpnTileProvider.get();
","            // Additional tiles.
            case ""ambient_display"":
                return mAmbientDisplayTileProvider.get();
            case ""aod"":
                return mAODTileProvider.get();
            case ""caffeine"":
                return mCaffeineTileProvider.get();
            case ""heads_up"":
                return mHeadsUpTileProvider.get();
            case ""reading_mode"":
                return mReadingModeTileProvider.get();
            case ""sync"":
                return mSyncTileProvider.get();
            case ""powershare"":
                return mPowerShareTileProvider.get();
            case ""","[0.904, 0.741]"
1711,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(760, 760, 1), (755, 755, 1)]","            Log.d(TAG, ""handleFingerprintAuthFailed()""
","            Log.d(TAG, ""handleFingerprintAuthFailed()""
","            Log.d(TAG, ""handleFingerprintAuthFailed()""
","[1.0, 1.0]"
1712,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(760, 760, 1), (790, 790, 1)]","            Log.d(TAG, ""handleFingerprintAuthFailed()""
","            Log.d(TAG, ""handleFingerprintAuthenticated()""
","            Log.d(TAG, ""handleFingerprintAuth","[0.818, 0.776]"
1713,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(795, 795, 1), (755, 755, 1)]","            Log.d(TAG, ""handleFingerprintAuthenticated()""
","            Log.d(TAG, ""handleFingerprintAuthFailed()""
","            Log.d(TAG, ""handleFingerprintAuth","[0.776, 0.818]"
1714,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(795, 795, 1), (790, 790, 1)]","            Log.d(TAG, ""handleFingerprintAuthenticated()""
","            Log.d(TAG, ""handleFingerprintAuthenticated()""
","            Log.d(TAG, ""handleFingerprintAuthenticated()""
","[1.0, 1.0]"
1715,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/connectivity/MobileSignalController.java,"[(274, 274, 1), (274, 274, 1)]","        if (mProviderModelBehavior) {
","        if (mProviderModelBehavior) {
","        if (mProviderModelBehavior) {
","[1.0, 1.0]"
1716,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/qs/QSTileHostTest.java,"[(134, 135, 2), (134, 135, 2)]","    private FakeExecutor mMainExecutor;

","    private FakeExecutor mMainExecutor;

","    private FakeExecutor mMainExecutor;

","[1.0, 1.0]"
1717,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/qs/QSTileHostTest.java,"[(153, 153, 1), (153, 153, 1)]","                mTileServiceRequestControllerBuilder, mTileLifecycleManagerFactory);
","                mTileServiceRequestControllerBuilder, mTileLifecycleManagerFactory);
","                mTileServiceRequestControllerBuilder, mTileLifecycleManagerFactory);
","[1.0, 1.0]"
1718,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/qs/QSTileHostTest.java,"[(496, 500, 5), (540, 544, 5)]","                TileLifecycleManager.Factory tileLifecycleManagerFactory) {
            super(context, iconController, defaultFactory, mainExecutor, pluginManager,
                    tunerService, autoTiles, dumpManager, Optional.of(centralSurfaces), qsLogger,
                    uiEventLogger, userTracker, secureSettings, customTileStatePersister,
                    tileServiceRequestControllerBuilder, tileLifecycleManagerFactory);
","                TileLifecycleManager.Factory tileLifecycleManagerFactory) {
            super(context, iconController, defaultFactory, mainExecutor, pluginManager,
                    tunerService, autoTiles, dumpManager, Optional.of(centralSurfaces), qsLogger,
                    uiEventLogger, userTracker, secureSettings, customTileStatePersister,
                    tileServiceRequestControllerBuilder, tileLifecycleManagerFactory);
","                TileLifecycleManager.Factory tileLifecycleManagerFactory) {
            super(context, iconController, defaultFactory, mainExecutor, pluginManager,
                    tunerService, autoTiles, dumpManager, Optional.of(centralSurfaces), qsLogger,
                    uiEventLogger, userTracker, secureSettings, customTileStatePersister,
                    tileServiceRequestControllerBuilder, tileLifecycleManagerFactory);
","[1.0, 1.0]"
1719,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",telephony/java/android/telephony/AccessNetworkConstants.java,"[(117, 117, 1), (117, 117, 1)]","            switch (str.toUpperCase()) {
","            switch (str.toUpperCase()) {
","            switch (str.toUpperCase()) {
","[1.0, 1.0]"
1720,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(374, 374, 1), (374, 374, 1)]","            mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
","            mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
","            mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
","[1.0, 1.0]"
1721,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",services/core/java/com/android/server/connectivity/Vpn.java,"[(2964, 3067, 104), (2937, 3040, 104)]","                    switch (ikeException.getErrorType()) {
                        case IkeProtocolException.ERROR_TYPE_NO_PROPOSAL_CHOSEN: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_INVALID_KE_PAYLOAD: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_AUTHENTICATION_FAILED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_SINGLE_PAIR_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_FAILED_CP_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_TS_UNACCEPTABLE:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_NOT_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                            markFailedAndDisconnect(exception);
                            return;
                        // All other cases possibly recoverable.
                        default:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                    }
                } else if (exception instanceof IllegalArgumentException) {
                    // Failed to build IKE/ChildSessionParams; fatal profile configuration error
                    markFailedAndDisconnect(exception);
                    return;
                } else if (exception instanceof IkeNetworkLostException) {
                    // TODO(b/230548427): Remove SDK check once VPN related stuff are
                    //  decoupled from ConnectivityServiceTest.
                    if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                        sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                VpnManager.ERROR_CLASS_RECOVERABLE,
                                VpnManager.ERROR_CODE_NETWORK_LOST,
                                getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                mActiveNetwork,
                                getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                        mUnderlyingNetworkCapabilities),
                                getRedactedLinkPropertiesOfUnderlyingNetwork(
                                        mUnderlyingLinkProperties));
                    }
                } else if (exception instanceof IkeNonProtocolException) {
                    if (exception.getCause() instanceof UnknownHostException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_UNKNOWN_HOST,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IkeTimeoutException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_PROTOCOL_TIMEOUT,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IOException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_IO,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    }
                } else if (exception != null) {
                    Log.wtf(TAG, ""onSessionLost: exception = "" + exception);
","                    switch (ikeException.getErrorType()) {
                        case IkeProtocolException.ERROR_TYPE_NO_PROPOSAL_CHOSEN: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_INVALID_KE_PAYLOAD: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_AUTHENTICATION_FAILED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_SINGLE_PAIR_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_FAILED_CP_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_TS_UNACCEPTABLE:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_NOT_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                            markFailedAndDisconnect(exception);
                            return;
                        // All other cases possibly recoverable.
                        default:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                    }
                } else if (exception instanceof IllegalArgumentException) {
                    // Failed to build IKE/ChildSessionParams; fatal profile configuration error
                    markFailedAndDisconnect(exception);
                    return;
                } else if (exception instanceof IkeNetworkLostException) {
                    // TODO(b/230548427): Remove SDK check once VPN related stuff are
                    //  decoupled from ConnectivityServiceTest.
                    if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                        sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                VpnManager.ERROR_CLASS_RECOVERABLE,
                                VpnManager.ERROR_CODE_NETWORK_LOST,
                                getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                mActiveNetwork,
                                getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                        mUnderlyingNetworkCapabilities),
                                getRedactedLinkPropertiesOfUnderlyingNetwork(
                                        mUnderlyingLinkProperties));
                    }
                } else if (exception instanceof IkeNonProtocolException) {
                    if (exception.getCause() instanceof UnknownHostException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_UNKNOWN_HOST,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IkeTimeoutException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_PROTOCOL_TIMEOUT,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IOException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_IO,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    }
                } else if (exception != null) {
                    Log.wtf(TAG, ""onSessionLost: exception = "" + exception);
","                    switch (ikeException.getErrorType()) {
                        case IkeProtocolException.ERROR_TYPE_NO_PROPOSAL_CHOSEN: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_INVALID_KE_PAYLOAD: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_AUTHENTICATION_FAILED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_SINGLE_PAIR_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_FAILED_CP_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_TS_UNACCEPTABLE:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_NOT_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                            markFailedAndDisconnect(exception);
                            return;
                        // All other cases possibly recoverable.
                        default:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                    }
                } else if (exception instanceof IllegalArgumentException) {
                    // Failed to build IKE/ChildSessionParams; fatal profile configuration error
                    markFailedAndDisconnect(exception);
                    return;
                } else if (exception instanceof IkeNetworkLostException) {
                    // TODO(b/230548427): Remove SDK check once VPN related stuff are
                    //  decoupled from ConnectivityServiceTest.
                    if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                        sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                VpnManager.ERROR_CLASS_RECOVERABLE,
                                VpnManager.ERROR_CODE_NETWORK_LOST,
                                getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                mActiveNetwork,
                                getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                        mUnderlyingNetworkCapabilities),
                                getRedactedLinkPropertiesOfUnderlyingNetwork(
                                        mUnderlyingLinkProperties));
                    }
                } else if (exception instanceof IkeNonProtocolException) {
                    if (exception.getCause() instanceof UnknownHostException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_UNKNOWN_HOST,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IkeTimeoutException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_PROTOCOL_TIMEOUT,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IOException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_IO,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    }
                } else if (exception != null) {
                    Log.wtf(TAG, ""onSessionLost: exception = "" + exception);
","[1.0, 1.0]"
1722,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/keyguard/KeyguardSecurityContainerControllerTest.java,"[(74, 74, 1), (74, 74, 1)]","    private static final int VIEW_WIDTH = 1600;
","    private static final int VIEW_WIDTH = 1600;
","    private static final int VIEW_WIDTH = 1600;
","[1.0, 1.0]"
1723,"['8a3fc87179eb4857cbde71ef0a7acc1d9189e2e6', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['calyx-13-SAP-block_text', 'omnirom-13.0-SAP-block_text']",core/java/com/android/internal/widget/LocalImageResolver.java,"[(112, 118, 7), (112, 118, 7)]","                if (!(TextUtils.isEmpty(icon.getResPackage())
                        || context.getPackageName().equals(icon.getResPackage()))) {
                    // We can't properly resolve icons from other packages here, so fall back.
                    return icon.loadDrawable(context);
                }

                Drawable result = resolveImage(icon.getResId(), context, maxWidth, maxHeight);
","                if (!(TextUtils.isEmpty(icon.getResPackage())
                        || context.getPackageName().equals(icon.getResPackage()))) {
                    // We can't properly resolve icons from other packages here, so fall back.
                    return icon.loadDrawable(context);
                }

                Drawable result = resolveImage(icon.getResId(), context, maxWidth, maxHeight);
","                if (!(TextUtils.isEmpty(icon.getResPackage())
                        || context.getPackageName().equals(icon.getResPackage()))) {
                    // We can't properly resolve icons from other packages here, so fall back.
                    return icon.loadDrawable(context);
                }

                Drawable result = resolveImage(icon.getResId(), context, maxWidth, maxHeight);
","[1.0, 1.0]"
1725,"['12930acc5076e1acff0744b8d225bb2d2173f1b5', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['lineage-16.0-SAP-block_text', 'omnirom-11-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(6014, 6025, 12), (6000, 6011, 12)]","        // Hack for pi
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
","        // TODO (b/67683350)
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
","
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
","[0.968, 0.96]"
1726,"['12930acc5076e1acff0744b8d225bb2d2173f1b5', '7100a7fa7244d86adf9e33b9079ce2a355e2a525']","['lineage-16.0-SAP-block_text', 'omnirom-9.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/globalactions/GlobalActionsDialog.java,"[(60, 61, 2), (47, 48, 2)]","import android.os.Messenger;
import android.os.PowerManager;
","import android.os.Messenger;
import android.os.PowerManager;
","import android.os.Messenger;
import android.os.PowerManager;
","[1.0, 1.0]"
1727,"['12930acc5076e1acff0744b8d225bb2d2173f1b5', '7100a7fa7244d86adf9e33b9079ce2a355e2a525']","['lineage-16.0-SAP-block_text', 'omnirom-9.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/globalactions/GlobalActionsDialog.java,"[(373, 374, 2), (297, 298, 2)]","        for (int i = 0; i < mCurrentMenuActions.length; i++) {
            String actionKey = mCurrentMenuActions[i];
","        for (int i = 0; i < mCurrentMenuActions.length; i++) {
            String actionKey = mCurrentMenuActions[i];
","        for (int i = 0; i < mCurrentMenuActions.length; i++) {
            String actionKey = mCurrentMenuActions[i];
","[1.0, 1.0]"
1728,"['12930acc5076e1acff0744b8d225bb2d2173f1b5', '7100a7fa7244d86adf9e33b9079ce2a355e2a525']","['lineage-16.0-SAP-block_text', 'omnirom-9.0-SAP-block_text']",services/core/java/com/android/server/am/ActivityManagerService.java,"[(6014, 6025, 12), (5944, 5955, 12)]","        // Hack for pi
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
","        // Hack for pi
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
","        // Hack for pi
        // When an app process is removed, activities from the process may be relaunched. In the
        // case of forceStopPackageLocked the activities are finished before any window is drawn,
        // and the launch time is not cleared. This will be incorrectly used to calculate launch
        // time for the next launched activity launched in the same windowing mode.
        if (clearLaunchStartTime) {
            final LaunchTimeTracker.Entry entry = mStackSupervisor
                    .getLaunchTimeTracker().getEntry(mStackSupervisor.getWindowingMode());
            if (entry != null) {
                entry.mLaunchStartTime = 0;
            }
        }
","[1.0, 1.0]"
1738,"['8943bbe92bfbc3ead44f63a6a3c145a135548b7c', 'b7ff81acc796b2957f68c9412cef71b9b47e67de']","['lineage-17.1-SAP-block_text', 'omnirom-10-SAP-block_text']",telephony/java/android/telephony/ServiceState.java,"[(990, 990, 1), (990, 990, 1)]","                rtString = ""NR"";
","                rtString = ""NR"";
","                rtString = ""NR"";
","[1.0, 1.0]"
1739,"['8943bbe92bfbc3ead44f63a6a3c145a135548b7c', 'b7ff81acc796b2957f68c9412cef71b9b47e67de']","['lineage-17.1-SAP-block_text', 'omnirom-10-SAP-block_text']",packages/SystemUI/src/com/android/systemui/screenshot/GlobalScreenshot.java,"[(144, 144, 1), (139, 139, 1)]","    private static final String SCREENSHOT_FILE_NAME_TEMPLATE_APPNAME = ""Screenshot_%s_%s.png"";
","    private static final String SCREENSHOT_FILE_NAME_TEMPLATE_APPNAME = ""Screenshot_%s_%s.png"";
","    private static final String SCREENSHOT_FILE_NAME_TEMPLATE_APPNAME = ""Screenshot_%s_%s.png"";
","[1.0, 1.0]"
1740,"['8943bbe92bfbc3ead44f63a6a3c145a135548b7c', '799030b703da27e7117eba75c2ca753b0e976a8d']","['lineage-17.1-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/ServiceState.java,"[(990, 990, 1), (990, 990, 1)]","                rtString = ""NR"";
","                rtString = ""NR"";
","                rtString = ""NR"";
","[1.0, 1.0]"
1741,"['8943bbe92bfbc3ead44f63a6a3c145a135548b7c', '7c6cc72e18cc1df5205fd2bc47664e6cc2534ad2']","['lineage-17.1-SAP-block_text', 'omnirom-11-SAP-block_text']",telephony/java/android/telephony/ServiceState.java,"[(990, 990, 1), (991, 991, 1)]","                rtString = ""NR"";
","                rtString = ""NR"";
","                rtString = ""NR"";
","[1.0, 1.0]"
1742,"['96e5fca97c43ea282d5ad4b7c6fad40acd91586d', '160034a542fd4cfe183b93b3a4888dc7c4f68b65']","['lineage-17.1-SAP-block_text', 'omnirom-10-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java,"[(1365, 1365, 1), (1270, 1270, 1)]","                new Handler(), mKeyguardUpdateMonitor, mKeyguardBypassController);
","                new Handler(), mKeyguardUpdateMonitor, Dependency.get(TunerService.class));
","                new Handler(), mKeyguardUpdateMonitor, ","[0.663, 0.598]"
1743,"['96e5fca97c43ea282d5ad4b7c6fad40acd91586d', '18970c4d9d55a44040fe6fb762dac93a077c64b5']","['lineage-17.1-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java,"[(1365, 1365, 1), (1215, 1215, 1)]","                new Handler(), mKeyguardUpdateMonitor, mKeyguardBypassController);
","                new Handler(), mKeyguardUpdateMonitor, Dependency.get(TunerService.class));
","                new Handler(), mKeyguardUpdateMonitor, ","[0.663, 0.598]"
1744,"['96e5fca97c43ea282d5ad4b7c6fad40acd91586d', 'efe5cc44da2c1772c733a6740a761b3b42969db4']","['lineage-17.1-SAP-block_text', 'omnirom-11-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java,"[(1365, 1365, 1), (1218, 1218, 1)]","                new Handler(), mKeyguardUpdateMonitor, mKeyguardBypassController);
","                new Handler(), mKeyguardUpdateMonitor, Dependency.get(TunerService.class));
","                new Handler(), mKeyguardUpdateMonitor, ","[0.663, 0.598]"
1749,"['58a632b15f68b88e6fd57c317d348a26a7ec2c6f', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(374, 374, 1), (374, 374, 1)]","            mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
","            mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
","            mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
","[1.0, 1.0]"
1750,"['58a632b15f68b88e6fd57c317d348a26a7ec2c6f', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(760, 760, 1), (755, 755, 1)]","            Log.d(TAG, ""handleFingerprintAuthFailed()""
","            Log.d(TAG, ""handleFingerprintAuthFailed()""
","            Log.d(TAG, ""handleFingerprintAuthFailed()""
","[1.0, 1.0]"
1751,"['58a632b15f68b88e6fd57c317d348a26a7ec2c6f', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(760, 760, 1), (790, 790, 1)]","            Log.d(TAG, ""handleFingerprintAuthFailed()""
","            Log.d(TAG, ""handleFingerprintAuthenticated()""
","            Log.d(TAG, ""handleFingerprintAuth","[0.818, 0.776]"
1752,"['58a632b15f68b88e6fd57c317d348a26a7ec2c6f', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(795, 795, 1), (755, 755, 1)]","            Log.d(TAG, ""handleFingerprintAuthenticated()""
","            Log.d(TAG, ""handleFingerprintAuthFailed()""
","            Log.d(TAG, ""handleFingerprintAuth","[0.776, 0.818]"
1753,"['58a632b15f68b88e6fd57c317d348a26a7ec2c6f', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java,"[(795, 795, 1), (790, 790, 1)]","            Log.d(TAG, ""handleFingerprintAuthenticated()""
","            Log.d(TAG, ""handleFingerprintAuthenticated()""
","            Log.d(TAG, ""handleFingerprintAuthenticated()""
","[1.0, 1.0]"
1754,"['58a632b15f68b88e6fd57c317d348a26a7ec2c6f', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",core/java/com/android/internal/widget/LocalImageResolver.java,"[(112, 118, 7), (112, 118, 7)]","                if (!(TextUtils.isEmpty(icon.getResPackage())
                        || context.getPackageName().equals(icon.getResPackage()))) {
                    // We can't properly resolve icons from other packages here, so fall back.
                    return icon.loadDrawable(context);
                }

                Drawable result = resolveImage(icon.getResId(), context, maxWidth, maxHeight);
","                if (!(TextUtils.isEmpty(icon.getResPackage())
                        || context.getPackageName().equals(icon.getResPackage()))) {
                    // We can't properly resolve icons from other packages here, so fall back.
                    return icon.loadDrawable(context);
                }

                Drawable result = resolveImage(icon.getResId(), context, maxWidth, maxHeight);
","                if (!(TextUtils.isEmpty(icon.getResPackage())
                        || context.getPackageName().equals(icon.getResPackage()))) {
                    // We can't properly resolve icons from other packages here, so fall back.
                    return icon.loadDrawable(context);
                }

                Drawable result = resolveImage(icon.getResId(), context, maxWidth, maxHeight);
","[1.0, 1.0]"
1755,"['58a632b15f68b88e6fd57c317d348a26a7ec2c6f', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",services/core/java/com/android/server/connectivity/Vpn.java,"[(2937, 3040, 104), (2937, 3040, 104)]","                    switch (ikeException.getErrorType()) {
                        case IkeProtocolException.ERROR_TYPE_NO_PROPOSAL_CHOSEN: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_INVALID_KE_PAYLOAD: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_AUTHENTICATION_FAILED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_SINGLE_PAIR_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_FAILED_CP_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_TS_UNACCEPTABLE:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_NOT_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                            markFailedAndDisconnect(exception);
                            return;
                        // All other cases possibly recoverable.
                        default:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                    }
                } else if (exception instanceof IllegalArgumentException) {
                    // Failed to build IKE/ChildSessionParams; fatal profile configuration error
                    markFailedAndDisconnect(exception);
                    return;
                } else if (exception instanceof IkeNetworkLostException) {
                    // TODO(b/230548427): Remove SDK check once VPN related stuff are
                    //  decoupled from ConnectivityServiceTest.
                    if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                        sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                VpnManager.ERROR_CLASS_RECOVERABLE,
                                VpnManager.ERROR_CODE_NETWORK_LOST,
                                getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                mActiveNetwork,
                                getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                        mUnderlyingNetworkCapabilities),
                                getRedactedLinkPropertiesOfUnderlyingNetwork(
                                        mUnderlyingLinkProperties));
                    }
                } else if (exception instanceof IkeNonProtocolException) {
                    if (exception.getCause() instanceof UnknownHostException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_UNKNOWN_HOST,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IkeTimeoutException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_PROTOCOL_TIMEOUT,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IOException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_IO,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    }
                } else if (exception != null) {
                    Log.wtf(TAG, ""onSessionLost: exception = "" + exception);
","                    switch (ikeException.getErrorType()) {
                        case IkeProtocolException.ERROR_TYPE_NO_PROPOSAL_CHOSEN: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_INVALID_KE_PAYLOAD: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_AUTHENTICATION_FAILED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_SINGLE_PAIR_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_FAILED_CP_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_TS_UNACCEPTABLE:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_NOT_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                            markFailedAndDisconnect(exception);
                            return;
                        // All other cases possibly recoverable.
                        default:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                    }
                } else if (exception instanceof IllegalArgumentException) {
                    // Failed to build IKE/ChildSessionParams; fatal profile configuration error
                    markFailedAndDisconnect(exception);
                    return;
                } else if (exception instanceof IkeNetworkLostException) {
                    // TODO(b/230548427): Remove SDK check once VPN related stuff are
                    //  decoupled from ConnectivityServiceTest.
                    if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                        sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                VpnManager.ERROR_CLASS_RECOVERABLE,
                                VpnManager.ERROR_CODE_NETWORK_LOST,
                                getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                mActiveNetwork,
                                getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                        mUnderlyingNetworkCapabilities),
                                getRedactedLinkPropertiesOfUnderlyingNetwork(
                                        mUnderlyingLinkProperties));
                    }
                } else if (exception instanceof IkeNonProtocolException) {
                    if (exception.getCause() instanceof UnknownHostException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_UNKNOWN_HOST,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IkeTimeoutException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_PROTOCOL_TIMEOUT,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IOException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_IO,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    }
                } else if (exception != null) {
                    Log.wtf(TAG, ""onSessionLost: exception = "" + exception);
","                    switch (ikeException.getErrorType()) {
                        case IkeProtocolException.ERROR_TYPE_NO_PROPOSAL_CHOSEN: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_INVALID_KE_PAYLOAD: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_AUTHENTICATION_FAILED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_SINGLE_PAIR_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_FAILED_CP_REQUIRED: // Fallthrough
                        case IkeProtocolException.ERROR_TYPE_TS_UNACCEPTABLE:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_NOT_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                            markFailedAndDisconnect(exception);
                            return;
                        // All other cases possibly recoverable.
                        default:
                            // All the above failures are configuration errors, and are terminal
                            // TODO(b/230548427): Remove SDK check once VPN related stuff are
                            //  decoupled from ConnectivityServiceTest.
                            if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                                sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_IKE_ERROR,
                                        VpnManager.ERROR_CLASS_RECOVERABLE,
                                        ikeException.getErrorType(),
                                        getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                        mActiveNetwork,
                                        getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                                mUnderlyingNetworkCapabilities),
                                        getRedactedLinkPropertiesOfUnderlyingNetwork(
                                                mUnderlyingLinkProperties));
                            }
                    }
                } else if (exception instanceof IllegalArgumentException) {
                    // Failed to build IKE/ChildSessionParams; fatal profile configuration error
                    markFailedAndDisconnect(exception);
                    return;
                } else if (exception instanceof IkeNetworkLostException) {
                    // TODO(b/230548427): Remove SDK check once VPN related stuff are
                    //  decoupled from ConnectivityServiceTest.
                    if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                        sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                VpnManager.ERROR_CLASS_RECOVERABLE,
                                VpnManager.ERROR_CODE_NETWORK_LOST,
                                getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                mActiveNetwork,
                                getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                        mUnderlyingNetworkCapabilities),
                                getRedactedLinkPropertiesOfUnderlyingNetwork(
                                        mUnderlyingLinkProperties));
                    }
                } else if (exception instanceof IkeNonProtocolException) {
                    if (exception.getCause() instanceof UnknownHostException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_UNKNOWN_HOST,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IkeTimeoutException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_PROTOCOL_TIMEOUT,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    } else if (exception.getCause() instanceof IOException) {
                        // TODO(b/230548427): Remove SDK check once VPN related stuff are
                        //  decoupled from ConnectivityServiceTest.
                        if (SdkLevel.isAtLeastT() && isVpnApp(mPackage)) {
                            sendEventToVpnManagerApp(VpnManager.CATEGORY_EVENT_NETWORK_ERROR,
                                    VpnManager.ERROR_CLASS_RECOVERABLE,
                                    VpnManager.ERROR_CODE_NETWORK_IO,
                                    getPackage(), mSessionKey, makeVpnProfileStateLocked(),
                                    mActiveNetwork,
                                    getRedactedNetworkCapabilitiesOfUnderlyingNetwork(
                                            mUnderlyingNetworkCapabilities),
                                    getRedactedLinkPropertiesOfUnderlyingNetwork(
                                            mUnderlyingLinkProperties));
                        }
                    }
                } else if (exception != null) {
                    Log.wtf(TAG, ""onSessionLost: exception = "" + exception);
","[1.0, 1.0]"
1756,"['58a632b15f68b88e6fd57c317d348a26a7ec2c6f', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/qs/QSTileHostTest.java,"[(134, 135, 2), (134, 135, 2)]","    private FakeExecutor mMainExecutor;

","    private FakeExecutor mMainExecutor;

","    private FakeExecutor mMainExecutor;

","[1.0, 1.0]"
1757,"['58a632b15f68b88e6fd57c317d348a26a7ec2c6f', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/qs/QSTileHostTest.java,"[(153, 153, 1), (153, 153, 1)]","                mTileServiceRequestControllerBuilder, mTileLifecycleManagerFactory);
","                mTileServiceRequestControllerBuilder, mTileLifecycleManagerFactory);
","                mTileServiceRequestControllerBuilder, mTileLifecycleManagerFactory);
","[1.0, 1.0]"
1758,"['58a632b15f68b88e6fd57c317d348a26a7ec2c6f', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/qs/QSTileHostTest.java,"[(496, 500, 5), (540, 544, 5)]","                TileLifecycleManager.Factory tileLifecycleManagerFactory) {
            super(context, iconController, defaultFactory, mainExecutor, pluginManager,
                    tunerService, autoTiles, dumpManager, Optional.of(centralSurfaces), qsLogger,
                    uiEventLogger, userTracker, secureSettings, customTileStatePersister,
                    tileServiceRequestControllerBuilder, tileLifecycleManagerFactory);
","                TileLifecycleManager.Factory tileLifecycleManagerFactory) {
            super(context, iconController, defaultFactory, mainExecutor, pluginManager,
                    tunerService, autoTiles, dumpManager, Optional.of(centralSurfaces), qsLogger,
                    uiEventLogger, userTracker, secureSettings, customTileStatePersister,
                    tileServiceRequestControllerBuilder, tileLifecycleManagerFactory);
","                TileLifecycleManager.Factory tileLifecycleManagerFactory) {
            super(context, iconController, defaultFactory, mainExecutor, pluginManager,
                    tunerService, autoTiles, dumpManager, Optional.of(centralSurfaces), qsLogger,
                    uiEventLogger, userTracker, secureSettings, customTileStatePersister,
                    tileServiceRequestControllerBuilder, tileLifecycleManagerFactory);
","[1.0, 1.0]"
1759,"['58a632b15f68b88e6fd57c317d348a26a7ec2c6f', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/connectivity/MobileSignalController.java,"[(274, 274, 1), (274, 274, 1)]","        if (mProviderModelBehavior) {
","        if (mProviderModelBehavior) {
","        if (mProviderModelBehavior) {
","[1.0, 1.0]"
1760,"['58a632b15f68b88e6fd57c317d348a26a7ec2c6f', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/keyguard/KeyguardSecurityContainerControllerTest.java,"[(74, 74, 1), (74, 74, 1)]","    private static final int VIEW_WIDTH = 1600;
","    private static final int VIEW_WIDTH = 1600;
","    private static final int VIEW_WIDTH = 1600;
","[1.0, 1.0]"
1761,"['58a632b15f68b88e6fd57c317d348a26a7ec2c6f', 'f2b53072aa24c3f9f84e762d313f85f5f179e4a4']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",telephony/java/android/telephony/AccessNetworkConstants.java,"[(117, 117, 1), (117, 117, 1)]","            switch (str.toUpperCase()) {
","            switch (str.toUpperCase()) {
","            switch (str.toUpperCase()) {
","[1.0, 1.0]"
1762,"['5cb9413cc504ba46231d9eef0ea04abd6f435b7a', '45681a1567c48072612384989589781af2c646f1']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/doze/DozeSensors.java,"[(226, 226, 1), (225, 225, 1)]","                        !dozeParameters.longPressNeedsProximityCheck() /* performsProxCheck */),
","                        !dozeParameters.longPressNeedsProximityCheck() /* performsProxCheck */),
","                        !dozeParameters.longPressNeedsProximityCheck() /* performsProxCheck */),
","[1.0, 1.0]"
1763,"['5cb9413cc504ba46231d9eef0ea04abd6f435b7a', '45681a1567c48072612384989589781af2c646f1']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/doze/DozeSensors.java,"[(544, 544, 1), (543, 543, 1)]","                    performsProxCheck
","                    performsProxCheck
","                    performsProxCheck
","[1.0, 1.0]"
1764,"['5cb9413cc504ba46231d9eef0ea04abd6f435b7a', '45681a1567c48072612384989589781af2c646f1']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/doze/DozeSensors.java,"[(544, 544, 1), (594, 594, 1)]","                    performsProxCheck
","                    performsProxCheck,
",                    performsProxCheck,"[0.974, 0.949]"
1765,"['5cb9413cc504ba46231d9eef0ea04abd6f435b7a', '45681a1567c48072612384989589781af2c646f1']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/doze/DozeSensors.java,"[(595, 595, 1), (543, 543, 1)]","                    performsProxCheck,
","                    performsProxCheck
",                    performsProxCheck,"[0.949, 0.974]"
1766,"['5cb9413cc504ba46231d9eef0ea04abd6f435b7a', '45681a1567c48072612384989589781af2c646f1']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/doze/DozeSensors.java,"[(595, 595, 1), (594, 594, 1)]","                    performsProxCheck,
","                    performsProxCheck,
","                    performsProxCheck,
","[1.0, 1.0]"
1767,"['5cb9413cc504ba46231d9eef0ea04abd6f435b7a', '45681a1567c48072612384989589781af2c646f1']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/doze/DozeSensors.java,"[(785, 788, 4), (784, 787, 4)]","                mSensorCallback.onSensorPulse(mPulseReason, mPerformsProxCheck,
                        screenX, screenY, event.values);
                if (!mRegistered) {
                    updateListening();  // reregister, this sensor only fires once
","                mSensorCallback.onSensorPulse(mPulseReason, mPerformsProxCheck,
                        screenX, screenY, event.values);
                if (!mRegistered) {
                    updateListening();  // reregister, this sensor only fires once
","                mSensorCallback.onSensorPulse(mPulseReason, mPerformsProxCheck,
                        screenX, screenY, event.values);
                if (!mRegistered) {
                    updateListening();  // reregister, this sensor only fires once
","[1.0, 1.0]"
1768,"['5cb9413cc504ba46231d9eef0ea04abd6f435b7a', '45681a1567c48072612384989589781af2c646f1']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/biometrics/UdfpsDialogMeasureAdapter.java,"[(103, 103, 1), (103, 103, 1)]","                dialogMargin);
","                dialogMargin);
","                dialogMargin);
","[1.0, 1.0]"
1769,"['5cb9413cc504ba46231d9eef0ea04abd6f435b7a', '45681a1567c48072612384989589781af2c646f1']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/biometrics/UdfpsDialogMeasureAdapter.java,"[(197, 197, 1), (196, 196, 1)]","                mSensorProps, displayWidth, dialogMargin);
","                mSensorProps, displayWidth, dialogMargin);
","                mSensorProps, displayWidth, dialogMargin);
","[1.0, 1.0]"
1770,"['5cb9413cc504ba46231d9eef0ea04abd6f435b7a', '45681a1567c48072612384989589781af2c646f1']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/biometrics/UdfpsDialogMeasureAdapter.java,"[(273, 273, 1), (272, 272, 1)]","            int textIndicatorHeightPx, int buttonBarHeightPx, int dialogMarginPx) {
","            int textIndicatorHeightPx, int buttonBarHeightPx, int dialogMarginPx) {
","            int textIndicatorHeightPx, int buttonBarHeightPx, int dialogMarginPx) {
","[1.0, 1.0]"
1771,"['5cb9413cc504ba46231d9eef0ea04abd6f435b7a', '45681a1567c48072612384989589781af2c646f1']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/biometrics/UdfpsDialogMeasureAdapter.java,"[(288, 288, 1), (287, 287, 1)]","                    + "", Bottom spacer height (portrait): "" + spacerHeight);
","                    + "", Bottom spacer height (portrait): "" + spacerHeight);
","                    + "", Bottom spacer height (portrait): "" + spacerHeight);
","[1.0, 1.0]"
1772,"['5cb9413cc504ba46231d9eef0ea04abd6f435b7a', '45681a1567c48072612384989589781af2c646f1']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/biometrics/UdfpsDialogMeasureAdapter.java,"[(334, 334, 1), (333, 333, 1)]","            int dialogMarginPx) {
","            int dialogMarginPx) {
","            int dialogMarginPx) {
","[1.0, 1.0]"
1773,"['5cb9413cc504ba46231d9eef0ea04abd6f435b7a', '45681a1567c48072612384989589781af2c646f1']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/biometrics/UdfpsDialogMeasureAdapter.java,"[(347, 347, 1), (346, 346, 1)]","                    + "", Horizontal spacer width (landscape): "" + horizontalPadding);
","                    + "", Horizontal spacer width (landscape): "" + horizontalPadding);
","                    + "", Horizontal spacer width (landscape): "" + horizontalPadding);
","[1.0, 1.0]"
1774,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/doze/DozeSensors.java,"[(914, 916, 3), (913, 915, 3)]","                if (DEBUG) Log.d(TAG, ""onSensorEvent: "" + triggerEventToString(event));
                mSensorCallback.onSensorPulse(mPulseReason, true /* sensorPerformsProxCheck */,
                        -1, -1, event.getValues());
","                if (DEBUG) Log.d(TAG, ""onSensorEvent: "" + triggerEventToString(event));
                mSensorCallback.onSensorPulse(mPulseReason, true /* sensorPerformsProxCheck */,
                        -1, -1, event.getValues());
","                if (DEBUG) Log.d(TAG, ""onSensorEvent: "" + triggerEventToString(event));
                mSensorCallback.onSensorPulse(mPulseReason, true /* sensorPerformsProxCheck */,
                        -1, -1, event.getValues());
","[1.0, 1.0]"
1775,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(405, 456, 52), (405, 456, 52)]","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","        } else if (mNotificationPanelViewController.isUnlockHintRunning()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mStatusBarStateController.getState() == StatusBarState.SHADE_LOCKED) {
            // Don't expand to the bouncer. Instead transition back to the lock screen (see
            // CentralSurfaces#showBouncerOrLockScreenIfKeyguard)
            return;
        } else if (bouncerNeedsScrimming()) {
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_VISIBLE);
            }
        } else if (mShowing && !hideBouncerOverDream) {
            if (!isWakeAndUnlocking()
                    && !(mBiometricUnlockController.getMode() == MODE_DISMISS_BOUNCER)
                    && !mCentralSurfaces.isInLaunchTransition()
                    && !isUnlockCollapsing()) {
                if (mBouncer != null) {
                    mBouncer.setExpansion(fraction);
                } else {
                    mBouncerInteractor.setExpansion(fraction);
                }
            }
            if (fraction != KeyguardBouncer.EXPANSION_HIDDEN && tracking
                    && !mKeyguardStateController.canDismissLockScreen()
                    && !bouncerIsShowing()
                    && !bouncerIsAnimatingAway()) {
                if (mBouncer != null) {
                    mBouncer.show(false /* resetSecuritySelection */, false /* scrimmed */);
                } else {
                    mBouncerInteractor.show(/* isScrimmed= */false);
                }
            }
        } else if (!mShowing && isBouncerInTransit()) {
            // Keyguard is not visible anymore, but expansion animation was still running.
            // We need to hide the bouncer, otherwise it will be stuck in transit.
            if (mBouncer != null) {
                mBouncer.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            } else {
                mBouncerInteractor.setExpansion(KeyguardBouncer.EXPANSION_HIDDEN);
            }
        } else if (mPulsing && fraction == KeyguardBouncer.EXPANSION_VISIBLE) {
            // Panel expanded while pulsing but didn't translate the bouncer (because we are
            // unlocked.) Let's simply wake-up to dismiss the lock screen.
            mCentralSurfaces.wakeUpIfDozing(
                    SystemClock.uptimeMillis(),
                    mCentralSurfaces.getBouncerContainer(),
                    ""BOUNCER_VISIBLE"");
","[1.0, 1.0]"
1776,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(493, 496, 4), (493, 496, 4)]","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","            if (mBouncer != null) {
                mBouncer.show(true /* resetSecuritySelection */);
            } else {
                mBouncerInteractor.show(true);
","[1.0, 1.0]"
1777,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(536, 541, 6), (536, 541, 6)]","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","        if (mBouncer != null) {
            mBouncer.hide(destroyView);
        } else {
            mBouncerInteractor.hide();
        }
        if (mShowing) {
","[1.0, 1.0]"
1778,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(558, 562, 5), (558, 562, 5)]","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","        if (mShowing && !isBouncerShowing()) {
            if (mBouncer != null) {
                mBouncer.show(false /* resetSecuritySelection */, scrimmed);
            } else {
                mBouncerInteractor.show(scrimmed);
","[1.0, 1.0]"
1779,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(615, 618, 4), (615, 618, 4)]","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.show(false /* resetSecuritySelection */);
                    } else {
                        mBouncerInteractor.show(/* isScrimmed= */true);
","[1.0, 1.0]"
1780,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(623, 629, 7), (623, 629, 7)]","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","                    if (mBouncer != null) {
                        mBouncer.showWithDismissAction(mAfterKeyguardGoneAction,
                                mKeyguardGoneCancelAction);
                    } else {
                        mBouncerInteractor.setDismissAction(
                                mAfterKeyguardGoneAction, mKeyguardGoneCancelAction);
                        mBouncerInteractor.show(/* isScrimmed= */true);
","[1.0, 1.0]"
1781,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(731, 734, 4), (731, 734, 4)]","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","        if (mBouncer != null) {
            mBouncer.onScreenTurnedOff();
        } else {
            mBouncerInteractor.onScreenTurnedOff();
","[1.0, 1.0]"
1782,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(844, 850, 7), (844, 850, 7)]","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","        if (bouncerIsShowing()) {
            if (mBouncer != null) {
                mBouncer.startPreHideAnimation(finishRunnable);
            } else {
                mBouncerInteractor.startDisappearAnimation(finishRunnable);
            }
            mCentralSurfaces.onBouncerPreHideAnimation();
","[1.0, 1.0]"
1783,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1117, 1127, 11), (1117, 1127, 11)]","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","            if (bouncerDismissible || !showing || remoteInputActive) {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(true);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(true);
                }
            } else {
                if (mBouncer != null) {
                    mBouncer.setBackButtonEnabled(false);
                } else {
                    mBouncerInteractor.setBackButtonEnabled(false);
","[1.0, 1.0]"
1784,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1292, 1295, 4), (1292, 1295, 4)]","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","        if (mBouncer != null) {
            mBouncer.notifyKeyguardAuthenticated(strongAuth);
        } else {
            mBouncerInteractor.notifyKeyguardAuthenticated(strongAuth);
","[1.0, 1.0]"
1785,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1311, 1314, 4), (1311, 1314, 4)]","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","            if (mBouncer != null) {
                mBouncer.showMessage(message, colorState);
            } else {
                mBouncerInteractor.showMessage(message, colorState);
","[1.0, 1.0]"
1786,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1360, 1363, 4), (1360, 1363, 4)]","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","        if (mBouncer != null) {
            mBouncer.updateResources();
        } else {
            mBouncerInteractor.updateResources();
","[1.0, 1.0]"
1787,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1447, 1450, 4), (1447, 1450, 4)]","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","        if (mBouncer != null) {
            mBouncer.updateKeyguardPosition(x);
        } else {
            mBouncerInteractor.setKeyguardPosition(x);
","[1.0, 1.0]"
1788,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1490, 1494, 5), (1490, 1494, 5)]","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","    public boolean isBouncerInTransit() {
        if (mBouncer != null) {
            return mBouncer.inTransit();
        } else {
            return mBouncerInteractor.isInTransit();
","[1.0, 1.0]"
1789,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1501, 1505, 5), (1501, 1505, 5)]","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","    public boolean bouncerIsShowing() {
        if (mBouncer != null) {
            return mBouncer.isShowing();
        } else {
            return mBouncerInteractor.isFullyShowing();
","[1.0, 1.0]"
1790,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1512, 1516, 5), (1512, 1516, 5)]","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","    public boolean bouncerIsScrimmed() {
        if (mBouncer != null) {
            return mBouncer.isScrimmed();
        } else {
            return mBouncerInteractor.isScrimmed();
","[1.0, 1.0]"
1791,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1524, 1527, 4), (1524, 1527, 4)]","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","        if (mBouncer != null) {
            return mBouncer.isAnimatingAway();
        } else {
            return mBouncerInteractor.isAnimatingAway();
","[1.0, 1.0]"
1792,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java,"[(1535, 1539, 5), (1535, 1539, 5)]","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","    public boolean bouncerWillDismissWithAction() {
        if (mBouncer != null) {
            return mBouncer.willDismissWithAction();
        } else {
            return mBouncerInteractor.willDismissWithAction();
","[1.0, 1.0]"
1793,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",services/appwidget/java/com/android/server/appwidget/AppWidgetXmlUtil.java,"[(96, 96, 1), (96, 96, 1)]","        out.attribute(null, ATTR_OS_FINGERPRINT, Build.VERSION.INCREMENTAL);
","        out.attribute(null, ATTR_OS_FINGERPRINT, String.valueOf(Build.TIME));
","        out.attribute(null, ATTR_OS_FINGERPRINT, ","[0.636, 0.628]"
1794,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/src/com/android/systemui/qs/QSPanelController.java,"[(34, 36, 3), (32, 34, 3)]","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","import com.android.systemui.media.MediaHierarchyManager;
import com.android.systemui.media.MediaHost;
import com.android.systemui.media.MediaHostState;
","[1.0, 1.0]"
1795,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",services/core/java/com/android/server/media/MediaSessionRecord.java,"[(939, 940, 2), (939, 940, 2)]","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","        public void setMediaButtonReceiver(PendingIntent pi, String sessionPackageName)
                throws RemoteException {
","[1.0, 1.0]"
1796,"['e33699a6fd9e692b2332b3c10642d49af617234e', '20b50bcf2cdd722955040b713056399f0ec17bd2']","['lineage-20.0-SAP-block_text', 'omnirom-13.0-SAP-block_text']",packages/SystemUI/tests/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManagerTest.java,"[(532, 535, 4), (532, 535, 4)]","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","    public void flag_off_DoesNotCallBouncerInteractor() {
        when(mFeatureFlags.isEnabled(MODERN_BOUNCER)).thenReturn(false);
        mStatusBarKeyguardViewManager.hideBouncer(false);
        verify(mBouncerInteractor, never()).hide();
","[1.0, 1.0]"
1823,"['240d78276b3206717587bea012131945c6f60179', '6e3be19b8a58c265a2c3ff4b9cbabdb6a4ae9bf6']","['omnirom-11-SAP-block_text', 'aospa-quartz-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java,"[(235, 247, 13), (190, 204, 15)]","    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback();
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
","    @Override
    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
","    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(","[0.672, 0.525]"
1824,"['240d78276b3206717587bea012131945c6f60179', 'ddcaa93e851eb5e57692799446f2ef3fe31436ae']","['omnirom-11-SAP-block_text', 'aospa-quartz-SAP-block_text']",packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java,"[(235, 247, 13), (190, 204, 15)]","    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback();
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
","    @Override
    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
    }

    @Override
    public void onStaDisconnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(isHotspotEnabled(), numConnectedDevices);
","    public void onNumClientsChanged(int numConnectedDevices) {
        // Do nothing - we don't care about changing anything here.
    }

    @Override
    public void onStaConnected(String Macaddr, int numConnectedDevices) {
        mNumConnectedDevices = numConnectedDevices;
        fireHotspotChangedCallback(","[0.672, 0.525]"
1826,"['6f47ceafbe6febe54aa5c376baed3415cdf848ad', '337095f9d277c566cb888bc3adbac16576f1ae70']","['omnirom-11-SAP-block_text', 'aospa-sapphire-SAP-block_text']",core/java/android/content/pm/ApplicationInfo.java,"[(2211, 2212, 2), (2266, 2266, 1)]","    /** {@hide} */ public void setGwpAsanEnabled(@Nullable Boolean value) { enableGwpAsan = value; }
    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
","    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
","    /** {@hide} */ public void setOverrideRes(int overrideResolution) { overrideRes = overrideResolution; }
","[0.517, 1.0]"
1829,"['ddcaa93e851eb5e57692799446f2ef3fe31436ae', '2051462f672b5986ef321bf1de3657e7653864e8']","['omnirom-11-SAP-block_text', 'aospa-sapphire-SAP-block_text']",packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java,"[(110, 123, 14), (152, 180, 29)]","    /* Gets Device for seondary TWS device
     * @param mDevice Primary TWS device  to get secondary
     * @return Description of the device
     */

    private BluetoothDevice getTwsPeerDevice() {
      BluetoothAdapter bluetoothAdapter;
      BluetoothDevice peerDevice = null;
      if (mDevice.isTwsPlusDevice()) {
        bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        String peerAddress = mDevice.getTwsPlusPeerAddress();
        peerDevice = bluetoothAdapter.getRemoteDevice(peerAddress);
      }
      return peerDevice;
","        mTwspBatteryState = -1;
        mTwspBatteryLevel = -1;
    }

    CachedBluetoothDevice(CachedBluetoothDevice cachedDevice) {
        mContext = cachedDevice.mContext;
        mLocalAdapter = BluetoothAdapter.getDefaultAdapter();
        mProfileManager = cachedDevice.mProfileManager;
        mDevice = cachedDevice.mDevice;
        fillData();
        mHiSyncId = BluetoothHearingAid.HI_SYNC_ID_INVALID;
        mTwspBatteryState = -1;
        mTwspBatteryLevel = -1;
    }

    /* Gets Device for seondary TWS device
     * @param mDevice Primary TWS device  to get secondary
     * @return Description of the device
     */

    private BluetoothDevice getTwsPeerDevice() {
      BluetoothAdapter bluetoothAdapter;
      BluetoothDevice peerDevice = null;
      if (mDevice.isTwsPlusDevice()) {
        bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        String peerAddress = mDevice.getTwsPlusPeerAddress();
        peerDevice = bluetoothAdapter.getRemoteDevice(peerAddress);
      }
      return peerDevice;
","    /* Gets Device for seondary TWS device
     * @param mDevice Primary TWS device  to get secondary
     * @return Description of the device
     */

    private BluetoothDevice getTwsPeerDevice() {
      BluetoothAdapter bluetoothAdapter;
      BluetoothDevice peerDevice = null;
      if (mDevice.isTwsPlusDevice()) {
        bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        String peerAddress = mDevice.getTwsPlusPeerAddress();
        peerDevice = bluetoothAdapter.getRemoteDevice(peerAddress);
      }
      return peerDevice;
","[1.0, 0.531]"
